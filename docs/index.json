[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/XKTModel/KDNode.js",
    "content": "/**\n * A kd-Tree node, used internally by {@link XKTModel}.\n *\n * @private\n */\nclass KDNode {\n\n    /**\n     * Create a KDNode with an axis-aligned 3D World-space boundary.\n     */\n    constructor(aabb) {\n\n        /**\n         * The axis-aligned 3D World-space boundary of this KDNode.\n         *\n         * @type {Float64Array}\n         */\n        this.aabb = aabb;\n\n        /**\n         * The {@link XKTEntity}s within this KDNode.\n         */\n        this.entities = null;\n\n        /**\n         * The left child KDNode.\n         */\n        this.left = null;\n\n        /**\n         * The right child KDNode.\n         */\n        this.right = null;\n    }\n}\n\nexport {KDNode};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/XKTModel/KDNode.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "KDNode",
    "memberof": "src/XKTModel/KDNode.js",
    "static": true,
    "longname": "src/XKTModel/KDNode.js~KDNode",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/KDNode.js",
    "importStyle": "{KDNode}",
    "description": "A kd-Tree node, used internally by {@link XKTModel}.",
    "lineNumber": 6,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 50,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/KDNode.js~KDNode",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/KDNode.js~KDNode#constructor",
    "access": "public",
    "description": "Create a KDNode with an axis-aligned 3D World-space boundary.",
    "lineNumber": 11
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "aabb",
    "memberof": "src/XKTModel/KDNode.js~KDNode",
    "static": false,
    "longname": "src/XKTModel/KDNode.js~KDNode#aabb",
    "access": "public",
    "description": "The axis-aligned 3D World-space boundary of this KDNode.",
    "lineNumber": 18,
    "type": {
      "nullable": null,
      "types": [
        "Float64Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "entities",
    "memberof": "src/XKTModel/KDNode.js~KDNode",
    "static": false,
    "longname": "src/XKTModel/KDNode.js~KDNode#entities",
    "access": "public",
    "description": "The {@link XKTEntity}s within this KDNode.",
    "lineNumber": 23,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 53,
    "kind": "member",
    "name": "left",
    "memberof": "src/XKTModel/KDNode.js~KDNode",
    "static": false,
    "longname": "src/XKTModel/KDNode.js~KDNode#left",
    "access": "public",
    "description": "The left child KDNode.",
    "lineNumber": 28,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 54,
    "kind": "member",
    "name": "right",
    "memberof": "src/XKTModel/KDNode.js~KDNode",
    "static": false,
    "longname": "src/XKTModel/KDNode.js~KDNode#right",
    "access": "public",
    "description": "The right child KDNode.",
    "lineNumber": 33,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "file",
    "name": "src/XKTModel/MockXKTModel.js",
    "content": "import {math} from \"../lib/math.js\";\nimport {geometryCompression} from \"./lib/geometryCompression.js\";\nimport {buildEdgeIndices} from \"./lib/buildEdgeIndices.js\";\n\nconst tempVec4a = math.vec4([0, 0, 0, 1]);\nconst tempVec4b = math.vec4([0, 0, 0, 1]);\nconst tempMat4 = math.mat4();\nconst tempMat4b = math.mat4();\n\n/**\n * A mock {@link XKTModel} that creates {@link Mesh}es and {@link Geometry}s to visualize the output of {@link parseGLTFIntoXKTModel}.\n *\n * @private\n */\nclass MockXKTModel {\n\n    /**\n     *\n     * @param cfg\n     */\n    constructor(cfg={}) {\n\n        if (!cfg.handlePrimitive) {\n            throw \"Expected config: handlePrimitive\";\n        }\n\n        if (!cfg.handleEntity) {\n            throw \"Expected config: handleEntity\";\n        }\n\n        this._handlePrimitive = cfg.handlePrimitive;\n        this._handleEntity = cfg.handleEntity;\n\n        this.geometries = {};\n    }\n\n    createGeometry(params) {\n\n        const geometryId = params.geometryId;\n        const primitiveType = params.primitiveType;\n        const reused = params.reused;\n        const primitiveModelingMatrix = params.primitiveModelingMatrix ? params.primitiveModelingMatrix.slice : math.identityMat4();\n        const color = params.color;\n        const opacity = params.opacity;\n        const positions = params.positions.slice();\n        const normals = params.normals.slice();\n        const indices = params.indices;\n\n        const positions2 = positions.slice();\n\n        const edgeIndices = buildEdgeIndices(positions, indices, null, 10);\n\n        if (!reused) {\n\n            // Bake single-use geometry's positions into World-space\n\n            for (let i = 0, len = positions.length; i < len; i += 3) {\n\n                tempVec4a[0] = positions[i + 0];\n                tempVec4a[1] = positions[i + 1];\n                tempVec4a[2] = positions[i + 2];\n\n                math.transformPoint4(primitiveModelingMatrix, tempVec4a, tempVec4b);\n\n                positions2[i + 0] = tempVec4b[0];\n                positions2[i + 1] = tempVec4b[1];\n                positions2[i + 2] = tempVec4b[2];\n            }\n        }\n\n        const modelNormalMatrix = math.inverseMat4(math.transposeMat4(primitiveModelingMatrix, tempMat4b), tempMat4);\n        const normalsOctEncoded = new Int8Array(normals.length);\n\n        geometryCompression.transformAndOctEncodeNormals(modelNormalMatrix, normals, normals.length, normalsOctEncoded, 0);\n\n        const primitive = new VBOGeometry(this.scene, {\n            id: geometryId,\n            primitive: \"triangles\",\n            positions: positions2,\n            normals: normals,\n            indices: indices,\n            edgeIndices: edgeIndices\n        });\n\n        this.geometries[geometryId] = primitive;\n    }\n\n    createEntity(params) {\n\n        const entityId = params.entityId;\n        const entityModelingMatrix = params.entityModelingMatrix ? params.entityModelingMatrix.slice() : math.identityMat4();\n        const primitiveIds = params.primitiveIds;\n\n        for (let primitiveIdIdx = 0, primitiveIdLen = primitiveIds.length; primitiveIdIdx < primitiveIdLen; primitiveIdIdx++) {\n\n            const geometryId = primitiveIds[primitiveIdIdx];\n            const primitive = this.geometries[geometryId];\n\n            if (!primitive) {\n                console.error(\"primitive not found: \" + geometryId);\n                continue;\n            }\n\n            new Mesh(this.scene, {\n                id: entityId,\n                geometry: primitive,\n                matrix: entityModelingMatrix,\n                edges: true\n            });\n        }\n    }\n\n    finalize() {\n    }\n}\n\nexport {MockXKTModel};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/XKTModel/MockXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 56,
    "kind": "variable",
    "name": "tempVec4a",
    "memberof": "src/XKTModel/MockXKTModel.js",
    "static": true,
    "longname": "src/XKTModel/MockXKTModel.js~tempVec4a",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/MockXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 57,
    "kind": "variable",
    "name": "tempVec4b",
    "memberof": "src/XKTModel/MockXKTModel.js",
    "static": true,
    "longname": "src/XKTModel/MockXKTModel.js~tempVec4b",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/MockXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 58,
    "kind": "variable",
    "name": "tempMat4",
    "memberof": "src/XKTModel/MockXKTModel.js",
    "static": true,
    "longname": "src/XKTModel/MockXKTModel.js~tempMat4",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/MockXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 59,
    "kind": "variable",
    "name": "tempMat4b",
    "memberof": "src/XKTModel/MockXKTModel.js",
    "static": true,
    "longname": "src/XKTModel/MockXKTModel.js~tempMat4b",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/MockXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 60,
    "kind": "class",
    "name": "MockXKTModel",
    "memberof": "src/XKTModel/MockXKTModel.js",
    "static": true,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/MockXKTModel.js",
    "importStyle": "{MockXKTModel}",
    "description": "A mock {@link XKTModel} that creates {@link Mesh}es and {@link Geometry}s to visualize the output of {@link parseGLTFIntoXKTModel}.",
    "lineNumber": 15,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 61,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 62,
    "kind": "member",
    "name": "_handlePrimitive",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#_handlePrimitive",
    "access": "private",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "member",
    "name": "_handleEntity",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#_handleEntity",
    "access": "private",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "member",
    "name": "geometries",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#geometries",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 65,
    "kind": "method",
    "name": "createGeometry",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#createGeometry",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "params",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 66,
    "kind": "method",
    "name": "createEntity",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#createEntity",
    "access": "public",
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "params": [
      {
        "name": "params",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 67,
    "kind": "method",
    "name": "finalize",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#finalize",
    "access": "public",
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 68,
    "kind": "file",
    "name": "src/XKTModel/XKTEntity.js",
    "content": "import {math} from \"../lib/math.js\";\n\n/**\n * An object within an {@link XKTModel}.\n *\n * * Created by {@link XKTModel#createEntity}\n * * Stored in {@link XKTModel#entities} and {@link XKTModel#entitiesList}\n * * Has one or more {@link XKTMesh}s, each having an {@link XKTGeometry}\n *\n * @class XKTEntity\n */\nclass XKTEntity {\n\n    /**\n     * @private\n     * @param entityId\n     * @param meshes\n     */\n    constructor(entityId,  meshes) {\n\n        /**\n         * Unique ID of this ````XKTEntity```` in {@link XKTModel#entities}.\n         *\n         * For a BIM model, this will be an IFC product ID.\n         *\n         * We can also use {@link XKTModel#createMetaObject} to create an {@link XKTMetaObject} to specify metadata for\n         * this ````XKTEntity````. To associate the {@link XKTMetaObject} with our {@link XKTEntity}, we give\n         * {@link XKTMetaObject#metaObjectId} the same value as {@link XKTEntity#entityId}.\n         *\n         * @type {String}\n         */\n        this.entityId = entityId;\n\n        /**\n         * Index of this ````XKTEntity```` in {@link XKTModel#entitiesList}.\n         *\n         * Set by {@link XKTModel#finalize}.\n         *\n         * @type {Number}\n         */\n        this.entityIndex = null;\n\n        /**\n         * A list of {@link XKTMesh}s that indicate which {@link XKTGeometry}s are used by this Entity.\n         *\n         * @type {XKTMesh[]}\n         */\n        this.meshes = meshes;\n\n        /**\n         * World-space axis-aligned bounding box (AABB) that encloses the {@link XKTGeometry#positions} of\n         * the {@link XKTGeometry}s that are used by this ````XKTEntity````.\n         *\n         * Set by {@link XKTModel#finalize}.\n         *\n         * @type {Float32Array}\n         */\n        this.aabb = math.AABB3();\n\n        /**\n         * Indicates if this ````XKTEntity```` shares {@link XKTGeometry}s with other {@link XKTEntity}'s.\n         *\n         * Set by {@link XKTModel#finalize}.\n         *\n         * Note that when an ````XKTEntity```` shares ````XKTGeometrys````, it shares **all** of its ````XKTGeometrys````. An ````XKTEntity````\n         * never shares only some of its ````XKTGeometrys```` - it always shares either the whole set or none at all.\n         *\n         * @type {Boolean}\n         */\n        this.hasReusedGeometries = false;\n    }\n}\n\nexport {XKTEntity};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/XKTModel/XKTEntity.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 69,
    "kind": "class",
    "name": "XKTEntity",
    "memberof": "src/XKTModel/XKTEntity.js",
    "static": true,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTEntity.js",
    "importStyle": "{XKTEntity}",
    "description": "An object within an {@link XKTModel}.\n\n* Created by {@link XKTModel#createEntity}\n* Stored in {@link XKTModel#entities} and {@link XKTModel#entitiesList}\n* Has one or more {@link XKTMesh}s, each having an {@link XKTGeometry}",
    "lineNumber": 12,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTEntity"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 70,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "entityId",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "meshes",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 71,
    "kind": "member",
    "name": "entityId",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#entityId",
    "access": "public",
    "description": "Unique ID of this ````XKTEntity```` in {@link XKTModel#entities}.\n\nFor a BIM model, this will be an IFC product ID.\n\nWe can also use {@link XKTModel#createMetaObject} to create an {@link XKTMetaObject} to specify metadata for\nthis ````XKTEntity````. To associate the {@link XKTMetaObject} with our {@link XKTEntity}, we give\n{@link XKTMetaObject#metaObjectId} the same value as {@link XKTEntity#entityId}.",
    "lineNumber": 32,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 72,
    "kind": "member",
    "name": "entityIndex",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#entityIndex",
    "access": "public",
    "description": "Index of this ````XKTEntity```` in {@link XKTModel#entitiesList}.\n\nSet by {@link XKTModel#finalize}.",
    "lineNumber": 41,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 73,
    "kind": "member",
    "name": "meshes",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#meshes",
    "access": "public",
    "description": "A list of {@link XKTMesh}s that indicate which {@link XKTGeometry}s are used by this Entity.",
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "XKTMesh[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 74,
    "kind": "member",
    "name": "aabb",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#aabb",
    "access": "public",
    "description": "World-space axis-aligned bounding box (AABB) that encloses the {@link XKTGeometry#positions} of\nthe {@link XKTGeometry}s that are used by this ````XKTEntity````.\n\nSet by {@link XKTModel#finalize}.",
    "lineNumber": 58,
    "type": {
      "nullable": null,
      "types": [
        "Float32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 75,
    "kind": "member",
    "name": "hasReusedGeometries",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#hasReusedGeometries",
    "access": "public",
    "description": "Indicates if this ````XKTEntity```` shares {@link XKTGeometry}s with other {@link XKTEntity}'s.\n\nSet by {@link XKTModel#finalize}.\n\nNote that when an ````XKTEntity```` shares ````XKTGeometrys````, it shares **all** of its ````XKTGeometrys````. An ````XKTEntity````\nnever shares only some of its ````XKTGeometrys```` - it always shares either the whole set or none at all.",
    "lineNumber": 70,
    "type": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 76,
    "kind": "file",
    "name": "src/XKTModel/XKTGeometry.js",
    "content": "/**\n * An element of reusable geometry within an {@link XKTModel}.\n *\n * * Created by {@link XKTModel#createGeometry}\n * * Stored in {@link XKTModel#geometries} and {@link XKTModel#geometriesList}\n * * Referenced by {@link XKTMesh}s, which belong to {@link XKTEntity}s\n *\n * @class XKTGeometry\n */\nclass XKTGeometry {\n\n    /**\n     * @private\n     * @param {*} cfg Configuration for the XKTGeometry.\n     * @param {Number} cfg.geometryId Unique ID of the geometry in {@link XKTModel#geometries}.\n     * @param {String} cfg.primitiveType Type of this geometry - \"triangles\", \"points\" or \"lines\" so far.\n     * @param {Number} cfg.geometryIndex Index of this XKTGeometry in {@link XKTModel#geometriesList}.\n     * @param {Float64Array} cfg.positions Non-quantized 3D vertex positions.\n     * @param {Float32Array} cfg.normals Non-compressed vertex normals.\n     * @param {Uint8Array} cfg.colorsCompressed Integer RGBA vertex colors.\n     * @param {Uint32Array} cfg.indices Indices to organize the vertex positions and normals into triangles.\n     * @param {Uint32Array} cfg.edgeIndices Indices to organize the vertex positions into edges.\n     */\n    constructor(cfg) {\n\n        /**\n         * Unique ID of this XKTGeometry in {@link XKTModel#geometries}.\n         *\n         * @type {Number}\n         */\n        this.geometryId = cfg.geometryId;\n\n        /**\n         * The type of primitive - \"triangles\" | \"points\" | \"lines\".\n         *\n         * @type {String}\n         */\n        this.primitiveType = cfg.primitiveType;\n\n        /**\n         * Index of this XKTGeometry in {@link XKTModel#geometriesList}.\n         *\n         * @type {Number}\n         */\n        this.geometryIndex = cfg.geometryIndex;\n\n        /**\n         * The number of {@link XKTMesh}s that reference this XKTGeometry.\n         *\n         * @type {Number}\n         */\n        this.numInstances = 0;\n\n        /**\n         * Non-quantized 3D vertex positions.\n         *\n         * Defined for all primitive types.\n         *\n         * @type {Float64Array}\n         */\n        this.positions = cfg.positions;\n\n        /**\n         * Quantized vertex positions.\n         *\n         * Defined for all primitive types.\n         *\n         * This array is later created from {@link XKTGeometry#positions} by {@link XKTModel#finalize}.\n         *\n         * @type {Uint16Array}\n         */\n        this.positionsQuantized = new Uint16Array(cfg.positions.length);\n\n        /**\n         * Non-compressed 3D vertex normals.\n         *\n         * Defined only for triangle primitives. Can be null if we want xeokit to auto-generate them. Ignored for points and lines.\n         *\n         * @type {Float32Array}\n         */\n        this.normals = cfg.normals;\n\n        /**\n         * Compressed vertex normals.\n         *\n         * Defined only for triangle primitives. Ignored for points and lines.\n         *\n         * This array is later created from {@link XKTGeometry#normals} by {@link XKTModel#finalize}.\n         *\n         * Will be null if {@link XKTGeometry#normals} is also null.\n         *\n         * @type {Int8Array}\n         */\n        this.normalsOctEncoded = null;\n\n        /**\n         * Compressed RGBA vertex colors.\n         *\n         * Defined only for point primitives. Ignored for triangles and lines.\n         *\n         * @type {Float32Array}\n         */\n        this.colorsCompressed = cfg.colorsCompressed;\n\n        /**\n         * Indices that organize the vertex positions and normals as triangles.\n         *\n         * Defined only for triangle and lines primitives. Ignored for points.\n         *\n         * @type {Uint32Array}\n         */\n        this.indices = cfg.indices;\n\n        /**\n         * Indices that organize the vertex positions as edges.\n         *\n         * Defined only for triangle primitives. Ignored for points and lines.\n         *\n         * @type {Uint32Array}\n         */\n        this.edgeIndices = cfg.edgeIndices;\n\n        /**\n         * When {@link XKTGeometry#primitiveType} is \"triangles\", this is ````true```` when this geometry is a watertight mesh.\n         *\n         * Defined only for triangle primitives. Ignored for points and lines.\n         *\n         * Set by {@link XKTModel#finalize}.\n         *\n         * @type {boolean}\n         */\n        this.solid = false;\n    }\n\n    /**\n     * Convenience property that is ````true```` when {@link XKTGeometry#numInstances} is greater that one.\n     * @returns {boolean}\n     */\n    get reused() {\n        return (this.numInstances > 1);\n    }\n}\n\nexport {XKTGeometry};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/XKTModel/XKTGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 77,
    "kind": "class",
    "name": "XKTGeometry",
    "memberof": "src/XKTModel/XKTGeometry.js",
    "static": true,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTGeometry.js",
    "importStyle": "{XKTGeometry}",
    "description": "An element of reusable geometry within an {@link XKTModel}.\n\n* Created by {@link XKTModel#createGeometry}\n* Stored in {@link XKTModel#geometries} and {@link XKTModel#geometriesList}\n* Referenced by {@link XKTMesh}s, which belong to {@link XKTEntity}s",
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTGeometry"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 78,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 24,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg",
        "description": "Configuration for the XKTGeometry."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.geometryId",
        "description": "Unique ID of the geometry in {@link XKTModel#geometries}."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.primitiveType",
        "description": "Type of this geometry - \"triangles\", \"points\" or \"lines\" so far."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.geometryIndex",
        "description": "Index of this XKTGeometry in {@link XKTModel#geometriesList}."
      },
      {
        "nullable": null,
        "types": [
          "Float64Array"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.positions",
        "description": "Non-quantized 3D vertex positions."
      },
      {
        "nullable": null,
        "types": [
          "Float32Array"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.normals",
        "description": "Non-compressed vertex normals."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.colorsCompressed",
        "description": "Integer RGBA vertex colors."
      },
      {
        "nullable": null,
        "types": [
          "Uint32Array"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.indices",
        "description": "Indices to organize the vertex positions and normals into triangles."
      },
      {
        "nullable": null,
        "types": [
          "Uint32Array"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.edgeIndices",
        "description": "Indices to organize the vertex positions into edges."
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 79,
    "kind": "member",
    "name": "geometryId",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#geometryId",
    "access": "public",
    "description": "Unique ID of this XKTGeometry in {@link XKTModel#geometries}.",
    "lineNumber": 31,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 80,
    "kind": "member",
    "name": "primitiveType",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#primitiveType",
    "access": "public",
    "description": "The type of primitive - \"triangles\" | \"points\" | \"lines\".",
    "lineNumber": 38,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 81,
    "kind": "member",
    "name": "geometryIndex",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#geometryIndex",
    "access": "public",
    "description": "Index of this XKTGeometry in {@link XKTModel#geometriesList}.",
    "lineNumber": 45,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 82,
    "kind": "member",
    "name": "numInstances",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#numInstances",
    "access": "public",
    "description": "The number of {@link XKTMesh}s that reference this XKTGeometry.",
    "lineNumber": 52,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 83,
    "kind": "member",
    "name": "positions",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#positions",
    "access": "public",
    "description": "Non-quantized 3D vertex positions.\n\nDefined for all primitive types.",
    "lineNumber": 61,
    "type": {
      "nullable": null,
      "types": [
        "Float64Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 84,
    "kind": "member",
    "name": "positionsQuantized",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#positionsQuantized",
    "access": "public",
    "description": "Quantized vertex positions.\n\nDefined for all primitive types.\n\nThis array is later created from {@link XKTGeometry#positions} by {@link XKTModel#finalize}.",
    "lineNumber": 72,
    "type": {
      "nullable": null,
      "types": [
        "Uint16Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 85,
    "kind": "member",
    "name": "normals",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#normals",
    "access": "public",
    "description": "Non-compressed 3D vertex normals.\n\nDefined only for triangle primitives. Can be null if we want xeokit to auto-generate them. Ignored for points and lines.",
    "lineNumber": 81,
    "type": {
      "nullable": null,
      "types": [
        "Float32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 86,
    "kind": "member",
    "name": "normalsOctEncoded",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#normalsOctEncoded",
    "access": "public",
    "description": "Compressed vertex normals.\n\nDefined only for triangle primitives. Ignored for points and lines.\n\nThis array is later created from {@link XKTGeometry#normals} by {@link XKTModel#finalize}.\n\nWill be null if {@link XKTGeometry#normals} is also null.",
    "lineNumber": 94,
    "type": {
      "nullable": null,
      "types": [
        "Int8Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 87,
    "kind": "member",
    "name": "colorsCompressed",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#colorsCompressed",
    "access": "public",
    "description": "Compressed RGBA vertex colors.\n\nDefined only for point primitives. Ignored for triangles and lines.",
    "lineNumber": 103,
    "type": {
      "nullable": null,
      "types": [
        "Float32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 88,
    "kind": "member",
    "name": "indices",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#indices",
    "access": "public",
    "description": "Indices that organize the vertex positions and normals as triangles.\n\nDefined only for triangle and lines primitives. Ignored for points.",
    "lineNumber": 112,
    "type": {
      "nullable": null,
      "types": [
        "Uint32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 89,
    "kind": "member",
    "name": "edgeIndices",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#edgeIndices",
    "access": "public",
    "description": "Indices that organize the vertex positions as edges.\n\nDefined only for triangle primitives. Ignored for points and lines.",
    "lineNumber": 121,
    "type": {
      "nullable": null,
      "types": [
        "Uint32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 90,
    "kind": "member",
    "name": "solid",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#solid",
    "access": "public",
    "description": "When {@link XKTGeometry#primitiveType} is \"triangles\", this is ````true```` when this geometry is a watertight mesh.\n\nDefined only for triangle primitives. Ignored for points and lines.\n\nSet by {@link XKTModel#finalize}.",
    "lineNumber": 132,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 91,
    "kind": "get",
    "name": "reused",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#reused",
    "access": "public",
    "description": "Convenience property that is ````true```` when {@link XKTGeometry#numInstances} is greater that one.",
    "lineNumber": 139,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 92,
    "kind": "file",
    "name": "src/XKTModel/XKTMesh.js",
    "content": "/**\n * Represents the usage of a {@link XKTGeometry} by an {@link XKTEntity}.\n *\n * * Created by {@link XKTModel#createEntity}\n * * Stored in {@link XKTEntity#meshes} and {@link XKTModel#meshesList}\n * * Specifies color and opacity\n *\n * @class XKTMesh\n */\nclass XKTMesh {\n\n    /**\n     * @private\n     */\n    constructor(cfg) {\n\n        /**\n         * Unique ID of this XKTMesh in {@link XKTModel#meshes}.\n         *\n         * @type {Number}\n         */\n        this.meshId = cfg.meshId;\n\n        /**\n         * Index of this XKTMesh in {@link XKTModel#meshesList};\n         *\n         * @type {Number}\n         */\n        this.meshIndex = cfg.meshIndex;\n\n        /**\n         * The 4x4 modeling transform matrix.\n         *\n         * Transform is relative to the center of the {@link XKTTile} that contains this XKTMesh's {@link XKTEntity},\n         * which is given in {@link XKTMesh#entity}.\n         *\n         * When the ````XKTEntity```` shares its {@link XKTGeometry}s with other ````XKTEntity````s, this matrix is used\n         * to transform this XKTMesh's XKTGeometry into World-space. When this XKTMesh does not share its ````XKTGeometry````,\n         * then this matrix is ignored.\n         *\n         * @type {Number[]}\n         */\n        this.matrix = cfg.matrix;\n\n        /**\n         * The instanced {@link XKTGeometry}.\n         *\n         * @type {XKTGeometry}\n         */\n        this.geometry = cfg.geometry;\n\n        /**\n         * RGB color of this XKTMesh.\n         *\n         * @type {Uint8Array}\n         */\n        this.color = cfg.color || new Uint8Array(3);\n\n        /**\n         * PBR metallness of this XKTMesh.\n         *\n         * @type {Number}\n         */\n        this.metallic = (cfg.metallic !== null && cfg.metallic !== undefined) ? cfg.metallic : 0;\n\n        /**\n         * PBR roughness of this XKTMesh.\n         *\n         * @type {Number}\n         */\n        this.roughness = (cfg.roughness !== null && cfg.roughness !== undefined) ? cfg.roughness : 1;\n\n        /**\n         * Opacity of this XKTMesh.\n         *\n         * @type {Number}\n         */\n        this.opacity = (cfg.opacity !== undefined && cfg.opacity !== null) ? cfg.opacity : 1.0;\n\n        /**\n         * The owner {@link XKTEntity}.\n         *\n         * Set by {@link XKTModel#createEntity}.\n         *\n         * @type {XKTEntity}\n         */\n        this.entity = null; // Set after instantiation, when the Entity is known\n    }\n}\n\nexport {XKTMesh};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/XKTModel/XKTMesh.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 93,
    "kind": "class",
    "name": "XKTMesh",
    "memberof": "src/XKTModel/XKTMesh.js",
    "static": true,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTMesh.js",
    "importStyle": "{XKTMesh}",
    "description": "Represents the usage of a {@link XKTGeometry} by an {@link XKTEntity}.\n\n* Created by {@link XKTModel#createEntity}\n* Stored in {@link XKTEntity#meshes} and {@link XKTModel#meshesList}\n* Specifies color and opacity",
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTMesh"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 94,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 15,
    "ignore": true
  },
  {
    "__docId__": 95,
    "kind": "member",
    "name": "meshId",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#meshId",
    "access": "public",
    "description": "Unique ID of this XKTMesh in {@link XKTModel#meshes}.",
    "lineNumber": 22,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 96,
    "kind": "member",
    "name": "meshIndex",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#meshIndex",
    "access": "public",
    "description": "Index of this XKTMesh in {@link XKTModel#meshesList};",
    "lineNumber": 29,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 97,
    "kind": "member",
    "name": "matrix",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#matrix",
    "access": "public",
    "description": "The 4x4 modeling transform matrix.\n\nTransform is relative to the center of the {@link XKTTile} that contains this XKTMesh's {@link XKTEntity},\nwhich is given in {@link XKTMesh#entity}.\n\nWhen the ````XKTEntity```` shares its {@link XKTGeometry}s with other ````XKTEntity````s, this matrix is used\nto transform this XKTMesh's XKTGeometry into World-space. When this XKTMesh does not share its ````XKTGeometry````,\nthen this matrix is ignored.",
    "lineNumber": 43,
    "type": {
      "nullable": null,
      "types": [
        "Number[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 98,
    "kind": "member",
    "name": "geometry",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#geometry",
    "access": "public",
    "description": "The instanced {@link XKTGeometry}.",
    "lineNumber": 50,
    "type": {
      "nullable": null,
      "types": [
        "XKTGeometry"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 99,
    "kind": "member",
    "name": "color",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#color",
    "access": "public",
    "description": "RGB color of this XKTMesh.",
    "lineNumber": 57,
    "type": {
      "nullable": null,
      "types": [
        "Uint8Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 100,
    "kind": "member",
    "name": "metallic",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#metallic",
    "access": "public",
    "description": "PBR metallness of this XKTMesh.",
    "lineNumber": 64,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 101,
    "kind": "member",
    "name": "roughness",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#roughness",
    "access": "public",
    "description": "PBR roughness of this XKTMesh.",
    "lineNumber": 71,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 102,
    "kind": "member",
    "name": "opacity",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#opacity",
    "access": "public",
    "description": "Opacity of this XKTMesh.",
    "lineNumber": 78,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 103,
    "kind": "member",
    "name": "entity",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#entity",
    "access": "public",
    "description": "The owner {@link XKTEntity}.\n\nSet by {@link XKTModel#createEntity}.",
    "lineNumber": 87,
    "type": {
      "nullable": null,
      "types": [
        "XKTEntity"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 104,
    "kind": "file",
    "name": "src/XKTModel/XKTMetaObject.js",
    "content": "/**\n * A meta object within an {@link XKTModel}.\n *\n * These are plugged together into a parent-child hierarchy to represent structural\n * metadata for the {@link XKTModel}.\n *\n * The leaf XKTMetaObjects are usually associated with\n * an {@link XKTEntity}, which they do so by sharing the same ID,\n * ie. where {@link XKTMetaObject#metaObjectId} == {@link XKTEntity#entityId}.\n *\n * * Created by {@link XKTModel#createMetaObject}\n * * Stored in {@link XKTModel#metaObjects} and {@link XKTModel#metaObjectsList}\n * * Has an ID, a type, and a human-readable name\n * * May have a parent {@link XKTMetaObject}\n * * When no children, is usually associated with an {@link XKTEntity}\n *\n * @class XKTMetaObject\n */\nclass XKTMetaObject {\n\n    /**\n     * @private\n     * @param metaObjectId\n     * @param propertySetIds\n     * @param metaObjectType\n     * @param metaObjectName\n     * @param parentMetaObjectId\n     */\n    constructor(metaObjectId, propertySetIds, metaObjectType, metaObjectName, parentMetaObjectId) {\n\n        /**\n         * Unique ID of this ````XKTMetaObject```` in {@link XKTModel#metaObjects}.\n         *\n         * For a BIM model, this will be an IFC product ID.\n         *\n         * If this is a leaf XKTMetaObject, where it is not a parent to any other XKTMetaObject,\n         * then this will be equal to the ID of an {@link XKTEntity} in {@link XKTModel#entities},\n         * ie. where {@link XKTMetaObject#metaObjectId} == {@link XKTEntity#entityId}.\n         *\n         * @type {String}\n         */\n        this.metaObjectId = metaObjectId;\n\n        /**\n         * Unique ID of one or more property sets that contains additional metadata about this\n         * {@link XKTMetaObject}. The property sets can be stored in an external system, or\n         * within the {@link XKTModel}, as {@link XKTPropertySet}s within {@link XKTModel#propertySets}.\n         *\n         * @type {String[]}\n         */\n        this.propertySetIds = propertySetIds;\n\n        /**\n         * Indicates the XKTMetaObject meta object type.\n         *\n         * This defaults to \"default\".\n         *\n         * @type {string}\n         */\n        this.metaObjectType = metaObjectType;\n\n        /**\n         * Indicates the XKTMetaObject meta object name.\n         *\n         * This defaults to {@link XKTMetaObject#metaObjectId}.\n         *\n         * @type {string}\n         */\n        this.metaObjectName = metaObjectName;\n\n        /**\n         * The parent XKTMetaObject, if any.\n         *\n         * Will be null if there is no parent.\n         *\n         * @type {String}\n         */\n        this.parentMetaObjectId = parentMetaObjectId;\n    }\n}\n\nexport {XKTMetaObject};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/XKTModel/XKTMetaObject.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 105,
    "kind": "class",
    "name": "XKTMetaObject",
    "memberof": "src/XKTModel/XKTMetaObject.js",
    "static": true,
    "longname": "src/XKTModel/XKTMetaObject.js~XKTMetaObject",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTMetaObject.js",
    "importStyle": "{XKTMetaObject}",
    "description": "A meta object within an {@link XKTModel}.\n\nThese are plugged together into a parent-child hierarchy to represent structural\nmetadata for the {@link XKTModel}.\n\nThe leaf XKTMetaObjects are usually associated with\nan {@link XKTEntity}, which they do so by sharing the same ID,\nie. where {@link XKTMetaObject#metaObjectId} == {@link XKTEntity#entityId}.\n\n* Created by {@link XKTModel#createMetaObject}\n* Stored in {@link XKTModel#metaObjects} and {@link XKTModel#metaObjectsList}\n* Has an ID, a type, and a human-readable name\n* May have a parent {@link XKTMetaObject}\n* When no children, is usually associated with an {@link XKTEntity}",
    "lineNumber": 19,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTMetaObject"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 106,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTMetaObject.js~XKTMetaObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTMetaObject.js~XKTMetaObject#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 29,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "metaObjectId",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "propertySetIds",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "metaObjectType",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "metaObjectName",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "parentMetaObjectId",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 107,
    "kind": "member",
    "name": "metaObjectId",
    "memberof": "src/XKTModel/XKTMetaObject.js~XKTMetaObject",
    "static": false,
    "longname": "src/XKTModel/XKTMetaObject.js~XKTMetaObject#metaObjectId",
    "access": "public",
    "description": "Unique ID of this ````XKTMetaObject```` in {@link XKTModel#metaObjects}.\n\nFor a BIM model, this will be an IFC product ID.\n\nIf this is a leaf XKTMetaObject, where it is not a parent to any other XKTMetaObject,\nthen this will be equal to the ID of an {@link XKTEntity} in {@link XKTModel#entities},\nie. where {@link XKTMetaObject#metaObjectId} == {@link XKTEntity#entityId}.",
    "lineNumber": 42,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 108,
    "kind": "member",
    "name": "propertySetIds",
    "memberof": "src/XKTModel/XKTMetaObject.js~XKTMetaObject",
    "static": false,
    "longname": "src/XKTModel/XKTMetaObject.js~XKTMetaObject#propertySetIds",
    "access": "public",
    "description": "Unique ID of one or more property sets that contains additional metadata about this\n{@link XKTMetaObject}. The property sets can be stored in an external system, or\nwithin the {@link XKTModel}, as {@link XKTPropertySet}s within {@link XKTModel#propertySets}.",
    "lineNumber": 51,
    "type": {
      "nullable": null,
      "types": [
        "String[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 109,
    "kind": "member",
    "name": "metaObjectType",
    "memberof": "src/XKTModel/XKTMetaObject.js~XKTMetaObject",
    "static": false,
    "longname": "src/XKTModel/XKTMetaObject.js~XKTMetaObject#metaObjectType",
    "access": "public",
    "description": "Indicates the XKTMetaObject meta object type.\n\nThis defaults to \"default\".",
    "lineNumber": 60,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 110,
    "kind": "member",
    "name": "metaObjectName",
    "memberof": "src/XKTModel/XKTMetaObject.js~XKTMetaObject",
    "static": false,
    "longname": "src/XKTModel/XKTMetaObject.js~XKTMetaObject#metaObjectName",
    "access": "public",
    "description": "Indicates the XKTMetaObject meta object name.\n\nThis defaults to {@link XKTMetaObject#metaObjectId}.",
    "lineNumber": 69,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 111,
    "kind": "member",
    "name": "parentMetaObjectId",
    "memberof": "src/XKTModel/XKTMetaObject.js~XKTMetaObject",
    "static": false,
    "longname": "src/XKTModel/XKTMetaObject.js~XKTMetaObject#parentMetaObjectId",
    "access": "public",
    "description": "The parent XKTMetaObject, if any.\n\nWill be null if there is no parent.",
    "lineNumber": 78,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 112,
    "kind": "file",
    "name": "src/XKTModel/XKTModel.js",
    "content": "import {math} from \"../lib/math.js\";\nimport {geometryCompression} from \"./lib/geometryCompression.js\";\nimport {buildEdgeIndices} from \"./lib/buildEdgeIndices.js\";\nimport {isTriangleMeshSolid} from \"./lib/isTriangleMeshSolid.js\";\n\nimport {XKTMesh} from './XKTMesh.js';\nimport {XKTGeometry} from './XKTGeometry.js';\nimport {XKTEntity} from './XKTEntity.js';\nimport {XKTTile} from './XKTTile.js';\nimport {KDNode} from \"./KDNode.js\";\nimport {XKTMetaObject} from \"./XKTMetaObject.js\";\nimport {XKTPropertySet} from \"./XKTPropertySet.js\";\nimport {mergeVertices} from \"../lib/mergeVertices.js\";\nimport {XKT_INFO} from \"../XKT_INFO.js\";\n\nconst tempVec4a = math.vec4([0, 0, 0, 1]);\nconst tempVec4b = math.vec4([0, 0, 0, 1]);\n\nconst tempMat4 = math.mat4();\nconst tempMat4b = math.mat4();\n\nconst MIN_TILE_DIAG = 10000;\n\nconst kdTreeDimLength = new Float64Array(3);\n\n/**\n * A document model that represents the contents of an .XKT file.\n *\n * * An XKTModel contains {@link XKTTile}s, which spatially subdivide the model into axis-aligned, box-shaped regions.\n * * Each {@link XKTTile} contains {@link XKTEntity}s, which represent the objects within its region.\n * * Each {@link XKTEntity} has {@link XKTMesh}s, which each have a {@link XKTGeometry}. Each {@link XKTGeometry} can be shared by multiple {@link XKTMesh}s.\n * * Import models into an XKTModel using {@link parseGLTFIntoXKTModel}, {@link parseIFCIntoXKTModel}, {@link parse3DXMLIntoXKTModel}, {@link parseCityJSONIntoXKTModel} etc.\n * * Build an XKTModel programmatically using {@link XKTModel#createGeometry}, {@link XKTModel#createMesh} and {@link XKTModel#createEntity}.\n * * Serialize an XKTModel to an ArrayBuffer using {@link writeXKTModelToArrayBuffer}.\n *\n * ## Usage\n *\n * See [main docs page](/docs/#javascript-api) for usage examples.\n *\n * @class XKTModel\n */\nclass XKTModel {\n\n    /**\n     * Constructs a new XKTModel.\n     *\n     * @param {*} [cfg] Configuration\n     * @param {Number} [cfg.edgeThreshold=10]\n     */\n    constructor(cfg = {}) {\n\n        /**\n         * The model's ID, if available.\n         *\n         * Will be \"default\" by default.\n         *\n         * @type {String}\n         */\n        this.modelId = cfg.modelId || \"default\";\n\n        /**\n         * The project ID, if available.\n         *\n         * Will be an empty string by default.\n         *\n         * @type {String}\n         */\n        this.projectId = cfg.projectId || \"\";\n\n        /**\n         * The revision ID, if available.\n         *\n         * Will be an empty string by default.\n         *\n         * @type {String}\n         */\n        this.revisionId = cfg.revisionId || \"\";\n\n        /**\n         * The model author, if available.\n         *\n         * Will be an empty string by default.\n         *\n         * @property author\n         * @type {String}\n         */\n        this.author = cfg.author || \"\";\n\n        /**\n         * The date the model was created, if available.\n         *\n         * Will be an empty string by default.\n         *\n         * @property createdAt\n         * @type {String}\n         */\n        this.createdAt = cfg.createdAt || \"\";\n\n        /**\n         * The application that created the model, if available.\n         *\n         * Will be an empty string by default.\n         *\n         * @property creatingApplication\n         * @type {String}\n         */\n        this.creatingApplication = cfg.creatingApplication || \"\";\n\n        /**\n         * The model schema version, if available.\n         *\n         * In the case of IFC, this could be \"IFC2x3\" or \"IFC4\", for example.\n         *\n         * Will be an empty string by default.\n         *\n         * @property schema\n         * @type {String}\n         */\n        this.schema = cfg.schema || \"\";\n\n        /**\n         * The XKT format version.\n         *\n         * @property xktVersion;\n         * @type {number}\n         */\n        this.xktVersion =  XKT_INFO.xktVersion;\n\n        /**\n         *\n         * @type {Number|number}\n         */\n        this.edgeThreshold = cfg.edgeThreshold || 10;\n\n        /**\n         * Map of {@link XKTPropertySet}s within this XKTModel, each mapped to {@link XKTPropertySet#propertySetId}.\n         *\n         * Created by {@link XKTModel#createPropertySet}.\n         *\n         * @type {{String:XKTPropertySet}}\n         */\n        this.propertySets = {};\n\n        /**\n         * {@link XKTPropertySet}s within this XKTModel.\n         *\n         * Each XKTPropertySet holds its position in this list in {@link XKTPropertySet#propertySetIndex}.\n         *\n         * Created by {@link XKTModel#finalize}.\n         *\n         * @type {XKTPropertySet[]}\n         */\n        this.propertySetsList = [];\n\n        /**\n         * Map of {@link XKTMetaObject}s within this XKTModel, each mapped to {@link XKTMetaObject#metaObjectId}.\n         *\n         * Created by {@link XKTModel#createMetaObject}.\n         *\n         * @type {{String:XKTMetaObject}}\n         */\n        this.metaObjects = {};\n\n        /**\n         * {@link XKTMetaObject}s within this XKTModel.\n         *\n         * Each XKTMetaObject holds its position in this list in {@link XKTMetaObject#metaObjectIndex}.\n         *\n         * Created by {@link XKTModel#finalize}.\n         *\n         * @type {XKTMetaObject[]}\n         */\n        this.metaObjectsList = [];\n\n        /**\n         * The positions of all shared {@link XKTGeometry}s are de-quantized using this singular\n         * de-quantization matrix.\n         *\n         * This de-quantization matrix is generated from the collective Local-space boundary of the\n         * positions of all shared {@link XKTGeometry}s.\n         *\n         * @type {Float32Array}\n         */\n        this.reusedGeometriesDecodeMatrix = new Float32Array(16);\n\n        /**\n         * Map of {@link XKTGeometry}s within this XKTModel, each mapped to {@link XKTGeometry#geometryId}.\n         *\n         * Created by {@link XKTModel#createGeometry}.\n         *\n         * @type {{Number:XKTGeometry}}\n         */\n        this.geometries = {};\n\n        /**\n         * List of {@link XKTGeometry}s within this XKTModel, in the order they were created.\n         *\n         * Each XKTGeometry holds its position in this list in {@link XKTGeometry#geometryIndex}.\n         *\n         * Created by {@link XKTModel#finalize}.\n         *\n         * @type {XKTGeometry[]}\n         */\n        this.geometriesList = [];\n\n        /**\n         * Map of {@link XKTMesh}s within this XKTModel, each mapped to {@link XKTMesh#meshId}.\n         *\n         * Created by {@link XKTModel#createMesh}.\n         *\n         * @type {{Number:XKTMesh}}\n         */\n        this.meshes = {};\n\n        /**\n         * List of {@link XKTMesh}s within this XKTModel, in the order they were created.\n         *\n         * Each XKTMesh holds its position in this list in {@link XKTMesh#meshIndex}.\n         *\n         * Created by {@link XKTModel#finalize}.\n         *\n         * @type {XKTMesh[]}\n         */\n        this.meshesList = [];\n\n        /**\n         * Map of {@link XKTEntity}s within this XKTModel, each mapped to {@link XKTEntity#entityId}.\n         *\n         * Created by {@link XKTModel#createEntity}.\n         *\n         * @type {{String:XKTEntity}}\n         */\n        this.entities = {};\n\n        /**\n         * {@link XKTEntity}s within this XKTModel.\n         *\n         * Each XKTEntity holds its position in this list in {@link XKTEntity#entityIndex}.\n         *\n         * Created by {@link XKTModel#finalize}.\n         *\n         * @type {XKTEntity[]}\n         */\n        this.entitiesList = [];\n\n        /**\n         * {@link XKTTile}s within this XKTModel.\n         *\n         * Created by {@link XKTModel#finalize}.\n         *\n         * @type {XKTTile[]}\n         */\n        this.tilesList = [];\n\n        /**\n         * The axis-aligned 3D World-space boundary of this XKTModel.\n         *\n         * Created by {@link XKTModel#finalize}.\n         *\n         * @type {Float64Array}\n         */\n        this.aabb = math.AABB3();\n\n        /**\n         * Indicates if this XKTModel has been finalized.\n         *\n         * Set ````true```` by {@link XKTModel#finalize}.\n         *\n         * @type {boolean}\n         */\n        this.finalized = false;\n    }\n\n    /**\n     * Creates an {@link XKTPropertySet} within this XKTModel.\n     *\n     * Logs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).\n     *\n     * @param {*} params Method parameters.\n     * @param {String} params.propertySetId Unique ID for the {@link XKTPropertySet}.\n     * @param {String} [params.propertySetType=\"default\"] A meta type for the {@link XKTPropertySet}.\n     * @param {String} [params.propertySetName] Human-readable name for the {@link XKTPropertySet}. Defaults to the ````propertySetId```` parameter.\n     * @param {String[]} params.properties Properties for the {@link XKTPropertySet}.\n     * @returns {XKTPropertySet} The new {@link XKTPropertySet}.\n     */\n    createPropertySet(params) {\n\n        if (!params) {\n            throw \"Parameters expected: params\";\n        }\n\n        if (params.propertySetId === null || params.propertySetId === undefined) {\n            throw \"Parameter expected: params.propertySetId\";\n        }\n\n        if (params.properties === null || params.properties === undefined) {\n            throw \"Parameter expected: params.properties\";\n        }\n\n        if (this.finalized) {\n            console.error(\"XKTModel has been finalized, can't add more property sets\");\n            return;\n        }\n\n        if (this.propertySets[params.propertySetId]) {\n            //          console.error(\"XKTPropertySet already exists with this ID: \" + params.propertySetId);\n            return;\n        }\n\n        const propertySetId = params.propertySetId;\n        const propertySetType = params.propertySetType || \"Default\";\n        const propertySetName = params.propertySetName || params.propertySetId;\n        const properties = params.properties || [];\n\n        const propertySet = new XKTPropertySet(propertySetId, propertySetType, propertySetName, properties);\n\n        this.propertySets[propertySetId] = propertySet;\n        this.propertySetsList.push(propertySet);\n\n        return propertySet;\n    }\n\n    /**\n     * Creates an {@link XKTMetaObject} within this XKTModel.\n     *\n     * Logs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).\n     *\n     * @param {*} params Method parameters.\n     * @param {String} params.metaObjectId Unique ID for the {@link XKTMetaObject}.\n     * @param {String} params.propertySetIds ID of one or more property sets that contains additional metadata about\n     * this {@link XKTMetaObject}. The property sets could be stored externally (ie not managed at all by the XKT file),\n     * or could be {@link XKTPropertySet}s within {@link XKTModel#propertySets}.\n     * @param {String} [params.metaObjectType=\"default\"] A meta type for the {@link XKTMetaObject}. Can be anything,\n     * but is usually an IFC type, such as \"IfcSite\" or \"IfcWall\".\n     * @param {String} [params.metaObjectName] Human-readable name for the {@link XKTMetaObject}. Defaults to the ````metaObjectId```` parameter.\n     * @param {String} [params.parentMetaObjectId] ID of the parent {@link XKTMetaObject}, if any. Defaults to the ````metaObjectId```` parameter.\n     * @returns {XKTMetaObject} The new {@link XKTMetaObject}.\n     */\n    createMetaObject(params) {\n\n        if (!params) {\n            throw \"Parameters expected: params\";\n        }\n\n        if (params.metaObjectId === null || params.metaObjectId === undefined) {\n            throw \"Parameter expected: params.metaObjectId\";\n        }\n\n        if (this.finalized) {\n            console.error(\"XKTModel has been finalized, can't add more meta objects\");\n            return;\n        }\n\n        if (this.metaObjects[params.metaObjectId]) {\n            //          console.error(\"XKTMetaObject already exists with this ID: \" + params.metaObjectId);\n            return;\n        }\n\n        const metaObjectId = params.metaObjectId;\n        const propertySetIds = params.propertySetIds;\n        const metaObjectType = params.metaObjectType || \"Default\";\n        const metaObjectName = params.metaObjectName || params.metaObjectId;\n        const parentMetaObjectId = params.parentMetaObjectId;\n\n        const metaObject = new XKTMetaObject(metaObjectId, propertySetIds, metaObjectType, metaObjectName, parentMetaObjectId);\n\n        this.metaObjects[metaObjectId] = metaObject;\n        this.metaObjectsList.push(metaObject);\n\n        if (!parentMetaObjectId) {\n            if (!this._rootMetaObject) {\n                this._rootMetaObject = metaObject;\n            }\n        }\n\n        return metaObject;\n    }\n\n    /**\n     * Creates an {@link XKTGeometry} within this XKTModel.\n     *\n     * Logs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).\n     *\n     * @param {*} params Method parameters.\n     * @param {Number} params.geometryId Unique ID for the {@link XKTGeometry}.\n     * @param {String} params.primitiveType The type of {@link XKTGeometry}: \"triangles\", \"lines\" or \"points\".\n     * @param {Float64Array} params.positions Floating-point Local-space vertex positions for the {@link XKTGeometry}. Required for all primitive types.\n     * @param {Number[]} [params.normals] Floating-point vertex normals for the {@link XKTGeometry}. Only used with triangles primitives. Ignored for points and lines.\n     * @param {Number[]} [params.colors] Floating-point RGBA vertex colors for the {@link XKTGeometry}. Required for points primitives. Ignored for lines and triangles.\n     * @param {Number[]} [params.colorsCompressed] Integer RGBA vertex colors for the {@link XKTGeometry}. Required for points primitives. Ignored for lines and triangles.\n     * @param {Uint32Array} [params.indices] Indices for the {@link XKTGeometry}. Required for triangles and lines primitives. Ignored for points.\n     * @param {Number} [params.edgeThreshold=10]\n     * @returns {XKTGeometry} The new {@link XKTGeometry}.\n     */\n    createGeometry(params) {\n\n        if (!params) {\n            throw \"Parameters expected: params\";\n        }\n\n        if (params.geometryId === null || params.geometryId === undefined) {\n            throw \"Parameter expected: params.geometryId\";\n        }\n\n        if (!params.primitiveType) {\n            throw \"Parameter expected: params.primitiveType\";\n        }\n\n        if (!params.positions) {\n            throw \"Parameter expected: params.positions\";\n        }\n\n        const triangles = params.primitiveType === \"triangles\";\n        const points = params.primitiveType === \"points\";\n        const lines = params.primitiveType === \"lines\";\n\n        if (!triangles && !points && !lines) {\n            throw \"Unsupported value for params.primitiveType: \" + params.primitiveType + \"' - supported values are 'triangles', 'points' and 'lines'\";\n        }\n\n        if (triangles) {\n            if (!params.indices) {\n                throw \"Parameter expected for 'triangles' primitive: params.indices\";\n            }\n        }\n\n        if (points) {\n            if (!params.colors && !params.colorsCompressed) {\n                throw \"Parameter expected for 'points' primitive: params.colors or params.colorsCompressed\";\n            }\n        }\n\n        if (lines) {\n            if (!params.indices) {\n                throw \"Parameter expected for 'lines' primitive: params.indices\";\n            }\n        }\n\n        if (this.finalized) {\n            console.error(\"XKTModel has been finalized, can't add more geometries\");\n            return;\n        }\n\n        if (this.geometries[params.geometryId]) {\n            console.error(\"XKTGeometry already exists with this ID: \" + params.geometryId);\n            return;\n        }\n\n        const geometryId = params.geometryId;\n        const primitiveType = params.primitiveType;\n        const positions = new Float64Array(params.positions); // May modify in #finalize\n\n        const xktGeometryCfg = {\n            geometryId: geometryId,\n            geometryIndex: this.geometriesList.length,\n            primitiveType: primitiveType,\n            positions: positions\n        }\n\n        if (triangles) {\n            if (params.normals) {\n                xktGeometryCfg.normals = new Float32Array(params.normals);\n            }\n            xktGeometryCfg.indices = params.indices;\n        }\n\n        if (points) {\n            if (params.colorsCompressed) {\n                xktGeometryCfg.colorsCompressed = new Uint8Array(params.colorsCompressed);\n\n            } else {\n                const colors = params.colors;\n                const colorsCompressed = new Uint8Array(colors.length);\n                for (let i = 0, len = colors.length; i < len; i++) {\n                    colorsCompressed[i] = Math.floor(colors[i] * 255);\n                }\n                xktGeometryCfg.colorsCompressed = colorsCompressed;\n            }\n        }\n\n        if (lines) {\n            xktGeometryCfg.indices = params.indices;\n        }\n\n        if (triangles) {\n\n            if (!params.normals) {\n\n                // Building models often duplicate positions to allow face-aligned vertex normals; when we're not\n                // providing normals for a geometry, it becomes possible to merge duplicate vertex positions within it.\n\n                // TODO: Make vertex merging also merge normals?\n\n                const mergedPositions = [];\n                const mergedIndices = [];\n                mergeVertices(xktGeometryCfg.positions, xktGeometryCfg.indices, mergedPositions, mergedIndices);\n                xktGeometryCfg.positions = new Float64Array(mergedPositions);\n                xktGeometryCfg.indices = mergedIndices;\n            }\n\n            xktGeometryCfg.edgeIndices = buildEdgeIndices(xktGeometryCfg.positions, xktGeometryCfg.indices, null, params.edgeThreshold || this.edgeThreshold || 10);\n        }\n\n        const geometry = new XKTGeometry(xktGeometryCfg);\n\n        this.geometries[geometryId] = geometry;\n        this.geometriesList.push(geometry);\n\n        return geometry;\n    }\n\n    /**\n     * Creates an {@link XKTMesh} within this XKTModel.\n     *\n     * An {@link XKTMesh} can be owned by one {@link XKTEntity}, which can own multiple {@link XKTMesh}es.\n     *\n     * @param {*} params Method parameters.\n     * @param {Number} params.meshId Unique ID for the {@link XKTMesh}.\n     * @param {Number} params.geometryId ID of an existing {@link XKTGeometry} in {@link XKTModel#geometries}.\n     * @param {Uint8Array} params.color RGB color for the {@link XKTMesh}, with each color component in range [0..1].\n     * @param {Number} [params.metallic=0] How metallic the {@link XKTMesh} is, in range [0..1]. A value of ````0```` indicates fully dielectric material, while ````1```` indicates fully metallic.\n     * @param {Number} [params.roughness=1] How rough the {@link XKTMesh} is, in range [0..1]. A value of ````0```` indicates fully smooth, while ````1```` indicates fully rough.\n     * @param {Number} params.opacity Opacity factor for the {@link XKTMesh}, in range [0..1].\n     * @param {Float64Array} [params.matrix] Modeling matrix for the {@link XKTMesh}. Overrides ````position````, ````scale```` and ````rotation```` parameters.\n     * @param {Number[]} [params.position=[0,0,0]] Position of the {@link XKTMesh}. Overridden by the ````matrix```` parameter.\n     * @param {Number[]} [params.scale=[1,1,1]] Scale of the {@link XKTMesh}. Overridden by the ````matrix```` parameter.\n     * @param {Number[]} [params.rotation=[0,0,0]] Rotation of the {@link XKTMesh} as Euler angles given in degrees, for each of the X, Y and Z axis. Overridden by the ````matrix```` parameter.\n     * @returns {XKTMesh} The new {@link XKTMesh}.\n     */\n    createMesh(params) {\n\n        if (params.meshId === null || params.meshId === undefined) {\n            throw \"Parameter expected: params.meshId\";\n        }\n\n        if (params.geometryId === null || params.geometryId === undefined) {\n            throw \"Parameter expected: params.geometryId\";\n        }\n\n        if (this.finalized) {\n            throw \"XKTModel has been finalized, can't add more meshes\";\n        }\n\n        if (this.meshes[params.meshId]) {\n            console.error(\"XKTMesh already exists with this ID: \" + params.meshId);\n            return;\n        }\n\n        const geometry = this.geometries[params.geometryId];\n\n        if (!geometry) {\n            console.error(\"XKTGeometry not found: \" + params.geometryId);\n            return;\n        }\n\n        geometry.numInstances++;\n\n        let matrix = params.matrix;\n\n        if (!matrix) {\n\n            const position = params.position;\n            const scale = params.scale;\n            const rotation = params.rotation;\n\n            if (position || scale || rotation) {\n                matrix = math.identityMat4();\n                const quaternion = math.eulerToQuaternion(rotation || [0, 0, 0], \"XYZ\", math.identityQuaternion());\n                math.composeMat4(position || [0, 0, 0], quaternion, scale || [1, 1, 1], matrix)\n\n            } else {\n                matrix = math.identityMat4();\n            }\n        }\n\n        const meshIndex = this.meshesList.length;\n\n        const mesh = new XKTMesh({\n            meshId: params.meshId,\n            meshIndex: meshIndex,\n            matrix: matrix,\n            geometry: geometry,\n            color: params.color,\n            metallic: params.metallic,\n            roughness: params.roughness,\n            opacity: params.opacity\n        });\n\n        this.meshes[mesh.meshId] = mesh;\n        this.meshesList.push(mesh);\n\n        return mesh;\n    }\n\n    /**\n     * Creates an {@link XKTEntity} within this XKTModel.\n     *\n     * Logs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).\n     *\n     * @param {*} params Method parameters.\n     * @param {String} params.entityId Unique ID for the {@link XKTEntity}.\n     * @param {String[]} params.meshIds IDs of {@link XKTMesh}es used by the {@link XKTEntity}. Note that each {@link XKTMesh} can only be used by one {@link XKTEntity}.\n     * @returns {XKTEntity} The new {@link XKTEntity}.\n     */\n    createEntity(params) {\n\n        if (!params) {\n            throw \"Parameters expected: params\";\n        }\n\n        if (params.entityId === null || params.entityId === undefined) {\n            throw \"Parameter expected: params.entityId\";\n        }\n\n        if (!params.meshIds) {\n            throw \"Parameter expected: params.meshIds\";\n        }\n\n        if (this.finalized) {\n            console.error(\"XKTModel has been finalized, can't add more entities\");\n            return;\n        }\n\n        if (params.meshIds.length === 0) {\n            console.warn(\"XKTEntity has no meshes - won't create: \" + params.entityId);\n            return;\n        }\n\n        let entityId = params.entityId;\n\n        if (this.entities[entityId]) {\n            while (this.entities[entityId]) {\n                entityId = math.createUUID();\n            }\n            console.error(\"XKTEntity already exists with this ID: \" + params.entityId + \" - substituting random ID instead: \" + entityId);\n        }\n\n        const meshIds = params.meshIds;\n        const meshes = [];\n\n        for (let meshIdIdx = 0, meshIdLen = meshIds.length; meshIdIdx < meshIdLen; meshIdIdx++) {\n\n            const meshId = meshIds[meshIdIdx];\n            const mesh = this.meshes[meshId];\n\n            if (!mesh) {\n                console.error(\"XKTMesh found: \" + meshId);\n                continue;\n            }\n\n            if (mesh.entity) {\n                console.error(\"XKTMesh \" + meshId + \" already used by XKTEntity \" + mesh.entity.entityId);\n                continue;\n            }\n\n            meshes.push(mesh);\n        }\n\n        const entity = new XKTEntity(entityId, meshes);\n\n        for (let i = 0, len = meshes.length; i < len; i++) {\n            const mesh = meshes[i];\n            mesh.entity = entity;\n        }\n\n        this.entities[entityId] = entity;\n        this.entitiesList.push(entity);\n\n        return entity;\n    }\n\n    /**\n     * Creates a default {@link XKTMetaObject} for each {@link XKTEntity} that does not already have one.\n     */\n    createDefaultMetaObjects() {\n\n        for (let i = 0, len = this.entitiesList.length; i < len; i++) {\n\n            const entity = this.entitiesList[i];\n            const metaObjectId = entity.entityId;\n            const metaObject = this.metaObjects[metaObjectId];\n\n            if (!metaObject) {\n\n                if (!this._rootMetaObject) {\n                    this._rootMetaObject = this.createMetaObject({\n                        metaObjectId: this.modelId,\n                        metaObjectType: \"Default\",\n                        metaObjectName: this.modelId\n                    });\n                }\n\n                this.createMetaObject({\n                    metaObjectId: metaObjectId,\n                    metaObjectType: \"Default\",\n                    metaObjectName: \"\" + metaObjectId,\n                    parentMetaObjectId: this._rootMetaObject.metaObjectId\n                });\n            }\n        }\n    }\n\n    /**\n     * Finalizes this XKTModel.\n     *\n     * After finalizing, we may then serialize the model to an array buffer using {@link writeXKTModelToArrayBuffer}.\n     *\n     * Logs error and does nothing if this XKTModel has already been finalized.\n     *\n     * Internally, this method:\n     *\n     * * for each {@link XKTEntity} that doesn't already have a {@link XKTMetaObject}, creates one with {@link XKTMetaObject#metaObjectType} set to \"default\"\n     * * sets each {@link XKTEntity}'s {@link XKTEntity#hasReusedGeometries} true if it shares its {@link XKTGeometry}s with other {@link XKTEntity}s,\n     * * creates each {@link XKTEntity}'s {@link XKTEntity#aabb},\n     * * creates {@link XKTTile}s in {@link XKTModel#tilesList}, and\n     * * sets {@link XKTModel#finalized} ````true````.\n     */\n    finalize() {\n\n        if (this.finalized) {\n            console.log(\"XKTModel already finalized\");\n            return;\n        }\n\n        this._bakeSingleUseGeometryPositions();\n\n        this._bakeAndOctEncodeNormals();\n\n        this._createEntityAABBs();\n\n        const rootKDNode = this._createKDTree();\n\n        this.entitiesList = [];\n\n        this._createTilesFromKDTree(rootKDNode);\n\n        this._createReusedGeometriesDecodeMatrix();\n\n        this._flagSolidGeometries();\n\n        this.aabb.set(rootKDNode.aabb);\n\n        this.finalized = true;\n    }\n\n    _bakeSingleUseGeometryPositions() {\n\n        for (let j = 0, lenj = this.meshesList.length; j < lenj; j++) {\n\n            const mesh = this.meshesList[j];\n\n            const geometry = mesh.geometry;\n\n            if (geometry.numInstances === 1) {\n\n                const matrix = mesh.matrix;\n\n                if (matrix && (!math.isIdentityMat4(matrix))) {\n\n                    const positions = geometry.positions;\n\n                    for (let i = 0, len = positions.length; i < len; i += 3) {\n\n                        tempVec4a[0] = positions[i + 0];\n                        tempVec4a[1] = positions[i + 1];\n                        tempVec4a[2] = positions[i + 2];\n                        tempVec4a[3] = 1;\n\n                        math.transformPoint4(matrix, tempVec4a, tempVec4b);\n\n                        positions[i + 0] = tempVec4b[0];\n                        positions[i + 1] = tempVec4b[1];\n                        positions[i + 2] = tempVec4b[2];\n                    }\n                }\n            }\n        }\n    }\n\n    _bakeAndOctEncodeNormals() {\n\n        for (let i = 0, len = this.meshesList.length; i < len; i++) {\n\n            const mesh = this.meshesList[i];\n            const geometry = mesh.geometry;\n\n            if (geometry.normals && !geometry.normalsOctEncoded) {\n\n                geometry.normalsOctEncoded = new Int8Array(geometry.normals.length);\n\n                if (geometry.numInstances > 1) {\n                    geometryCompression.octEncodeNormals(geometry.normals, geometry.normals.length, geometry.normalsOctEncoded, 0);\n\n                } else {\n                    const modelNormalMatrix = math.inverseMat4(math.transposeMat4(mesh.matrix, tempMat4), tempMat4b);\n                    geometryCompression.transformAndOctEncodeNormals(modelNormalMatrix, geometry.normals, geometry.normals.length, geometry.normalsOctEncoded, 0);\n                }\n            }\n        }\n    }\n\n    _createEntityAABBs() {\n\n        for (let i = 0, len = this.entitiesList.length; i < len; i++) {\n\n            const entity = this.entitiesList[i];\n            const entityAABB = entity.aabb;\n            const meshes = entity.meshes;\n\n            math.collapseAABB3(entityAABB);\n\n            for (let j = 0, lenj = meshes.length; j < lenj; j++) {\n\n                const mesh = meshes[j];\n                const geometry = mesh.geometry;\n                const matrix = mesh.matrix;\n\n                if (geometry.numInstances > 1) {\n\n                    const positions = geometry.positions;\n                    for (let i = 0, len = positions.length; i < len; i += 3) {\n                        tempVec4a[0] = positions[i + 0];\n                        tempVec4a[1] = positions[i + 1];\n                        tempVec4a[2] = positions[i + 2];\n                        tempVec4a[3] = 1;\n                        math.transformPoint4(matrix, tempVec4a, tempVec4b);\n                        math.expandAABB3Point3(entityAABB, tempVec4b);\n                    }\n\n                } else {\n\n                    const positions = geometry.positions;\n                    for (let i = 0, len = positions.length; i < len; i += 3) {\n                        tempVec4a[0] = positions[i + 0];\n                        tempVec4a[1] = positions[i + 1];\n                        tempVec4a[2] = positions[i + 2];\n                        math.expandAABB3Point3(entityAABB, tempVec4a);\n                    }\n                }\n            }\n        }\n    }\n\n    _createKDTree() {\n\n        const aabb = math.collapseAABB3();\n\n        for (let i = 0, len = this.entitiesList.length; i < len; i++) {\n            const entity = this.entitiesList[i];\n            math.expandAABB3(aabb, entity.aabb);\n        }\n\n        const rootKDNode = new KDNode(aabb);\n\n        for (let i = 0, len = this.entitiesList.length; i < len; i++) {\n            const entity = this.entitiesList[i];\n            this._insertEntityIntoKDTree(rootKDNode, entity);\n        }\n\n        return rootKDNode;\n    }\n\n    _insertEntityIntoKDTree(kdNode, entity) {\n\n        const nodeAABB = kdNode.aabb;\n        const entityAABB = entity.aabb;\n\n        const nodeAABBDiag = math.getAABB3Diag(nodeAABB);\n\n        if (nodeAABBDiag < MIN_TILE_DIAG) {\n            kdNode.entities = kdNode.entities || [];\n            kdNode.entities.push(entity);\n            math.expandAABB3(nodeAABB, entityAABB);\n            return;\n        }\n\n        if (kdNode.left) {\n            if (math.containsAABB3(kdNode.left.aabb, entityAABB)) {\n                this._insertEntityIntoKDTree(kdNode.left, entity);\n                return;\n            }\n        }\n\n        if (kdNode.right) {\n            if (math.containsAABB3(kdNode.right.aabb, entityAABB)) {\n                this._insertEntityIntoKDTree(kdNode.right, entity);\n                return;\n            }\n        }\n\n        kdTreeDimLength[0] = nodeAABB[3] - nodeAABB[0];\n        kdTreeDimLength[1] = nodeAABB[4] - nodeAABB[1];\n        kdTreeDimLength[2] = nodeAABB[5] - nodeAABB[2];\n\n        let dim = 0;\n\n        if (kdTreeDimLength[1] > kdTreeDimLength[dim]) {\n            dim = 1;\n        }\n\n        if (kdTreeDimLength[2] > kdTreeDimLength[dim]) {\n            dim = 2;\n        }\n\n        if (!kdNode.left) {\n            const aabbLeft = nodeAABB.slice();\n            aabbLeft[dim + 3] = ((nodeAABB[dim] + nodeAABB[dim + 3]) / 2.0);\n            kdNode.left = new KDNode(aabbLeft);\n            if (math.containsAABB3(aabbLeft, entityAABB)) {\n                this._insertEntityIntoKDTree(kdNode.left, entity);\n                return;\n            }\n        }\n\n        if (!kdNode.right) {\n            const aabbRight = nodeAABB.slice();\n            aabbRight[dim] = ((nodeAABB[dim] + nodeAABB[dim + 3]) / 2.0);\n            kdNode.right = new KDNode(aabbRight);\n            if (math.containsAABB3(aabbRight, entityAABB)) {\n                this._insertEntityIntoKDTree(kdNode.right, entity);\n                return;\n            }\n        }\n\n        kdNode.entities = kdNode.entities || [];\n        kdNode.entities.push(entity);\n\n        math.expandAABB3(nodeAABB, entityAABB);\n    }\n\n    _createTilesFromKDTree(rootKDNode) {\n        this._createTilesFromKDNode(rootKDNode);\n    }\n\n    _createTilesFromKDNode(kdNode) {\n        if (kdNode.entities && kdNode.entities.length > 0) {\n            this._createTileFromEntities(kdNode.entities);\n        }\n        if (kdNode.left) {\n            this._createTilesFromKDNode(kdNode.left);\n        }\n        if (kdNode.right) {\n            this._createTilesFromKDNode(kdNode.right);\n        }\n    }\n\n    /**\n     * Creates a tile from the given entities.\n     *\n     * For each single-use {@link XKTGeometry}, this method centers {@link XKTGeometry#positions} to make them relative to the\n     * tile's center, then quantizes the positions to unsigned 16-bit integers, relative to the tile's boundary.\n     *\n     * @param entities\n     */\n    _createTileFromEntities(entities) {\n\n        const tileAABB = math.AABB3(); // A tighter World-space AABB around the entities\n        math.collapseAABB3(tileAABB);\n\n        for (let i = 0; i < entities.length; i++) {\n            const entity = entities [i];\n            math.expandAABB3(tileAABB, entity.aabb);\n        }\n\n        const tileCenter = math.getAABB3Center(tileAABB);\n        const tileCenterNeg = math.mulVec3Scalar(tileCenter, -1, math.vec3());\n\n        const rtcAABB = math.AABB3(); // AABB centered at the RTC origin\n\n        rtcAABB[0] = tileAABB[0] - tileCenter[0];\n        rtcAABB[1] = tileAABB[1] - tileCenter[1];\n        rtcAABB[2] = tileAABB[2] - tileCenter[2];\n        rtcAABB[3] = tileAABB[3] - tileCenter[0];\n        rtcAABB[4] = tileAABB[4] - tileCenter[1];\n        rtcAABB[5] = tileAABB[5] - tileCenter[2];\n\n        for (let i = 0; i < entities.length; i++) {\n\n            const entity = entities [i];\n\n            const meshes = entity.meshes;\n\n            for (let j = 0, lenj = meshes.length; j < lenj; j++) {\n\n                const mesh = meshes[j];\n                const geometry = mesh.geometry;\n\n                if (!geometry.reused) { // Batched geometry\n\n                    const positions = geometry.positions;\n\n                    // Center positions relative to their tile's World-space center\n\n                    for (let k = 0, lenk = positions.length; k < lenk; k += 3) {\n\n                        positions[k + 0] -= tileCenter[0];\n                        positions[k + 1] -= tileCenter[1];\n                        positions[k + 2] -= tileCenter[2];\n                    }\n\n                    // Quantize positions relative to tile's RTC-space boundary\n\n                    geometryCompression.quantizePositions(positions, positions.length, rtcAABB, geometry.positionsQuantized);\n\n                } else { // Instanced geometry\n\n                    // Post-multiply a translation to the mesh's modeling matrix\n                    // to center the entity's geometry instances to the tile RTC center\n\n                    math.translateMat4v(tileCenterNeg, mesh.matrix);\n                }\n            }\n\n            entity.entityIndex = this.entitiesList.length;\n\n            this.entitiesList.push(entity);\n        }\n\n        const tile = new XKTTile(tileAABB, entities);\n\n        this.tilesList.push(tile);\n    }\n\n    _createReusedGeometriesDecodeMatrix() {\n\n        const tempVec3a = math.vec3();\n        const reusedGeometriesAABB = math.collapseAABB3(math.AABB3());\n        let countReusedGeometries = 0;\n\n        for (let geometryIndex = 0, numGeometries = this.geometriesList.length; geometryIndex < numGeometries; geometryIndex++) {\n\n            const geometry = this.geometriesList [geometryIndex];\n\n            if (geometry.reused) { // Instanced geometry\n\n                const positions = geometry.positions;\n\n                for (let i = 0, len = positions.length; i < len; i += 3) {\n\n                    tempVec3a[0] = positions[i];\n                    tempVec3a[1] = positions[i + 1];\n                    tempVec3a[2] = positions[i + 2];\n\n                    math.expandAABB3Point3(reusedGeometriesAABB, tempVec3a);\n                }\n\n                countReusedGeometries++;\n            }\n        }\n\n        if (countReusedGeometries > 0) {\n\n            geometryCompression.createPositionsDecodeMatrix(reusedGeometriesAABB, this.reusedGeometriesDecodeMatrix);\n\n            for (let geometryIndex = 0, numGeometries = this.geometriesList.length; geometryIndex < numGeometries; geometryIndex++) {\n\n                const geometry = this.geometriesList [geometryIndex];\n\n                if (geometry.reused) {\n                    geometryCompression.quantizePositions(geometry.positions, geometry.positions.length, reusedGeometriesAABB, geometry.positionsQuantized);\n                }\n            }\n\n        } else {\n            math.identityMat4(this.reusedGeometriesDecodeMatrix); // No need for this matrix, but we'll be tidy and set it to identity\n        }\n    }\n\n    _flagSolidGeometries() {\n        let maxNumPositions = 0;\n        let maxNumIndices = 0;\n        for (let i = 0, len = this.geometriesList.length; i < len; i++) {\n            const geometry = this.geometriesList[i];\n            if (geometry.primitiveType === \"triangles\") {\n                if (geometry.positionsQuantized.length > maxNumPositions) {\n                    maxNumPositions = geometry.positionsQuantized.length;\n                }\n                if (geometry.indices.length > maxNumIndices) {\n                    maxNumIndices = geometry.indices.length;\n                }\n            }\n        }\n        let vertexIndexMapping = new Array (maxNumPositions / 3);\n        let edges = new Array (maxNumIndices);\n        for (let i = 0, len = this.geometriesList.length; i < len; i++) {\n            const geometry = this.geometriesList[i];\n            if (geometry.primitiveType === \"triangles\") {\n                geometry.solid = isTriangleMeshSolid(geometry.indices, geometry.positionsQuantized, vertexIndexMapping, edges);\n            }\n        }\n    }\n}\n\nexport {XKTModel};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/XKTModel/XKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 113,
    "kind": "variable",
    "name": "tempVec4a",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~tempVec4a",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 114,
    "kind": "variable",
    "name": "tempVec4b",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~tempVec4b",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 115,
    "kind": "variable",
    "name": "tempMat4",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~tempMat4",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 19,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 116,
    "kind": "variable",
    "name": "tempMat4b",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~tempMat4b",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 117,
    "kind": "variable",
    "name": "MIN_TILE_DIAG",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~MIN_TILE_DIAG",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 118,
    "kind": "variable",
    "name": "kdTreeDimLength",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~kdTreeDimLength",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 119,
    "kind": "class",
    "name": "XKTModel",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~XKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTModel.js",
    "importStyle": "{XKTModel}",
    "description": "A document model that represents the contents of an .XKT file.\n\n* An XKTModel contains {@link XKTTile}s, which spatially subdivide the model into axis-aligned, box-shaped regions.\n* Each {@link XKTTile} contains {@link XKTEntity}s, which represent the objects within its region.\n* Each {@link XKTEntity} has {@link XKTMesh}s, which each have a {@link XKTGeometry}. Each {@link XKTGeometry} can be shared by multiple {@link XKTMesh}s.\n* Import models into an XKTModel using {@link parseGLTFIntoXKTModel}, {@link parseIFCIntoXKTModel}, {@link parse3DXMLIntoXKTModel}, {@link parseCityJSONIntoXKTModel} etc.\n* Build an XKTModel programmatically using {@link XKTModel#createGeometry}, {@link XKTModel#createMesh} and {@link XKTModel#createEntity}.\n* Serialize an XKTModel to an ArrayBuffer using {@link writeXKTModelToArrayBuffer}.\n\n## Usage\n\nSee [main docs page](/docs/#javascript-api) for usage examples.",
    "lineNumber": 42,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTModel"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 120,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#constructor",
    "access": "public",
    "description": "Constructs a new XKTModel.",
    "lineNumber": 50,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configuration"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "10",
        "defaultRaw": 10,
        "name": "cfg.edgeThreshold",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 121,
    "kind": "member",
    "name": "modelId",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#modelId",
    "access": "public",
    "description": "The model's ID, if available.\n\nWill be \"default\" by default.",
    "lineNumber": 59,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 122,
    "kind": "member",
    "name": "projectId",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#projectId",
    "access": "public",
    "description": "The project ID, if available.\n\nWill be an empty string by default.",
    "lineNumber": 68,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 123,
    "kind": "member",
    "name": "revisionId",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#revisionId",
    "access": "public",
    "description": "The revision ID, if available.\n\nWill be an empty string by default.",
    "lineNumber": 77,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 124,
    "kind": "member",
    "name": "author",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#author",
    "access": "public",
    "description": "The model author, if available.\n\nWill be an empty string by default.",
    "lineNumber": 87,
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "author",
        "description": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 125,
    "kind": "member",
    "name": "createdAt",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#createdAt",
    "access": "public",
    "description": "The date the model was created, if available.\n\nWill be an empty string by default.",
    "lineNumber": 97,
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "createdAt",
        "description": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 126,
    "kind": "member",
    "name": "creatingApplication",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#creatingApplication",
    "access": "public",
    "description": "The application that created the model, if available.\n\nWill be an empty string by default.",
    "lineNumber": 107,
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "creatingApplication",
        "description": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 127,
    "kind": "member",
    "name": "schema",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#schema",
    "access": "public",
    "description": "The model schema version, if available.\n\nIn the case of IFC, this could be \"IFC2x3\" or \"IFC4\", for example.\n\nWill be an empty string by default.",
    "lineNumber": 119,
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 128,
    "kind": "member",
    "name": "xktVersion",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#xktVersion",
    "access": "public",
    "description": "The XKT format version.",
    "lineNumber": 127,
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "xktVersion;",
        "description": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 129,
    "kind": "member",
    "name": "edgeThreshold",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#edgeThreshold",
    "access": "public",
    "description": "",
    "lineNumber": 133,
    "type": {
      "nullable": null,
      "types": [
        "Number",
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 130,
    "kind": "member",
    "name": "propertySets",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#propertySets",
    "access": "public",
    "description": "Map of {@link XKTPropertySet}s within this XKTModel, each mapped to {@link XKTPropertySet#propertySetId}.\n\nCreated by {@link XKTModel#createPropertySet}.",
    "lineNumber": 142,
    "type": {
      "nullable": null,
      "types": [
        "{String:XKTPropertySet}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 131,
    "kind": "member",
    "name": "propertySetsList",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#propertySetsList",
    "access": "public",
    "description": "{@link XKTPropertySet}s within this XKTModel.\n\nEach XKTPropertySet holds its position in this list in {@link XKTPropertySet#propertySetIndex}.\n\nCreated by {@link XKTModel#finalize}.",
    "lineNumber": 153,
    "type": {
      "nullable": null,
      "types": [
        "XKTPropertySet[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 132,
    "kind": "member",
    "name": "metaObjects",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#metaObjects",
    "access": "public",
    "description": "Map of {@link XKTMetaObject}s within this XKTModel, each mapped to {@link XKTMetaObject#metaObjectId}.\n\nCreated by {@link XKTModel#createMetaObject}.",
    "lineNumber": 162,
    "type": {
      "nullable": null,
      "types": [
        "{String:XKTMetaObject}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 133,
    "kind": "member",
    "name": "metaObjectsList",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#metaObjectsList",
    "access": "public",
    "description": "{@link XKTMetaObject}s within this XKTModel.\n\nEach XKTMetaObject holds its position in this list in {@link XKTMetaObject#metaObjectIndex}.\n\nCreated by {@link XKTModel#finalize}.",
    "lineNumber": 173,
    "type": {
      "nullable": null,
      "types": [
        "XKTMetaObject[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 134,
    "kind": "member",
    "name": "reusedGeometriesDecodeMatrix",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#reusedGeometriesDecodeMatrix",
    "access": "public",
    "description": "The positions of all shared {@link XKTGeometry}s are de-quantized using this singular\nde-quantization matrix.\n\nThis de-quantization matrix is generated from the collective Local-space boundary of the\npositions of all shared {@link XKTGeometry}s.",
    "lineNumber": 184,
    "type": {
      "nullable": null,
      "types": [
        "Float32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 135,
    "kind": "member",
    "name": "geometries",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#geometries",
    "access": "public",
    "description": "Map of {@link XKTGeometry}s within this XKTModel, each mapped to {@link XKTGeometry#geometryId}.\n\nCreated by {@link XKTModel#createGeometry}.",
    "lineNumber": 193,
    "type": {
      "nullable": null,
      "types": [
        "{Number:XKTGeometry}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 136,
    "kind": "member",
    "name": "geometriesList",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#geometriesList",
    "access": "public",
    "description": "List of {@link XKTGeometry}s within this XKTModel, in the order they were created.\n\nEach XKTGeometry holds its position in this list in {@link XKTGeometry#geometryIndex}.\n\nCreated by {@link XKTModel#finalize}.",
    "lineNumber": 204,
    "type": {
      "nullable": null,
      "types": [
        "XKTGeometry[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 137,
    "kind": "member",
    "name": "meshes",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#meshes",
    "access": "public",
    "description": "Map of {@link XKTMesh}s within this XKTModel, each mapped to {@link XKTMesh#meshId}.\n\nCreated by {@link XKTModel#createMesh}.",
    "lineNumber": 213,
    "type": {
      "nullable": null,
      "types": [
        "{Number:XKTMesh}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 138,
    "kind": "member",
    "name": "meshesList",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#meshesList",
    "access": "public",
    "description": "List of {@link XKTMesh}s within this XKTModel, in the order they were created.\n\nEach XKTMesh holds its position in this list in {@link XKTMesh#meshIndex}.\n\nCreated by {@link XKTModel#finalize}.",
    "lineNumber": 224,
    "type": {
      "nullable": null,
      "types": [
        "XKTMesh[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 139,
    "kind": "member",
    "name": "entities",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#entities",
    "access": "public",
    "description": "Map of {@link XKTEntity}s within this XKTModel, each mapped to {@link XKTEntity#entityId}.\n\nCreated by {@link XKTModel#createEntity}.",
    "lineNumber": 233,
    "type": {
      "nullable": null,
      "types": [
        "{String:XKTEntity}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 140,
    "kind": "member",
    "name": "entitiesList",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#entitiesList",
    "access": "public",
    "description": "{@link XKTEntity}s within this XKTModel.\n\nEach XKTEntity holds its position in this list in {@link XKTEntity#entityIndex}.\n\nCreated by {@link XKTModel#finalize}.",
    "lineNumber": 244,
    "type": {
      "nullable": null,
      "types": [
        "XKTEntity[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 141,
    "kind": "member",
    "name": "tilesList",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#tilesList",
    "access": "public",
    "description": "{@link XKTTile}s within this XKTModel.\n\nCreated by {@link XKTModel#finalize}.",
    "lineNumber": 253,
    "type": {
      "nullable": null,
      "types": [
        "XKTTile[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 142,
    "kind": "member",
    "name": "aabb",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#aabb",
    "access": "public",
    "description": "The axis-aligned 3D World-space boundary of this XKTModel.\n\nCreated by {@link XKTModel#finalize}.",
    "lineNumber": 262,
    "type": {
      "nullable": null,
      "types": [
        "Float64Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 143,
    "kind": "member",
    "name": "finalized",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#finalized",
    "access": "public",
    "description": "Indicates if this XKTModel has been finalized.\n\nSet ````true```` by {@link XKTModel#finalize}.",
    "lineNumber": 271,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 144,
    "kind": "method",
    "name": "createPropertySet",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#createPropertySet",
    "access": "public",
    "description": "Creates an {@link XKTPropertySet} within this XKTModel.\n\nLogs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).",
    "lineNumber": 286,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{XKTPropertySet} The new {@link XKTPropertySet}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Method parameters."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "params.propertySetId",
        "description": "Unique ID for the {@link XKTPropertySet}."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "\"default\"",
        "defaultRaw": "default",
        "name": "params.propertySetType",
        "description": "A meta type for the {@link XKTPropertySet}."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "params.propertySetName",
        "description": "Human-readable name for the {@link XKTPropertySet}. Defaults to the ````propertySetId```` parameter."
      },
      {
        "nullable": null,
        "types": [
          "String[]"
        ],
        "spread": false,
        "optional": false,
        "name": "params.properties",
        "description": "Properties for the {@link XKTPropertySet}."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "XKTPropertySet"
      ],
      "spread": false,
      "description": "The new {@link XKTPropertySet}."
    }
  },
  {
    "__docId__": 145,
    "kind": "method",
    "name": "createMetaObject",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#createMetaObject",
    "access": "public",
    "description": "Creates an {@link XKTMetaObject} within this XKTModel.\n\nLogs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).",
    "lineNumber": 339,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{XKTMetaObject} The new {@link XKTMetaObject}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Method parameters."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "params.metaObjectId",
        "description": "Unique ID for the {@link XKTMetaObject}."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "params.propertySetIds",
        "description": "ID of one or more property sets that contains additional metadata about\nthis {@link XKTMetaObject}. The property sets could be stored externally (ie not managed at all by the XKT file),\nor could be {@link XKTPropertySet}s within {@link XKTModel#propertySets}."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "\"default\"",
        "defaultRaw": "default",
        "name": "params.metaObjectType",
        "description": "A meta type for the {@link XKTMetaObject}. Can be anything,\nbut is usually an IFC type, such as \"IfcSite\" or \"IfcWall\"."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "params.metaObjectName",
        "description": "Human-readable name for the {@link XKTMetaObject}. Defaults to the ````metaObjectId```` parameter."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "params.parentMetaObjectId",
        "description": "ID of the parent {@link XKTMetaObject}, if any. Defaults to the ````metaObjectId```` parameter."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "XKTMetaObject"
      ],
      "spread": false,
      "description": "The new {@link XKTMetaObject}."
    }
  },
  {
    "__docId__": 146,
    "kind": "member",
    "name": "_rootMetaObject",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_rootMetaObject",
    "access": "private",
    "description": null,
    "lineNumber": 372,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 147,
    "kind": "method",
    "name": "createGeometry",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#createGeometry",
    "access": "public",
    "description": "Creates an {@link XKTGeometry} within this XKTModel.\n\nLogs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).",
    "lineNumber": 395,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{XKTGeometry} The new {@link XKTGeometry}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Method parameters."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "params.geometryId",
        "description": "Unique ID for the {@link XKTGeometry}."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "params.primitiveType",
        "description": "The type of {@link XKTGeometry}: \"triangles\", \"lines\" or \"points\"."
      },
      {
        "nullable": null,
        "types": [
          "Float64Array"
        ],
        "spread": false,
        "optional": false,
        "name": "params.positions",
        "description": "Floating-point Local-space vertex positions for the {@link XKTGeometry}. Required for all primitive types."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "params.normals",
        "description": "Floating-point vertex normals for the {@link XKTGeometry}. Only used with triangles primitives. Ignored for points and lines."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "params.colors",
        "description": "Floating-point RGBA vertex colors for the {@link XKTGeometry}. Required for points primitives. Ignored for lines and triangles."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "params.colorsCompressed",
        "description": "Integer RGBA vertex colors for the {@link XKTGeometry}. Required for points primitives. Ignored for lines and triangles."
      },
      {
        "nullable": null,
        "types": [
          "Uint32Array"
        ],
        "spread": false,
        "optional": true,
        "name": "params.indices",
        "description": "Indices for the {@link XKTGeometry}. Required for triangles and lines primitives. Ignored for points."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "10",
        "defaultRaw": 10,
        "name": "params.edgeThreshold",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "XKTGeometry"
      ],
      "spread": false,
      "description": "The new {@link XKTGeometry}."
    }
  },
  {
    "__docId__": 148,
    "kind": "method",
    "name": "createMesh",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#createMesh",
    "access": "public",
    "description": "Creates an {@link XKTMesh} within this XKTModel.\n\nAn {@link XKTMesh} can be owned by one {@link XKTEntity}, which can own multiple {@link XKTMesh}es.",
    "lineNumber": 530,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{XKTMesh} The new {@link XKTMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Method parameters."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "params.meshId",
        "description": "Unique ID for the {@link XKTMesh}."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "params.geometryId",
        "description": "ID of an existing {@link XKTGeometry} in {@link XKTModel#geometries}."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "params.color",
        "description": "RGB color for the {@link XKTMesh}, with each color component in range [0..1]."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "params.metallic",
        "description": "How metallic the {@link XKTMesh} is, in range [0..1]. A value of ````0```` indicates fully dielectric material, while ````1```` indicates fully metallic."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "params.roughness",
        "description": "How rough the {@link XKTMesh} is, in range [0..1]. A value of ````0```` indicates fully smooth, while ````1```` indicates fully rough."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "params.opacity",
        "description": "Opacity factor for the {@link XKTMesh}, in range [0..1]."
      },
      {
        "nullable": null,
        "types": [
          "Float64Array"
        ],
        "spread": false,
        "optional": true,
        "name": "params.matrix",
        "description": "Modeling matrix for the {@link XKTMesh}. Overrides ````position````, ````scale```` and ````rotation```` parameters."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[0,0,0]",
        "defaultRaw": [
          0,
          0,
          0
        ],
        "name": "params.position",
        "description": "Position of the {@link XKTMesh}. Overridden by the ````matrix```` parameter."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[1,1,1]",
        "defaultRaw": [
          1,
          1,
          1
        ],
        "name": "params.scale",
        "description": "Scale of the {@link XKTMesh}. Overridden by the ````matrix```` parameter."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[0,0,0]",
        "defaultRaw": [
          0,
          0,
          0
        ],
        "name": "params.rotation",
        "description": "Rotation of the {@link XKTMesh} as Euler angles given in degrees, for each of the X, Y and Z axis. Overridden by the ````matrix```` parameter."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "XKTMesh"
      ],
      "spread": false,
      "description": "The new {@link XKTMesh}."
    }
  },
  {
    "__docId__": 149,
    "kind": "method",
    "name": "createEntity",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#createEntity",
    "access": "public",
    "description": "Creates an {@link XKTEntity} within this XKTModel.\n\nLogs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).",
    "lineNumber": 605,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{XKTEntity} The new {@link XKTEntity}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Method parameters."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "params.entityId",
        "description": "Unique ID for the {@link XKTEntity}."
      },
      {
        "nullable": null,
        "types": [
          "String[]"
        ],
        "spread": false,
        "optional": false,
        "name": "params.meshIds",
        "description": "IDs of {@link XKTMesh}es used by the {@link XKTEntity}. Note that each {@link XKTMesh} can only be used by one {@link XKTEntity}."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "XKTEntity"
      ],
      "spread": false,
      "description": "The new {@link XKTEntity}."
    }
  },
  {
    "__docId__": 150,
    "kind": "method",
    "name": "createDefaultMetaObjects",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#createDefaultMetaObjects",
    "access": "public",
    "description": "Creates a default {@link XKTMetaObject} for each {@link XKTEntity} that does not already have one.",
    "lineNumber": 675,
    "params": [],
    "return": null
  },
  {
    "__docId__": 152,
    "kind": "method",
    "name": "finalize",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#finalize",
    "access": "public",
    "description": "Finalizes this XKTModel.\n\nAfter finalizing, we may then serialize the model to an array buffer using {@link writeXKTModelToArrayBuffer}.\n\nLogs error and does nothing if this XKTModel has already been finalized.\n\nInternally, this method:\n\n* for each {@link XKTEntity} that doesn't already have a {@link XKTMetaObject}, creates one with {@link XKTMetaObject#metaObjectType} set to \"default\"\n* sets each {@link XKTEntity}'s {@link XKTEntity#hasReusedGeometries} true if it shares its {@link XKTGeometry}s with other {@link XKTEntity}s,\n* creates each {@link XKTEntity}'s {@link XKTEntity#aabb},\n* creates {@link XKTTile}s in {@link XKTModel#tilesList}, and\n* sets {@link XKTModel#finalized} ````true````.",
    "lineNumber": 718,
    "params": [],
    "return": null
  },
  {
    "__docId__": 155,
    "kind": "method",
    "name": "_bakeSingleUseGeometryPositions",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_bakeSingleUseGeometryPositions",
    "access": "private",
    "description": null,
    "lineNumber": 746,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 156,
    "kind": "method",
    "name": "_bakeAndOctEncodeNormals",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_bakeAndOctEncodeNormals",
    "access": "private",
    "description": null,
    "lineNumber": 780,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 157,
    "kind": "method",
    "name": "_createEntityAABBs",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createEntityAABBs",
    "access": "private",
    "description": null,
    "lineNumber": 802,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 158,
    "kind": "method",
    "name": "_createKDTree",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createKDTree",
    "access": "private",
    "description": null,
    "lineNumber": 844,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 159,
    "kind": "method",
    "name": "_insertEntityIntoKDTree",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_insertEntityIntoKDTree",
    "access": "private",
    "description": null,
    "lineNumber": 863,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "kdNode",
        "types": [
          "*"
        ]
      },
      {
        "name": "entity",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 160,
    "kind": "method",
    "name": "_createTilesFromKDTree",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createTilesFromKDTree",
    "access": "private",
    "description": null,
    "lineNumber": 931,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "rootKDNode",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 161,
    "kind": "method",
    "name": "_createTilesFromKDNode",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createTilesFromKDNode",
    "access": "private",
    "description": null,
    "lineNumber": 935,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "kdNode",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 162,
    "kind": "method",
    "name": "_createTileFromEntities",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createTileFromEntities",
    "access": "private",
    "description": "Creates a tile from the given entities.\n\nFor each single-use {@link XKTGeometry}, this method centers {@link XKTGeometry#positions} to make them relative to the\ntile's center, then quantizes the positions to unsigned 16-bit integers, relative to the tile's boundary.",
    "lineNumber": 955,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "entities",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 163,
    "kind": "method",
    "name": "_createReusedGeometriesDecodeMatrix",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createReusedGeometriesDecodeMatrix",
    "access": "private",
    "description": null,
    "lineNumber": 1024,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 164,
    "kind": "method",
    "name": "_flagSolidGeometries",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_flagSolidGeometries",
    "access": "private",
    "description": null,
    "lineNumber": 1069,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 165,
    "kind": "file",
    "name": "src/XKTModel/XKTPropertySet.js",
    "content": "/**\n * A property set within an {@link XKTModel}.\n *\n * These are shared among {@link XKTMetaObject}s.\n *\n * * Created by {@link XKTModel#createPropertySet}\n * * Stored in {@link XKTModel#propertySets} and {@link XKTModel#propertySetsList}\n * * Has an ID, a type, and a human-readable name\n *\n * @class XKTPropertySet\n */\nclass XKTPropertySet {\n\n    /**\n     * @private\n     */\n    constructor(propertySetId, propertySetType, propertySetName, properties) {\n\n        /**\n         * Unique ID of this ````XKTPropertySet```` in {@link XKTModel#propertySets}.\n         *\n         * @type {String}\n         */\n        this.propertySetId = propertySetId;\n\n        /**\n         * Indicates the ````XKTPropertySet````'s type.\n         *\n         * This defaults to \"default\".\n         *\n         * @type {string}\n         */\n        this.propertySetType = propertySetType;\n\n        /**\n         * Indicates the XKTPropertySet meta object name.\n         *\n         * This defaults to {@link XKTPropertySet#propertySetId}.\n         *\n         * @type {string}\n         */\n        this.propertySetName = propertySetName;\n\n        /**\n         * The properties within this ````XKTPropertySet````.\n         *\n         * @type {*[]}\n         */\n        this.properties = properties;\n    }\n}\n\nexport {XKTPropertySet};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/XKTModel/XKTPropertySet.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 166,
    "kind": "class",
    "name": "XKTPropertySet",
    "memberof": "src/XKTModel/XKTPropertySet.js",
    "static": true,
    "longname": "src/XKTModel/XKTPropertySet.js~XKTPropertySet",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTPropertySet.js",
    "importStyle": "{XKTPropertySet}",
    "description": "A property set within an {@link XKTModel}.\n\nThese are shared among {@link XKTMetaObject}s.\n\n* Created by {@link XKTModel#createPropertySet}\n* Stored in {@link XKTModel#propertySets} and {@link XKTModel#propertySetsList}\n* Has an ID, a type, and a human-readable name",
    "lineNumber": 12,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTPropertySet"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 167,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTPropertySet.js~XKTPropertySet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTPropertySet.js~XKTPropertySet#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 17,
    "ignore": true
  },
  {
    "__docId__": 168,
    "kind": "member",
    "name": "propertySetId",
    "memberof": "src/XKTModel/XKTPropertySet.js~XKTPropertySet",
    "static": false,
    "longname": "src/XKTModel/XKTPropertySet.js~XKTPropertySet#propertySetId",
    "access": "public",
    "description": "Unique ID of this ````XKTPropertySet```` in {@link XKTModel#propertySets}.",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 169,
    "kind": "member",
    "name": "propertySetType",
    "memberof": "src/XKTModel/XKTPropertySet.js~XKTPropertySet",
    "static": false,
    "longname": "src/XKTModel/XKTPropertySet.js~XKTPropertySet#propertySetType",
    "access": "public",
    "description": "Indicates the ````XKTPropertySet````'s type.\n\nThis defaults to \"default\".",
    "lineNumber": 33,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 170,
    "kind": "member",
    "name": "propertySetName",
    "memberof": "src/XKTModel/XKTPropertySet.js~XKTPropertySet",
    "static": false,
    "longname": "src/XKTModel/XKTPropertySet.js~XKTPropertySet#propertySetName",
    "access": "public",
    "description": "Indicates the XKTPropertySet meta object name.\n\nThis defaults to {@link XKTPropertySet#propertySetId}.",
    "lineNumber": 42,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 171,
    "kind": "member",
    "name": "properties",
    "memberof": "src/XKTModel/XKTPropertySet.js~XKTPropertySet",
    "static": false,
    "longname": "src/XKTModel/XKTPropertySet.js~XKTPropertySet#properties",
    "access": "public",
    "description": "The properties within this ````XKTPropertySet````.",
    "lineNumber": 49,
    "type": {
      "nullable": null,
      "types": [
        "*[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 172,
    "kind": "file",
    "name": "src/XKTModel/XKTTile.js",
    "content": "/**\n * @desc A box-shaped 3D region within an {@link XKTModel} that contains {@link XKTEntity}s.\n *\n * * Created by {@link XKTModel#finalize}\n * * Stored in {@link XKTModel#tilesList}\n *\n * @class XKTTile\n */\nclass XKTTile {\n\n    /**\n     * Creates a new XKTTile.\n     *\n     * @private\n     * @param aabb\n     * @param entities\n     */\n    constructor(aabb, entities) {\n\n        /**\n         * Axis-aligned World-space bounding box that encloses the {@link XKTEntity}'s within this Tile.\n         *\n         * @type {Float64Array}\n         */\n        this.aabb = aabb;\n\n        /**\n         * The {@link XKTEntity}'s within this XKTTile.\n         *\n         * @type {XKTEntity[]}\n         */\n        this.entities = entities;\n    }\n}\n\nexport {XKTTile};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/XKTModel/XKTTile.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 173,
    "kind": "class",
    "name": "XKTTile",
    "memberof": "src/XKTModel/XKTTile.js",
    "static": true,
    "longname": "src/XKTModel/XKTTile.js~XKTTile",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTTile.js",
    "importStyle": "{XKTTile}",
    "description": "A box-shaped 3D region within an {@link XKTModel} that contains {@link XKTEntity}s.\n\n* Created by {@link XKTModel#finalize}\n* Stored in {@link XKTModel#tilesList}",
    "lineNumber": 9,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTTile"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 174,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTTile.js~XKTTile",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTTile.js~XKTTile#constructor",
    "access": "private",
    "description": "Creates a new XKTTile.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "aabb",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "entities",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 175,
    "kind": "member",
    "name": "aabb",
    "memberof": "src/XKTModel/XKTTile.js~XKTTile",
    "static": false,
    "longname": "src/XKTModel/XKTTile.js~XKTTile#aabb",
    "access": "public",
    "description": "Axis-aligned World-space bounding box that encloses the {@link XKTEntity}'s within this Tile.",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "Float64Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 176,
    "kind": "member",
    "name": "entities",
    "memberof": "src/XKTModel/XKTTile.js~XKTTile",
    "static": false,
    "longname": "src/XKTModel/XKTTile.js~XKTTile#entities",
    "access": "public",
    "description": "The {@link XKTEntity}'s within this XKTTile.",
    "lineNumber": 32,
    "type": {
      "nullable": null,
      "types": [
        "XKTEntity[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 177,
    "kind": "file",
    "name": "src/XKTModel/lib/buildEdgeIndices.js",
    "content": "import {math} from \"../../lib/math.js\";\n\n/**\n * @private\n */\nconst buildEdgeIndices = (function () {\n\n    const uniquePositions = [];\n    const indicesLookup = [];\n    const indicesReverseLookup = [];\n    const weldedIndices = [];\n\n// TODO: Optimize with caching, but need to cater to both compressed and uncompressed positions\n\n    const faces = [];\n    let numFaces = 0;\n    const compa = new Uint16Array(3);\n    const compb = new Uint16Array(3);\n    const compc = new Uint16Array(3);\n    const a = math.vec3();\n    const b = math.vec3();\n    const c = math.vec3();\n    const cb = math.vec3();\n    const ab = math.vec3();\n    const cross = math.vec3();\n    const normal = math.vec3();\n    const inverseNormal = math.vec3();\n\n    function weldVertices(positions, indices) {\n        const positionsMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n        let vx;\n        let vy;\n        let vz;\n        let key;\n        const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n        const precision = Math.pow(10, precisionPoints);\n        let i;\n        let len;\n        let lenUniquePositions = 0;\n        for (i = 0, len = positions.length; i < len; i += 3) {\n            vx = positions[i];\n            vy = positions[i + 1];\n            vz = positions[i + 2];\n            key = Math.round(vx * precision) + '_' + Math.round(vy * precision) + '_' + Math.round(vz * precision);\n            if (positionsMap[key] === undefined) {\n                positionsMap[key] = lenUniquePositions / 3;\n                uniquePositions[lenUniquePositions++] = vx;\n                uniquePositions[lenUniquePositions++] = vy;\n                uniquePositions[lenUniquePositions++] = vz;\n            }\n            indicesLookup[i / 3] = positionsMap[key];\n        }\n        for (i = 0, len = indices.length; i < len; i++) {\n            weldedIndices[i] = indicesLookup[indices[i]];\n            indicesReverseLookup[weldedIndices[i]] = indices[i];\n        }\n    }\n\n    function buildFaces(numIndices, positionsDecodeMatrix) {\n        numFaces = 0;\n        for (let i = 0, len = numIndices; i < len; i += 3) {\n            const ia = ((weldedIndices[i]) * 3);\n            const ib = ((weldedIndices[i + 1]) * 3);\n            const ic = ((weldedIndices[i + 2]) * 3);\n            if (positionsDecodeMatrix) {\n                compa[0] = uniquePositions[ia];\n                compa[1] = uniquePositions[ia + 1];\n                compa[2] = uniquePositions[ia + 2];\n                compb[0] = uniquePositions[ib];\n                compb[1] = uniquePositions[ib + 1];\n                compb[2] = uniquePositions[ib + 2];\n                compc[0] = uniquePositions[ic];\n                compc[1] = uniquePositions[ic + 1];\n                compc[2] = uniquePositions[ic + 2];\n                // Decode\n                math.decompressPosition(compa, positionsDecodeMatrix, a);\n                math.decompressPosition(compb, positionsDecodeMatrix, b);\n                math.decompressPosition(compc, positionsDecodeMatrix, c);\n            } else {\n                a[0] = uniquePositions[ia];\n                a[1] = uniquePositions[ia + 1];\n                a[2] = uniquePositions[ia + 2];\n                b[0] = uniquePositions[ib];\n                b[1] = uniquePositions[ib + 1];\n                b[2] = uniquePositions[ib + 2];\n                c[0] = uniquePositions[ic];\n                c[1] = uniquePositions[ic + 1];\n                c[2] = uniquePositions[ic + 2];\n            }\n            math.subVec3(c, b, cb);\n            math.subVec3(a, b, ab);\n            math.cross3Vec3(cb, ab, cross);\n            math.normalizeVec3(cross, normal);\n            const face = faces[numFaces] || (faces[numFaces] = {normal: math.vec3()});\n            face.normal[0] = normal[0];\n            face.normal[1] = normal[1];\n            face.normal[2] = normal[2];\n            numFaces++;\n        }\n    }\n\n    return function (positions, indices, positionsDecodeMatrix, edgeThreshold) {\n        weldVertices(positions, indices);\n        buildFaces(indices.length, positionsDecodeMatrix);\n        const edgeIndices = [];\n        const thresholdDot = Math.cos(math.DEGTORAD * edgeThreshold);\n        const edges = {};\n        let edge1;\n        let edge2;\n        let index1;\n        let index2;\n        let key;\n        let largeIndex = false;\n        let edge;\n        let normal1;\n        let normal2;\n        let dot;\n        let ia;\n        let ib;\n        for (let i = 0, len = indices.length; i < len; i += 3) {\n            const faceIndex = i / 3;\n            for (let j = 0; j < 3; j++) {\n                edge1 = weldedIndices[i + j];\n                edge2 = weldedIndices[i + ((j + 1) % 3)];\n                index1 = Math.min(edge1, edge2);\n                index2 = Math.max(edge1, edge2);\n                key = index1 + ',' + index2;\n                if (edges[key] === undefined) {\n                    edges[key] = {\n                        index1: index1,\n                        index2: index2,\n                        face1: faceIndex,\n                        face2: undefined,\n                    };\n                } else {\n                    edges[key].face2 = faceIndex;\n                }\n            }\n        }\n        for (key in edges) {\n            edge = edges[key];\n            // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\n            if (edge.face2 !== undefined) {\n                normal1 = faces[edge.face1].normal;\n                normal2 = faces[edge.face2].normal;\n                inverseNormal[0] = -normal2[0];\n                inverseNormal[1] = -normal2[1];\n                inverseNormal[2] = -normal2[2];\n                dot = Math.abs(math.dotVec3(normal1, normal2));\n                const dot2 = Math.abs(math.dotVec3(normal1, inverseNormal));\n                if (dot > thresholdDot && dot2 > thresholdDot) {\n                    continue;\n                }\n            }\n            ia = indicesReverseLookup[edge.index1];\n            ib = indicesReverseLookup[edge.index2];\n            if (!largeIndex && ia > 65535 || ib > 65535) {\n                largeIndex = true;\n            }\n            edgeIndices.push(ia);\n            edgeIndices.push(ib);\n        }\n        return (largeIndex) ? new Uint32Array(edgeIndices) : new Uint16Array(edgeIndices);\n    };\n})();\n\n\nexport {buildEdgeIndices};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/XKTModel/lib/buildEdgeIndices.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 178,
    "kind": "variable",
    "name": "buildEdgeIndices",
    "memberof": "src/XKTModel/lib/buildEdgeIndices.js",
    "static": true,
    "longname": "src/XKTModel/lib/buildEdgeIndices.js~buildEdgeIndices",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/buildEdgeIndices.js",
    "importStyle": "{buildEdgeIndices}",
    "description": "",
    "lineNumber": 6,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 179,
    "kind": "file",
    "name": "src/XKTModel/lib/buildFaceNormals.js",
    "content": "import {math} from \"./math.js\";\n\n/**\n * Builds face-aligned vertex normal vectors from positions and indices.\n *\n * @private\n */\nfunction buildFaceNormals(positions, indices, normals) {\n\n    const a = math.vec3();\n    const b = math.vec3();\n    const c = math.vec3();\n\n    const normVec = math.vec3();\n\n    for (let i = 0, len = indices.length; i < len; i += 3) {\n\n        const j0 = indices[i];\n        const j1 = indices[i + 1];\n        const j2 = indices[i + 2];\n\n        a[0] = positions[j0 * 3];\n        a[1] = positions[j0 * 3 + 1];\n        a[2] = positions[j0 * 3 + 2];\n\n        b[0] = positions[j1 * 3];\n        b[1] = positions[j1 * 3 + 1];\n        b[2] = positions[j1 * 3 + 2];\n\n        c[0] = positions[j2 * 3];\n        c[1] = positions[j2 * 3 + 1];\n        c[2] = positions[j2 * 3 + 2];\n\n        triangleNormal(a,b,c, normVec);\n\n        normals[j0 * 3 + 0] = normVec[0];\n        normals[j0 * 3 + 1] = normVec[1];\n        normals[j0 * 3 + 2] = normVec[2];\n\n        normals[j1 * 3 + 0] = normVec[0];\n        normals[j1 * 3 + 1] = normVec[1];\n        normals[j1 * 3 + 2] = normVec[2];\n\n        normals[j2 * 3 + 0] = normVec[0];\n        normals[j2 * 3 + 1] = normVec[1];\n        normals[j2 * 3 + 2] = normVec[2];\n    }\n}\n\nfunction triangleNormal(a, b, c, normal = math.vec3()) {\n    const p1x = b[0] - a[0];\n    const p1y = b[1] - a[1];\n    const p1z = b[2] - a[2];\n\n    const p2x = c[0] - a[0];\n    const p2y = c[1] - a[1];\n    const p2z = c[2] - a[2];\n\n    const p3x = p1y * p2z - p1z * p2y;\n    const p3y = p1z * p2x - p1x * p2z;\n    const p3z = p1x * p2y - p1y * p2x;\n\n    const mag = Math.sqrt(p3x * p3x + p3y * p3y + p3z * p3z);\n    if (mag === 0) {\n        normal[0] = 0;\n        normal[1] = 0;\n        normal[2] = 0;\n    } else {\n        normal[0] = p3x / mag;\n        normal[1] = p3y / mag;\n        normal[2] = p3z / mag;\n    }\n\n    return normal\n}\n\nexport {buildFaceNormals};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/XKTModel/lib/buildFaceNormals.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 180,
    "kind": "function",
    "name": "triangleNormal",
    "memberof": "src/XKTModel/lib/buildFaceNormals.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/buildFaceNormals.js~triangleNormal",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/buildFaceNormals.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      },
      {
        "name": "c",
        "types": [
          "*"
        ]
      },
      {
        "name": "normal",
        "optional": true,
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 181,
    "kind": "function",
    "name": "buildFaceNormals",
    "memberof": "src/XKTModel/lib/buildFaceNormals.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/buildFaceNormals.js~buildFaceNormals",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/buildFaceNormals.js",
    "importStyle": "{buildFaceNormals}",
    "description": "Builds face-aligned vertex normal vectors from positions and indices.",
    "lineNumber": 8,
    "ignore": true,
    "params": [
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "indices",
        "types": [
          "*"
        ]
      },
      {
        "name": "normals",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 182,
    "kind": "file",
    "name": "src/XKTModel/lib/buildVertexNormals.js",
    "content": "import {math} from \"./math.js\";\n\n/**\n * Builds vertex normal vectors from positions and indices.\n *\n * @private\n */\nfunction buildVertexNormals(positions, indices, normals) {\n\n    const a = math.vec3();\n    const b = math.vec3();\n    const c = math.vec3();\n    const ab = math.vec3();\n    const ac = math.vec3();\n    const crossVec = math.vec3();\n    const nvecs = new Array(positions.length / 3);\n\n    for (let i = 0, len = indices.length; i < len; i += 3) {\n\n        const j0 = indices[i];\n        const j1 = indices[i + 1];\n        const j2 = indices[i + 2];\n\n        a[0] = positions[j0 * 3];\n        a[1] = positions[j0 * 3 + 1];\n        a[2] = positions[j0 * 3 + 2];\n\n        b[0] = positions[j1 * 3];\n        b[1] = positions[j1 * 3 + 1];\n        b[2] = positions[j1 * 3 + 2];\n\n        c[0] = positions[j2 * 3];\n        c[1] = positions[j2 * 3 + 1];\n        c[2] = positions[j2 * 3 + 2];\n\n        math.subVec3(b, a, ab);\n        math.subVec3(c, a, ac);\n\n        const normVec = math.vec3();\n\n        math.normalizeVec3(math.cross3Vec3(ab, ac, crossVec), normVec);\n\n        if (!nvecs[j0]) {\n            nvecs[j0] = [];\n        }\n        if (!nvecs[j1]) {\n            nvecs[j1] = [];\n        }\n        if (!nvecs[j2]) {\n            nvecs[j2] = [];\n        }\n\n        nvecs[j0].push(normVec);\n        nvecs[j1].push(normVec);\n        nvecs[j2].push(normVec);\n    }\n\n    normals = (normals && normals.length === positions.length) ? normals : new Float32Array(positions.length);\n\n    for (let i = 0, len = nvecs.length; i < len; i++) {  // Now go through and average out everything\n\n        const count = nvecs[i].length;\n\n        let x = 0;\n        let y = 0;\n        let z = 0;\n\n        for (let j = 0; j < count; j++) {\n            x += nvecs[i][j][0];\n            y += nvecs[i][j][1];\n            z += nvecs[i][j][2];\n        }\n\n        normals[i * 3] = (x / count);\n        normals[i * 3 + 1] = (y / count);\n        normals[i * 3 + 2] = (z / count);\n    }\n\n    return normals;\n}\n\nexport {buildVertexNormals};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/XKTModel/lib/buildVertexNormals.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 183,
    "kind": "function",
    "name": "buildVertexNormals",
    "memberof": "src/XKTModel/lib/buildVertexNormals.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/buildVertexNormals.js~buildVertexNormals",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/buildVertexNormals.js",
    "importStyle": "{buildVertexNormals}",
    "description": "Builds vertex normal vectors from positions and indices.",
    "lineNumber": 8,
    "ignore": true,
    "params": [
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "indices",
        "types": [
          "*"
        ]
      },
      {
        "name": "normals",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 184,
    "kind": "file",
    "name": "src/XKTModel/lib/earcut.js",
    "content": "/** @private */\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 1 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim);\n            triangles.push(ear.i / dim);\n            triangles.push(next.i / dim);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n                // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n                // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var p = ear.next.next;\n\n    while (p !== ear.prev) {\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // triangle bbox; min & max are calculated like this for speed\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\n        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\n        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\n        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(minTX, minTY, minX, minY, invSize),\n        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim);\n            triangles.push(p.i / dim);\n            triangles.push(b.i / dim);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize);\n                earcutLinked(c, triangles, dim, minX, minY, invSize);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        eliminateHole(queue[i], outerNode);\n        outerNode = filterPoints(outerNode, outerNode.next);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    outerNode = findHoleBridge(hole, outerNode);\n    if (outerNode) {\n        var b = splitPolygon(outerNode, hole);\n\n        // filter collinear points around the cuts\n        filterPoints(outerNode, outerNode.next);\n        filterPoints(b, b.next);\n    }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                if (x === hx) {\n                    if (hy === p.y) return p;\n                    if (hy === p.next.y) return p.next;\n                }\n                m = p.x < p.next.x ? p : p.next;\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n            pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = 32767 * (x - minX) * invSize;\n    y = 32767 * (y - minY) * invSize;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n        (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n        (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n        (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n            intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n            (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = null;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n\nexport {earcut};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/XKTModel/lib/earcut.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 185,
    "kind": "function",
    "name": "linkedList",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~linkedList",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "end",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      },
      {
        "name": "clockwise",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 186,
    "kind": "function",
    "name": "filterPoints",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~filterPoints",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "end",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 187,
    "kind": "function",
    "name": "earcutLinked",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~earcutLinked",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 84,
    "undocument": true,
    "params": [
      {
        "name": "ear",
        "types": [
          "*"
        ]
      },
      {
        "name": "triangles",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      },
      {
        "name": "minX",
        "types": [
          "*"
        ]
      },
      {
        "name": "minY",
        "types": [
          "*"
        ]
      },
      {
        "name": "invSize",
        "types": [
          "*"
        ]
      },
      {
        "name": "pass",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 188,
    "kind": "function",
    "name": "isEar",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~isEar",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 137,
    "undocument": true,
    "params": [
      {
        "name": "ear",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 189,
    "kind": "function",
    "name": "isEarHashed",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~isEarHashed",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 156,
    "undocument": true,
    "params": [
      {
        "name": "ear",
        "types": [
          "*"
        ]
      },
      {
        "name": "minX",
        "types": [
          "*"
        ]
      },
      {
        "name": "minY",
        "types": [
          "*"
        ]
      },
      {
        "name": "invSize",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 190,
    "kind": "function",
    "name": "cureLocalIntersections",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~cureLocalIntersections",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 209,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "triangles",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 191,
    "kind": "function",
    "name": "splitEarcut",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~splitEarcut",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 234,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "triangles",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      },
      {
        "name": "minX",
        "types": [
          "*"
        ]
      },
      {
        "name": "minY",
        "types": [
          "*"
        ]
      },
      {
        "name": "invSize",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 192,
    "kind": "function",
    "name": "eliminateHoles",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~eliminateHoles",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 260,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "holeIndices",
        "types": [
          "*"
        ]
      },
      {
        "name": "outerNode",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 193,
    "kind": "function",
    "name": "compareX",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~compareX",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 283,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 194,
    "kind": "function",
    "name": "eliminateHole",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~eliminateHole",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 288,
    "undocument": true,
    "params": [
      {
        "name": "hole",
        "types": [
          "*"
        ]
      },
      {
        "name": "outerNode",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 195,
    "kind": "function",
    "name": "findHoleBridge",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~findHoleBridge",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 300,
    "undocument": true,
    "params": [
      {
        "name": "hole",
        "types": [
          "*"
        ]
      },
      {
        "name": "outerNode",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 196,
    "kind": "function",
    "name": "sectorContainsSector",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~sectorContainsSector",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 360,
    "undocument": true,
    "params": [
      {
        "name": "m",
        "types": [
          "*"
        ]
      },
      {
        "name": "p",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 197,
    "kind": "function",
    "name": "indexCurve",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~indexCurve",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 365,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "minX",
        "types": [
          "*"
        ]
      },
      {
        "name": "minY",
        "types": [
          "*"
        ]
      },
      {
        "name": "invSize",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 198,
    "kind": "function",
    "name": "sortLinked",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~sortLinked",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 382,
    "undocument": true,
    "params": [
      {
        "name": "list",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 199,
    "kind": "function",
    "name": "zOrder",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~zOrder",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 434,
    "undocument": true,
    "params": [
      {
        "name": "x",
        "types": [
          "*"
        ]
      },
      {
        "name": "y",
        "types": [
          "*"
        ]
      },
      {
        "name": "minX",
        "types": [
          "*"
        ]
      },
      {
        "name": "minY",
        "types": [
          "*"
        ]
      },
      {
        "name": "invSize",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 200,
    "kind": "function",
    "name": "getLeftmost",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~getLeftmost",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 453,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 201,
    "kind": "function",
    "name": "pointInTriangle",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~pointInTriangle",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 465,
    "undocument": true,
    "params": [
      {
        "name": "ax",
        "types": [
          "*"
        ]
      },
      {
        "name": "ay",
        "types": [
          "*"
        ]
      },
      {
        "name": "bx",
        "types": [
          "*"
        ]
      },
      {
        "name": "by",
        "types": [
          "*"
        ]
      },
      {
        "name": "cx",
        "types": [
          "*"
        ]
      },
      {
        "name": "cy",
        "types": [
          "*"
        ]
      },
      {
        "name": "px",
        "types": [
          "*"
        ]
      },
      {
        "name": "py",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 202,
    "kind": "function",
    "name": "isValidDiagonal",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~isValidDiagonal",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 472,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 203,
    "kind": "function",
    "name": "area",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~area",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 480,
    "undocument": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      },
      {
        "name": "q",
        "types": [
          "*"
        ]
      },
      {
        "name": "r",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 204,
    "kind": "function",
    "name": "equals",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~equals",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 485,
    "undocument": true,
    "params": [
      {
        "name": "p1",
        "types": [
          "*"
        ]
      },
      {
        "name": "p2",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 205,
    "kind": "function",
    "name": "intersects",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~intersects",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 490,
    "undocument": true,
    "params": [
      {
        "name": "p1",
        "types": [
          "*"
        ]
      },
      {
        "name": "q1",
        "types": [
          "*"
        ]
      },
      {
        "name": "p2",
        "types": [
          "*"
        ]
      },
      {
        "name": "q2",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 206,
    "kind": "function",
    "name": "onSegment",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~onSegment",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 507,
    "undocument": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      },
      {
        "name": "q",
        "types": [
          "*"
        ]
      },
      {
        "name": "r",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 207,
    "kind": "function",
    "name": "sign",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~sign",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 511,
    "undocument": true,
    "params": [
      {
        "name": "num",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 208,
    "kind": "function",
    "name": "intersectsPolygon",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~intersectsPolygon",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 516,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 209,
    "kind": "function",
    "name": "locallyInside",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~locallyInside",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 528,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 210,
    "kind": "function",
    "name": "middleInside",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~middleInside",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 535,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 211,
    "kind": "function",
    "name": "splitPolygon",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~splitPolygon",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 552,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 212,
    "kind": "function",
    "name": "insertNode",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~insertNode",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 574,
    "undocument": true,
    "params": [
      {
        "name": "i",
        "types": [
          "*"
        ]
      },
      {
        "name": "x",
        "types": [
          "*"
        ]
      },
      {
        "name": "y",
        "types": [
          "*"
        ]
      },
      {
        "name": "last",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 213,
    "kind": "function",
    "name": "removeNode",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~removeNode",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 590,
    "undocument": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 214,
    "kind": "function",
    "name": "Node",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~Node",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 598,
    "undocument": true,
    "params": [
      {
        "name": "i",
        "types": [
          "*"
        ]
      },
      {
        "name": "x",
        "types": [
          "*"
        ]
      },
      {
        "name": "y",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 215,
    "kind": "function",
    "name": "deviation",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~deviation",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 623,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "holeIndices",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      },
      {
        "name": "triangles",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 216,
    "kind": "function",
    "name": "signedArea",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~signedArea",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 650,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "end",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 217,
    "kind": "function",
    "name": "flatten",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~flatten",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 660,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 218,
    "kind": "function",
    "name": "earcut",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~earcut",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": "{earcut}",
    "description": null,
    "lineNumber": 2,
    "ignore": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "holeIndices",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 219,
    "kind": "file",
    "name": "src/XKTModel/lib/faceToVertexNormals.js",
    "content": "import {math} from \"./math.js\";\n\n/**\n * Converts surface-perpendicular face normals to vertex normals. Assumes that the mesh contains disjoint triangles\n * that don't share vertex array elements. Works by finding groups of vertices that have the same location and\n * averaging their normal vectors.\n *\n * @returns {{positions: Array, normals: *}}\n * @private\n */\nfunction faceToVertexNormals(positions, normals, options = {}) {\n    const smoothNormalsAngleThreshold = options.smoothNormalsAngleThreshold || 20;\n    const vertexMap = {};\n    const vertexNormals = [];\n    const vertexNormalAccum = {};\n    let acc;\n    let vx;\n    let vy;\n    let vz;\n    let key;\n    const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n    const precision = 10 ** precisionPoints;\n    let posi;\n    let i;\n    let j;\n    let len;\n    let a;\n    let b;\n    let c;\n\n    for (i = 0, len = positions.length; i < len; i += 3) {\n\n        posi = i / 3;\n\n        vx = positions[i];\n        vy = positions[i + 1];\n        vz = positions[i + 2];\n\n        key = `${Math.round(vx * precision)}_${Math.round(vy * precision)}_${Math.round(vz * precision)}`;\n\n        if (vertexMap[key] === undefined) {\n            vertexMap[key] = [posi];\n        } else {\n            vertexMap[key].push(posi);\n        }\n\n        const normal = math.normalizeVec3([normals[i], normals[i + 1], normals[i + 2]]);\n\n        vertexNormals[posi] = normal;\n\n        acc = math.vec4([normal[0], normal[1], normal[2], 1]);\n\n        vertexNormalAccum[posi] = acc;\n    }\n\n    for (key in vertexMap) {\n\n        if (vertexMap.hasOwnProperty(key)) {\n\n            const vertices = vertexMap[key];\n            const numVerts = vertices.length;\n\n            for (i = 0; i < numVerts; i++) {\n\n                const ii = vertices[i];\n\n                acc = vertexNormalAccum[ii];\n\n                for (j = 0; j < numVerts; j++) {\n\n                    if (i === j) {\n                        continue;\n                    }\n\n                    const jj = vertices[j];\n\n                    a = vertexNormals[ii];\n                    b = vertexNormals[jj];\n\n                    const angle = Math.abs(math.angleVec3(a, b) / math.DEGTORAD);\n\n                    if (angle < smoothNormalsAngleThreshold) {\n\n                        acc[0] += b[0];\n                        acc[1] += b[1];\n                        acc[2] += b[2];\n                        acc[3] += 1.0;\n                    }\n                }\n            }\n        }\n    }\n\n    for (i = 0, len = normals.length; i < len; i += 3) {\n\n        acc = vertexNormalAccum[i / 3];\n\n        normals[i + 0] = acc[0] / acc[3];\n        normals[i + 1] = acc[1] / acc[3];\n        normals[i + 2] = acc[2] / acc[3];\n\n    }\n}\n\nexport {faceToVertexNormals};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/XKTModel/lib/faceToVertexNormals.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 220,
    "kind": "function",
    "name": "faceToVertexNormals",
    "memberof": "src/XKTModel/lib/faceToVertexNormals.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/faceToVertexNormals.js~faceToVertexNormals",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/faceToVertexNormals.js",
    "importStyle": "{faceToVertexNormals}",
    "description": "Converts surface-perpendicular face normals to vertex normals. Assumes that the mesh contains disjoint triangles\nthat don't share vertex array elements. Works by finding groups of vertices that have the same location and\naveraging their normal vectors.",
    "lineNumber": 11,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{positions: Array, normals: *}}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{positions: Array, normals: *}"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true,
    "params": [
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "normals",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ]
  },
  {
    "__docId__": 221,
    "kind": "file",
    "name": "src/XKTModel/lib/geometryCompression.js",
    "content": "import {math} from \"../../lib/math.js\";\n\nfunction quantizePositions (positions, lenPositions, aabb, quantizedPositions) {\n    const xmin = aabb[0];\n    const ymin = aabb[1];\n    const zmin = aabb[2];\n    const xwid = aabb[3] - xmin;\n    const ywid = aabb[4] - ymin;\n    const zwid = aabb[5] - zmin;\n    const maxInt = 65535;\n    const xMultiplier = maxInt / xwid;\n    const yMultiplier = maxInt / ywid;\n    const zMultiplier = maxInt / zwid;\n    const verify = (num) => num >= 0 ? num : 0;\n    for (let i = 0; i < lenPositions; i += 3) {\n        quantizedPositions[i + 0] = Math.floor(verify(positions[i + 0] - xmin) * xMultiplier);\n        quantizedPositions[i + 1] = Math.floor(verify(positions[i + 1] - ymin) * yMultiplier);\n        quantizedPositions[i + 2] = Math.floor(verify(positions[i + 2] - zmin) * zMultiplier);\n    }\n}\n\nvar createPositionsDecodeMatrix = (function () {\n    const translate = math.mat4();\n    const scale = math.mat4();\n    return function (aabb, positionsDecodeMatrix) {\n        positionsDecodeMatrix = positionsDecodeMatrix || math.mat4();\n        const xmin = aabb[0];\n        const ymin = aabb[1];\n        const zmin = aabb[2];\n        const xwid = aabb[3] - xmin;\n        const ywid = aabb[4] - ymin;\n        const zwid = aabb[5] - zmin;\n        const maxInt = 65535;\n        math.identityMat4(translate);\n        math.translationMat4v(aabb, translate);\n        math.identityMat4(scale);\n        math.scalingMat4v([xwid / maxInt, ywid / maxInt, zwid / maxInt], scale);\n        math.mulMat4(translate, scale, positionsDecodeMatrix);\n        return positionsDecodeMatrix;\n    };\n})();\n\nfunction transformAndOctEncodeNormals(modelNormalMatrix, normals, lenNormals, compressedNormals, lenCompressedNormals) {\n    // http://jcgt.org/published/0003/02/01/\n    let oct, dec, best, currentCos, bestCos;\n    let i, ei;\n    let localNormal = math.vec3();\n    let worldNormal =  math.vec3();\n    for (i = 0; i < lenNormals; i += 3) {\n        localNormal[0] = normals[i];\n        localNormal[1] = normals[i + 1];\n        localNormal[2] = normals[i + 2];\n\n        math.transformVec3(modelNormalMatrix, localNormal, worldNormal);\n        math.normalizeVec3(worldNormal, worldNormal);\n\n        // Test various combinations of ceil and floor to minimize rounding errors\n        best = oct = octEncodeVec3(worldNormal, 0, \"floor\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = bestCos = dot(worldNormal, 0, dec);\n        oct = octEncodeVec3(worldNormal, 0, \"ceil\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(worldNormal, 0, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeVec3(worldNormal, 0, \"floor\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(worldNormal, 0, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeVec3(worldNormal, 0, \"ceil\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(worldNormal, 0, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        compressedNormals[lenCompressedNormals + i + 0] = best[0];\n        compressedNormals[lenCompressedNormals + i + 1] = best[1];\n        compressedNormals[lenCompressedNormals + i + 2] = 0.0; // Unused\n    }\n    lenCompressedNormals += lenNormals;\n    return lenCompressedNormals;\n}\n\nfunction octEncodeNormals(normals, lenNormals, compressedNormals, lenCompressedNormals) { // http://jcgt.org/published/0003/02/01/\n    let oct, dec, best, currentCos, bestCos;\n    for (let i = 0; i < lenNormals; i += 3) {\n        // Test various combinations of ceil and floor to minimize rounding errors\n        best = oct = octEncodeVec3(normals, i, \"floor\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = bestCos = dot(normals, i, dec);\n        oct = octEncodeVec3(normals, i, \"ceil\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(normals, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeVec3(normals, i, \"floor\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(normals, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeVec3(normals, i, \"ceil\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(normals, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        compressedNormals[lenCompressedNormals + i + 0] = best[0];\n        compressedNormals[lenCompressedNormals + i + 1] = best[1];\n        compressedNormals[lenCompressedNormals + i + 2] = 0.0; // Unused\n    }\n    lenCompressedNormals += lenNormals;\n    return lenCompressedNormals;\n}\n\n/**\n * @private\n */\nfunction octEncodeVec3(array, i, xfunc, yfunc) { // Oct-encode single normal vector in 2 bytes\n    let x = array[i] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));\n    let y = array[i + 1] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));\n    if (array[i + 2] < 0) {\n        let tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n        let tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n        x = tempx;\n        y = tempy;\n    }\n    return new Int8Array([\n        Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0)),\n        Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0))\n    ]);\n}\n\n/**\n * Decode an oct-encoded normal\n */\nfunction octDecodeVec2(oct) {\n    let x = oct[0];\n    let y = oct[1];\n    x /= x < 0 ? 127 : 128;\n    y /= y < 0 ? 127 : 128;\n    const z = 1 - Math.abs(x) - Math.abs(y);\n    if (z < 0) {\n        x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n        y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n    }\n    const length = Math.sqrt(x * x + y * y + z * z);\n    return [\n        x / length,\n        y / length,\n        z / length\n    ];\n}\n\n/**\n * Dot product of a normal in an array against a candidate decoding\n * @private\n */\nfunction dot(array, i, vec3) {\n    return array[i] * vec3[0] + array[i + 1] * vec3[1] + array[i + 2] * vec3[2];\n}\n\n/**\n * @private\n */\nconst geometryCompression = {\n    quantizePositions,\n    createPositionsDecodeMatrix,\n    transformAndOctEncodeNormals,\n    octEncodeNormals,\n};\n\nexport {geometryCompression}",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/XKTModel/lib/geometryCompression.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 222,
    "kind": "function",
    "name": "quantizePositions",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~quantizePositions",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "lenPositions",
        "types": [
          "*"
        ]
      },
      {
        "name": "aabb",
        "types": [
          "*"
        ]
      },
      {
        "name": "quantizedPositions",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 223,
    "kind": "variable",
    "name": "createPositionsDecodeMatrix",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~createPositionsDecodeMatrix",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 224,
    "kind": "function",
    "name": "transformAndOctEncodeNormals",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~transformAndOctEncodeNormals",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 43,
    "undocument": true,
    "params": [
      {
        "name": "modelNormalMatrix",
        "types": [
          "*"
        ]
      },
      {
        "name": "normals",
        "types": [
          "*"
        ]
      },
      {
        "name": "lenNormals",
        "types": [
          "*"
        ]
      },
      {
        "name": "compressedNormals",
        "types": [
          "*"
        ]
      },
      {
        "name": "lenCompressedNormals",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 225,
    "kind": "function",
    "name": "octEncodeNormals",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~octEncodeNormals",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 90,
    "undocument": true,
    "params": [
      {
        "name": "normals",
        "types": [
          "*"
        ]
      },
      {
        "name": "lenNormals",
        "types": [
          "*"
        ]
      },
      {
        "name": "compressedNormals",
        "types": [
          "*"
        ]
      },
      {
        "name": "lenCompressedNormals",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 226,
    "kind": "function",
    "name": "octEncodeVec3",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~octEncodeVec3",
    "access": "private",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 129,
    "ignore": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      },
      {
        "name": "i",
        "types": [
          "*"
        ]
      },
      {
        "name": "xfunc",
        "types": [
          "*"
        ]
      },
      {
        "name": "yfunc",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 227,
    "kind": "function",
    "name": "octDecodeVec2",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~octDecodeVec2",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": "Decode an oct-encoded normal",
    "lineNumber": 147,
    "params": [
      {
        "name": "oct",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 228,
    "kind": "function",
    "name": "dot",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~dot",
    "access": "private",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": "Dot product of a normal in an array against a candidate decoding",
    "lineNumber": 169,
    "ignore": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      },
      {
        "name": "i",
        "types": [
          "*"
        ]
      },
      {
        "name": "vec3",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 229,
    "kind": "variable",
    "name": "geometryCompression",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~geometryCompression",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/geometryCompression.js",
    "importStyle": "{geometryCompression}",
    "description": "",
    "lineNumber": 176,
    "ignore": true,
    "type": {
      "types": [
        "{\"quantizePositions\": *, \"createPositionsDecodeMatrix\": *, \"transformAndOctEncodeNormals\": *, \"octEncodeNormals\": *}"
      ]
    }
  },
  {
    "__docId__": 230,
    "kind": "file",
    "name": "src/XKTModel/lib/isTriangleMeshSolid.js",
    "content": "/**\n * Uses edge adjacency counts to identify if the given triangle mesh can be rendered with backface culling enabled.\n *\n * If all edges are connected to exactly two triangles, then the mesh will likely be a closed solid, and we can safely\n * render it with backface culling enabled.\n *\n * Otherwise, the mesh is a surface, and we must render it with backface culling disabled.\n *\n * @private\n */\nconst isTriangleMeshSolid = (indices, positions, vertexIndexMapping, edges) => {\n\n    function compareIndexPositions(a, b)\n    {\n        let posA, posB;\n\n        for (let i = 0; i < 3; i++) {\n            posA = positions [a*3+i];\n            posB = positions [b*3+i];\n\n            if (posA !== posB) {\n                return posB - posA;\n            }\n        }\n\n        return 0;\n    };\n\n    // Group together indices corresponding to same position coordinates\n    let newIndices = indices.slice ().sort (compareIndexPositions);\n\n    // Calculate the mapping:\n    // - from original index in indices array\n    // - to indices-for-unique-positions\n    let uniqueVertexIndex = null;\n\n    for (let i = 0, len = newIndices.length; i < len; i++) {\n        if (i == 0 || 0 != compareIndexPositions (\n            newIndices[i],\n            newIndices[i-1],\n        )) {\n            // different position\n            uniqueVertexIndex = newIndices [i];\n        }\n\n        vertexIndexMapping [\n            newIndices[i]\n            ] = uniqueVertexIndex;\n    }\n\n    // Generate the list of edges\n    for (let i = 0, len = indices.length; i < len; i += 3) {\n\n        const a = vertexIndexMapping[indices[i]];\n        const b = vertexIndexMapping[indices[i+1]];\n        const c = vertexIndexMapping[indices[i+2]];\n\n        let a2 = a;\n        let b2 = b;\n        let c2 = c;\n\n        if (a > b && a > c) {\n            if (b > c) {\n                a2 = a;\n                b2 = b;\n                c2 = c;\n            } else {\n                a2 = a;\n                b2 = c;\n                c2 = b;\n            }\n        } else if (b > a && b > c) {\n            if (a > c) {\n                a2 = b;\n                b2 = a;\n                c2 = c;\n            } else {\n                a2 = b;\n                b2 = c;\n                c2 = a;\n            }\n        } else if (c > a && c > b) {\n            if (a > b) {\n                a2 = c;\n                b2 = a;\n                c2 = b;\n            } else {\n                a2 = c;\n                b2 = b;\n                c2 = a;\n            }\n        }\n\n        edges[i+0] = [\n            a2, b2\n        ];\n        edges[i+1] = [\n            b2, c2\n        ];\n\n        if (a2 > c2) {\n            const temp = c2;\n            c2 = a2;\n            a2 = temp;\n        }\n\n        edges[i+2] = [\n            c2, a2\n        ];\n    }\n\n    // Group semantically equivalent edgdes together\n    function compareEdges (e1, e2) {\n        let a, b;\n\n        for (let i = 0; i < 2; i++) {\n            a = e1[i];\n            b = e2[i];\n\n            if (b !== a) {\n                return b - a;\n            }\n        }\n\n        return 0;\n    }\n\n    edges = edges.slice(0, indices.length);\n\n    edges.sort (compareEdges);\n\n    // Make sure each edge is used exactly twice\n    let sameEdgeCount = 0;\n\n    for (let i = 0; i < edges.length; i++)\n    {\n        if (i === 0 || 0 !== compareEdges (\n            edges[i], edges[i-1]\n        )) {\n            // different edge\n            if (0 !== i && sameEdgeCount !== 2)\n            {\n                return false;\n            }\n\n            sameEdgeCount = 1;\n        }\n        else\n        {\n            // same edge\n            sameEdgeCount++;\n        }\n    }\n\n    if (edges.length > 0 && sameEdgeCount !== 2)\n    {\n        return false;\n    }\n\n    // Each edge is used exactly twice, this is a\n    // watertight surface and hence a solid geometry.\n    return true;\n};\n\nexport {isTriangleMeshSolid};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/XKTModel/lib/isTriangleMeshSolid.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 231,
    "kind": "function",
    "name": "isTriangleMeshSolid",
    "memberof": "src/XKTModel/lib/isTriangleMeshSolid.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/isTriangleMeshSolid.js~isTriangleMeshSolid",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/isTriangleMeshSolid.js",
    "importStyle": "{isTriangleMeshSolid}",
    "description": "Uses edge adjacency counts to identify if the given triangle mesh can be rendered with backface culling enabled.\n\nIf all edges are connected to exactly two triangles, then the mesh will likely be a closed solid, and we can safely\nrender it with backface culling enabled.\n\nOtherwise, the mesh is a surface, and we must render it with backface culling disabled.",
    "lineNumber": 11,
    "ignore": true,
    "params": [
      {
        "name": "indices",
        "types": [
          "*"
        ]
      },
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "vertexIndexMapping",
        "types": [
          "*"
        ]
      },
      {
        "name": "edges",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 232,
    "kind": "file",
    "name": "src/XKTModel/lib/math.js",
    "content": "// Some temporary vars to help avoid garbage collection\n\nconst doublePrecision = true;\nconst FloatArrayType = doublePrecision ? Float64Array : Float32Array;\n\nconst tempMat1 = new FloatArrayType(16);\nconst tempMat2 = new FloatArrayType(16);\nconst tempVec4 = new FloatArrayType(4);\n\n/**\n * @private\n */\nconst math = {\n\n    MIN_DOUBLE: -Number.MAX_SAFE_INTEGER,\n    MAX_DOUBLE:  Number.MAX_SAFE_INTEGER,\n\n    /**\n     * The number of radiians in a degree (0.0174532925).\n     * @property DEGTORAD\n     * @type {Number}\n     */\n    DEGTORAD: 0.0174532925,\n\n    /**\n     * The number of degrees in a radian.\n     * @property RADTODEG\n     * @type {Number}\n     */\n    RADTODEG: 57.295779513,\n\n    /**\n     * Returns a new, uninitialized two-element vector.\n     * @method vec2\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec2(values) {\n        return new FloatArrayType(values || 2);\n    },\n\n    /**\n     * Returns a new, uninitialized three-element vector.\n     * @method vec3\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec3(values) {\n        return new FloatArrayType(values || 3);\n    },\n\n    /**\n     * Returns a new, uninitialized four-element vector.\n     * @method vec4\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec4(values) {\n        return new FloatArrayType(values || 4);\n    },\n\n    /**\n     * Returns a new, uninitialized 3x3 matrix.\n     * @method mat3\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    mat3(values) {\n        return new FloatArrayType(values || 9);\n    },\n\n    /**\n     * Converts a 3x3 matrix to 4x4\n     * @method mat3ToMat4\n     * @param mat3 3x3 matrix.\n     * @param mat4 4x4 matrix\n     * @static\n     * @returns {Number[]}\n     */\n    mat3ToMat4(mat3, mat4 = new FloatArrayType(16)) {\n        mat4[0] = mat3[0];\n        mat4[1] = mat3[1];\n        mat4[2] = mat3[2];\n        mat4[3] = 0;\n        mat4[4] = mat3[3];\n        mat4[5] = mat3[4];\n        mat4[6] = mat3[5];\n        mat4[7] = 0;\n        mat4[8] = mat3[6];\n        mat4[9] = mat3[7];\n        mat4[10] = mat3[8];\n        mat4[11] = 0;\n        mat4[12] = 0;\n        mat4[13] = 0;\n        mat4[14] = 0;\n        mat4[15] = 1;\n        return mat4;\n    },\n\n    /**\n     * Returns a new, uninitialized 4x4 matrix.\n     * @method mat4\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    mat4(values) {\n        return new FloatArrayType(values || 16);\n    },\n\n    /**\n     * Converts a 4x4 matrix to 3x3\n     * @method mat4ToMat3\n     * @param mat4 4x4 matrix.\n     * @param mat3 3x3 matrix\n     * @static\n     * @returns {Number[]}\n     */\n    mat4ToMat3(mat4, mat3) { // TODO\n        //return new FloatArrayType(values || 9);\n    },\n\n    /**\n     * Returns a new UUID.\n     * @method createUUID\n     * @static\n     * @return string The new UUID\n     */\n    createUUID: ((() => {\n        const self = {};\n        const lut = [];\n        for (let i = 0; i < 256; i++) {\n            lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\n        }\n        return () => {\n            const d0 = Math.random() * 0xffffffff | 0;\n            const d1 = Math.random() * 0xffffffff | 0;\n            const d2 = Math.random() * 0xffffffff | 0;\n            const d3 = Math.random() * 0xffffffff | 0;\n            return `${lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff]}-${lut[d1 & 0xff]}${lut[d1 >> 8 & 0xff]}-${lut[d1 >> 16 & 0x0f | 0x40]}${lut[d1 >> 24 & 0xff]}-${lut[d2 & 0x3f | 0x80]}${lut[d2 >> 8 & 0xff]}-${lut[d2 >> 16 & 0xff]}${lut[d2 >> 24 & 0xff]}${lut[d3 & 0xff]}${lut[d3 >> 8 & 0xff]}${lut[d3 >> 16 & 0xff]}${lut[d3 >> 24 & 0xff]}`;\n        };\n    }))(),\n\n    /**\n     * Clamps a value to the given range.\n     * @param {Number} value Value to clamp.\n     * @param {Number} min Lower bound.\n     * @param {Number} max Upper bound.\n     * @returns {Number} Clamped result.\n     */\n    clamp(value, min, max) {\n        return Math.max(min, Math.min(max, value));\n    },\n\n    /**\n     * Floating-point modulus\n     * @method fmod\n     * @static\n     * @param {Number} a\n     * @param {Number} b\n     * @returns {*}\n     */\n    fmod(a, b) {\n        if (a < b) {\n            console.error(\"math.fmod : Attempting to find modulus within negative range - would be infinite loop - ignoring\");\n            return a;\n        }\n        while (b <= a) {\n            a -= b;\n        }\n        return a;\n    },\n\n    /**\n     * Negates a four-element vector.\n     * @method negateVec4\n     * @static\n     * @param {Array(Number)} v Vector to negate\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    negateVec4(v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = -v[0];\n        dest[1] = -v[1];\n        dest[2] = -v[2];\n        dest[3] = -v[3];\n        return dest;\n    },\n\n    /**\n     * Adds one four-element vector to another.\n     * @method addVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    addVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] + v[0];\n        dest[1] = u[1] + v[1];\n        dest[2] = u[2] + v[2];\n        dest[3] = u[3] + v[3];\n        return dest;\n    },\n\n    /**\n     * Adds a scalar value to each element of a four-element vector.\n     * @method addVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    addVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] + s;\n        dest[1] = v[1] + s;\n        dest[2] = v[2] + s;\n        dest[3] = v[3] + s;\n        return dest;\n    },\n\n    /**\n     * Adds one three-element vector to another.\n     * @method addVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    addVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] + v[0];\n        dest[1] = u[1] + v[1];\n        dest[2] = u[2] + v[2];\n        return dest;\n    },\n\n    /**\n     * Adds a scalar value to each element of a three-element vector.\n     * @method addVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    addVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] + s;\n        dest[1] = v[1] + s;\n        dest[2] = v[2] + s;\n        return dest;\n    },\n\n    /**\n     * Subtracts one four-element vector from another.\n     * @method subVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        dest[2] = u[2] - v[2];\n        dest[3] = u[3] - v[3];\n        return dest;\n    },\n\n    /**\n     * Subtracts one three-element vector from another.\n     * @method subVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        dest[2] = u[2] - v[2];\n        return dest;\n    },\n\n    /**\n     * Subtracts one two-element vector from another.\n     * @method subVec2\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec2(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        return dest;\n    },\n\n    /**\n     * Subtracts a scalar value from each element of a four-element vector.\n     * @method subVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    subVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] - s;\n        dest[1] = v[1] - s;\n        dest[2] = v[2] - s;\n        dest[3] = v[3] - s;\n        return dest;\n    },\n\n    /**\n     * Sets each element of a 4-element vector to a scalar value minus the value of that element.\n     * @method subScalarVec4\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    subScalarVec4(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s - v[0];\n        dest[1] = s - v[1];\n        dest[2] = s - v[2];\n        dest[3] = s - v[3];\n        return dest;\n    },\n\n    /**\n     * Multiplies one three-element vector by another.\n     * @method mulVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    mulVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] * v[0];\n        dest[1] = u[1] * v[1];\n        dest[2] = u[2] * v[2];\n        dest[3] = u[3] * v[3];\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a four-element vector by a scalar.\n     * @method mulVec34calar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        dest[2] = v[2] * s;\n        dest[3] = v[3] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a three-element vector by a scalar.\n     * @method mulVec3Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        dest[2] = v[2] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a two-element vector by a scalar.\n     * @method mulVec2Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec2Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        return dest;\n    },\n\n    /**\n     * Divides one three-element vector by another.\n     * @method divVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    divVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] / v[0];\n        dest[1] = u[1] / v[1];\n        dest[2] = u[2] / v[2];\n        return dest;\n    },\n\n    /**\n     * Divides one four-element vector by another.\n     * @method divVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    divVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] / v[0];\n        dest[1] = u[1] / v[1];\n        dest[2] = u[2] / v[2];\n        dest[3] = u[3] / v[3];\n        return dest;\n    },\n\n    /**\n     * Divides a scalar by a three-element vector, returning a new vector.\n     * @method divScalarVec3\n     * @static\n     * @param v vec3\n     * @param s scalar\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divScalarVec3(s, v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s / v[0];\n        dest[1] = s / v[1];\n        dest[2] = s / v[2];\n        return dest;\n    },\n\n    /**\n     * Divides a three-element vector by a scalar.\n     * @method divVec3Scalar\n     * @static\n     * @param v vec3\n     * @param s scalar\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] / s;\n        dest[1] = v[1] / s;\n        dest[2] = v[2] / s;\n        return dest;\n    },\n\n    /**\n     * Divides a four-element vector by a scalar.\n     * @method divVec4Scalar\n     * @static\n     * @param v vec4\n     * @param s scalar\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] / s;\n        dest[1] = v[1] / s;\n        dest[2] = v[2] / s;\n        dest[3] = v[3] / s;\n        return dest;\n    },\n\n\n    /**\n     * Divides a scalar by a four-element vector, returning a new vector.\n     * @method divScalarVec4\n     * @static\n     * @param s scalar\n     * @param v vec4\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divScalarVec4(s, v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s / v[0];\n        dest[1] = s / v[1];\n        dest[2] = s / v[2];\n        dest[3] = s / v[3];\n        return dest;\n    },\n\n    /**\n     * Returns the dot product of two four-element vectors.\n     * @method dotVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec4(u, v) {\n        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2] + u[3] * v[3]);\n    },\n\n    /**\n     * Returns the cross product of two four-element vectors.\n     * @method cross3Vec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The cross product\n     */\n    cross3Vec4(u, v) {\n        const u0 = u[0];\n        const u1 = u[1];\n        const u2 = u[2];\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        return [\n            u1 * v2 - u2 * v1,\n            u2 * v0 - u0 * v2,\n            u0 * v1 - u1 * v0,\n            0.0];\n    },\n\n    /**\n     * Returns the cross product of two three-element vectors.\n     * @method cross3Vec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The cross product\n     */\n    cross3Vec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        const x = u[0];\n        const y = u[1];\n        const z = u[2];\n        const x2 = v[0];\n        const y2 = v[1];\n        const z2 = v[2];\n        dest[0] = y * z2 - z * y2;\n        dest[1] = z * x2 - x * z2;\n        dest[2] = x * y2 - y * x2;\n        return dest;\n    },\n\n\n    sqLenVec4(v) { // TODO\n        return math.dotVec4(v, v);\n    },\n\n    /**\n     * Returns the length of a four-element vector.\n     * @method lenVec4\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec4(v) {\n        return Math.sqrt(math.sqLenVec4(v));\n    },\n\n    /**\n     * Returns the dot product of two three-element vectors.\n     * @method dotVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec3(u, v) {\n        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2]);\n    },\n\n    /**\n     * Returns the dot product of two two-element vectors.\n     * @method dotVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec2(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]);\n    },\n\n\n    sqLenVec3(v) {\n        return math.dotVec3(v, v);\n    },\n\n\n    sqLenVec2(v) {\n        return math.dotVec2(v, v);\n    },\n\n    /**\n     * Returns the length of a three-element vector.\n     * @method lenVec3\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec3(v) {\n        return Math.sqrt(math.sqLenVec3(v));\n    },\n\n    distVec3: ((() => {\n        const vec = new FloatArrayType(3);\n        return (v, w) => math.lenVec3(math.subVec3(v, w, vec));\n    }))(),\n\n    /**\n     * Returns the length of a two-element vector.\n     * @method lenVec2\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec2(v) {\n        return Math.sqrt(math.sqLenVec2(v));\n    },\n\n    distVec2: ((() => {\n        const vec = new FloatArrayType(2);\n        return (v, w) => math.lenVec2(math.subVec2(v, w, vec));\n    }))(),\n\n    /**\n     * @method rcpVec3\n     * @static\n     * @param v vec3\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     *\n     */\n    rcpVec3(v, dest) {\n        return math.divScalarVec3(1.0, v, dest);\n    },\n\n    /**\n     * Normalizes a four-element vector\n     * @method normalizeVec4\n     * @static\n     * @param v vec4\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     *\n     */\n    normalizeVec4(v, dest) {\n        const f = 1.0 / math.lenVec4(v);\n        return math.mulVec4Scalar(v, f, dest);\n    },\n\n    /**\n     * Normalizes a three-element vector\n     * @method normalizeVec4\n     * @static\n     */\n    normalizeVec3(v, dest) {\n        const f = 1.0 / math.lenVec3(v);\n        return math.mulVec3Scalar(v, f, dest);\n    },\n\n    /**\n     * Normalizes a two-element vector\n     * @method normalizeVec2\n     * @static\n     */\n    normalizeVec2(v, dest) {\n        const f = 1.0 / math.lenVec2(v);\n        return math.mulVec2Scalar(v, f, dest);\n    },\n\n    /**\n     * Gets the angle between two vectors\n     * @method angleVec3\n     * @param v\n     * @param w\n     * @returns {number}\n     */\n    angleVec3(v, w) {\n        let theta = math.dotVec3(v, w) / (Math.sqrt(math.sqLenVec3(v) * math.sqLenVec3(w)));\n        theta = theta < -1 ? -1 : (theta > 1 ? 1 : theta);  // Clamp to handle numerical problems\n        return Math.acos(theta);\n    },\n\n    /**\n     * Creates a three-element vector from the rotation part of a sixteen-element matrix.\n     * @param m\n     * @param dest\n     */\n    vec3FromMat4Scale: ((() => {\n\n        const tempVec3 = new FloatArrayType(3);\n\n        return (m, dest) => {\n\n            tempVec3[0] = m[0];\n            tempVec3[1] = m[1];\n            tempVec3[2] = m[2];\n\n            dest[0] = math.lenVec3(tempVec3);\n\n            tempVec3[0] = m[4];\n            tempVec3[1] = m[5];\n            tempVec3[2] = m[6];\n\n            dest[1] = math.lenVec3(tempVec3);\n\n            tempVec3[0] = m[8];\n            tempVec3[1] = m[9];\n            tempVec3[2] = m[10];\n\n            dest[2] = math.lenVec3(tempVec3);\n\n            return dest;\n        };\n    }))(),\n\n    /**\n     * Converts an n-element vector to a JSON-serializable\n     * array with values rounded to two decimal places.\n     */\n    vecToArray: ((() => {\n        function trunc(v) {\n            return Math.round(v * 100000) / 100000\n        }\n\n        return v => {\n            v = Array.prototype.slice.call(v);\n            for (let i = 0, len = v.length; i < len; i++) {\n                v[i] = trunc(v[i]);\n            }\n            return v;\n        };\n    }))(),\n\n    /**\n     * Converts a 3-element vector from an array to an object of the form ````{x:999, y:999, z:999}````.\n     * @param arr\n     * @returns {{x: *, y: *, z: *}}\n     */\n    xyzArrayToObject(arr) {\n        return {\"x\": arr[0], \"y\": arr[1], \"z\": arr[2]};\n    },\n\n    /**\n     * Converts a 3-element vector object of the form ````{x:999, y:999, z:999}```` to an array.\n     * @param xyz\n     * @param  [arry]\n     * @returns {*[]}\n     */\n    xyzObjectToArray(xyz, arry) {\n        arry = arry || new FloatArrayType(3);\n        arry[0] = xyz.x;\n        arry[1] = xyz.y;\n        arry[2] = xyz.z;\n        return arry;\n    },\n\n    /**\n     * Duplicates a 4x4 identity matrix.\n     * @method dupMat4\n     * @static\n     */\n    dupMat4(m) {\n        return m.slice(0, 16);\n    },\n\n    /**\n     * Extracts a 3x3 matrix from a 4x4 matrix.\n     * @method mat4To3\n     * @static\n     */\n    mat4To3(m) {\n        return [\n            m[0], m[1], m[2],\n            m[4], m[5], m[6],\n            m[8], m[9], m[10]\n        ];\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to the given scalar value.\n     * @method m4s\n     * @static\n     */\n    m4s(s) {\n        return [\n            s, s, s, s,\n            s, s, s, s,\n            s, s, s, s,\n            s, s, s, s\n        ];\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to zero.\n     * @method setMat4ToZeroes\n     * @static\n     */\n    setMat4ToZeroes() {\n        return math.m4s(0.0);\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to 1.0.\n     * @method setMat4ToOnes\n     * @static\n     */\n    setMat4ToOnes() {\n        return math.m4s(1.0);\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to 1.0.\n     * @method setMat4ToOnes\n     * @static\n     */\n    diagonalMat4v(v) {\n        return new FloatArrayType([\n            v[0], 0.0, 0.0, 0.0,\n            0.0, v[1], 0.0, 0.0,\n            0.0, 0.0, v[2], 0.0,\n            0.0, 0.0, 0.0, v[3]\n        ]);\n    },\n\n    /**\n     * Returns a 4x4 matrix with diagonal elements set to the given vector.\n     * @method diagonalMat4c\n     * @static\n     */\n    diagonalMat4c(x, y, z, w) {\n        return math.diagonalMat4v([x, y, z, w]);\n    },\n\n    /**\n     * Returns a 4x4 matrix with diagonal elements set to the given scalar.\n     * @method diagonalMat4s\n     * @static\n     */\n    diagonalMat4s(s) {\n        return math.diagonalMat4c(s, s, s, s);\n    },\n\n    /**\n     * Returns a 4x4 identity matrix.\n     * @method identityMat4\n     * @static\n     */\n    identityMat4(mat = new FloatArrayType(16)) {\n        mat[0] = 1.0;\n        mat[1] = 0.0;\n        mat[2] = 0.0;\n        mat[3] = 0.0;\n\n        mat[4] = 0.0;\n        mat[5] = 1.0;\n        mat[6] = 0.0;\n        mat[7] = 0.0;\n\n        mat[8] = 0.0;\n        mat[9] = 0.0;\n        mat[10] = 1.0;\n        mat[11] = 0.0;\n\n        mat[12] = 0.0;\n        mat[13] = 0.0;\n        mat[14] = 0.0;\n        mat[15] = 1.0;\n\n        return mat;\n    },\n\n    /**\n     * Returns a 3x3 identity matrix.\n     * @method identityMat3\n     * @static\n     */\n    identityMat3(mat = new FloatArrayType(9)) {\n        mat[0] = 1.0;\n        mat[1] = 0.0;\n        mat[2] = 0.0;\n\n        mat[3] = 0.0;\n        mat[4] = 1.0;\n        mat[5] = 0.0;\n\n        mat[6] = 0.0;\n        mat[7] = 0.0;\n        mat[8] = 1.0;\n\n        return mat;\n    },\n\n    /**\n     * Tests if the given 4x4 matrix is the identity matrix.\n     * @method isIdentityMat4\n     * @static\n     */\n    isIdentityMat4(m) {\n        if (m[0] !== 1.0 || m[1] !== 0.0 || m[2] !== 0.0 || m[3] !== 0.0 ||\n            m[4] !== 0.0 || m[5] !== 1.0 || m[6] !== 0.0 || m[7] !== 0.0 ||\n            m[8] !== 0.0 || m[9] !== 0.0 || m[10] !== 1.0 || m[11] !== 0.0 ||\n            m[12] !== 0.0 || m[13] !== 0.0 || m[14] !== 0.0 || m[15] !== 1.0) {\n            return false;\n        }\n        return true;\n    },\n\n    /**\n     * Negates the given 4x4 matrix.\n     * @method negateMat4\n     * @static\n     */\n    negateMat4(m, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = -m[0];\n        dest[1] = -m[1];\n        dest[2] = -m[2];\n        dest[3] = -m[3];\n        dest[4] = -m[4];\n        dest[5] = -m[5];\n        dest[6] = -m[6];\n        dest[7] = -m[7];\n        dest[8] = -m[8];\n        dest[9] = -m[9];\n        dest[10] = -m[10];\n        dest[11] = -m[11];\n        dest[12] = -m[12];\n        dest[13] = -m[13];\n        dest[14] = -m[14];\n        dest[15] = -m[15];\n        return dest;\n    },\n\n    /**\n     * Adds the given 4x4 matrices together.\n     * @method addMat4\n     * @static\n     */\n    addMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n        dest[0] = a[0] + b[0];\n        dest[1] = a[1] + b[1];\n        dest[2] = a[2] + b[2];\n        dest[3] = a[3] + b[3];\n        dest[4] = a[4] + b[4];\n        dest[5] = a[5] + b[5];\n        dest[6] = a[6] + b[6];\n        dest[7] = a[7] + b[7];\n        dest[8] = a[8] + b[8];\n        dest[9] = a[9] + b[9];\n        dest[10] = a[10] + b[10];\n        dest[11] = a[11] + b[11];\n        dest[12] = a[12] + b[12];\n        dest[13] = a[13] + b[13];\n        dest[14] = a[14] + b[14];\n        dest[15] = a[15] + b[15];\n        return dest;\n    },\n\n    /**\n     * Adds the given scalar to each element of the given 4x4 matrix.\n     * @method addMat4Scalar\n     * @static\n     */\n    addMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] + s;\n        dest[1] = m[1] + s;\n        dest[2] = m[2] + s;\n        dest[3] = m[3] + s;\n        dest[4] = m[4] + s;\n        dest[5] = m[5] + s;\n        dest[6] = m[6] + s;\n        dest[7] = m[7] + s;\n        dest[8] = m[8] + s;\n        dest[9] = m[9] + s;\n        dest[10] = m[10] + s;\n        dest[11] = m[11] + s;\n        dest[12] = m[12] + s;\n        dest[13] = m[13] + s;\n        dest[14] = m[14] + s;\n        dest[15] = m[15] + s;\n        return dest;\n    },\n\n    /**\n     * Adds the given scalar to each element of the given 4x4 matrix.\n     * @method addScalarMat4\n     * @static\n     */\n    addScalarMat4(s, m, dest) {\n        return math.addMat4Scalar(m, s, dest);\n    },\n\n    /**\n     * Subtracts the second 4x4 matrix from the first.\n     * @method subMat4\n     * @static\n     */\n    subMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n        dest[0] = a[0] - b[0];\n        dest[1] = a[1] - b[1];\n        dest[2] = a[2] - b[2];\n        dest[3] = a[3] - b[3];\n        dest[4] = a[4] - b[4];\n        dest[5] = a[5] - b[5];\n        dest[6] = a[6] - b[6];\n        dest[7] = a[7] - b[7];\n        dest[8] = a[8] - b[8];\n        dest[9] = a[9] - b[9];\n        dest[10] = a[10] - b[10];\n        dest[11] = a[11] - b[11];\n        dest[12] = a[12] - b[12];\n        dest[13] = a[13] - b[13];\n        dest[14] = a[14] - b[14];\n        dest[15] = a[15] - b[15];\n        return dest;\n    },\n\n    /**\n     * Subtracts the given scalar from each element of the given 4x4 matrix.\n     * @method subMat4Scalar\n     * @static\n     */\n    subMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] - s;\n        dest[1] = m[1] - s;\n        dest[2] = m[2] - s;\n        dest[3] = m[3] - s;\n        dest[4] = m[4] - s;\n        dest[5] = m[5] - s;\n        dest[6] = m[6] - s;\n        dest[7] = m[7] - s;\n        dest[8] = m[8] - s;\n        dest[9] = m[9] - s;\n        dest[10] = m[10] - s;\n        dest[11] = m[11] - s;\n        dest[12] = m[12] - s;\n        dest[13] = m[13] - s;\n        dest[14] = m[14] - s;\n        dest[15] = m[15] - s;\n        return dest;\n    },\n\n    /**\n     * Subtracts the given scalar from each element of the given 4x4 matrix.\n     * @method subScalarMat4\n     * @static\n     */\n    subScalarMat4(s, m, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = s - m[0];\n        dest[1] = s - m[1];\n        dest[2] = s - m[2];\n        dest[3] = s - m[3];\n        dest[4] = s - m[4];\n        dest[5] = s - m[5];\n        dest[6] = s - m[6];\n        dest[7] = s - m[7];\n        dest[8] = s - m[8];\n        dest[9] = s - m[9];\n        dest[10] = s - m[10];\n        dest[11] = s - m[11];\n        dest[12] = s - m[12];\n        dest[13] = s - m[13];\n        dest[14] = s - m[14];\n        dest[15] = s - m[15];\n        return dest;\n    },\n\n    /**\n     * Multiplies the two given 4x4 matrix by each other.\n     * @method mulMat4\n     * @static\n     */\n    mulMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = a[0];\n\n        const a01 = a[1];\n        const a02 = a[2];\n        const a03 = a[3];\n        const a10 = a[4];\n        const a11 = a[5];\n        const a12 = a[6];\n        const a13 = a[7];\n        const a20 = a[8];\n        const a21 = a[9];\n        const a22 = a[10];\n        const a23 = a[11];\n        const a30 = a[12];\n        const a31 = a[13];\n        const a32 = a[14];\n        const a33 = a[15];\n        const b00 = b[0];\n        const b01 = b[1];\n        const b02 = b[2];\n        const b03 = b[3];\n        const b10 = b[4];\n        const b11 = b[5];\n        const b12 = b[6];\n        const b13 = b[7];\n        const b20 = b[8];\n        const b21 = b[9];\n        const b22 = b[10];\n        const b23 = b[11];\n        const b30 = b[12];\n        const b31 = b[13];\n        const b32 = b[14];\n        const b33 = b[15];\n\n        dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;\n        dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;\n        dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;\n        dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;\n        dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;\n        dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;\n        dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;\n        dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;\n        dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;\n        dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;\n        dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;\n        dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;\n        dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;\n        dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;\n        dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;\n        dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;\n\n        return dest;\n    },\n\n    /**\n     * Multiplies the two given 3x3 matrices by each other.\n     * @method mulMat4\n     * @static\n     */\n    mulMat3(a, b, dest) {\n        if (!dest) {\n            dest = new FloatArrayType(9);\n        }\n\n        const a11 = a[0];\n        const a12 = a[3];\n        const a13 = a[6];\n        const a21 = a[1];\n        const a22 = a[4];\n        const a23 = a[7];\n        const a31 = a[2];\n        const a32 = a[5];\n        const a33 = a[8];\n        const b11 = b[0];\n        const b12 = b[3];\n        const b13 = b[6];\n        const b21 = b[1];\n        const b22 = b[4];\n        const b23 = b[7];\n        const b31 = b[2];\n        const b32 = b[5];\n        const b33 = b[8];\n\n        dest[0] = a11 * b11 + a12 * b21 + a13 * b31;\n        dest[3] = a11 * b12 + a12 * b22 + a13 * b32;\n        dest[6] = a11 * b13 + a12 * b23 + a13 * b33;\n\n        dest[1] = a21 * b11 + a22 * b21 + a23 * b31;\n        dest[4] = a21 * b12 + a22 * b22 + a23 * b32;\n        dest[7] = a21 * b13 + a22 * b23 + a23 * b33;\n\n        dest[2] = a31 * b11 + a32 * b21 + a33 * b31;\n        dest[5] = a31 * b12 + a32 * b22 + a33 * b32;\n        dest[8] = a31 * b13 + a32 * b23 + a33 * b33;\n\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of the given 4x4 matrix by the given scalar.\n     * @method mulMat4Scalar\n     * @static\n     */\n    mulMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] * s;\n        dest[1] = m[1] * s;\n        dest[2] = m[2] * s;\n        dest[3] = m[3] * s;\n        dest[4] = m[4] * s;\n        dest[5] = m[5] * s;\n        dest[6] = m[6] * s;\n        dest[7] = m[7] * s;\n        dest[8] = m[8] * s;\n        dest[9] = m[9] * s;\n        dest[10] = m[10] * s;\n        dest[11] = m[11] * s;\n        dest[12] = m[12] * s;\n        dest[13] = m[13] * s;\n        dest[14] = m[14] * s;\n        dest[15] = m[15] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies the given 4x4 matrix by the given four-element vector.\n     * @method mulMat4v4\n     * @static\n     */\n    mulMat4v4(m, v, dest = math.vec4()) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;\n        dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;\n        dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;\n        dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;\n        return dest;\n    },\n\n    /**\n     * Transposes the given 4x4 matrix.\n     * @method transposeMat4\n     * @static\n     */\n    transposeMat4(mat, dest) {\n        // If we are transposing ourselves we can skip a few steps but have to cache some values\n        const m4 = mat[4];\n\n        const m14 = mat[14];\n        const m8 = mat[8];\n        const m13 = mat[13];\n        const m12 = mat[12];\n        const m9 = mat[9];\n        if (!dest || mat === dest) {\n            const a01 = mat[1];\n            const a02 = mat[2];\n            const a03 = mat[3];\n            const a12 = mat[6];\n            const a13 = mat[7];\n            const a23 = mat[11];\n            mat[1] = m4;\n            mat[2] = m8;\n            mat[3] = m12;\n            mat[4] = a01;\n            mat[6] = m9;\n            mat[7] = m13;\n            mat[8] = a02;\n            mat[9] = a12;\n            mat[11] = m14;\n            mat[12] = a03;\n            mat[13] = a13;\n            mat[14] = a23;\n            return mat;\n        }\n        dest[0] = mat[0];\n        dest[1] = m4;\n        dest[2] = m8;\n        dest[3] = m12;\n        dest[4] = mat[1];\n        dest[5] = mat[5];\n        dest[6] = m9;\n        dest[7] = m13;\n        dest[8] = mat[2];\n        dest[9] = mat[6];\n        dest[10] = mat[10];\n        dest[11] = m14;\n        dest[12] = mat[3];\n        dest[13] = mat[7];\n        dest[14] = mat[11];\n        dest[15] = mat[15];\n        return dest;\n    },\n\n    /**\n     * Transposes the given 3x3 matrix.\n     *\n     * @method transposeMat3\n     * @static\n     */\n    transposeMat3(mat, dest) {\n        if (dest === mat) {\n            const a01 = mat[1];\n            const a02 = mat[2];\n            const a12 = mat[5];\n            dest[1] = mat[3];\n            dest[2] = mat[6];\n            dest[3] = a01;\n            dest[5] = mat[7];\n            dest[6] = a02;\n            dest[7] = a12;\n        } else {\n            dest[0] = mat[0];\n            dest[1] = mat[3];\n            dest[2] = mat[6];\n            dest[3] = mat[1];\n            dest[4] = mat[4];\n            dest[5] = mat[7];\n            dest[6] = mat[2];\n            dest[7] = mat[5];\n            dest[8] = mat[8];\n        }\n        return dest;\n    },\n\n    /**\n     * Returns the determinant of the given 4x4 matrix.\n     * @method determinantMat4\n     * @static\n     */\n    determinantMat4(mat) {\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = mat[0];\n\n        const a01 = mat[1];\n        const a02 = mat[2];\n        const a03 = mat[3];\n        const a10 = mat[4];\n        const a11 = mat[5];\n        const a12 = mat[6];\n        const a13 = mat[7];\n        const a20 = mat[8];\n        const a21 = mat[9];\n        const a22 = mat[10];\n        const a23 = mat[11];\n        const a30 = mat[12];\n        const a31 = mat[13];\n        const a32 = mat[14];\n        const a33 = mat[15];\n        return a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 +\n            a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 +\n            a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 +\n            a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 +\n            a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 +\n            a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33;\n    },\n\n    /**\n     * Returns the inverse of the given 4x4 matrix.\n     * @method inverseMat4\n     * @static\n     */\n    inverseMat4(mat, dest) {\n        if (!dest) {\n            dest = mat;\n        }\n\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = mat[0];\n\n        const a01 = mat[1];\n        const a02 = mat[2];\n        const a03 = mat[3];\n        const a10 = mat[4];\n        const a11 = mat[5];\n        const a12 = mat[6];\n        const a13 = mat[7];\n        const a20 = mat[8];\n        const a21 = mat[9];\n        const a22 = mat[10];\n        const a23 = mat[11];\n        const a30 = mat[12];\n        const a31 = mat[13];\n        const a32 = mat[14];\n        const a33 = mat[15];\n        const b00 = a00 * a11 - a01 * a10;\n        const b01 = a00 * a12 - a02 * a10;\n        const b02 = a00 * a13 - a03 * a10;\n        const b03 = a01 * a12 - a02 * a11;\n        const b04 = a01 * a13 - a03 * a11;\n        const b05 = a02 * a13 - a03 * a12;\n        const b06 = a20 * a31 - a21 * a30;\n        const b07 = a20 * a32 - a22 * a30;\n        const b08 = a20 * a33 - a23 * a30;\n        const b09 = a21 * a32 - a22 * a31;\n        const b10 = a21 * a33 - a23 * a31;\n        const b11 = a22 * a33 - a23 * a32;\n\n        // Calculate the determinant (inlined to avoid double-caching)\n        const invDet = 1 / (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);\n\n        dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;\n        dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;\n        dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;\n        dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;\n        dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;\n        dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;\n        dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;\n        dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;\n        dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;\n        dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;\n        dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;\n        dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;\n        dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;\n        dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;\n        dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;\n        dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;\n\n        return dest;\n    },\n\n    /**\n     * Returns the trace of the given 4x4 matrix.\n     * @method traceMat4\n     * @static\n     */\n    traceMat4(m) {\n        return (m[0] + m[5] + m[10] + m[15]);\n    },\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4\n     * @static\n     */\n    translationMat4v(v, dest) {\n        const m = dest || math.identityMat4();\n        m[12] = v[0];\n        m[13] = v[1];\n        m[14] = v[2];\n        return m;\n    },\n\n    /**\n     * Returns 3x3 translation matrix.\n     * @method translationMat3\n     * @static\n     */\n    translationMat3v(v, dest) {\n        const m = dest || math.identityMat3();\n        m[6] = v[0];\n        m[7] = v[1];\n        return m;\n    },\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4c\n     * @static\n     */\n    translationMat4c: ((() => {\n        const xyz = new FloatArrayType(3);\n        return (x, y, z, dest) => {\n            xyz[0] = x;\n            xyz[1] = y;\n            xyz[2] = z;\n            return math.translationMat4v(xyz, dest);\n        };\n    }))(),\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4s\n     * @static\n     */\n    translationMat4s(s, dest) {\n        return math.translationMat4c(s, s, s, dest);\n    },\n\n    /**\n     * Efficiently post-concatenates a translation to the given matrix.\n     * @param v\n     * @param m\n     */\n    translateMat4v(xyz, m) {\n        return math.translateMat4c(xyz[0], xyz[1], xyz[2], m);\n    },\n\n    /**\n     * Efficiently post-concatenates a translation to the given matrix.\n     * @param x\n     * @param y\n     * @param z\n     * @param m\n     */\n    OLDtranslateMat4c(x, y, z, m) {\n\n        const m12 = m[12];\n        m[0] += m12 * x;\n        m[4] += m12 * y;\n        m[8] += m12 * z;\n\n        const m13 = m[13];\n        m[1] += m13 * x;\n        m[5] += m13 * y;\n        m[9] += m13 * z;\n\n        const m14 = m[14];\n        m[2] += m14 * x;\n        m[6] += m14 * y;\n        m[10] += m14 * z;\n\n        const m15 = m[15];\n        m[3] += m15 * x;\n        m[7] += m15 * y;\n        m[11] += m15 * z;\n\n        return m;\n    },\n\n    translateMat4c(x, y, z, m) {\n\n        const m3 = m[3];\n        m[0] += m3 * x;\n        m[1] += m3 * y;\n        m[2] += m3 * z;\n\n        const m7 = m[7];\n        m[4] += m7 * x;\n        m[5] += m7 * y;\n        m[6] += m7 * z;\n\n        const m11 = m[11];\n        m[8] += m11 * x;\n        m[9] += m11 * y;\n        m[10] += m11 * z;\n\n        const m15 = m[15];\n        m[12] += m15 * x;\n        m[13] += m15 * y;\n        m[14] += m15 * z;\n\n        return m;\n    },\n    /**\n     * Returns 4x4 rotation matrix.\n     * @method rotationMat4v\n     * @static\n     */\n    rotationMat4v(anglerad, axis, m) {\n        const ax = math.normalizeVec4([axis[0], axis[1], axis[2], 0.0], []);\n        const s = Math.sin(anglerad);\n        const c = Math.cos(anglerad);\n        const q = 1.0 - c;\n\n        const x = ax[0];\n        const y = ax[1];\n        const z = ax[2];\n\n        let xy;\n        let yz;\n        let zx;\n        let xs;\n        let ys;\n        let zs;\n\n        //xx = x * x; used once\n        //yy = y * y; used once\n        //zz = z * z; used once\n        xy = x * y;\n        yz = y * z;\n        zx = z * x;\n        xs = x * s;\n        ys = y * s;\n        zs = z * s;\n\n        m = m || math.mat4();\n\n        m[0] = (q * x * x) + c;\n        m[1] = (q * xy) + zs;\n        m[2] = (q * zx) - ys;\n        m[3] = 0.0;\n\n        m[4] = (q * xy) - zs;\n        m[5] = (q * y * y) + c;\n        m[6] = (q * yz) + xs;\n        m[7] = 0.0;\n\n        m[8] = (q * zx) + ys;\n        m[9] = (q * yz) - xs;\n        m[10] = (q * z * z) + c;\n        m[11] = 0.0;\n\n        m[12] = 0.0;\n        m[13] = 0.0;\n        m[14] = 0.0;\n        m[15] = 1.0;\n\n        return m;\n    },\n\n    /**\n     * Returns 4x4 rotation matrix.\n     * @method rotationMat4c\n     * @static\n     */\n    rotationMat4c(anglerad, x, y, z, mat) {\n        return math.rotationMat4v(anglerad, [x, y, z], mat);\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4v\n     * @static\n     */\n    scalingMat4v(v, m = math.identityMat4()) {\n        m[0] = v[0];\n        m[5] = v[1];\n        m[10] = v[2];\n        return m;\n    },\n\n    /**\n     * Returns 3x3 scale matrix.\n     * @method scalingMat3v\n     * @static\n     */\n    scalingMat3v(v, m = math.identityMat3()) {\n        m[0] = v[0];\n        m[4] = v[1];\n        return m;\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4c\n     * @static\n     */\n    scalingMat4c: ((() => {\n        const xyz = new FloatArrayType(3);\n        return (x, y, z, dest) => {\n            xyz[0] = x;\n            xyz[1] = y;\n            xyz[2] = z;\n            return math.scalingMat4v(xyz, dest);\n        };\n    }))(),\n\n    /**\n     * Efficiently post-concatenates a scaling to the given matrix.\n     * @method scaleMat4c\n     * @param x\n     * @param y\n     * @param z\n     * @param m\n     */\n    scaleMat4c(x, y, z, m) {\n\n        m[0] *= x;\n        m[4] *= y;\n        m[8] *= z;\n\n        m[1] *= x;\n        m[5] *= y;\n        m[9] *= z;\n\n        m[2] *= x;\n        m[6] *= y;\n        m[10] *= z;\n\n        m[3] *= x;\n        m[7] *= y;\n        m[11] *= z;\n        return m;\n    },\n\n    /**\n     * Efficiently post-concatenates a scaling to the given matrix.\n     * @method scaleMat4c\n     * @param xyz\n     * @param m\n     */\n    scaleMat4v(xyz, m) {\n\n        const x = xyz[0];\n        const y = xyz[1];\n        const z = xyz[2];\n\n        m[0] *= x;\n        m[4] *= y;\n        m[8] *= z;\n        m[1] *= x;\n        m[5] *= y;\n        m[9] *= z;\n        m[2] *= x;\n        m[6] *= y;\n        m[10] *= z;\n        m[3] *= x;\n        m[7] *= y;\n        m[11] *= z;\n\n        return m;\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4s\n     * @static\n     */\n    scalingMat4s(s) {\n        return math.scalingMat4c(s, s, s);\n    },\n\n    /**\n     * Creates a matrix from a quaternion rotation and vector translation\n     *\n     * @param {Number[]} q Rotation quaternion\n     * @param {Number[]} v Translation vector\n     * @param {Number[]} dest Destination matrix\n     * @returns {Number[]} dest\n     */\n    rotationTranslationMat4(q, v, dest = math.mat4()) {\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n\n        dest[0] = 1 - (yy + zz);\n        dest[1] = xy + wz;\n        dest[2] = xz - wy;\n        dest[3] = 0;\n        dest[4] = xy - wz;\n        dest[5] = 1 - (xx + zz);\n        dest[6] = yz + wx;\n        dest[7] = 0;\n        dest[8] = xz + wy;\n        dest[9] = yz - wx;\n        dest[10] = 1 - (xx + yy);\n        dest[11] = 0;\n        dest[12] = v[0];\n        dest[13] = v[1];\n        dest[14] = v[2];\n        dest[15] = 1;\n\n        return dest;\n    },\n\n    /**\n     * Gets Euler angles from a 4x4 matrix.\n     *\n     * @param {Number[]} mat The 4x4 matrix.\n     * @param {String} order Desired Euler angle order: \"XYZ\", \"YXZ\", \"ZXY\" etc.\n     * @param {Number[]} [dest] Destination Euler angles, created by default.\n     * @returns {Number[]} The Euler angles.\n     */\n    mat4ToEuler(mat, order, dest = math.vec4()) {\n        const clamp = math.clamp;\n\n        // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n        const m11 = mat[0];\n\n        const m12 = mat[4];\n        const m13 = mat[8];\n        const m21 = mat[1];\n        const m22 = mat[5];\n        const m23 = mat[9];\n        const m31 = mat[2];\n        const m32 = mat[6];\n        const m33 = mat[10];\n\n        if (order === 'XYZ') {\n\n            dest[1] = Math.asin(clamp(m13, -1, 1));\n\n            if (Math.abs(m13) < 0.99999) {\n                dest[0] = Math.atan2(-m23, m33);\n                dest[2] = Math.atan2(-m12, m11);\n            } else {\n                dest[0] = Math.atan2(m32, m22);\n                dest[2] = 0;\n\n            }\n\n        } else if (order === 'YXZ') {\n\n            dest[0] = Math.asin(-clamp(m23, -1, 1));\n\n            if (Math.abs(m23) < 0.99999) {\n                dest[1] = Math.atan2(m13, m33);\n                dest[2] = Math.atan2(m21, m22);\n            } else {\n                dest[1] = Math.atan2(-m31, m11);\n                dest[2] = 0;\n            }\n\n        } else if (order === 'ZXY') {\n\n            dest[0] = Math.asin(clamp(m32, -1, 1));\n\n            if (Math.abs(m32) < 0.99999) {\n                dest[1] = Math.atan2(-m31, m33);\n                dest[2] = Math.atan2(-m12, m22);\n            } else {\n                dest[1] = 0;\n                dest[2] = Math.atan2(m21, m11);\n            }\n\n        } else if (order === 'ZYX') {\n\n            dest[1] = Math.asin(-clamp(m31, -1, 1));\n\n            if (Math.abs(m31) < 0.99999) {\n                dest[0] = Math.atan2(m32, m33);\n                dest[2] = Math.atan2(m21, m11);\n            } else {\n                dest[0] = 0;\n                dest[2] = Math.atan2(-m12, m22);\n            }\n\n        } else if (order === 'YZX') {\n\n            dest[2] = Math.asin(clamp(m21, -1, 1));\n\n            if (Math.abs(m21) < 0.99999) {\n                dest[0] = Math.atan2(-m23, m22);\n                dest[1] = Math.atan2(-m31, m11);\n            } else {\n                dest[0] = 0;\n                dest[1] = Math.atan2(m13, m33);\n            }\n\n        } else if (order === 'XZY') {\n\n            dest[2] = Math.asin(-clamp(m12, -1, 1));\n\n            if (Math.abs(m12) < 0.99999) {\n                dest[0] = Math.atan2(m32, m22);\n                dest[1] = Math.atan2(m13, m11);\n            } else {\n                dest[0] = Math.atan2(-m23, m33);\n                dest[1] = 0;\n            }\n        }\n\n        return dest;\n    },\n\n    composeMat4(position, quaternion, scale, mat = math.mat4()) {\n        math.quaternionToRotationMat4(quaternion, mat);\n        math.scaleMat4v(scale, mat);\n        math.translateMat4v(position, mat);\n\n        return mat;\n    },\n\n    decomposeMat4: (() => {\n\n        const vec = new FloatArrayType(3);\n        const matrix = new FloatArrayType(16);\n\n        return function decompose(mat, position, quaternion, scale) {\n\n            vec[0] = mat[0];\n            vec[1] = mat[1];\n            vec[2] = mat[2];\n\n            let sx = math.lenVec3(vec);\n\n            vec[0] = mat[4];\n            vec[1] = mat[5];\n            vec[2] = mat[6];\n\n            const sy = math.lenVec3(vec);\n\n            vec[8] = mat[8];\n            vec[9] = mat[9];\n            vec[10] = mat[10];\n\n            const sz = math.lenVec3(vec);\n\n            // if determine is negative, we need to invert one scale\n            const det = math.determinantMat4(mat);\n\n            if (det < 0) {\n                sx = -sx;\n            }\n\n            position[0] = mat[12];\n            position[1] = mat[13];\n            position[2] = mat[14];\n\n            // scale the rotation part\n            matrix.set(mat);\n\n            const invSX = 1 / sx;\n            const invSY = 1 / sy;\n            const invSZ = 1 / sz;\n\n            matrix[0] *= invSX;\n            matrix[1] *= invSX;\n            matrix[2] *= invSX;\n\n            matrix[4] *= invSY;\n            matrix[5] *= invSY;\n            matrix[6] *= invSY;\n\n            matrix[8] *= invSZ;\n            matrix[9] *= invSZ;\n            matrix[10] *= invSZ;\n\n            math.mat4ToQuaternion(matrix, quaternion);\n\n            scale[0] = sx;\n            scale[1] = sy;\n            scale[2] = sz;\n\n            return this;\n\n        };\n\n    })(),\n\n    /**\n     * Returns a 4x4 'lookat' viewing transform matrix.\n     * @method lookAtMat4v\n     * @param pos vec3 position of the viewer\n     * @param target vec3 point the viewer is looking at\n     * @param up vec3 pointing \"up\"\n     * @param dest mat4 Optional, mat4 matrix will be written into\n     *\n     * @return {mat4} dest if specified, a new mat4 otherwise\n     */\n    lookAtMat4v(pos, target, up, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n\n        const posx = pos[0];\n        const posy = pos[1];\n        const posz = pos[2];\n        const upx = up[0];\n        const upy = up[1];\n        const upz = up[2];\n        const targetx = target[0];\n        const targety = target[1];\n        const targetz = target[2];\n\n        if (posx === targetx && posy === targety && posz === targetz) {\n            return math.identityMat4();\n        }\n\n        let z0;\n        let z1;\n        let z2;\n        let x0;\n        let x1;\n        let x2;\n        let y0;\n        let y1;\n        let y2;\n        let len;\n\n        //vec3.direction(eye, center, z);\n        z0 = posx - targetx;\n        z1 = posy - targety;\n        z2 = posz - targetz;\n\n        // normalize (no check needed for 0 because of early return)\n        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n        z0 *= len;\n        z1 *= len;\n        z2 *= len;\n\n        //vec3.normalize(vec3.cross(up, z, x));\n        x0 = upy * z2 - upz * z1;\n        x1 = upz * z0 - upx * z2;\n        x2 = upx * z1 - upy * z0;\n        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n        if (!len) {\n            x0 = 0;\n            x1 = 0;\n            x2 = 0;\n        } else {\n            len = 1 / len;\n            x0 *= len;\n            x1 *= len;\n            x2 *= len;\n        }\n\n        //vec3.normalize(vec3.cross(z, x, y));\n        y0 = z1 * x2 - z2 * x1;\n        y1 = z2 * x0 - z0 * x2;\n        y2 = z0 * x1 - z1 * x0;\n\n        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n        if (!len) {\n            y0 = 0;\n            y1 = 0;\n            y2 = 0;\n        } else {\n            len = 1 / len;\n            y0 *= len;\n            y1 *= len;\n            y2 *= len;\n        }\n\n        dest[0] = x0;\n        dest[1] = y0;\n        dest[2] = z0;\n        dest[3] = 0;\n        dest[4] = x1;\n        dest[5] = y1;\n        dest[6] = z1;\n        dest[7] = 0;\n        dest[8] = x2;\n        dest[9] = y2;\n        dest[10] = z2;\n        dest[11] = 0;\n        dest[12] = -(x0 * posx + x1 * posy + x2 * posz);\n        dest[13] = -(y0 * posx + y1 * posy + y2 * posz);\n        dest[14] = -(z0 * posx + z1 * posy + z2 * posz);\n        dest[15] = 1;\n\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 'lookat' viewing transform matrix.\n     * @method lookAtMat4c\n     * @static\n     */\n    lookAtMat4c(posx, posy, posz, targetx, targety, targetz, upx, upy, upz) {\n        return math.lookAtMat4v([posx, posy, posz], [targetx, targety, targetz], [upx, upy, upz], []);\n    },\n\n    /**\n     * Returns a 4x4 orthographic projection matrix.\n     * @method orthoMat4c\n     * @static\n     */\n    orthoMat4c(left, right, bottom, top, near, far, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n        const rl = (right - left);\n        const tb = (top - bottom);\n        const fn = (far - near);\n\n        dest[0] = 2.0 / rl;\n        dest[1] = 0.0;\n        dest[2] = 0.0;\n        dest[3] = 0.0;\n\n        dest[4] = 0.0;\n        dest[5] = 2.0 / tb;\n        dest[6] = 0.0;\n        dest[7] = 0.0;\n\n        dest[8] = 0.0;\n        dest[9] = 0.0;\n        dest[10] = -2.0 / fn;\n        dest[11] = 0.0;\n\n        dest[12] = -(left + right) / rl;\n        dest[13] = -(top + bottom) / tb;\n        dest[14] = -(far + near) / fn;\n        dest[15] = 1.0;\n\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method frustumMat4v\n     * @static\n     */\n    frustumMat4v(fmin, fmax, m) {\n        if (!m) {\n            m = math.mat4();\n        }\n\n        const fmin4 = [fmin[0], fmin[1], fmin[2], 0.0];\n        const fmax4 = [fmax[0], fmax[1], fmax[2], 0.0];\n\n        math.addVec4(fmax4, fmin4, tempMat1);\n        math.subVec4(fmax4, fmin4, tempMat2);\n\n        const t = 2.0 * fmin4[2];\n\n        const tempMat20 = tempMat2[0];\n        const tempMat21 = tempMat2[1];\n        const tempMat22 = tempMat2[2];\n\n        m[0] = t / tempMat20;\n        m[1] = 0.0;\n        m[2] = 0.0;\n        m[3] = 0.0;\n\n        m[4] = 0.0;\n        m[5] = t / tempMat21;\n        m[6] = 0.0;\n        m[7] = 0.0;\n\n        m[8] = tempMat1[0] / tempMat20;\n        m[9] = tempMat1[1] / tempMat21;\n        m[10] = -tempMat1[2] / tempMat22;\n        m[11] = -1.0;\n\n        m[12] = 0.0;\n        m[13] = 0.0;\n        m[14] = -t * fmax4[2] / tempMat22;\n        m[15] = 0.0;\n\n        return m;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method frustumMat4v\n     * @static\n     */\n    frustumMat4(left, right, bottom, top, near, far, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n        const rl = (right - left);\n        const tb = (top - bottom);\n        const fn = (far - near);\n        dest[0] = (near * 2) / rl;\n        dest[1] = 0;\n        dest[2] = 0;\n        dest[3] = 0;\n        dest[4] = 0;\n        dest[5] = (near * 2) / tb;\n        dest[6] = 0;\n        dest[7] = 0;\n        dest[8] = (right + left) / rl;\n        dest[9] = (top + bottom) / tb;\n        dest[10] = -(far + near) / fn;\n        dest[11] = -1;\n        dest[12] = 0;\n        dest[13] = 0;\n        dest[14] = -(far * near * 2) / fn;\n        dest[15] = 0;\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method perspectiveMat4v\n     * @static\n     */\n    perspectiveMat4(fovyrad, aspectratio, znear, zfar, m) {\n        const pmin = [];\n        const pmax = [];\n\n        pmin[2] = znear;\n        pmax[2] = zfar;\n\n        pmax[1] = pmin[2] * Math.tan(fovyrad / 2.0);\n        pmin[1] = -pmax[1];\n\n        pmax[0] = pmax[1] * aspectratio;\n        pmin[0] = -pmax[0];\n\n        return math.frustumMat4v(pmin, pmax, m);\n    },\n\n    /**\n     * Transforms a three-element position by a 4x4 matrix.\n     * @method transformPoint3\n     * @static\n     */\n    transformPoint3(m, p, dest = math.vec3()) {\n\n        const x = p[0];\n        const y = p[1];\n        const z = p[2];\n\n        dest[0] = (m[0] * x) + (m[4] * y) + (m[8] * z) + m[12];\n        dest[1] = (m[1] * x) + (m[5] * y) + (m[9] * z) + m[13];\n        dest[2] = (m[2] * x) + (m[6] * y) + (m[10] * z) + m[14];\n\n        return dest;\n    },\n\n    /**\n     * Transforms a homogeneous coordinate by a 4x4 matrix.\n     * @method transformPoint3\n     * @static\n     */\n    transformPoint4(m, v, dest = math.vec4()) {\n        dest[0] = m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3];\n        dest[1] = m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3];\n        dest[2] = m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3];\n        dest[3] = m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3];\n\n        return dest;\n    },\n\n\n    /**\n     * Transforms an array of three-element positions by a 4x4 matrix.\n     * @method transformPoints3\n     * @static\n     */\n    transformPoints3(m, points, points2) {\n        const result = points2 || [];\n        const len = points.length;\n        let p0;\n        let p1;\n        let p2;\n        let pi;\n\n        // cache values\n        const m0 = m[0];\n\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        let r;\n\n        for (let i = 0; i < len; ++i) {\n\n            // cache values\n            pi = points[i];\n\n            p0 = pi[0];\n            p1 = pi[1];\n            p2 = pi[2];\n\n            r = result[i] || (result[i] = [0, 0, 0]);\n\n            r[0] = (m0 * p0) + (m4 * p1) + (m8 * p2) + m12;\n            r[1] = (m1 * p0) + (m5 * p1) + (m9 * p2) + m13;\n            r[2] = (m2 * p0) + (m6 * p1) + (m10 * p2) + m14;\n            r[3] = (m3 * p0) + (m7 * p1) + (m11 * p2) + m15;\n        }\n\n        result.length = len;\n\n        return result;\n    },\n\n    /**\n     * Transforms an array of positions by a 4x4 matrix.\n     * @method transformPositions3\n     * @static\n     */\n    transformPositions3(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 3) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /**\n     * Transforms an array of positions by a 4x4 matrix.\n     * @method transformPositions4\n     * @static\n     */\n    transformPositions4(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 4) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /**\n     * Transforms a three-element vector by a 4x4 matrix.\n     * @method transformVec3\n     * @static\n     */\n    transformVec3(m, v, dest) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        dest = dest || this.vec3();\n        dest[0] = (m[0] * v0) + (m[4] * v1) + (m[8] * v2);\n        dest[1] = (m[1] * v0) + (m[5] * v1) + (m[9] * v2);\n        dest[2] = (m[2] * v0) + (m[6] * v1) + (m[10] * v2);\n        return dest;\n    },\n\n    /**\n     * Transforms a four-element vector by a 4x4 matrix.\n     * @method transformVec4\n     * @static\n     */\n    transformVec4(m, v, dest) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        dest = dest || math.vec4();\n        dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;\n        dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;\n        dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;\n        dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the x-axis\n     *\n     * @method rotateVec3X\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3X(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[0];\n        r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);\n        r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the y-axis\n     *\n     * @method rotateVec3Y\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3Y(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);\n        r[1] = p[1];\n        r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the z-axis\n     *\n     * @method rotateVec3Z\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3Z(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);\n        r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);\n        r[2] = p[2];\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Transforms a four-element vector by a 4x4 projection matrix.\n     *\n     * @method projectVec4\n     * @param {Number[]} p 3D View-space coordinate\n     * @param {Number[]} q 2D Projected coordinate\n     * @returns {Number[]} 2D Projected coordinate\n     * @static\n     */\n    projectVec4(p, q) {\n        const f = 1.0 / p[3];\n        q = q || math.vec2();\n        q[0] = v[0] * f;\n        q[1] = v[1] * f;\n        return q;\n    },\n\n    /**\n     * Unprojects a three-element vector.\n     *\n     * @method unprojectVec3\n     * @param {Number[]} p 3D Projected coordinate\n     * @param {Number[]} viewMat View matrix\n     * @returns {Number[]} projMat Projection matrix\n     * @static\n     */\n    unprojectVec3: ((() => {\n        const mat = new FloatArrayType(16);\n        const mat2 = new FloatArrayType(16);\n        const mat3 = new FloatArrayType(16);\n        return function (p, viewMat, projMat, q) {\n            return this.transformVec3(this.mulMat4(this.inverseMat4(viewMat, mat), this.inverseMat4(projMat, mat2), mat3), p, q)\n        };\n    }))(),\n\n    /**\n     * Linearly interpolates between two 3D vectors.\n     * @method lerpVec3\n     * @static\n     */\n    lerpVec3(t, t1, t2, p1, p2, dest) {\n        const result = dest || math.vec3();\n        const f = (t - t1) / (t2 - t1);\n        result[0] = p1[0] + (f * (p2[0] - p1[0]));\n        result[1] = p1[1] + (f * (p2[1] - p1[1]));\n        result[2] = p1[2] + (f * (p2[2] - p1[2]));\n        return result;\n    },\n\n\n    /**\n     * Flattens a two-dimensional array into a one-dimensional array.\n     *\n     * @method flatten\n     * @static\n     * @param {Array of Arrays} a A 2D array\n     * @returns Flattened 1D array\n     */\n    flatten(a) {\n\n        const result = [];\n\n        let i;\n        let leni;\n        let j;\n        let lenj;\n        let item;\n\n        for (i = 0, leni = a.length; i < leni; i++) {\n            item = a[i];\n            for (j = 0, lenj = item.length; j < lenj; j++) {\n                result.push(item[j]);\n            }\n        }\n\n        return result;\n    },\n\n\n    identityQuaternion(dest = math.vec4()) {\n        dest[0] = 0.0;\n        dest[1] = 0.0;\n        dest[2] = 0.0;\n        dest[3] = 1.0;\n        return dest;\n    },\n\n    /**\n     * Initializes a quaternion from Euler angles.\n     *\n     * @param {Number[]} euler The Euler angles.\n     * @param {String} order Euler angle order: \"XYZ\", \"YXZ\", \"ZXY\" etc.\n     * @param {Number[]} [dest] Destination quaternion, created by default.\n     * @returns {Number[]} The quaternion.\n     */\n    eulerToQuaternion(euler, order, dest = math.vec4()) {\n        // http://www.mathworks.com/matlabcentral/fileexchange/\n        // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n        //\tcontent/SpinCalc.m\n\n        const a = (euler[0] * math.DEGTORAD) / 2;\n        const b = (euler[1] * math.DEGTORAD) / 2;\n        const c = (euler[2] * math.DEGTORAD) / 2;\n\n        const c1 = Math.cos(a);\n        const c2 = Math.cos(b);\n        const c3 = Math.cos(c);\n        const s1 = Math.sin(a);\n        const s2 = Math.sin(b);\n        const s3 = Math.sin(c);\n\n        if (order === 'XYZ') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'YXZ') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n\n        } else if (order === 'ZXY') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'ZYX') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n\n        } else if (order === 'YZX') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'XZY') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n        }\n\n        return dest;\n    },\n\n    mat4ToQuaternion(m, dest = math.vec4()) {\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n        // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n        const m11 = m[0];\n        const m12 = m[4];\n        const m13 = m[8];\n        const m21 = m[1];\n        const m22 = m[5];\n        const m23 = m[9];\n        const m31 = m[2];\n        const m32 = m[6];\n        const m33 = m[10];\n        let s;\n\n        const trace = m11 + m22 + m33;\n\n        if (trace > 0) {\n\n            s = 0.5 / Math.sqrt(trace + 1.0);\n\n            dest[3] = 0.25 / s;\n            dest[0] = (m32 - m23) * s;\n            dest[1] = (m13 - m31) * s;\n            dest[2] = (m21 - m12) * s;\n\n        } else if (m11 > m22 && m11 > m33) {\n\n            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n\n            dest[3] = (m32 - m23) / s;\n            dest[0] = 0.25 * s;\n            dest[1] = (m12 + m21) / s;\n            dest[2] = (m13 + m31) / s;\n\n        } else if (m22 > m33) {\n\n            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n\n            dest[3] = (m13 - m31) / s;\n            dest[0] = (m12 + m21) / s;\n            dest[1] = 0.25 * s;\n            dest[2] = (m23 + m32) / s;\n\n        } else {\n\n            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n\n            dest[3] = (m21 - m12) / s;\n            dest[0] = (m13 + m31) / s;\n            dest[1] = (m23 + m32) / s;\n            dest[2] = 0.25 * s;\n        }\n\n        return dest;\n    },\n\n    vec3PairToQuaternion(u, v, dest = math.vec4()) {\n        const norm_u_norm_v = Math.sqrt(math.dotVec3(u, u) * math.dotVec3(v, v));\n        let real_part = norm_u_norm_v + math.dotVec3(u, v);\n\n        if (real_part < 0.00000001 * norm_u_norm_v) {\n\n            // If u and v are exactly opposite, rotate 180 degrees\n            // around an arbitrary orthogonal axis. Axis normalisation\n            // can happen later, when we normalise the quaternion.\n\n            real_part = 0.0;\n\n            if (Math.abs(u[0]) > Math.abs(u[2])) {\n\n                dest[0] = -u[1];\n                dest[1] = u[0];\n                dest[2] = 0;\n\n            } else {\n                dest[0] = 0;\n                dest[1] = -u[2];\n                dest[2] = u[1]\n            }\n\n        } else {\n\n            // Otherwise, build quaternion the standard way.\n            math.cross3Vec3(u, v, dest);\n        }\n\n        dest[3] = real_part;\n\n        return math.normalizeQuaternion(dest);\n    },\n\n    angleAxisToQuaternion(angleAxis, dest = math.vec4()) {\n        const halfAngle = angleAxis[3] / 2.0;\n        const fsin = Math.sin(halfAngle);\n        dest[0] = fsin * angleAxis[0];\n        dest[1] = fsin * angleAxis[1];\n        dest[2] = fsin * angleAxis[2];\n        dest[3] = Math.cos(halfAngle);\n        return dest;\n    },\n\n    quaternionToEuler: ((() => {\n        const mat = new FloatArrayType(16);\n        return (q, order, dest) => {\n            dest = dest || math.vec3();\n            math.quaternionToRotationMat4(q, mat);\n            math.mat4ToEuler(mat, order, dest);\n            return dest;\n        };\n    }))(),\n\n    mulQuaternions(p, q, dest = math.vec4()) {\n        const p0 = p[0];\n        const p1 = p[1];\n        const p2 = p[2];\n        const p3 = p[3];\n        const q0 = q[0];\n        const q1 = q[1];\n        const q2 = q[2];\n        const q3 = q[3];\n        dest[0] = p3 * q0 + p0 * q3 + p1 * q2 - p2 * q1;\n        dest[1] = p3 * q1 + p1 * q3 + p2 * q0 - p0 * q2;\n        dest[2] = p3 * q2 + p2 * q3 + p0 * q1 - p1 * q0;\n        dest[3] = p3 * q3 - p0 * q0 - p1 * q1 - p2 * q2;\n        return dest;\n    },\n\n    vec3ApplyQuaternion(q, vec, dest = math.vec3()) {\n        const x = vec[0];\n        const y = vec[1];\n        const z = vec[2];\n\n        const qx = q[0];\n        const qy = q[1];\n        const qz = q[2];\n        const qw = q[3];\n\n        // calculate quat * vector\n\n        const ix = qw * x + qy * z - qz * y;\n        const iy = qw * y + qz * x - qx * z;\n        const iz = qw * z + qx * y - qy * x;\n        const iw = -qx * x - qy * y - qz * z;\n\n        // calculate result * inverse quat\n\n        dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n        dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n        dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n        return dest;\n    },\n\n    quaternionToMat4(q, dest) {\n\n        dest = math.identityMat4(dest);\n\n        const q0 = q[0];  //x\n        const q1 = q[1];  //y\n        const q2 = q[2];  //z\n        const q3 = q[3];  //w\n\n        const tx = 2.0 * q0;\n        const ty = 2.0 * q1;\n        const tz = 2.0 * q2;\n\n        const twx = tx * q3;\n        const twy = ty * q3;\n        const twz = tz * q3;\n\n        const txx = tx * q0;\n        const txy = ty * q0;\n        const txz = tz * q0;\n\n        const tyy = ty * q1;\n        const tyz = tz * q1;\n        const tzz = tz * q2;\n\n        dest[0] = 1.0 - (tyy + tzz);\n        dest[1] = txy + twz;\n        dest[2] = txz - twy;\n\n        dest[4] = txy - twz;\n        dest[5] = 1.0 - (txx + tzz);\n        dest[6] = tyz + twx;\n\n        dest[8] = txz + twy;\n        dest[9] = tyz - twx;\n\n        dest[10] = 1.0 - (txx + tyy);\n\n        return dest;\n    },\n\n    quaternionToRotationMat4(q, m) {\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n\n        m[0] = 1 - (yy + zz);\n        m[4] = xy - wz;\n        m[8] = xz + wy;\n\n        m[1] = xy + wz;\n        m[5] = 1 - (xx + zz);\n        m[9] = yz - wx;\n\n        m[2] = xz - wy;\n        m[6] = yz + wx;\n        m[10] = 1 - (xx + yy);\n\n        // last column\n        m[3] = 0;\n        m[7] = 0;\n        m[11] = 0;\n\n        // bottom row\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = 0;\n        m[15] = 1;\n\n        return m;\n    },\n\n    normalizeQuaternion(q, dest = q) {\n        const len = math.lenVec4([q[0], q[1], q[2], q[3]]);\n        dest[0] = q[0] / len;\n        dest[1] = q[1] / len;\n        dest[2] = q[2] / len;\n        dest[3] = q[3] / len;\n        return dest;\n    },\n\n    conjugateQuaternion(q, dest = q) {\n        dest[0] = -q[0];\n        dest[1] = -q[1];\n        dest[2] = -q[2];\n        dest[3] = q[3];\n        return dest;\n    },\n\n    inverseQuaternion(q, dest) {\n        return math.normalizeQuaternion(math.conjugateQuaternion(q, dest));\n    },\n\n    quaternionToAngleAxis(q, angleAxis = math.vec4()) {\n        q = math.normalizeQuaternion(q, tempVec4);\n        const q3 = q[3];\n        const angle = 2 * Math.acos(q3);\n        const s = Math.sqrt(1 - q3 * q3);\n        if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt\n            angleAxis[0] = q[0];\n            angleAxis[1] = q[1];\n            angleAxis[2] = q[2];\n        } else {\n            angleAxis[0] = q[0] / s;\n            angleAxis[1] = q[1] / s;\n            angleAxis[2] = q[2] / s;\n        }\n        angleAxis[3] = angle; // * 57.295779579;\n        return angleAxis;\n    },\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Boundaries\n    //------------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Returns a new, uninitialized 3D axis-aligned bounding box.\n     *\n     * @private\n     */\n    AABB3(values) {\n        return new FloatArrayType(values || 6);\n    },\n\n    /**\n     * Returns a new, uninitialized 2D axis-aligned bounding box.\n     *\n     * @private\n     */\n    AABB2(values) {\n        return new FloatArrayType(values || 4);\n    },\n\n    /**\n     * Returns a new, uninitialized 3D oriented bounding box (OBB).\n     *\n     * @private\n     */\n    OBB3(values) {\n        return new FloatArrayType(values || 32);\n    },\n\n    /**\n     * Returns a new, uninitialized 2D oriented bounding box (OBB).\n     *\n     * @private\n     */\n    OBB2(values) {\n        return new FloatArrayType(values || 16);\n    },\n\n    /** Returns a new 3D bounding sphere */\n    Sphere3(x, y, z, r) {\n        return new FloatArrayType([x, y, z, r]);\n    },\n\n    /**\n     * Transforms an OBB3 by a 4x4 matrix.\n     *\n     * @private\n     */\n    transformOBB3(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 4) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /** Returns true if the first AABB contains the second AABB.\n     * @param aabb1\n     * @param aabb2\n     * @returns {boolean}\n     */\n    containsAABB3: function (aabb1, aabb2) {\n        const result = (\n            aabb1[0] <= aabb2[0] && aabb2[3] <= aabb1[3] &&\n            aabb1[1] <= aabb2[1] && aabb2[4] <= aabb1[4] &&\n            aabb1[2] <= aabb2[2] && aabb2[5] <= aabb1[5]);\n        return result;\n    },\n\n    /**\n     * Gets the diagonal size of an AABB3 given as minima and maxima.\n     *\n     * @private\n     */\n    getAABB3Diag: ((() => {\n\n        const min = new FloatArrayType(3);\n        const max = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return aabb => {\n\n            min[0] = aabb[0];\n            min[1] = aabb[1];\n            min[2] = aabb[2];\n\n            max[0] = aabb[3];\n            max[1] = aabb[4];\n            max[2] = aabb[5];\n\n            math.subVec3(max, min, tempVec3);\n\n            return Math.abs(math.lenVec3(tempVec3));\n        };\n    }))(),\n\n    /**\n     * Get a diagonal boundary size that is symmetrical about the given point.\n     *\n     * @private\n     */\n    getAABB3DiagPoint: ((() => {\n\n        const min = new FloatArrayType(3);\n        const max = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return (aabb, p) => {\n\n            min[0] = aabb[0];\n            min[1] = aabb[1];\n            min[2] = aabb[2];\n\n            max[0] = aabb[3];\n            max[1] = aabb[4];\n            max[2] = aabb[5];\n\n            const diagVec = math.subVec3(max, min, tempVec3);\n\n            const xneg = p[0] - aabb[0];\n            const xpos = aabb[3] - p[0];\n            const yneg = p[1] - aabb[1];\n            const ypos = aabb[4] - p[1];\n            const zneg = p[2] - aabb[2];\n            const zpos = aabb[5] - p[2];\n\n            diagVec[0] += (xneg > xpos) ? xneg : xpos;\n            diagVec[1] += (yneg > ypos) ? yneg : ypos;\n            diagVec[2] += (zneg > zpos) ? zneg : zpos;\n\n            return Math.abs(math.lenVec3(diagVec));\n        };\n    }))(),\n\n    /**\n     * Gets the center of an AABB.\n     *\n     * @private\n     */\n    getAABB3Center(aabb, dest) {\n        const r = dest || math.vec3();\n\n        r[0] = (aabb[0] + aabb[3]) / 2;\n        r[1] = (aabb[1] + aabb[4]) / 2;\n        r[2] = (aabb[2] + aabb[5]) / 2;\n\n        return r;\n    },\n\n    /**\n     * Gets the center of a 2D AABB.\n     *\n     * @private\n     */\n    getAABB2Center(aabb, dest) {\n        const r = dest || math.vec2();\n\n        r[0] = (aabb[2] + aabb[0]) / 2;\n        r[1] = (aabb[3] + aabb[1]) / 2;\n\n        return r;\n    },\n\n    /**\n     * Collapses a 3D axis-aligned boundary, ready to expand to fit 3D points.\n     * Creates new AABB if none supplied.\n     *\n     * @private\n     */\n    collapseAABB3(aabb = math.AABB3()) {\n        aabb[0] = math.MAX_DOUBLE;\n        aabb[1] = math.MAX_DOUBLE;\n        aabb[2] = math.MAX_DOUBLE;\n        aabb[3] = -math.MAX_DOUBLE;\n        aabb[4] = -math.MAX_DOUBLE;\n        aabb[5] = -math.MAX_DOUBLE;\n\n        return aabb;\n    },\n\n    /**\n     * Converts an axis-aligned 3D boundary into an oriented boundary consisting of\n     * an array of eight 3D positions, one for each corner of the boundary.\n     *\n     * @private\n     */\n    AABB3ToOBB3(aabb, obb = math.OBB3()) {\n        obb[0] = aabb[0];\n        obb[1] = aabb[1];\n        obb[2] = aabb[2];\n        obb[3] = 1;\n\n        obb[4] = aabb[3];\n        obb[5] = aabb[1];\n        obb[6] = aabb[2];\n        obb[7] = 1;\n\n        obb[8] = aabb[3];\n        obb[9] = aabb[4];\n        obb[10] = aabb[2];\n        obb[11] = 1;\n\n        obb[12] = aabb[0];\n        obb[13] = aabb[4];\n        obb[14] = aabb[2];\n        obb[15] = 1;\n\n        obb[16] = aabb[0];\n        obb[17] = aabb[1];\n        obb[18] = aabb[5];\n        obb[19] = 1;\n\n        obb[20] = aabb[3];\n        obb[21] = aabb[1];\n        obb[22] = aabb[5];\n        obb[23] = 1;\n\n        obb[24] = aabb[3];\n        obb[25] = aabb[4];\n        obb[26] = aabb[5];\n        obb[27] = 1;\n\n        obb[28] = aabb[0];\n        obb[29] = aabb[4];\n        obb[30] = aabb[5];\n        obb[31] = 1;\n\n        return obb;\n    },\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n     *\n     * @private\n     */\n    positions3ToAABB3: ((() => {\n\n        const p = new FloatArrayType(3);\n\n        return (positions, aabb, positionsDecodeMatrix) => {\n            aabb = aabb || math.AABB3();\n\n            let xmin = math.MAX_DOUBLE;\n            let ymin = math.MAX_DOUBLE;\n            let zmin = math.MAX_DOUBLE;\n            let xmax = -math.MAX_DOUBLE;\n            let ymax = -math.MAX_DOUBLE;\n            let zmax = -math.MAX_DOUBLE;\n\n            let x;\n            let y;\n            let z;\n\n            for (let i = 0, len = positions.length; i < len; i += 3) {\n\n                if (positionsDecodeMatrix) {\n\n                    p[0] = positions[i + 0];\n                    p[1] = positions[i + 1];\n                    p[2] = positions[i + 2];\n\n                    math.decompressPosition(p, positionsDecodeMatrix, p);\n\n                    x = p[0];\n                    y = p[1];\n                    z = p[2];\n\n                } else {\n                    x = positions[i + 0];\n                    y = positions[i + 1];\n                    z = positions[i + 2];\n                }\n\n                if (x < xmin) {\n                    xmin = x;\n                }\n\n                if (y < ymin) {\n                    ymin = y;\n                }\n\n                if (z < zmin) {\n                    zmin = z;\n                }\n\n                if (x > xmax) {\n                    xmax = x;\n                }\n\n                if (y > ymax) {\n                    ymax = y;\n                }\n\n                if (z > zmax) {\n                    zmax = z;\n                }\n            }\n\n            aabb[0] = xmin;\n            aabb[1] = ymin;\n            aabb[2] = zmin;\n            aabb[3] = xmax;\n            aabb[4] = ymax;\n            aabb[5] = zmax;\n\n            return aabb;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n     *\n     * @private\n     */\n    OBB3ToAABB3(obb, aabb = math.AABB3()) {\n        let xmin = math.MAX_DOUBLE;\n        let ymin = math.MAX_DOUBLE;\n        let zmin = math.MAX_DOUBLE;\n        let xmax = -math.MAX_DOUBLE;\n        let ymax = -math.MAX_DOUBLE;\n        let zmax = -math.MAX_DOUBLE;\n\n        let x;\n        let y;\n        let z;\n\n        for (let i = 0, len = obb.length; i < len; i += 4) {\n\n            x = obb[i + 0];\n            y = obb[i + 1];\n            z = obb[i + 2];\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (z < zmin) {\n                zmin = z;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n\n            if (z > zmax) {\n                zmax = z;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = zmin;\n        aabb[3] = xmax;\n        aabb[4] = ymax;\n        aabb[5] = zmax;\n\n        return aabb;\n    },\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the given 3D points.\n     *\n     * @private\n     */\n    points3ToAABB3(points, aabb = math.AABB3()) {\n        let xmin = math.MAX_DOUBLE;\n        let ymin = math.MAX_DOUBLE;\n        let zmin = math.MAX_DOUBLE;\n        let xmax = -math.MAX_DOUBLE;\n        let ymax = -math.MAX_DOUBLE;\n        let zmax = -math.MAX_DOUBLE;\n\n        let x;\n        let y;\n        let z;\n\n        for (let i = 0, len = points.length; i < len; i++) {\n\n            x = points[i][0];\n            y = points[i][1];\n            z = points[i][2];\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (z < zmin) {\n                zmin = z;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n\n            if (z > zmax) {\n                zmax = z;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = zmin;\n        aabb[3] = xmax;\n        aabb[4] = ymax;\n        aabb[5] = zmax;\n\n        return aabb;\n    },\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D points.\n     *\n     * @private\n     */\n    points3ToSphere3: ((() => {\n\n        const tempVec3 = new FloatArrayType(3);\n\n        return (points, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const numPoints = points.length;\n\n            for (i = 0; i < numPoints; i++) {\n                x += points[i][0];\n                y += points[i][1];\n                z += points[i][2];\n            }\n\n            sphere[0] = x / numPoints;\n            sphere[1] = y / numPoints;\n            sphere[2] = z / numPoints;\n\n            let radius = 0;\n            let dist;\n\n            for (i = 0; i < numPoints; i++) {\n\n                dist = Math.abs(math.lenVec3(math.subVec3(points[i], sphere, tempVec3)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D positions.\n     *\n     * @private\n     */\n    positions3ToSphere3: ((() => {\n\n        const tempVec3a = new FloatArrayType(3);\n        const tempVec3b = new FloatArrayType(3);\n\n        return (positions, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const lenPositions = positions.length;\n            let radius = 0;\n\n            for (i = 0; i < lenPositions; i += 3) {\n                x += positions[i];\n                y += positions[i + 1];\n                z += positions[i + 2];\n            }\n\n            const numPositions = lenPositions / 3;\n\n            sphere[0] = x / numPositions;\n            sphere[1] = y / numPositions;\n            sphere[2] = z / numPositions;\n\n            let dist;\n\n            for (i = 0; i < lenPositions; i += 3) {\n\n                tempVec3a[0] = positions[i];\n                tempVec3a[1] = positions[i + 1];\n                tempVec3a[2] = positions[i + 2];\n\n                dist = Math.abs(math.lenVec3(math.subVec3(tempVec3a, sphere, tempVec3b)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D points.\n     *\n     * @private\n     */\n    OBB3ToSphere3: ((() => {\n\n        const point = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return (points, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const lenPoints = points.length;\n            const numPoints = lenPoints / 4;\n\n            for (i = 0; i < lenPoints; i += 4) {\n                x += points[i + 0];\n                y += points[i + 1];\n                z += points[i + 2];\n            }\n\n            sphere[0] = x / numPoints;\n            sphere[1] = y / numPoints;\n            sphere[2] = z / numPoints;\n\n            let radius = 0;\n            let dist;\n\n            for (i = 0; i < lenPoints; i += 4) {\n\n                point[0] = points[i + 0];\n                point[1] = points[i + 1];\n                point[2] = points[i + 2];\n\n                dist = Math.abs(math.lenVec3(math.subVec3(point, sphere, tempVec3)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Gets the center of a bounding sphere.\n     *\n     * @private\n     */\n    getSphere3Center(sphere, dest = math.vec3()) {\n        dest[0] = sphere[0];\n        dest[1] = sphere[1];\n        dest[2] = sphere[2];\n\n        return dest;\n    },\n\n    /**\n     * Expands the first axis-aligned 3D boundary to enclose the second, if required.\n     *\n     * @private\n     */\n    expandAABB3(aabb1, aabb2) {\n\n        if (aabb1[0] > aabb2[0]) {\n            aabb1[0] = aabb2[0];\n        }\n\n        if (aabb1[1] > aabb2[1]) {\n            aabb1[1] = aabb2[1];\n        }\n\n        if (aabb1[2] > aabb2[2]) {\n            aabb1[2] = aabb2[2];\n        }\n\n        if (aabb1[3] < aabb2[3]) {\n            aabb1[3] = aabb2[3];\n        }\n\n        if (aabb1[4] < aabb2[4]) {\n            aabb1[4] = aabb2[4];\n        }\n\n        if (aabb1[5] < aabb2[5]) {\n            aabb1[5] = aabb2[5];\n        }\n\n        return aabb1;\n    },\n\n    /**\n     * Expands an axis-aligned 3D boundary to enclose the given point, if needed.\n     *\n     * @private\n     */\n    expandAABB3Point3(aabb, p) {\n\n        if (aabb[0] > p[0]) {\n            aabb[0] = p[0];\n        }\n\n        if (aabb[1] > p[1]) {\n            aabb[1] = p[1];\n        }\n\n        if (aabb[2] > p[2]) {\n            aabb[2] = p[2];\n        }\n\n        if (aabb[3] < p[0]) {\n            aabb[3] = p[0];\n        }\n\n        if (aabb[4] < p[1]) {\n            aabb[4] = p[1];\n        }\n\n        if (aabb[5] < p[2]) {\n            aabb[5] = p[2];\n        }\n\n        return aabb;\n    },\n\n    /**\n     * Calculates the normal vector of a triangle.\n     *\n     * @private\n     */\n    triangleNormal(a, b, c, normal = math.vec3()) {\n        const p1x = b[0] - a[0];\n        const p1y = b[1] - a[1];\n        const p1z = b[2] - a[2];\n\n        const p2x = c[0] - a[0];\n        const p2y = c[1] - a[1];\n        const p2z = c[2] - a[2];\n\n        const p3x = p1y * p2z - p1z * p2y;\n        const p3y = p1z * p2x - p1x * p2z;\n        const p3z = p1x * p2y - p1y * p2x;\n\n        const mag = Math.sqrt(p3x * p3x + p3y * p3y + p3z * p3z);\n        if (mag === 0) {\n            normal[0] = 0;\n            normal[1] = 0;\n            normal[2] = 0;\n        } else {\n            normal[0] = p3x / mag;\n            normal[1] = p3y / mag;\n            normal[2] = p3z / mag;\n        }\n\n        return normal\n    }\n};\n\nexport {math};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/XKTModel/lib/math.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 233,
    "kind": "variable",
    "name": "doublePrecision",
    "memberof": "src/XKTModel/lib/math.js",
    "static": true,
    "longname": "src/XKTModel/lib/math.js~doublePrecision",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 234,
    "kind": "variable",
    "name": "FloatArrayType",
    "memberof": "src/XKTModel/lib/math.js",
    "static": true,
    "longname": "src/XKTModel/lib/math.js~FloatArrayType",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 235,
    "kind": "variable",
    "name": "tempMat1",
    "memberof": "src/XKTModel/lib/math.js",
    "static": true,
    "longname": "src/XKTModel/lib/math.js~tempMat1",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 236,
    "kind": "variable",
    "name": "tempMat2",
    "memberof": "src/XKTModel/lib/math.js",
    "static": true,
    "longname": "src/XKTModel/lib/math.js~tempMat2",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 237,
    "kind": "variable",
    "name": "tempVec4",
    "memberof": "src/XKTModel/lib/math.js",
    "static": true,
    "longname": "src/XKTModel/lib/math.js~tempVec4",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 238,
    "kind": "variable",
    "name": "math",
    "memberof": "src/XKTModel/lib/math.js",
    "static": true,
    "longname": "src/XKTModel/lib/math.js~math",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/math.js",
    "importStyle": "{math}",
    "description": "",
    "lineNumber": 13,
    "ignore": true,
    "type": {
      "types": [
        "{\"MIN_DOUBLE\": *, \"MAX_DOUBLE\": *, \"DEGTORAD\": number, \"RADTODEG\": number, \"vec2\": function, \"vec3\": function, \"vec4\": function, \"mat3\": function, \"mat3ToMat4\": function, \"mat4\": function, \"mat4ToMat3\": function, \"createUUID\": *, \"clamp\": function, \"fmod\": function, \"negateVec4\": function, \"addVec4\": function, \"addVec4Scalar\": function, \"addVec3\": function, \"addVec3Scalar\": function, \"subVec4\": function, \"subVec3\": function, \"subVec2\": function, \"subVec4Scalar\": function, \"subScalarVec4\": function, \"mulVec4\": function, \"mulVec4Scalar\": function, \"mulVec3Scalar\": function, \"mulVec2Scalar\": function, \"divVec3\": function, \"divVec4\": function, \"divScalarVec3\": function, \"divVec3Scalar\": function, \"divVec4Scalar\": function, \"divScalarVec4\": function, \"dotVec4\": function, \"cross3Vec4\": function, \"cross3Vec3\": function, \"sqLenVec4\": function, \"lenVec4\": function, \"dotVec3\": function, \"dotVec2\": function, \"sqLenVec3\": function, \"sqLenVec2\": function, \"lenVec3\": function, \"distVec3\": *, \"lenVec2\": function, \"distVec2\": *, \"rcpVec3\": function, \"normalizeVec4\": function, \"normalizeVec3\": function, \"normalizeVec2\": function, \"angleVec3\": function, \"vec3FromMat4Scale\": *, \"vecToArray\": *, \"xyzArrayToObject\": function, \"xyzObjectToArray\": function, \"dupMat4\": function, \"mat4To3\": function, \"m4s\": function, \"setMat4ToZeroes\": function, \"setMat4ToOnes\": function, \"diagonalMat4v\": function, \"diagonalMat4c\": function, \"diagonalMat4s\": function, \"identityMat4\": function, \"identityMat3\": function, \"isIdentityMat4\": function, \"negateMat4\": function, \"addMat4\": function, \"addMat4Scalar\": function, \"addScalarMat4\": function, \"subMat4\": function, \"subMat4Scalar\": function, \"subScalarMat4\": function, \"mulMat4\": function, \"mulMat3\": function, \"mulMat4Scalar\": function, \"mulMat4v4\": function, \"transposeMat4\": function, \"transposeMat3\": function, \"determinantMat4\": function, \"inverseMat4\": function, \"traceMat4\": function, \"translationMat4v\": function, \"translationMat3v\": function, \"translationMat4c\": *, \"translationMat4s\": function, \"translateMat4v\": function, \"OLDtranslateMat4c\": function, \"translateMat4c\": function, \"rotationMat4v\": function, \"rotationMat4c\": function, \"scalingMat4v\": function, \"scalingMat3v\": function, \"scalingMat4c\": *, \"scaleMat4c\": function, \"scaleMat4v\": function, \"scalingMat4s\": function, \"rotationTranslationMat4\": function, \"mat4ToEuler\": function, \"composeMat4\": function, \"decomposeMat4\": *, \"lookAtMat4v\": function, \"lookAtMat4c\": function, \"orthoMat4c\": function, \"frustumMat4v\": function, \"frustumMat4\": function, \"perspectiveMat4\": function, \"transformPoint3\": function, \"transformPoint4\": function, \"transformPoints3\": function, \"transformPositions3\": function, \"transformPositions4\": function, \"transformVec3\": function, \"transformVec4\": function, \"rotateVec3X\": function, \"rotateVec3Y\": function, \"rotateVec3Z\": function, \"projectVec4\": function, \"unprojectVec3\": *, \"lerpVec3\": function, \"flatten\": function, \"identityQuaternion\": function, \"eulerToQuaternion\": function, \"mat4ToQuaternion\": function, \"vec3PairToQuaternion\": function, \"angleAxisToQuaternion\": function, \"quaternionToEuler\": *, \"mulQuaternions\": function, \"vec3ApplyQuaternion\": function, \"quaternionToMat4\": function, \"quaternionToRotationMat4\": function, \"normalizeQuaternion\": function, \"conjugateQuaternion\": function, \"inverseQuaternion\": function, \"quaternionToAngleAxis\": function, \"AABB3\": function, \"AABB2\": function, \"OBB3\": function, \"OBB2\": function, \"Sphere3\": function, \"transformOBB3\": function, \"containsAABB3\": *, \"getAABB3Diag\": *, \"getAABB3DiagPoint\": *, \"getAABB3Center\": function, \"getAABB2Center\": function, \"collapseAABB3\": function, \"AABB3ToOBB3\": function, \"positions3ToAABB3\": *, \"OBB3ToAABB3\": function, \"points3ToAABB3\": function, \"points3ToSphere3\": *, \"positions3ToSphere3\": *, \"OBB3ToSphere3\": *, \"getSphere3Center\": function, \"expandAABB3\": function, \"expandAABB3Point3\": function, \"triangleNormal\": function}"
      ]
    }
  },
  {
    "__docId__": 239,
    "kind": "file",
    "name": "src/XKTModel/lib/mergeVertices.js",
    "content": "/**\n * Given geometry defined as an array of positions, optional normals, option uv and an array of indices, returns\n * modified arrays that have duplicate vertices removed.\n *\n * @private\n */\nfunction mergeVertices(positions, indices, mergedPositions, mergedIndices) {\n    const positionsMap = {};\n    const indicesLookup = [];\n    const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n    const precision = 10 ** precisionPoints;\n    let uvi = 0;\n    for (let i = 0, len = positions.length; i < len; i += 3) {\n        const vx = positions[i];\n        const vy = positions[i + 1];\n        const vz = positions[i + 2];\n        const key = `${Math.round(vx * precision)}_${Math.round(vy * precision)}_${Math.round(vz * precision)}`;\n        if (positionsMap[key] === undefined) {\n            positionsMap[key] = mergedPositions.length / 3;\n            mergedPositions.push(vx);\n            mergedPositions.push(vy);\n            mergedPositions.push(vz);\n        }\n        indicesLookup[i / 3] = positionsMap[key];\n        uvi += 2;\n    }\n    for (let i = 0, len = indices.length; i < len; i++) {\n        mergedIndices[i] = indicesLookup[indices[i]];\n    }\n}\n\nexport {mergeVertices};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/XKTModel/lib/mergeVertices.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 240,
    "kind": "function",
    "name": "mergeVertices",
    "memberof": "src/XKTModel/lib/mergeVertices.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/mergeVertices.js~mergeVertices",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/mergeVertices.js",
    "importStyle": "{mergeVertices}",
    "description": "Given geometry defined as an array of positions, optional normals, option uv and an array of indices, returns\nmodified arrays that have duplicate vertices removed.",
    "lineNumber": 7,
    "ignore": true,
    "params": [
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "indices",
        "types": [
          "*"
        ]
      },
      {
        "name": "mergedPositions",
        "types": [
          "*"
        ]
      },
      {
        "name": "mergedIndices",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 241,
    "kind": "file",
    "name": "src/XKTModel/lib/utils.js",
    "content": "function isString(value) {\n    return (typeof value === 'string' || value instanceof String);\n}\n\n/**\n * @private\n */\nconst utils = {\n    isString: isString,\n};\n\nexport {utils};\n",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/XKTModel/lib/utils.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 242,
    "kind": "function",
    "name": "isString",
    "memberof": "src/XKTModel/lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/utils.js~isString",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 243,
    "kind": "variable",
    "name": "utils",
    "memberof": "src/XKTModel/lib/utils.js",
    "static": true,
    "longname": "src/XKTModel/lib/utils.js~utils",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/utils.js",
    "importStyle": "{utils}",
    "description": "",
    "lineNumber": 8,
    "ignore": true,
    "type": {
      "types": [
        "{\"isString\": *}"
      ]
    }
  },
  {
    "__docId__": 244,
    "kind": "file",
    "name": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "content": "import * as p from \"./lib/pako.es.js\";\nimport {XKT_INFO} from \"../XKT_INFO.js\";\n\nlet pako = p;\nif (!pako.inflate) {  // See https://github.com/nodeca/pako/issues/97\n    pako = pako.default;\n}\n\nconst XKT_VERSION = XKT_INFO.xktVersion;\n\n/**\n * Writes an {@link XKTModel} to an {@link ArrayBuffer}.\n *\n * @param {XKTModel} xktModel The {@link XKTModel}.\n * @returns {ArrayBuffer} The {@link ArrayBuffer}.\n */\nfunction writeXKTModelToArrayBuffer(xktModel) {\n\n    const data = getModelData(xktModel);\n\n    const deflatedData = deflateData(data);\n\n    const arrayBuffer = createArrayBuffer(deflatedData);\n\n    return arrayBuffer;\n}\n\nfunction getModelData(xktModel) {\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Allocate data\n    //------------------------------------------------------------------------------------------------------------------\n\n    const propertySetsList = xktModel.propertySetsList;\n    const metaObjectsList = xktModel.metaObjectsList;\n    const geometriesList = xktModel.geometriesList;\n    const meshesList = xktModel.meshesList;\n    const entitiesList = xktModel.entitiesList;\n    const tilesList = xktModel.tilesList;\n\n    const numPropertySets = propertySetsList.length;\n    const numMetaObjects = metaObjectsList.length;\n    const numGeometries = geometriesList.length;\n    const numMeshes = meshesList.length;\n    const numEntities = entitiesList.length;\n    const numTiles = tilesList.length;\n\n    let lenPositions = 0;\n    let lenNormals = 0;\n    let lenColors = 0;\n    let lenIndices = 0;\n    let lenEdgeIndices = 0;\n    let lenMatrices = 0;\n\n    for (let geometryIndex = 0; geometryIndex < numGeometries; geometryIndex++) {\n        const geometry = geometriesList [geometryIndex];\n        if (geometry.positionsQuantized) {\n            lenPositions += geometry.positionsQuantized.length;\n        }\n        if (geometry.normalsOctEncoded) {\n            lenNormals += geometry.normalsOctEncoded.length;\n        }\n        if (geometry.colorsCompressed) {\n            lenColors += geometry.colorsCompressed.length;\n        }\n        if (geometry.indices) {\n            lenIndices += geometry.indices.length;\n        }\n        if (geometry.edgeIndices) {\n            lenEdgeIndices += geometry.edgeIndices.length;\n        }\n    }\n\n    for (let meshIndex = 0; meshIndex < numMeshes; meshIndex++) {\n        const mesh = meshesList[meshIndex];\n        if (mesh.geometry.numInstances > 1) {\n            lenMatrices += 16;\n        }\n    }\n\n    const data = {\n\n        // Metadata\n\n        metadata: {},\n\n        // Geometry data - vertex attributes and indices\n\n        positions: new Uint16Array(lenPositions), // All geometry arrays\n        normals: new Int8Array(lenNormals),\n        colors: new Uint8Array(lenColors),\n        indices: new Uint32Array(lenIndices),\n        edgeIndices: new Uint32Array(lenEdgeIndices),\n\n        // Transform matrices shared by meshes\n\n        matrices: new Float32Array(lenMatrices), // Modeling matrices for entities that share geometries. Each entity either shares all it's geometries, or owns all its geometries exclusively. Exclusively-owned geometries are pre-transformed into World-space, and so their entities don't have modeling matrices in this array.\n\n        // De-quantization matrix shared by all rused geometries\n\n        reusedGeometriesDecodeMatrix: new Float32Array(xktModel.reusedGeometriesDecodeMatrix), // A single, global vertex position de-quantization matrix for all reused geometries. Reused geometries are quantized to their collective Local-space AABB, and this matrix is derived from that AABB.\n\n        // Geometries\n\n        eachGeometryPrimitiveType: new Uint8Array(numGeometries), // Primitive type for each geometry (0=solid triangles, 1=surface triangles, 2=lines, 3=points)\n        eachGeometryPositionsPortion: new Uint32Array(numGeometries), // For each geometry, an index to its first element in data.positions. Every primitive type has positions.\n        eachGeometryNormalsPortion: new Uint32Array(numGeometries), // For each geometry, an index to its first element in data.normals. If the next geometry has the same index, then this geometry has no normals.\n        eachGeometryColorsPortion: new Uint32Array(numGeometries), // For each geometry, an index to its first element in data.colors. If the next geometry has the same index, then this geometry has no colors.\n        eachGeometryIndicesPortion: new Uint32Array(numGeometries), // For each geometry, an index to its first element in data.indices. If the next geometry has the same index, then this geometry has no indices.\n        eachGeometryEdgeIndicesPortion: new Uint32Array(numGeometries), // For each geometry, an index to its first element in data.edgeIndices. If the next geometry has the same index, then this geometry has no edge indices.\n\n        // Meshes are grouped in runs that are shared by the same entities.\n\n        // We duplicate materials for meshes, rather than reusing them, because each material is only 6 bytes and an index\n        // into a common materials array would be 4 bytes, so it's hardly worth reusing materials, as long as they are that compact.\n\n        eachMeshGeometriesPortion: new Uint32Array(numMeshes), // For each mesh, an index into the eachGeometry* arrays\n        eachMeshMatricesPortion: new Uint32Array(numMeshes), // For each mesh that shares its geometry, an index to its first element in data.matrices, to indicate the modeling matrix that transforms the shared geometry Local-space vertex positions. This is ignored for meshes that don't share geometries, because the vertex positions of non-shared geometries are pre-transformed into World-space.\n        eachMeshMaterial: new Uint8Array(numMeshes * 6), // For each mesh, an RGBA integer color of format [0..255, 0..255, 0..255, 0..255], and PBR metallic and roughness factors, of format [0..255, 0..255]\n\n        // Entity elements in the following arrays are grouped in runs that are shared by the same tiles\n\n        eachEntityId: [], // For each entity, an ID string\n        eachEntityMeshesPortion: new Uint32Array(numEntities), // For each entity, the index of the first element of meshes used by the entity\n\n        eachTileAABB: new Float64Array(numTiles * 6), // For each tile, an axis-aligned bounding box\n        eachTileEntitiesPortion: new Uint32Array(numTiles) // For each tile, the index of the the first element of eachEntityId, eachEntityMeshesPortion and eachEntityMatricesPortion used by the tile\n    };\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Populate the data\n    //------------------------------------------------------------------------------------------------------------------\n\n    let countPositions = 0;\n    let countNormals = 0;\n    let countColors = 0;\n    let countIndices = 0;\n    let countEdgeIndices = 0;\n    let countMeshColors = 0;\n\n    // Metadata\n\n    data.metadata = {\n\n        id: xktModel.modelId,\n        projectId: xktModel.projectId,\n        revisionId: xktModel.revisionId,\n        author: xktModel.author,\n        createdAt: xktModel.createdAt,\n        creatingApplication: xktModel.creatingApplication,\n        schema: xktModel.schema,\n\n        propertySets: [],\n        metaObjects: []\n    };\n\n    for (let propertySetsIndex = 0; propertySetsIndex < numPropertySets; propertySetsIndex++) {\n\n        const propertySet = propertySetsList[propertySetsIndex];\n\n        const propertySetJSON = {\n            id: \"\" + propertySet.propertySetId,\n            name: propertySet.propertySetName,\n            type: propertySet.propertySetType,\n            properties: propertySet.properties\n        };\n\n        data.metadata.propertySets.push(propertySetJSON);\n    }\n\n    for (let metaObjectsIndex = 0; metaObjectsIndex < numMetaObjects; metaObjectsIndex++) {\n\n        const metaObject = metaObjectsList[metaObjectsIndex];\n\n        const metaObjectJSON = {\n            name: metaObject.metaObjectName,\n            type: metaObject.metaObjectType,\n            id: \"\" + metaObject.metaObjectId\n        };\n\n        if (metaObject.parentMetaObjectId !== undefined && metaObject.parentMetaObjectId !== null) {\n            metaObjectJSON.parent = \"\" + metaObject.parentMetaObjectId;\n        }\n\n        if (metaObject.propertySetIds && metaObject.propertySetIds.length > 0) {\n            metaObjectJSON.propertySetIds = metaObject.propertySetIds;\n        }\n\n        data.metadata.metaObjects.push(metaObjectJSON);\n    }\n\n    // console.log(JSON.stringify(data.metadata, null, \"\\t\"))\n\n    // Geometries\n\n    let matricesIndex = 0;\n\n    for (let geometryIndex = 0; geometryIndex < numGeometries; geometryIndex++) {\n\n        const geometry = geometriesList [geometryIndex];\n\n        const primitiveType\n            = (geometry.primitiveType === \"triangles\")\n            ? (geometry.solid ? 0 : 1)\n            : (geometry.primitiveType === \"points\" ? 2 : 3)\n\n        data.eachGeometryPrimitiveType [geometryIndex] = primitiveType;\n        data.eachGeometryPositionsPortion [geometryIndex] = countPositions;\n        data.eachGeometryNormalsPortion [geometryIndex] = countNormals;\n        data.eachGeometryColorsPortion [geometryIndex] = countColors;\n        data.eachGeometryIndicesPortion [geometryIndex] = countIndices;\n        data.eachGeometryEdgeIndicesPortion [geometryIndex] = countEdgeIndices;\n\n        if (geometry.positionsQuantized) {\n            data.positions.set(geometry.positionsQuantized, countPositions);\n            countPositions += geometry.positionsQuantized.length;\n        }\n        if (geometry.normalsOctEncoded) {\n            data.normals.set(geometry.normalsOctEncoded, countNormals);\n            countNormals += geometry.normalsOctEncoded.length;\n        }\n        if (geometry.colorsCompressed) {\n            data.colors.set(geometry.colorsCompressed, countColors);\n            countColors += geometry.colorsCompressed.length;\n        }\n        if (geometry.indices) {\n            data.indices.set(geometry.indices, countIndices);\n            countIndices += geometry.indices.length;\n        }\n        if (geometry.edgeIndices) {\n            data.edgeIndices.set(geometry.edgeIndices, countEdgeIndices);\n            countEdgeIndices += geometry.edgeIndices.length;\n        }\n    }\n\n    // Meshes\n\n    for (let meshIndex = 0; meshIndex < numMeshes; meshIndex++) {\n\n        const mesh = meshesList [meshIndex];\n\n        if (mesh.geometry.numInstances > 1) {\n\n            data.matrices.set(mesh.matrix, matricesIndex);\n            data.eachMeshMatricesPortion [meshIndex] = matricesIndex;\n\n            matricesIndex += 16;\n        }\n\n        data.eachMeshMaterial[countMeshColors + 0] = Math.floor(mesh.color[0] * 255);\n        data.eachMeshMaterial[countMeshColors + 1] = Math.floor(mesh.color[1] * 255);\n        data.eachMeshMaterial[countMeshColors + 2] = Math.floor(mesh.color[2] * 255);\n        data.eachMeshMaterial[countMeshColors + 3] = Math.floor(mesh.opacity * 255);\n        data.eachMeshMaterial[countMeshColors + 4] = Math.floor(mesh.metallic * 255);\n        data.eachMeshMaterial[countMeshColors + 5] = Math.floor(mesh.roughness * 255);\n\n        countMeshColors += 6;\n    }\n\n    // Entities, geometry instances, and tiles\n\n    let entityIndex = 0;\n    let countEntityMeshesPortion = 0;\n\n    for (let tileIndex = 0; tileIndex < numTiles; tileIndex++) {\n\n        const tile = tilesList [tileIndex];\n        const tileEntities = tile.entities;\n        const numTileEntities = tileEntities.length;\n\n        if (numTileEntities === 0) {\n            continue;\n        }\n\n        data.eachTileEntitiesPortion[tileIndex] = entityIndex;\n\n        const tileAABB = tile.aabb;\n\n        for (let j = 0; j < numTileEntities; j++) {\n\n            const entity = tileEntities[j];\n            const entityMeshes = entity.meshes;\n            const numEntityMeshes = entityMeshes.length;\n\n            for (let k = 0; k < numEntityMeshes; k++) {\n\n                const mesh = entityMeshes[k];\n                const geometry = mesh.geometry;\n                const geometryIndex = geometry.geometryIndex;\n\n                data.eachMeshGeometriesPortion [countEntityMeshesPortion + k] = geometryIndex;\n            }\n\n            data.eachEntityId [entityIndex] = entity.entityId;\n            data.eachEntityMeshesPortion[entityIndex] = countEntityMeshesPortion; // <<<<<<<<<<<<<<<<<<<< Error here? Order/value of countEntityMeshesPortion correct?\n\n            entityIndex++;\n            countEntityMeshesPortion += numEntityMeshes;\n        }\n\n        const tileAABBIndex = tileIndex * 6;\n\n        data.eachTileAABB.set(tileAABB, tileAABBIndex);\n    }\n\n    return data;\n}\n\nfunction deflateData(data) {\n\n    return {\n\n        metadata: pako.deflate(deflateJSON(data.metadata)),\n\n        positions: pako.deflate(data.positions.buffer),\n        normals: pako.deflate(data.normals.buffer),\n        colors: pako.deflate(data.colors.buffer),\n        indices: pako.deflate(data.indices.buffer),\n        edgeIndices: pako.deflate(data.edgeIndices.buffer),\n\n        matrices: pako.deflate(data.matrices.buffer),\n        reusedGeometriesDecodeMatrix: pako.deflate(data.reusedGeometriesDecodeMatrix.buffer),\n\n        eachGeometryPrimitiveType: pako.deflate(data.eachGeometryPrimitiveType.buffer),\n        eachGeometryPositionsPortion: pako.deflate(data.eachGeometryPositionsPortion.buffer),\n        eachGeometryNormalsPortion: pako.deflate(data.eachGeometryNormalsPortion.buffer),\n        eachGeometryColorsPortion: pako.deflate(data.eachGeometryColorsPortion.buffer),\n        eachGeometryIndicesPortion: pako.deflate(data.eachGeometryIndicesPortion.buffer),\n        eachGeometryEdgeIndicesPortion: pako.deflate(data.eachGeometryEdgeIndicesPortion.buffer),\n\n        eachMeshGeometriesPortion: pako.deflate(data.eachMeshGeometriesPortion.buffer),\n        eachMeshMatricesPortion: pako.deflate(data.eachMeshMatricesPortion.buffer),\n        eachMeshMaterial: pako.deflate(data.eachMeshMaterial.buffer),\n\n        eachEntityId: pako.deflate(JSON.stringify(data.eachEntityId)\n            .replace(/[\\u007F-\\uFFFF]/g, function (chr) { // Produce only ASCII-chars, so that the data can be inflated later\n                return \"\\\\u\" + (\"0000\" + chr.charCodeAt(0).toString(16)).substr(-4)\n            })),\n        eachEntityMeshesPortion: pako.deflate(data.eachEntityMeshesPortion.buffer),\n\n        eachTileAABB: pako.deflate(data.eachTileAABB.buffer),\n        eachTileEntitiesPortion: pako.deflate(data.eachTileEntitiesPortion.buffer)\n    };\n}\n\nfunction deflateJSON(strings) {\n    return JSON.stringify(strings)\n        .replace(/[\\u007F-\\uFFFF]/g, function (chr) { // Produce only ASCII-chars, so that the data can be inflated later\n            return \"\\\\u\" + (\"0000\" + chr.charCodeAt(0).toString(16)).substr(-4)\n        });\n}\n\nfunction createArrayBuffer(deflatedData) {\n\n    return toArrayBuffer([\n\n        deflatedData.metadata,\n\n        deflatedData.positions,\n        deflatedData.normals,\n        deflatedData.colors,\n        deflatedData.indices,\n        deflatedData.edgeIndices,\n\n        deflatedData.matrices,\n        deflatedData.reusedGeometriesDecodeMatrix,\n\n        deflatedData.eachGeometryPrimitiveType,\n        deflatedData.eachGeometryPositionsPortion,\n        deflatedData.eachGeometryNormalsPortion,\n        deflatedData.eachGeometryColorsPortion,\n        deflatedData.eachGeometryIndicesPortion,\n        deflatedData.eachGeometryEdgeIndicesPortion,\n\n        deflatedData.eachMeshGeometriesPortion,\n        deflatedData.eachMeshMatricesPortion,\n        deflatedData.eachMeshMaterial,\n\n        deflatedData.eachEntityId,\n        deflatedData.eachEntityMeshesPortion,\n\n        deflatedData.eachTileAABB,\n        deflatedData.eachTileEntitiesPortion\n    ]);\n}\n\nfunction toArrayBuffer(elements) {\n    const indexData = new Uint32Array(elements.length + 2);\n    indexData[0] = XKT_VERSION;\n    indexData [1] = elements.length;  // Stored Data 1.1: number of stored elements\n    let dataLen = 0;    // Stored Data 1.2: length of stored elements\n    for (let i = 0, len = elements.length; i < len; i++) {\n        const element = elements[i];\n        const elementsize = element.length;\n        indexData[i + 2] = elementsize;\n        dataLen += elementsize;\n    }\n    const indexBuf = new Uint8Array(indexData.buffer);\n    const dataArray = new Uint8Array(indexBuf.length + dataLen);\n    dataArray.set(indexBuf);\n    let offset = indexBuf.length;\n    for (let i = 0, len = elements.length; i < len; i++) {     // Stored Data 2: the elements themselves\n        const element = elements[i];\n        dataArray.set(element, offset);\n        offset += element.length;\n    }\n    return dataArray.buffer;\n}\n\nexport {writeXKTModelToArrayBuffer};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 245,
    "kind": "variable",
    "name": "pako",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~pako",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 246,
    "kind": "variable",
    "name": "XKT_VERSION",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~XKT_VERSION",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 247,
    "kind": "function",
    "name": "getModelData",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~getModelData",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "params": [
      {
        "name": "xktModel",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 248,
    "kind": "function",
    "name": "deflateData",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~deflateData",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 309,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"metadata\": *, \"positions\": *, \"normals\": *, \"colors\": *, \"indices\": *, \"edgeIndices\": *, \"matrices\": *, \"reusedGeometriesDecodeMatrix\": *, \"eachGeometryPrimitiveType\": *, \"eachGeometryPositionsPortion\": *, \"eachGeometryNormalsPortion\": *, \"eachGeometryColorsPortion\": *, \"eachGeometryIndicesPortion\": *, \"eachGeometryEdgeIndicesPortion\": *, \"eachMeshGeometriesPortion\": *, \"eachMeshMatricesPortion\": *, \"eachMeshMaterial\": *, \"eachEntityId\": *, \"eachEntityMeshesPortion\": *, \"eachTileAABB\": *, \"eachTileEntitiesPortion\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 249,
    "kind": "function",
    "name": "deflateJSON",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~deflateJSON",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 346,
    "undocument": true,
    "params": [
      {
        "name": "strings",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 250,
    "kind": "function",
    "name": "createArrayBuffer",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~createArrayBuffer",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 353,
    "undocument": true,
    "params": [
      {
        "name": "deflatedData",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 251,
    "kind": "function",
    "name": "toArrayBuffer",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~toArrayBuffer",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 387,
    "undocument": true,
    "params": [
      {
        "name": "elements",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 252,
    "kind": "function",
    "name": "writeXKTModelToArrayBuffer",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~writeXKTModelToArrayBuffer",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": "{writeXKTModelToArrayBuffer}",
    "description": "Writes an {@link XKTModel} to an {@link ArrayBuffer}.",
    "lineNumber": 17,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ArrayBuffer} The {@link ArrayBuffer}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "xktModel",
        "description": "The {@link XKTModel}."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ArrayBuffer"
      ],
      "spread": false,
      "description": "The {@link ArrayBuffer}."
    }
  },
  {
    "__docId__": 253,
    "kind": "file",
    "name": "src/XKT_INFO.js",
    "content": "/**\n * @desc Provides info on the XKT generated by xeokit-convert.\n */\nconst XKT_INFO = {\n\n    /**\n     * The XKT version generated by xeokit-convert.\n     *\n     * This is the XKT version that's modeled by {@link XKTModel}, serialized\n     * by {@link writeXKTModelToArrayBuffer}, and written by {@link convert2xkt}.\n     *\n     * * Current XKT version: **9**\n     * * [XKT format specs](https://github.com/xeokit/xeokit-convert/blob/main/specs/index.md)\n     *\n     * @property xktVersion\n     * @type {number}\n     */\n    xktVersion: 9\n};\n\nexport {XKT_INFO};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/XKT_INFO.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 254,
    "kind": "variable",
    "name": "XKT_INFO",
    "memberof": "src/XKT_INFO.js",
    "static": true,
    "longname": "src/XKT_INFO.js~XKT_INFO",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKT_INFO.js",
    "importStyle": "{XKT_INFO}",
    "description": "Provides info on the XKT generated by xeokit-convert.",
    "lineNumber": 4,
    "type": {
      "types": [
        "{\"xktVersion\": number}"
      ]
    }
  },
  {
    "__docId__": 255,
    "kind": "file",
    "name": "src/convert2xkt.js",
    "content": "import {parseMetaModelIntoXKTModel} from \"./parsers/parseMetaModelIntoXKTModel.js\";\nimport {parseCityJSONIntoXKTModel} from \"./parsers/parseCityJSONIntoXKTModel.js\";\nimport {parseGLTFIntoXKTModel} from \"./parsers/parseGLTFIntoXKTModel.js\";\nimport {parseIFCIntoXKTModel} from \"./parsers/parseIFCIntoXKTModel.js\";\nimport {parseLASIntoXKTModel} from \"./parsers/parseLASIntoXKTModel.js\";\nimport {parsePCDIntoXKTModel} from \"./parsers/parsePCDIntoXKTModel.js\";\nimport {parsePLYIntoXKTModel} from \"./parsers/parsePLYIntoXKTModel.js\";\nimport {parseSTLIntoXKTModel} from \"./parsers/parseSTLIntoXKTModel.js\";\nimport {parse3DXMLIntoXKTModel} from \"./parsers/parse3DXMLIntoXKTModel.js\";\nimport {writeXKTModelToArrayBuffer} from \"./XKTModel/writeXKTModelToArrayBuffer.js\";\nimport {XKTModel} from \"./XKTModel/XKTModel.js\";\nimport {XKT_INFO} from \"./XKT_INFO.js\";\n\nconst fs = require('fs');\nconst DOMParser = require('xmldom').DOMParser;\n\n/**\n * Converts model files into xeokit's native XKT format.\n *\n * Supported source formats are: IFC, CityJSON, 3DXML, glTF, LAZ and LAS.\n *\n * ## Usage\n *\n * ````javascript\n * const convert2xkt = require(\"@xeokit/xeokit-convert/dist/convert2xkt.cjs.js\");\n * const fs = require('fs');\n *\n * convert2xkt({\n *      sourceData: fs.readFileSync(\"rme_advanced_sample_project.ifc\"),\n *      outputXKT: (xtkArrayBuffer) => {\n *          fs.writeFileSync(\"rme_advanced_sample_project.ifc.xkt\", xtkArrayBuffer);\n *      }\n *  }).then(() => {\n *      console.log(\"Converted.\");\n *  }, (errMsg) => {\n *      console.error(\"Conversion failed: \" + errMsg)\n *  });\n ````\n * @param {Object} params Conversion parameters.\n * @param {String} [params.source] Path to source file. Alternative to ````sourceData````.\n * @param {ArrayBuffer|JSON} [params.sourceData] Source file data. Alternative to ````source````.\n * @param {String} [params.sourceFormat] Format of source file/data. Always needed with ````sourceData````, but not normally needed with ````source````, because convert2xkt will determine the format automatically from the file extension of ````source````.\n * @param {ArrayBuffer|JSON} [params.metaModelData] Source file data. Overrides metadata from ````metaModelSource````, ````sourceData```` and ````source````.\n * @param {String} [params.metaModelSource] Path to source metaModel file. Overrides metadata from ````sourceData```` and ````source````. Overridden by ````metaModelData````.\n * @param {String} [params.output] Path to destination XKT file. Directories on this path are automatically created if not existing.\n * @param {Function} [params.outputXKTModel] Callback to collect the ````XKTModel```` that is internally build by this method.\n * @param {Function} [params.outputXKT] Callback to collect XKT file data.\n * @param {String[]} [params.includeTypes] Option to only convert objects of these types.\n * @param {String[]} [params.excludeTypes] Option to never convert objects of these types.\n * @param {Object} [stats] Collects conversion statistics. Statistics are attached to this object if provided.\n * @param {Function} [params.outputStats] Callback to collect statistics.\n * @param {Boolean} [params.rotateX=false] Whether to rotate the model 90 degrees about the X axis to make the Y axis \"up\", if necessary. Applies to CityJSON and LAS/LAZ models.\n * @param {Function} [params.log] Logging callback.\n * @return {Promise<number>}\n */\nfunction convert2xkt({\n                         source,\n                         sourceData,\n                         sourceFormat,\n                         metaModelSource,\n                         metaModelData,\n                         output,\n                         outputXKTModel,\n                         outputXKT,\n                         includeTypes,\n                         excludeTypes,\n                         stats = {},\n                         outputStats,\n                         rotateX,\n                         log = (msg) => {\n                         }\n                     }) {\n\n    stats.sourceFormat = \"\";\n    stats.schemaVersion = \"\";\n    stats.title = \"\";\n    stats.author = \"\";\n    stats.created = \"\";\n    stats.numMetaObjects = 0;\n    stats.numPropertySets = 0;\n    stats.numTriangles = 0;\n    stats.numVertices = 0;\n    stats.numObjects = 0;\n    stats.numGeometries = 0;\n    stats.sourceSize = 0;\n    stats.xktSize = 0;\n    stats.xktVersion = \"\";\n    stats.compressionRatio = 0;\n    stats.conversionTime = 0;\n    stats.aabb = null;\n\n    return new Promise(function (resolve, reject) {\n\n        const _log = log;\n        log = (msg) => {\n            _log(\"[convert2xkt] \" + msg)\n        }\n\n        if (!source && !sourceData) {\n            reject(\"Argument expected: source or sourceData\");\n            return;\n        }\n\n        if (!sourceFormat && sourceData) {\n            reject(\"Argument expected: sourceFormat is required with sourceData\");\n            return;\n        }\n\n        if (!output && !outputXKTModel && !outputXKT) {\n            reject(\"Argument expected: output, outputXKTModel or outputXKT\");\n            return;\n        }\n\n        if (source) {\n            log('Reading input file: ' + source);\n        }\n\n        const startTime = new Date();\n\n        const ext = sourceFormat || source.split('.').pop();\n\n        if (!sourceData) {\n            try {\n                sourceData = fs.readFileSync(source);\n            } catch (err) {\n                reject(err);\n                return;\n            }\n        }\n\n        const sourceFileSizeBytes = sourceData.byteLength;\n\n        log(\"Input file size: \" + (sourceFileSizeBytes / 1000).toFixed(2) + \" kB\");\n\n        if (!metaModelData && metaModelSource) {\n            log('Reading input metadata file: ' + metaModelSource);\n            try {\n                const metaModelFileData = fs.readFileSync(metaModelSource);\n                metaModelData = JSON.parse(metaModelFileData);\n            } catch (err) {\n                reject(err);\n                return;\n            }\n        }\n\n        log(\"Converting...\");\n\n        const xktModel = new XKTModel();\n\n        if (metaModelData) {\n\n            parseMetaModelIntoXKTModel({metaModelData, xktModel}).then(\n                () => {\n                    convertForFormat();\n                },\n                (errMsg) => {\n                    reject(errMsg);\n                });\n        } else {\n            convertForFormat();\n        }\n\n        function convertForFormat() {\n\n            switch (ext) {\n                case \"json\":\n                    convert(parseCityJSONIntoXKTModel, {\n                        data: JSON.parse(sourceData),\n                        xktModel,\n                        stats,\n                        rotateX,\n                        log\n                    });\n                    break;\n\n                case \"gltf\":\n                    const gltfBasePath = source ? getBasePath(source) : \"\";\n                    convert(parseGLTFIntoXKTModel, {\n                        data: JSON.parse(sourceData),\n                        metaModelData,\n                        xktModel,\n                        getAttachment: async (name) => {\n                            return fs.readFileSync(gltfBasePath + name);\n                        },\n                        stats,\n                        log\n                    });\n                    break;\n\n                case \"ifc\":\n                    convert(parseIFCIntoXKTModel, {\n                        data: sourceData,\n                        xktModel,\n                        wasmPath: \"./\",\n                        includeTypes,\n                        excludeTypes,\n                        stats,\n                        log\n                    });\n                    break;\n\n                case \"laz\":\n                    convert(parseLASIntoXKTModel, {\n                        data: sourceData,\n                        xktModel,\n                        stats,\n                        rotateX,\n                        log\n                    });\n                    break;\n\n                case \"las\":\n                    convert(parseLASIntoXKTModel, {\n                        data: sourceData,\n                        xktModel,\n                        stats,\n                        log\n                    });\n                    break;\n\n                case \"pcd\":\n                    convert(parsePCDIntoXKTModel, {\n                        data: sourceData,\n                        xktModel,\n                        stats,\n                        log\n                    });\n                    break;\n\n                case \"ply\":\n                    convert(parsePLYIntoXKTModel, {\n                        data: sourceData,\n                        xktModel,\n                        stats,\n                        log\n                    });\n                    break;\n\n                case \"stl\":\n                    convert(parseSTLIntoXKTModel, {\n                        data: sourceData,\n                        xktModel,\n                        stats,\n                        log\n                    });\n                    break;\n\n                case \"3dxml\":\n                    const domParser = new DOMParser();\n                    convert(parse3DXMLIntoXKTModel, {\n                        data: sourceData,\n                        domParser,\n                        xktModel,\n                        stats,\n                        log\n                    });\n                    break;\n\n                default:\n                    reject('Error: unsupported source format: \"${ext}\".');\n                    return;\n            }\n        }\n\n        function convert(parser, converterParams) {\n\n            parser(converterParams).then(() => {\n\n                xktModel.createDefaultMetaObjects();\n\n                xktModel.finalize();\n\n                const xktArrayBuffer = writeXKTModelToArrayBuffer(xktModel);\n                const xktContent = Buffer.from(xktArrayBuffer);\n\n                const targetFileSizeBytes = xktArrayBuffer.byteLength;\n\n                stats.sourceSize = (sourceFileSizeBytes / 1000).toFixed(2);\n                stats.xktSize = (targetFileSizeBytes / 1000).toFixed(2);\n                stats.xktVersion = XKT_INFO.xktVersion;\n                stats.compressionRatio = (sourceFileSizeBytes / targetFileSizeBytes).toFixed(2);\n                stats.conversionTime = ((new Date() - startTime) / 1000.0).toFixed(2);\n                stats.aabb = xktModel.aabb;\n                log(\"Converted to: XKT v9\");\n                if (includeTypes) {\n                    log(\"Include types: \" + (includeTypes ? includeTypes : \"(include all)\"));\n                }\n                if (excludeTypes) {\n                    log(\"Exclude types: \" + (excludeTypes ? excludeTypes : \"(exclude none)\"));\n                }\n                log(\"XKT size: \" + stats.xktSize + \" kB\");\n                log(\"Compression ratio: \" + stats.compressionRatio);\n                log(\"Conversion time: \" + stats.conversionTime + \" s\");\n                log(\"Converted metaobjects: \" + stats.numMetaObjects);\n                log(\"Converted property sets: \" + stats.numPropertySets);\n                log(\"Converted drawable objects: \" + stats.numObjects);\n                log(\"Converted geometries: \" + stats.numGeometries);\n                log(\"Converted triangles: \" + stats.numTriangles);\n                log(\"Converted vertices: \" + stats.numVertices);\n\n                if (output) {\n                    const outputDir = getBasePath(output).trim();\n                    if (outputDir !== \"\" && !fs.existsSync(outputDir)) {\n                        fs.mkdirSync(outputDir, {recursive: true});\n                    }\n                    log('Writing XKT file: ' + output);\n                    fs.writeFileSync(output, xktContent);\n                }\n\n                if (outputXKTModel) {\n                    outputXKTModel(xktModel);\n                }\n\n                if (outputXKT) {\n                    outputXKT(xktContent);\n                }\n\n                if (outputStats) {\n                    outputStats(stats);\n                }\n\n                resolve();\n\n            }, (err) => {\n                reject(err);\n            });\n        }\n    });\n}\n\nfunction getBasePath(src) {\n    const i = src.lastIndexOf(\"/\");\n    return (i !== 0) ? src.substring(0, i + 1) : \"\";\n}\n\nexport default convert2xkt;",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/convert2xkt.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 256,
    "kind": "function",
    "name": "getBasePath",
    "memberof": "src/convert2xkt.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/convert2xkt.js~getBasePath",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/convert2xkt.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 331,
    "undocument": true,
    "params": [
      {
        "name": "src",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 257,
    "kind": "function",
    "name": "convert2xkt",
    "memberof": "src/convert2xkt.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/convert2xkt.js~convert2xkt",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/convert2xkt.js",
    "importStyle": "convert2xkt",
    "description": "Converts model files into xeokit's native XKT format.\n\nSupported source formats are: IFC, CityJSON, 3DXML, glTF, LAZ and LAS.\n\n## Usage\n\n````javascript\nconst convert2xkt = require(\"@xeokit/xeokit-convert/dist/convert2xkt.cjs.js\");\nconst fs = require('fs');\n\nconvert2xkt({\n     sourceData: fs.readFileSync(\"rme_advanced_sample_project.ifc\"),\n     outputXKT: (xtkArrayBuffer) => {\n         fs.writeFileSync(\"rme_advanced_sample_project.ifc.xkt\", xtkArrayBuffer);\n     }\n }).then(() => {\n     console.log(\"Converted.\");\n }, (errMsg) => {\n     console.error(\"Conversion failed: \" + errMsg)\n });\n````",
    "lineNumber": 56,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Conversion parameters."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "params.source",
        "description": "Path to source file. Alternative to ````sourceData````."
      },
      {
        "nullable": null,
        "types": [
          "ArrayBuffer",
          "JSON"
        ],
        "spread": false,
        "optional": true,
        "name": "params.sourceData",
        "description": "Source file data. Alternative to ````source````."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "params.sourceFormat",
        "description": "Format of source file/data. Always needed with ````sourceData````, but not normally needed with ````source````, because convert2xkt will determine the format automatically from the file extension of ````source````."
      },
      {
        "nullable": null,
        "types": [
          "ArrayBuffer",
          "JSON"
        ],
        "spread": false,
        "optional": true,
        "name": "params.metaModelData",
        "description": "Source file data. Overrides metadata from ````metaModelSource````, ````sourceData```` and ````source````."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "params.metaModelSource",
        "description": "Path to source metaModel file. Overrides metadata from ````sourceData```` and ````source````. Overridden by ````metaModelData````."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "params.output",
        "description": "Path to destination XKT file. Directories on this path are automatically created if not existing."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.outputXKTModel",
        "description": "Callback to collect the ````XKTModel```` that is internally build by this method."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.outputXKT",
        "description": "Callback to collect XKT file data."
      },
      {
        "nullable": null,
        "types": [
          "String[]"
        ],
        "spread": false,
        "optional": true,
        "name": "params.includeTypes",
        "description": "Option to only convert objects of these types."
      },
      {
        "nullable": null,
        "types": [
          "String[]"
        ],
        "spread": false,
        "optional": true,
        "name": "params.excludeTypes",
        "description": "Option to never convert objects of these types."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "stats",
        "description": "Collects conversion statistics. Statistics are attached to this object if provided."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.outputStats",
        "description": "Callback to collect statistics."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "params.rotateX",
        "description": "Whether to rotate the model 90 degrees about the X axis to make the Y axis \"up\", if necessary. Applies to CityJSON and LAS/LAZ models."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.log",
        "description": "Logging callback."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<number>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 258,
    "kind": "file",
    "name": "src/geometryBuilders/buildBoxGeometry.js",
    "content": "/**\n * @desc Creates box-shaped triangle mesh geometry arrays.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a box-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildBoxGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const box = buildBoxGeometry({\n *     primitiveType: \"triangles\" // or \"lines\"\n *     center: [0,0,0],\n *     xSize: 1,  // Half-size on each axis\n *     ySize: 1,\n *     zSize: 1\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"boxGeometry\",\n *      primitiveType: box.primitiveType,\n *      positions: box.positions,\n *      normals: box.normals,\n *      indices: box.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redBoxMesh\",\n *      geometryId: \"boxGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n * const xktEntity = xktModel.createEntity({\n *      entityId: \"redBox\",\n *      meshIds: [\"redBoxMesh\"]\n *  });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildBoxGeometry\n * @param {*} [cfg] Configs\n * @param {Number[]} [cfg.center]  3D point indicating the center position.\n * @param {Number} [cfg.xSize=1.0]  Half-size on the X-axis.\n * @param {Number} [cfg.ySize=1.0]  Half-size on the Y-axis.\n * @param {Number} [cfg.zSize=1.0]  Half-size on the Z-axis.\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildBoxGeometry(cfg = {}) {\n\n    let xSize = cfg.xSize || 1;\n    if (xSize < 0) {\n        console.error(\"negative xSize not allowed - will invert\");\n        xSize *= -1;\n    }\n\n    let ySize = cfg.ySize || 1;\n    if (ySize < 0) {\n        console.error(\"negative ySize not allowed - will invert\");\n        ySize *= -1;\n    }\n\n    let zSize = cfg.zSize || 1;\n    if (zSize < 0) {\n        console.error(\"negative zSize not allowed - will invert\");\n        zSize *= -1;\n    }\n\n    const center = cfg.center;\n    const centerX = center ? center[0] : 0;\n    const centerY = center ? center[1] : 0;\n    const centerZ = center ? center[2] : 0;\n\n    const xmin = -xSize + centerX;\n    const ymin = -ySize + centerY;\n    const zmin = -zSize + centerZ;\n    const xmax = xSize + centerX;\n    const ymax = ySize + centerY;\n    const zmax = zSize + centerZ;\n\n    return {\n\n        primitiveType: \"triangles\",\n\n        // The vertices - eight for our cube, each\n        // one spanning three array elements for X,Y and Z\n\n        positions: [\n\n            // v0-v1-v2-v3 front\n            xmax, ymax, zmax,\n            xmin, ymax, zmax,\n            xmin, ymin, zmax,\n            xmax, ymin, zmax,\n\n            // v0-v3-v4-v1 right\n            xmax, ymax, zmax,\n            xmax, ymin, zmax,\n            xmax, ymin, zmin,\n            xmax, ymax, zmin,\n\n            // v0-v1-v6-v1 top\n            xmax, ymax, zmax,\n            xmax, ymax, zmin,\n            xmin, ymax, zmin,\n            xmin, ymax, zmax,\n\n            // v1-v6-v7-v2 left\n            xmin, ymax, zmax,\n            xmin, ymax, zmin,\n            xmin, ymin, zmin,\n            xmin, ymin, zmax,\n\n            // v7-v4-v3-v2 bottom\n            xmin, ymin, zmin,\n            xmax, ymin, zmin,\n            xmax, ymin, zmax,\n            xmin, ymin, zmax,\n\n            // v4-v7-v6-v1 back\n            xmax, ymin, zmin,\n            xmin, ymin, zmin,\n            xmin, ymax, zmin,\n            xmax, ymax, zmin\n        ],\n\n        // Normal vectors, one for each vertex\n        normals: [\n\n            // v0-v1-v2-v3 front\n            0, 0, 1,\n            0, 0, 1,\n            0, 0, 1,\n            0, 0, 1,\n\n            // v0-v3-v4-v5 right\n            1, 0, 0,\n            1, 0, 0,\n            1, 0, 0,\n            1, 0, 0,\n\n            // v0-v5-v6-v1 top\n            0, 1, 0,\n            0, 1, 0,\n            0, 1, 0,\n            0, 1, 0,\n\n            // v1-v6-v7-v2 left\n            -1, 0, 0,\n            -1, 0, 0,\n            -1, 0, 0,\n            -1, 0, 0,\n\n            // v7-v4-v3-v2 bottom\n            0, -1, 0,\n            0, -1, 0,\n            0, -1, 0,\n            0, -1, 0,\n\n            // v4-v7-v6-v5 back\n            0, 0, -1,\n            0, 0, -1,\n            0, 0, -1,\n            0, 0, -1\n        ],\n\n        // UV coords\n        uv: [\n\n            // v0-v1-v2-v3 front\n            1, 0,\n            0, 0,\n            0, 1,\n            1, 1,\n\n            // v0-v3-v4-v1 right\n            0, 0,\n            0, 1,\n            1, 1,\n            1, 0,\n\n            // v0-v1-v6-v1 top\n            1, 1,\n            1, 0,\n            0, 0,\n            0, 1,\n\n            // v1-v6-v7-v2 left\n            1, 0,\n            0, 0,\n            0, 1,\n            1, 1,\n\n            // v7-v4-v3-v2 bottom\n            0, 1,\n            1, 1,\n            1, 0,\n            0, 0,\n\n            // v4-v7-v6-v1 back\n            0, 1,\n            1, 1,\n            1, 0,\n            0, 0\n        ],\n\n        // Indices - these organise the\n        // positions and uv texture coordinates\n        // into geometric primitives in accordance\n        // with the \"primitive\" parameter,\n        // in this case a set of three indices\n        // for each triangle.\n        //\n        // Note that each triangle is specified\n        // in counter-clockwise winding order.\n        //\n        // You can specify them in clockwise\n        // order if you configure the Modes\n        // node's frontFace flag as \"cw\", instead of\n        // the default \"ccw\".\n        indices: [\n            0, 1, 2,\n            0, 2, 3,\n            // front\n            4, 5, 6,\n            4, 6, 7,\n            // right\n            8, 9, 10,\n            8, 10, 11,\n            // top\n            12, 13, 14,\n            12, 14, 15,\n            // left\n            16, 17, 18,\n            16, 18, 19,\n            // bottom\n            20, 21, 22,\n            20, 22, 23\n        ]\n    };\n}\n\nexport {buildBoxGeometry};\n",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/geometryBuilders/buildBoxGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 259,
    "kind": "function",
    "name": "buildBoxGeometry",
    "memberof": "src/geometryBuilders/buildBoxGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildBoxGeometry.js~buildBoxGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/geometryBuilders/buildBoxGeometry.js",
    "importStyle": "{buildBoxGeometry}",
    "description": "Creates box-shaped triangle mesh geometry arrays.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a box-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildBoxGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst box = buildBoxGeometry({\n    primitiveType: \"triangles\" // or \"lines\"\n    center: [0,0,0],\n    xSize: 1,  // Half-size on each axis\n    ySize: 1,\n    zSize: 1\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"boxGeometry\",\n     primitiveType: box.primitiveType,\n     positions: box.positions,\n     normals: box.normals,\n     indices: box.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redBoxMesh\",\n     geometryId: \"boxGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redBox\",\n     meshIds: [\"redBoxMesh\"]\n });\n\nxktModel.finalize();\n````",
    "lineNumber": 55,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildBoxGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.center",
        "description": "3D point indicating the center position."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1.0",
        "defaultRaw": 1,
        "name": "cfg.xSize",
        "description": "Half-size on the X-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1.0",
        "defaultRaw": 1,
        "name": "cfg.ySize",
        "description": "Half-size on the Y-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1.0",
        "defaultRaw": 1,
        "name": "cfg.zSize",
        "description": "Half-size on the Z-axis."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 260,
    "kind": "file",
    "name": "src/geometryBuilders/buildBoxLinesGeometry.js",
    "content": "/**\n * @desc Creates box-shaped line segment geometry arrays.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a box-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildBoxLinesGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const box = buildBoxLinesGeometry({\n *     center: [0,0,0],\n *     xSize: 1,  // Half-size on each axis\n *     ySize: 1,\n *     zSize: 1\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"boxGeometry\",\n *      primitiveType: box.primitiveType, // \"lines\"\n *      positions: box.positions,\n *      normals: box.normals,\n *      indices: box.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redBoxMesh\",\n *      geometryId: \"boxGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n * const xktEntity = xktModel.createEntity({\n *      entityId: \"redBox\",\n *      meshIds: [\"redBoxMesh\"]\n *  });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildBoxLinesGeometry\n * @param {*} [cfg] Configs\n * @param {Number[]} [cfg.center]  3D point indicating the center position.\n * @param {Number} [cfg.xSize=1.0]  Half-size on the X-axis.\n * @param {Number} [cfg.ySize=1.0]  Half-size on the Y-axis.\n * @param {Number} [cfg.zSize=1.0]  Half-size on the Z-axis.\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildBoxLinesGeometry(cfg = {}) {\n\n    let xSize = cfg.xSize || 1;\n    if (xSize < 0) {\n        console.error(\"negative xSize not allowed - will invert\");\n        xSize *= -1;\n    }\n\n    let ySize = cfg.ySize || 1;\n    if (ySize < 0) {\n        console.error(\"negative ySize not allowed - will invert\");\n        ySize *= -1;\n    }\n\n    let zSize = cfg.zSize || 1;\n    if (zSize < 0) {\n        console.error(\"negative zSize not allowed - will invert\");\n        zSize *= -1;\n    }\n\n    const center = cfg.center;\n    const centerX = center ? center[0] : 0;\n    const centerY = center ? center[1] : 0;\n    const centerZ = center ? center[2] : 0;\n\n    const xmin = -xSize + centerX;\n    const ymin = -ySize + centerY;\n    const zmin = -zSize + centerZ;\n    const xmax = xSize + centerX;\n    const ymax = ySize + centerY;\n    const zmax = zSize + centerZ;\n\n    return {\n        primitiveType: \"lines\",\n        positions: [\n            xmin, ymin, zmin,\n            xmin, ymin, zmax,\n            xmin, ymax, zmin,\n            xmin, ymax, zmax,\n            xmax, ymin, zmin,\n            xmax, ymin, zmax,\n            xmax, ymax, zmin,\n            xmax, ymax, zmax\n        ],\n        indices: [\n            0, 1,\n            1, 3,\n            3, 2,\n            2, 0,\n            4, 5,\n            5, 7,\n            7, 6,\n            6, 4,\n            0, 4,\n            1, 5,\n            2, 6,\n            3, 7\n        ]\n    }\n}\n\nexport {buildBoxLinesGeometry};\n",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/geometryBuilders/buildBoxLinesGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 261,
    "kind": "function",
    "name": "buildBoxLinesGeometry",
    "memberof": "src/geometryBuilders/buildBoxLinesGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildBoxLinesGeometry.js~buildBoxLinesGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/geometryBuilders/buildBoxLinesGeometry.js",
    "importStyle": "{buildBoxLinesGeometry}",
    "description": "Creates box-shaped line segment geometry arrays.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a box-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildBoxLinesGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst box = buildBoxLinesGeometry({\n    center: [0,0,0],\n    xSize: 1,  // Half-size on each axis\n    ySize: 1,\n    zSize: 1\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"boxGeometry\",\n     primitiveType: box.primitiveType, // \"lines\"\n     positions: box.positions,\n     normals: box.normals,\n     indices: box.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redBoxMesh\",\n     geometryId: \"boxGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redBox\",\n     meshIds: [\"redBoxMesh\"]\n });\n\nxktModel.finalize();\n````",
    "lineNumber": 54,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildBoxLinesGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.center",
        "description": "3D point indicating the center position."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1.0",
        "defaultRaw": 1,
        "name": "cfg.xSize",
        "description": "Half-size on the X-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1.0",
        "defaultRaw": 1,
        "name": "cfg.ySize",
        "description": "Half-size on the Y-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1.0",
        "defaultRaw": 1,
        "name": "cfg.zSize",
        "description": "Half-size on the Z-axis."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 262,
    "kind": "file",
    "name": "src/geometryBuilders/buildCylinderGeometry.js",
    "content": "/**\n * @desc Creates cylinder-shaped geometry arrays.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a cylinder-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildCylinderGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const cylinder = buildCylinderGeometry({\n *      center: [0,0,0],\n *      radiusTop: 2.0,\n *      radiusBottom: 2.0,\n *      height: 5.0,\n *      radialSegments: 20,\n *      heightSegments: 1,\n *      openEnded: false\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"cylinderGeometry\",\n *      primitiveType: cylinder.primitiveType,\n *      positions: cylinder.positions,\n *      normals: cylinder.normals,\n *      indices: cylinder.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redCylinderMesh\",\n *      geometryId: \"cylinderGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n * const xktEntity = xktModel.createEntity({\n *      entityId: \"redCylinder\",\n *      meshIds: [\"redCylinderMesh\"]\n *  });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildCylinderGeometry\n * @param {*} [cfg] Configs\n * @param {Number[]} [cfg.center] 3D point indicating the center position.\n * @param {Number} [cfg.radiusTop=1]  Radius of top.\n * @param {Number} [cfg.radiusBottom=1]  Radius of bottom.\n * @param {Number} [cfg.height=1] Height.\n * @param {Number} [cfg.radialSegments=60]  Number of horizontal segments.\n * @param {Number} [cfg.heightSegments=1]  Number of vertical segments.\n * @param {Boolean} [cfg.openEnded=false]  Whether or not the cylinder has solid caps on the ends.\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildCylinderGeometry(cfg = {}) {\n\n    let radiusTop = cfg.radiusTop || 1;\n    if (radiusTop < 0) {\n        console.error(\"negative radiusTop not allowed - will invert\");\n        radiusTop *= -1;\n    }\n\n    let radiusBottom = cfg.radiusBottom || 1;\n    if (radiusBottom < 0) {\n        console.error(\"negative radiusBottom not allowed - will invert\");\n        radiusBottom *= -1;\n    }\n\n    let height = cfg.height || 1;\n    if (height < 0) {\n        console.error(\"negative height not allowed - will invert\");\n        height *= -1;\n    }\n\n    let radialSegments = cfg.radialSegments || 32;\n    if (radialSegments < 0) {\n        console.error(\"negative radialSegments not allowed - will invert\");\n        radialSegments *= -1;\n    }\n    if (radialSegments < 3) {\n        radialSegments = 3;\n    }\n\n    let heightSegments = cfg.heightSegments || 1;\n    if (heightSegments < 0) {\n        console.error(\"negative heightSegments not allowed - will invert\");\n        heightSegments *= -1;\n    }\n    if (heightSegments < 1) {\n        heightSegments = 1;\n    }\n\n    const openEnded = !!cfg.openEnded;\n\n    let center = cfg.center;\n    const centerX = center ? center[0] : 0;\n    const centerY = center ? center[1] : 0;\n    const centerZ = center ? center[2] : 0;\n\n    const heightHalf = height / 2;\n    const heightLength = height / heightSegments;\n    const radialAngle = (2.0 * Math.PI / radialSegments);\n    const radialLength = 1.0 / radialSegments;\n    //var nextRadius = this._radiusBottom;\n    const radiusChange = (radiusTop - radiusBottom) / heightSegments;\n\n    const positions = [];\n    const normals = [];\n    const uvs = [];\n    const indices = [];\n\n    let h;\n    let i;\n\n    let x;\n    let z;\n\n    let currentRadius;\n    let currentHeight;\n\n    let first;\n    let second;\n\n    let startIndex;\n    let tu;\n    let tv;\n\n    // create vertices\n    const normalY = (90.0 - (Math.atan(height / (radiusBottom - radiusTop))) * 180 / Math.PI) / 90.0;\n\n    for (h = 0; h <= heightSegments; h++) {\n        currentRadius = radiusTop - h * radiusChange;\n        currentHeight = heightHalf - h * heightLength;\n\n        for (i = 0; i <= radialSegments; i++) {\n            x = Math.sin(i * radialAngle);\n            z = Math.cos(i * radialAngle);\n\n            normals.push(currentRadius * x);\n            normals.push(normalY); //todo\n            normals.push(currentRadius * z);\n\n            uvs.push((i * radialLength));\n            uvs.push(h * 1 / heightSegments);\n\n            positions.push((currentRadius * x) + centerX);\n            positions.push((currentHeight) + centerY);\n            positions.push((currentRadius * z) + centerZ);\n        }\n    }\n\n    // create faces\n    for (h = 0; h < heightSegments; h++) {\n        for (i = 0; i <= radialSegments; i++) {\n\n            first = h * (radialSegments + 1) + i;\n            second = first + radialSegments;\n\n            indices.push(first);\n            indices.push(second);\n            indices.push(second + 1);\n\n            indices.push(first);\n            indices.push(second + 1);\n            indices.push(first + 1);\n        }\n    }\n\n    // create top cap\n    if (!openEnded && radiusTop > 0) {\n        startIndex = (positions.length / 3);\n\n        // top center\n        normals.push(0.0);\n        normals.push(1.0);\n        normals.push(0.0);\n\n        uvs.push(0.5);\n        uvs.push(0.5);\n\n        positions.push(0 + centerX);\n        positions.push(heightHalf + centerY);\n        positions.push(0 + centerZ);\n\n        // top triangle fan\n        for (i = 0; i <= radialSegments; i++) {\n            x = Math.sin(i * radialAngle);\n            z = Math.cos(i * radialAngle);\n            tu = (0.5 * Math.sin(i * radialAngle)) + 0.5;\n            tv = (0.5 * Math.cos(i * radialAngle)) + 0.5;\n\n            normals.push(radiusTop * x);\n            normals.push(1.0);\n            normals.push(radiusTop * z);\n\n            uvs.push(tu);\n            uvs.push(tv);\n\n            positions.push((radiusTop * x) + centerX);\n            positions.push((heightHalf) + centerY);\n            positions.push((radiusTop * z) + centerZ);\n        }\n\n        for (i = 0; i < radialSegments; i++) {\n            center = startIndex;\n            first = startIndex + 1 + i;\n\n            indices.push(first);\n            indices.push(first + 1);\n            indices.push(center);\n        }\n    }\n\n    // create bottom cap\n    if (!openEnded && radiusBottom > 0) {\n\n        startIndex = (positions.length / 3);\n\n        // top center\n        normals.push(0.0);\n        normals.push(-1.0);\n        normals.push(0.0);\n\n        uvs.push(0.5);\n        uvs.push(0.5);\n\n        positions.push(0 + centerX);\n        positions.push(0 - heightHalf + centerY);\n        positions.push(0 + centerZ);\n\n        // top triangle fan\n        for (i = 0; i <= radialSegments; i++) {\n\n            x = Math.sin(i * radialAngle);\n            z = Math.cos(i * radialAngle);\n\n            tu = (0.5 * Math.sin(i * radialAngle)) + 0.5;\n            tv = (0.5 * Math.cos(i * radialAngle)) + 0.5;\n\n            normals.push(radiusBottom * x);\n            normals.push(-1.0);\n            normals.push(radiusBottom * z);\n\n            uvs.push(tu);\n            uvs.push(tv);\n\n            positions.push((radiusBottom * x) + centerX);\n            positions.push((0 - heightHalf) + centerY);\n            positions.push((radiusBottom * z) + centerZ);\n        }\n\n        for (i = 0; i < radialSegments; i++) {\n\n            center = startIndex;\n            first = startIndex + 1 + i;\n\n            indices.push(center);\n            indices.push(first + 1);\n            indices.push(first);\n        }\n    }\n\n    return  {\n        primitiveType: \"triangles\",\n        positions: positions,\n        normals: normals,\n        uv: uvs,\n        indices: indices\n    };\n}\n\n\nexport {buildCylinderGeometry};\n",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/geometryBuilders/buildCylinderGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 263,
    "kind": "function",
    "name": "buildCylinderGeometry",
    "memberof": "src/geometryBuilders/buildCylinderGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildCylinderGeometry.js~buildCylinderGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/geometryBuilders/buildCylinderGeometry.js",
    "importStyle": "{buildCylinderGeometry}",
    "description": "Creates cylinder-shaped geometry arrays.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a cylinder-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildCylinderGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst cylinder = buildCylinderGeometry({\n     center: [0,0,0],\n     radiusTop: 2.0,\n     radiusBottom: 2.0,\n     height: 5.0,\n     radialSegments: 20,\n     heightSegments: 1,\n     openEnded: false\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"cylinderGeometry\",\n     primitiveType: cylinder.primitiveType,\n     positions: cylinder.positions,\n     normals: cylinder.normals,\n     indices: cylinder.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redCylinderMesh\",\n     geometryId: \"cylinderGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redCylinder\",\n     meshIds: [\"redCylinderMesh\"]\n });\n\nxktModel.finalize();\n````",
    "lineNumber": 60,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildCylinderGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.center",
        "description": "3D point indicating the center position."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.radiusTop",
        "description": "Radius of top."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.radiusBottom",
        "description": "Radius of bottom."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.height",
        "description": "Height."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "60",
        "defaultRaw": 60,
        "name": "cfg.radialSegments",
        "description": "Number of horizontal segments."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.heightSegments",
        "description": "Number of vertical segments."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "cfg.openEnded",
        "description": "Whether or not the cylinder has solid caps on the ends."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 264,
    "kind": "file",
    "name": "src/geometryBuilders/buildGridGeometry.js",
    "content": "/**\n * @desc Creates grid-shaped geometry arrays..\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a grid-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildGridGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const grid = buildGridGeometry({\n *      size: 1000,\n *      divisions: 500\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"gridGeometry\",\n *      primitiveType: grid.primitiveType, // Will be \"lines\"\n *      positions: grid.positions,\n *      indices: grid.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redGridMesh\",\n *      geometryId: \"gridGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n * const xktEntity = xktModel.createEntity({\n *      entityId: \"redGrid\",\n *      meshIds: [\"redGridMesh\"]\n * });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildGridGeometry\n * @param {*} [cfg] Configs\n * @param {Number} [cfg.size=1] Dimension on the X and Z-axis.\n * @param {Number} [cfg.divisions=1] Number of divisions on X and Z axis..\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildGridGeometry(cfg = {}) {\n\n    let size = cfg.size || 1;\n    if (size < 0) {\n        console.error(\"negative size not allowed - will invert\");\n        size *= -1;\n    }\n\n    let divisions = cfg.divisions || 1;\n    if (divisions < 0) {\n        console.error(\"negative divisions not allowed - will invert\");\n        divisions *= -1;\n    }\n    if (divisions < 1) {\n        divisions = 1;\n    }\n\n    size = size || 10;\n    divisions = divisions || 10;\n\n    const step = size / divisions;\n    const halfSize = size / 2;\n\n    const positions = [];\n    const indices = [];\n    let l = 0;\n\n    for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {\n\n        positions.push(-halfSize);\n        positions.push(0);\n        positions.push(k);\n\n        positions.push(halfSize);\n        positions.push(0);\n        positions.push(k);\n\n        positions.push(k);\n        positions.push(0);\n        positions.push(-halfSize);\n\n        positions.push(k);\n        positions.push(0);\n        positions.push(halfSize);\n\n        indices.push(l++);\n        indices.push(l++);\n        indices.push(l++);\n        indices.push(l++);\n    }\n\n    return {\n        primitiveType: \"lines\",\n        positions: positions,\n        indices: indices\n    };\n}\n\n\nexport {buildGridGeometry};\n",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/geometryBuilders/buildGridGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 265,
    "kind": "function",
    "name": "buildGridGeometry",
    "memberof": "src/geometryBuilders/buildGridGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildGridGeometry.js~buildGridGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/geometryBuilders/buildGridGeometry.js",
    "importStyle": "{buildGridGeometry}",
    "description": "Creates grid-shaped geometry arrays..\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a grid-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildGridGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst grid = buildGridGeometry({\n     size: 1000,\n     divisions: 500\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"gridGeometry\",\n     primitiveType: grid.primitiveType, // Will be \"lines\"\n     positions: grid.positions,\n     indices: grid.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redGridMesh\",\n     geometryId: \"gridGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redGrid\",\n     meshIds: [\"redGridMesh\"]\n});\n\nxktModel.finalize();\n````",
    "lineNumber": 49,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildGridGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.size",
        "description": "Dimension on the X and Z-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.divisions",
        "description": "Number of divisions on X and Z axis.."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 266,
    "kind": "file",
    "name": "src/geometryBuilders/buildPlaneGeometry.js",
    "content": "/**\n * @desc Creates plane-shaped geometry arrays.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a plane-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildPlaneGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const plane = buildPlaneGeometry({\n *      center: [0,0,0],\n *      xSize: 2,\n *      zSize: 2,\n *      xSegments: 10,\n *      zSegments: 10\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"planeGeometry\",\n *      primitiveType: plane.primitiveType, // Will be \"triangles\"\n *      positions: plane.positions,\n *      normals: plane.normals,\n *      indices: plane.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redPlaneMesh\",\n *      geometryId: \"planeGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n * const xktEntity = xktModel.createEntity({\n *      entityId: \"redPlane\",\n *      meshIds: [\"redPlaneMesh\"]\n *  });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildPlaneGeometry\n * @param {*} [cfg] Configs\n * @param {Number[]} [cfg.center]  3D point indicating the center position.\n * @param {Number} [cfg.xSize=1] Dimension on the X-axis.\n * @param {Number} [cfg.zSize=1] Dimension on the Z-axis.\n * @param {Number} [cfg.xSegments=1] Number of segments on the X-axis.\n * @param {Number} [cfg.zSegments=1] Number of segments on the Z-axis.\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildPlaneGeometry(cfg = {}) {\n\n    let xSize = cfg.xSize || 1;\n    if (xSize < 0) {\n        console.error(\"negative xSize not allowed - will invert\");\n        xSize *= -1;\n    }\n\n    let zSize = cfg.zSize || 1;\n    if (zSize < 0) {\n        console.error(\"negative zSize not allowed - will invert\");\n        zSize *= -1;\n    }\n\n    let xSegments = cfg.xSegments || 1;\n    if (xSegments < 0) {\n        console.error(\"negative xSegments not allowed - will invert\");\n        xSegments *= -1;\n    }\n    if (xSegments < 1) {\n        xSegments = 1;\n    }\n\n    let zSegments = cfg.xSegments || 1;\n    if (zSegments < 0) {\n        console.error(\"negative zSegments not allowed - will invert\");\n        zSegments *= -1;\n    }\n    if (zSegments < 1) {\n        zSegments = 1;\n    }\n\n    const center = cfg.center;\n    const centerX = center ? center[0] : 0;\n    const centerY = center ? center[1] : 0;\n    const centerZ = center ? center[2] : 0;\n\n    const halfWidth = xSize / 2;\n    const halfHeight = zSize / 2;\n\n    const planeX = Math.floor(xSegments) || 1;\n    const planeZ = Math.floor(zSegments) || 1;\n\n    const planeX1 = planeX + 1;\n    const planeZ1 = planeZ + 1;\n\n    const segmentWidth = xSize / planeX;\n    const segmentHeight = zSize / planeZ;\n\n    const positions = new Float32Array(planeX1 * planeZ1 * 3);\n    const normals = new Float32Array(planeX1 * planeZ1 * 3);\n    const uvs = new Float32Array(planeX1 * planeZ1 * 2);\n\n    let offset = 0;\n    let offset2 = 0;\n\n    let iz;\n    let ix;\n    let x;\n    let a;\n    let b;\n    let c;\n    let d;\n\n    for (iz = 0; iz < planeZ1; iz++) {\n\n        const z = iz * segmentHeight - halfHeight;\n\n        for (ix = 0; ix < planeX1; ix++) {\n\n            x = ix * segmentWidth - halfWidth;\n\n            positions[offset] = x + centerX;\n            positions[offset + 1] = centerY;\n            positions[offset + 2] = -z + centerZ;\n\n            normals[offset + 2] = -1;\n\n            uvs[offset2] = (ix) / planeX;\n            uvs[offset2 + 1] = ((planeZ - iz) / planeZ);\n\n            offset += 3;\n            offset2 += 2;\n        }\n    }\n\n    offset = 0;\n\n    const indices = new ((positions.length / 3) > 65535 ? Uint32Array : Uint16Array)(planeX * planeZ * 6);\n\n    for (iz = 0; iz < planeZ; iz++) {\n\n        for (ix = 0; ix < planeX; ix++) {\n\n            a = ix + planeX1 * iz;\n            b = ix + planeX1 * (iz + 1);\n            c = (ix + 1) + planeX1 * (iz + 1);\n            d = (ix + 1) + planeX1 * iz;\n\n            indices[offset] = d;\n            indices[offset + 1] = b;\n            indices[offset + 2] = a;\n\n            indices[offset + 3] = d;\n            indices[offset + 4] = c;\n            indices[offset + 5] = b;\n\n            offset += 6;\n        }\n    }\n\n    return {\n        primitiveType: \"triangles\",\n        positions: positions,\n        normals: normals,\n        uv: uvs,\n        indices: indices\n    };\n}\n\nexport {buildPlaneGeometry};\n",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/geometryBuilders/buildPlaneGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 267,
    "kind": "function",
    "name": "buildPlaneGeometry",
    "memberof": "src/geometryBuilders/buildPlaneGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildPlaneGeometry.js~buildPlaneGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/geometryBuilders/buildPlaneGeometry.js",
    "importStyle": "{buildPlaneGeometry}",
    "description": "Creates plane-shaped geometry arrays.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a plane-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildPlaneGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst plane = buildPlaneGeometry({\n     center: [0,0,0],\n     xSize: 2,\n     zSize: 2,\n     xSegments: 10,\n     zSegments: 10\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"planeGeometry\",\n     primitiveType: plane.primitiveType, // Will be \"triangles\"\n     positions: plane.positions,\n     normals: plane.normals,\n     indices: plane.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redPlaneMesh\",\n     geometryId: \"planeGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redPlane\",\n     meshIds: [\"redPlaneMesh\"]\n });\n\nxktModel.finalize();\n````",
    "lineNumber": 56,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildPlaneGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.center",
        "description": "3D point indicating the center position."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.xSize",
        "description": "Dimension on the X-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.zSize",
        "description": "Dimension on the Z-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.xSegments",
        "description": "Number of segments on the X-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.zSegments",
        "description": "Number of segments on the Z-axis."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 268,
    "kind": "file",
    "name": "src/geometryBuilders/buildSphereGeometry.js",
    "content": "/**\n * @desc Creates sphere-shaped geometry arrays.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a sphere-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildSphereGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const sphere = buildSphereGeometry({\n *      center: [0,0,0],\n *      radius: 1.5,\n *      heightSegments: 60,\n *      widthSegments: 60\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"sphereGeometry\",\n *      primitiveType: sphere.primitiveType, // Will be \"triangles\"\n *      positions: sphere.positions,\n *      normals: sphere.normals,\n *      indices: sphere.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redSphereMesh\",\n *      geometryId: \"sphereGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n *const xktEntity = xktModel.createEntity({\n *      entityId: \"redSphere\",\n *      meshIds: [\"redSphereMesh\"]\n *  });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildSphereGeometry\n * @param {*} [cfg] Configs\n * @param {Number[]} [cfg.center]  3D point indicating the center position.\n * @param {Number} [cfg.radius=1]  Radius.\n * @param {Number} [cfg.heightSegments=24] Number of latitudinal bands.\n * @param  {Number} [cfg.widthSegments=18] Number of longitudinal bands.\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildSphereGeometry(cfg = {}) {\n\n    const lod = cfg.lod || 1;\n\n    const centerX = cfg.center ? cfg.center[0] : 0;\n    const centerY = cfg.center ? cfg.center[1] : 0;\n    const centerZ = cfg.center ? cfg.center[2] : 0;\n\n    let radius = cfg.radius || 1;\n    if (radius < 0) {\n        console.error(\"negative radius not allowed - will invert\");\n        radius *= -1;\n    }\n\n    let heightSegments = cfg.heightSegments || 18;\n    if (heightSegments < 0) {\n        console.error(\"negative heightSegments not allowed - will invert\");\n        heightSegments *= -1;\n    }\n    heightSegments = Math.floor(lod * heightSegments);\n    if (heightSegments < 18) {\n        heightSegments = 18;\n    }\n\n    let widthSegments = cfg.widthSegments || 18;\n    if (widthSegments < 0) {\n        console.error(\"negative widthSegments not allowed - will invert\");\n        widthSegments *= -1;\n    }\n    widthSegments = Math.floor(lod * widthSegments);\n    if (widthSegments < 18) {\n        widthSegments = 18;\n    }\n\n    const positions = [];\n    const normals = [];\n    const uvs = [];\n    const indices = [];\n\n    let i;\n    let j;\n\n    let theta;\n    let sinTheta;\n    let cosTheta;\n\n    let phi;\n    let sinPhi;\n    let cosPhi;\n\n    let x;\n    let y;\n    let z;\n\n    let u;\n    let v;\n\n    let first;\n    let second;\n\n    for (i = 0; i <= heightSegments; i++) {\n\n        theta = i * Math.PI / heightSegments;\n        sinTheta = Math.sin(theta);\n        cosTheta = Math.cos(theta);\n\n        for (j = 0; j <= widthSegments; j++) {\n\n            phi = j * 2 * Math.PI / widthSegments;\n            sinPhi = Math.sin(phi);\n            cosPhi = Math.cos(phi);\n\n            x = cosPhi * sinTheta;\n            y = cosTheta;\n            z = sinPhi * sinTheta;\n            u = 1.0 - j / widthSegments;\n            v = i / heightSegments;\n\n            normals.push(x);\n            normals.push(y);\n            normals.push(z);\n\n            uvs.push(u);\n            uvs.push(v);\n\n            positions.push(centerX + radius * x);\n            positions.push(centerY + radius * y);\n            positions.push(centerZ + radius * z);\n        }\n    }\n\n    for (i = 0; i < heightSegments; i++) {\n        for (j = 0; j < widthSegments; j++) {\n\n            first = (i * (widthSegments + 1)) + j;\n            second = first + widthSegments + 1;\n\n            indices.push(first + 1);\n            indices.push(second + 1);\n            indices.push(second);\n            indices.push(first + 1);\n            indices.push(second);\n            indices.push(first);\n        }\n    }\n\n    return {\n        primitiveType: \"triangles\",\n        positions: positions,\n        normals: normals,\n        uv: uvs,\n        indices: indices\n    };\n}\n\nexport {buildSphereGeometry};\n",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/geometryBuilders/buildSphereGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 269,
    "kind": "function",
    "name": "buildSphereGeometry",
    "memberof": "src/geometryBuilders/buildSphereGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildSphereGeometry.js~buildSphereGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/geometryBuilders/buildSphereGeometry.js",
    "importStyle": "{buildSphereGeometry}",
    "description": "Creates sphere-shaped geometry arrays.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a sphere-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildSphereGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst sphere = buildSphereGeometry({\n     center: [0,0,0],\n     radius: 1.5,\n     heightSegments: 60,\n     widthSegments: 60\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"sphereGeometry\",\n     primitiveType: sphere.primitiveType, // Will be \"triangles\"\n     positions: sphere.positions,\n     normals: sphere.normals,\n     indices: sphere.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redSphereMesh\",\n     geometryId: \"sphereGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redSphere\",\n     meshIds: [\"redSphereMesh\"]\n });\n\nxktModel.finalize();\n````",
    "lineNumber": 54,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildSphereGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.center",
        "description": "3D point indicating the center position."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.radius",
        "description": "Radius."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "24",
        "defaultRaw": 24,
        "name": "cfg.heightSegments",
        "description": "Number of latitudinal bands."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "18",
        "defaultRaw": 18,
        "name": "cfg.widthSegments",
        "description": "Number of longitudinal bands."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 270,
    "kind": "file",
    "name": "src/geometryBuilders/buildTorusGeometry.js",
    "content": "import {math} from '../lib/math.js';\n\n/**\n * @desc Creates torus-shaped geometry arrays.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a torus-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildTorusGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const torus = buildTorusGeometry({\n *      center: [0,0,0],\n *      radius: 1.0,\n *      tube: 0.5,\n *      radialSegments: 32,\n *      tubeSegments: 24,\n *      arc: Math.PI * 2.0\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"torusGeometry\",\n *      primitiveType: torus.primitiveType, // Will be \"triangles\"\n *      positions: torus.positions,\n *      normals: torus.normals,\n *      indices: torus.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redTorusMesh\",\n *      geometryId: \"torusGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n * const xktEntity = xktModel.createEntity({\n *      entityId: \"redTorus\",\n *      meshIds: [\"redTorusMesh\"]\n * });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildTorusGeometry\n * @param {*} [cfg] Configs\n * @param {Number[]} [cfg.center] 3D point indicating the center position.\n * @param {Number} [cfg.radius=1] The overall radius.\n * @param {Number} [cfg.tube=0.3] The tube radius.\n * @param {Number} [cfg.radialSegments=32] The number of radial segments.\n * @param {Number} [cfg.tubeSegments=24] The number of tubular segments.\n * @param {Number} [cfg.arc=Math.PI*0.5] The length of the arc in radians, where Math.PI*2 is a closed torus.\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildTorusGeometry(cfg = {}) {\n\n    let radius = cfg.radius || 1;\n    if (radius < 0) {\n        console.error(\"negative radius not allowed - will invert\");\n        radius *= -1;\n    }\n    radius *= 0.5;\n\n    let tube = cfg.tube || 0.3;\n    if (tube < 0) {\n        console.error(\"negative tube not allowed - will invert\");\n        tube *= -1;\n    }\n\n    let radialSegments = cfg.radialSegments || 32;\n    if (radialSegments < 0) {\n        console.error(\"negative radialSegments not allowed - will invert\");\n        radialSegments *= -1;\n    }\n    if (radialSegments < 4) {\n        radialSegments = 4;\n    }\n\n    let tubeSegments = cfg.tubeSegments || 24;\n    if (tubeSegments < 0) {\n        console.error(\"negative tubeSegments not allowed - will invert\");\n        tubeSegments *= -1;\n    }\n    if (tubeSegments < 4) {\n        tubeSegments = 4;\n    }\n\n    let arc = cfg.arc || Math.PI * 2;\n    if (arc < 0) {\n        console.warn(\"negative arc not allowed - will invert\");\n        arc *= -1;\n    }\n    if (arc > 360) {\n        arc = 360;\n    }\n\n    const center = cfg.center;\n    let centerX = center ? center[0] : 0;\n    let centerY = center ? center[1] : 0;\n    const centerZ = center ? center[2] : 0;\n\n    const positions = [];\n    const normals = [];\n    const uvs = [];\n    const indices = [];\n\n    let u;\n    let v;\n    let x;\n    let y;\n    let z;\n    let vec;\n\n    let i;\n    let j;\n\n    for (j = 0; j <= tubeSegments; j++) {\n        for (i = 0; i <= radialSegments; i++) {\n\n            u = i / radialSegments * arc;\n            v = 0.785398 + (j / tubeSegments * Math.PI * 2);\n\n            centerX = radius * Math.cos(u);\n            centerY = radius * Math.sin(u);\n\n            x = (radius + tube * Math.cos(v)) * Math.cos(u);\n            y = (radius + tube * Math.cos(v)) * Math.sin(u);\n            z = tube * Math.sin(v);\n\n            positions.push(x + centerX);\n            positions.push(y + centerY);\n            positions.push(z + centerZ);\n\n            uvs.push(1 - (i / radialSegments));\n            uvs.push((j / tubeSegments));\n\n            vec = math.normalizeVec3(math.subVec3([x, y, z], [centerX, centerY, centerZ], []), []);\n\n            normals.push(vec[0]);\n            normals.push(vec[1]);\n            normals.push(vec[2]);\n        }\n    }\n\n    let a;\n    let b;\n    let c;\n    let d;\n\n    for (j = 1; j <= tubeSegments; j++) {\n        for (i = 1; i <= radialSegments; i++) {\n\n            a = (radialSegments + 1) * j + i - 1;\n            b = (radialSegments + 1) * (j - 1) + i - 1;\n            c = (radialSegments + 1) * (j - 1) + i;\n            d = (radialSegments + 1) * j + i;\n\n            indices.push(a);\n            indices.push(b);\n            indices.push(c);\n\n            indices.push(c);\n            indices.push(d);\n            indices.push(a);\n        }\n    }\n\n    return {\n        primitiveType: \"triangles\",\n        positions: positions,\n        normals: normals,\n        uv: uvs,\n        indices: indices\n    };\n}\n\nexport {buildTorusGeometry};\n",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/geometryBuilders/buildTorusGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 271,
    "kind": "function",
    "name": "buildTorusGeometry",
    "memberof": "src/geometryBuilders/buildTorusGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildTorusGeometry.js~buildTorusGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/geometryBuilders/buildTorusGeometry.js",
    "importStyle": "{buildTorusGeometry}",
    "description": "Creates torus-shaped geometry arrays.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a torus-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildTorusGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst torus = buildTorusGeometry({\n     center: [0,0,0],\n     radius: 1.0,\n     tube: 0.5,\n     radialSegments: 32,\n     tubeSegments: 24,\n     arc: Math.PI * 2.0\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"torusGeometry\",\n     primitiveType: torus.primitiveType, // Will be \"triangles\"\n     positions: torus.positions,\n     normals: torus.normals,\n     indices: torus.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redTorusMesh\",\n     geometryId: \"torusGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redTorus\",\n     meshIds: [\"redTorusMesh\"]\n});\n\nxktModel.finalize();\n````",
    "lineNumber": 60,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildTorusGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.center",
        "description": "3D point indicating the center position."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.radius",
        "description": "The overall radius."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0.3",
        "defaultRaw": 0.3,
        "name": "cfg.tube",
        "description": "The tube radius."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "32",
        "defaultRaw": 32,
        "name": "cfg.radialSegments",
        "description": "The number of radial segments."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "24",
        "defaultRaw": 24,
        "name": "cfg.tubeSegments",
        "description": "The number of tubular segments."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Math.PI*0.5",
        "defaultRaw": "Math.PI*0.5",
        "name": "cfg.arc",
        "description": "The length of the arc in radians, where Math.PI*2 is a closed torus."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 272,
    "kind": "file",
    "name": "src/geometryBuilders/buildVectorTextGeometry.js",
    "content": "const letters = {\n    ' ': {width: 16, points: []},\n    '!': {\n        width: 10, points: [\n            [5, 21],\n            [5, 7],\n            [-1, -1],\n            [5, 2],\n            [4, 1],\n            [5, 0],\n            [6, 1],\n            [5, 2]\n        ]\n    },\n    '\"': {\n        width: 16, points: [\n            [4, 21],\n            [4, 14],\n            [-1, -1],\n            [12, 21],\n            [12, 14]\n        ]\n    },\n    '#': {\n        width: 21, points: [\n            [11, 25],\n            [4, -7],\n            [-1, -1],\n            [17, 25],\n            [10, -7],\n            [-1, -1],\n            [4, 12],\n            [18, 12],\n            [-1, -1],\n            [3, 6],\n            [17, 6]\n        ]\n    },\n    '$': {\n        width: 20, points: [\n            [8, 25],\n            [8, -4],\n            [-1, -1],\n            [12, 25],\n            [12, -4],\n            [-1, -1],\n            [17, 18],\n            [15, 20],\n            [12, 21],\n            [8, 21],\n            [5, 20],\n            [3, 18],\n            [3, 16],\n            [4, 14],\n            [5, 13],\n            [7, 12],\n            [13, 10],\n            [15, 9],\n            [16, 8],\n            [17, 6],\n            [17, 3],\n            [15, 1],\n            [12, 0],\n            [8, 0],\n            [5, 1],\n            [3, 3]\n        ]\n    },\n    '%': {\n        width: 24, points: [\n            [21, 21],\n            [3, 0],\n            [-1, -1],\n            [8, 21],\n            [10, 19],\n            [10, 17],\n            [9, 15],\n            [7, 14],\n            [5, 14],\n            [3, 16],\n            [3, 18],\n            [4, 20],\n            [6, 21],\n            [8, 21],\n            [10, 20],\n            [13, 19],\n            [16, 19],\n            [19, 20],\n            [21, 21],\n            [-1, -1],\n            [17, 7],\n            [15, 6],\n            [14, 4],\n            [14, 2],\n            [16, 0],\n            [18, 0],\n            [20, 1],\n            [21, 3],\n            [21, 5],\n            [19, 7],\n            [17, 7]\n        ]\n    },\n    '&': {\n        width: 26, points: [\n            [23, 12],\n            [23, 13],\n            [22, 14],\n            [21, 14],\n            [20, 13],\n            [19, 11],\n            [17, 6],\n            [15, 3],\n            [13, 1],\n            [11, 0],\n            [7, 0],\n            [5, 1],\n            [4, 2],\n            [3, 4],\n            [3, 6],\n            [4, 8],\n            [5, 9],\n            [12, 13],\n            [13, 14],\n            [14, 16],\n            [14, 18],\n            [13, 20],\n            [11, 21],\n            [9, 20],\n            [8, 18],\n            [8, 16],\n            [9, 13],\n            [11, 10],\n            [16, 3],\n            [18, 1],\n            [20, 0],\n            [22, 0],\n            [23, 1],\n            [23, 2]\n        ]\n    },\n    '\\'': {\n        width: 10, points: [\n            [5, 19],\n            [4, 20],\n            [5, 21],\n            [6, 20],\n            [6, 18],\n            [5, 16],\n            [4, 15]\n        ]\n    },\n    '(': {\n        width: 14, points: [\n            [11, 25],\n            [9, 23],\n            [7, 20],\n            [5, 16],\n            [4, 11],\n            [4, 7],\n            [5, 2],\n            [7, -2],\n            [9, -5],\n            [11, -7]\n        ]\n    },\n    ')': {\n        width: 14, points: [\n            [3, 25],\n            [5, 23],\n            [7, 20],\n            [9, 16],\n            [10, 11],\n            [10, 7],\n            [9, 2],\n            [7, -2],\n            [5, -5],\n            [3, -7]\n        ]\n    },\n    '*': {\n        width: 16, points: [\n            [8, 21],\n            [8, 9],\n            [-1, -1],\n            [3, 18],\n            [13, 12],\n            [-1, -1],\n            [13, 18],\n            [3, 12]\n        ]\n    },\n    '+': {\n        width: 26, points: [\n            [13, 18],\n            [13, 0],\n            [-1, -1],\n            [4, 9],\n            [22, 9]\n        ]\n    },\n    ',': {\n        width: 10, points: [\n            [6, 1],\n            [5, 0],\n            [4, 1],\n            [5, 2],\n            [6, 1],\n            [6, -1],\n            [5, -3],\n            [4, -4]\n        ]\n    },\n    '-': {\n        width: 26, points: [\n            [4, 9],\n            [22, 9]\n        ]\n    },\n    '.': {\n        width: 10, points: [\n            [5, 2],\n            [4, 1],\n            [5, 0],\n            [6, 1],\n            [5, 2]\n        ]\n    },\n    '/': {\n        width: 22, points: [\n            [20, 25],\n            [2, -7]\n        ]\n    },\n    '0': {\n        width: 20, points: [\n            [9, 21],\n            [6, 20],\n            [4, 17],\n            [3, 12],\n            [3, 9],\n            [4, 4],\n            [6, 1],\n            [9, 0],\n            [11, 0],\n            [14, 1],\n            [16, 4],\n            [17, 9],\n            [17, 12],\n            [16, 17],\n            [14, 20],\n            [11, 21],\n            [9, 21]\n        ]\n    },\n    '1': {\n        width: 20, points: [\n            [6, 17],\n            [8, 18],\n            [11, 21],\n            [11, 0]\n        ]\n    },\n    '2': {\n        width: 20, points: [\n            [4, 16],\n            [4, 17],\n            [5, 19],\n            [6, 20],\n            [8, 21],\n            [12, 21],\n            [14, 20],\n            [15, 19],\n            [16, 17],\n            [16, 15],\n            [15, 13],\n            [13, 10],\n            [3, 0],\n            [17, 0]\n        ]\n    },\n    '3': {\n        width: 20, points: [\n            [5, 21],\n            [16, 21],\n            [10, 13],\n            [13, 13],\n            [15, 12],\n            [16, 11],\n            [17, 8],\n            [17, 6],\n            [16, 3],\n            [14, 1],\n            [11, 0],\n            [8, 0],\n            [5, 1],\n            [4, 2],\n            [3, 4]\n        ]\n    },\n    '4': {\n        width: 20, points: [\n            [13, 21],\n            [3, 7],\n            [18, 7],\n            [-1, -1],\n            [13, 21],\n            [13, 0]\n        ]\n    },\n    '5': {\n        width: 20, points: [\n            [15, 21],\n            [5, 21],\n            [4, 12],\n            [5, 13],\n            [8, 14],\n            [11, 14],\n            [14, 13],\n            [16, 11],\n            [17, 8],\n            [17, 6],\n            [16, 3],\n            [14, 1],\n            [11, 0],\n            [8, 0],\n            [5, 1],\n            [4, 2],\n            [3, 4]\n        ]\n    },\n    '6': {\n        width: 20, points: [\n            [16, 18],\n            [15, 20],\n            [12, 21],\n            [10, 21],\n            [7, 20],\n            [5, 17],\n            [4, 12],\n            [4, 7],\n            [5, 3],\n            [7, 1],\n            [10, 0],\n            [11, 0],\n            [14, 1],\n            [16, 3],\n            [17, 6],\n            [17, 7],\n            [16, 10],\n            [14, 12],\n            [11, 13],\n            [10, 13],\n            [7, 12],\n            [5, 10],\n            [4, 7]\n        ]\n    },\n    '7': {\n        width: 20, points: [\n            [17, 21],\n            [7, 0],\n            [-1, -1],\n            [3, 21],\n            [17, 21]\n        ]\n    },\n    '8': {\n        width: 20, points: [\n            [8, 21],\n            [5, 20],\n            [4, 18],\n            [4, 16],\n            [5, 14],\n            [7, 13],\n            [11, 12],\n            [14, 11],\n            [16, 9],\n            [17, 7],\n            [17, 4],\n            [16, 2],\n            [15, 1],\n            [12, 0],\n            [8, 0],\n            [5, 1],\n            [4, 2],\n            [3, 4],\n            [3, 7],\n            [4, 9],\n            [6, 11],\n            [9, 12],\n            [13, 13],\n            [15, 14],\n            [16, 16],\n            [16, 18],\n            [15, 20],\n            [12, 21],\n            [8, 21]\n        ]\n    },\n    '9': {\n        width: 20, points: [\n            [16, 14],\n            [15, 11],\n            [13, 9],\n            [10, 8],\n            [9, 8],\n            [6, 9],\n            [4, 11],\n            [3, 14],\n            [3, 15],\n            [4, 18],\n            [6, 20],\n            [9, 21],\n            [10, 21],\n            [13, 20],\n            [15, 18],\n            [16, 14],\n            [16, 9],\n            [15, 4],\n            [13, 1],\n            [10, 0],\n            [8, 0],\n            [5, 1],\n            [4, 3]\n        ]\n    },\n    ':': {\n        width: 10, points: [\n            [5, 14],\n            [4, 13],\n            [5, 12],\n            [6, 13],\n            [5, 14],\n            [-1, -1],\n            [5, 2],\n            [4, 1],\n            [5, 0],\n            [6, 1],\n            [5, 2]\n        ]\n    },\n    ';': {\n        width: 10, points: [\n            [5, 14],\n            [4, 13],\n            [5, 12],\n            [6, 13],\n            [5, 14],\n            [-1, -1],\n            [6, 1],\n            [5, 0],\n            [4, 1],\n            [5, 2],\n            [6, 1],\n            [6, -1],\n            [5, -3],\n            [4, -4]\n        ]\n    },\n    '<': {\n        width: 24, points: [\n            [20, 18],\n            [4, 9],\n            [20, 0]\n        ]\n    },\n    '=': {\n        width: 26, points: [\n            [4, 12],\n            [22, 12],\n            [-1, -1],\n            [4, 6],\n            [22, 6]\n        ]\n    },\n    '>': {\n        width: 24, points: [\n            [4, 18],\n            [20, 9],\n            [4, 0]\n        ]\n    },\n    '?': {\n        width: 18, points: [\n            [3, 16],\n            [3, 17],\n            [4, 19],\n            [5, 20],\n            [7, 21],\n            [11, 21],\n            [13, 20],\n            [14, 19],\n            [15, 17],\n            [15, 15],\n            [14, 13],\n            [13, 12],\n            [9, 10],\n            [9, 7],\n            [-1, -1],\n            [9, 2],\n            [8, 1],\n            [9, 0],\n            [10, 1],\n            [9, 2]\n        ]\n    },\n    '@': {\n        width: 27, points: [\n            [18, 13],\n            [17, 15],\n            [15, 16],\n            [12, 16],\n            [10, 15],\n            [9, 14],\n            [8, 11],\n            [8, 8],\n            [9, 6],\n            [11, 5],\n            [14, 5],\n            [16, 6],\n            [17, 8],\n            [-1, -1],\n            [12, 16],\n            [10, 14],\n            [9, 11],\n            [9, 8],\n            [10, 6],\n            [11, 5],\n            [-1, -1],\n            [18, 16],\n            [17, 8],\n            [17, 6],\n            [19, 5],\n            [21, 5],\n            [23, 7],\n            [24, 10],\n            [24, 12],\n            [23, 15],\n            [22, 17],\n            [20, 19],\n            [18, 20],\n            [15, 21],\n            [12, 21],\n            [9, 20],\n            [7, 19],\n            [5, 17],\n            [4, 15],\n            [3, 12],\n            [3, 9],\n            [4, 6],\n            [5, 4],\n            [7, 2],\n            [9, 1],\n            [12, 0],\n            [15, 0],\n            [18, 1],\n            [20, 2],\n            [21, 3],\n            [-1, -1],\n            [19, 16],\n            [18, 8],\n            [18, 6],\n            [19, 5]\n        ]\n    },\n    'A': {\n        width: 18, points: [\n            [9, 21],\n            [1, 0],\n            [-1, -1],\n            [9, 21],\n            [17, 0],\n            [-1, -1],\n            [4, 7],\n            [14, 7]\n        ]\n    },\n    'B': {\n        width: 21, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [13, 21],\n            [16, 20],\n            [17, 19],\n            [18, 17],\n            [18, 15],\n            [17, 13],\n            [16, 12],\n            [13, 11],\n            [-1, -1],\n            [4, 11],\n            [13, 11],\n            [16, 10],\n            [17, 9],\n            [18, 7],\n            [18, 4],\n            [17, 2],\n            [16, 1],\n            [13, 0],\n            [4, 0]\n        ]\n    },\n    'C': {\n        width: 21, points: [\n            [18, 16],\n            [17, 18],\n            [15, 20],\n            [13, 21],\n            [9, 21],\n            [7, 20],\n            [5, 18],\n            [4, 16],\n            [3, 13],\n            [3, 8],\n            [4, 5],\n            [5, 3],\n            [7, 1],\n            [9, 0],\n            [13, 0],\n            [15, 1],\n            [17, 3],\n            [18, 5]\n        ]\n    },\n    'D': {\n        width: 21, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [11, 21],\n            [14, 20],\n            [16, 18],\n            [17, 16],\n            [18, 13],\n            [18, 8],\n            [17, 5],\n            [16, 3],\n            [14, 1],\n            [11, 0],\n            [4, 0]\n        ]\n    },\n    'E': {\n        width: 19, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [17, 21],\n            [-1, -1],\n            [4, 11],\n            [12, 11],\n            [-1, -1],\n            [4, 0],\n            [17, 0]\n        ]\n    },\n    'F': {\n        width: 18, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [17, 21],\n            [-1, -1],\n            [4, 11],\n            [12, 11]\n        ]\n    },\n    'G': {\n        width: 21, points: [\n            [18, 16],\n            [17, 18],\n            [15, 20],\n            [13, 21],\n            [9, 21],\n            [7, 20],\n            [5, 18],\n            [4, 16],\n            [3, 13],\n            [3, 8],\n            [4, 5],\n            [5, 3],\n            [7, 1],\n            [9, 0],\n            [13, 0],\n            [15, 1],\n            [17, 3],\n            [18, 5],\n            [18, 8],\n            [-1, -1],\n            [13, 8],\n            [18, 8]\n        ]\n    },\n    'H': {\n        width: 22, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [18, 21],\n            [18, 0],\n            [-1, -1],\n            [4, 11],\n            [18, 11]\n        ]\n    },\n    'I': {\n        width: 8, points: [\n            [4, 21],\n            [4, 0]\n        ]\n    },\n    'J': {\n        width: 16, points: [\n            [12, 21],\n            [12, 5],\n            [11, 2],\n            [10, 1],\n            [8, 0],\n            [6, 0],\n            [4, 1],\n            [3, 2],\n            [2, 5],\n            [2, 7]\n        ]\n    },\n    'K': {\n        width: 21, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [18, 21],\n            [4, 7],\n            [-1, -1],\n            [9, 12],\n            [18, 0]\n        ]\n    },\n    'L': {\n        width: 17, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 0],\n            [16, 0]\n        ]\n    },\n    'M': {\n        width: 24, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [12, 0],\n            [-1, -1],\n            [20, 21],\n            [12, 0],\n            [-1, -1],\n            [20, 21],\n            [20, 0]\n        ]\n    },\n    'N': {\n        width: 22, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [18, 0],\n            [-1, -1],\n            [18, 21],\n            [18, 0]\n        ]\n    },\n    'O': {\n        width: 22, points: [\n            [9, 21],\n            [7, 20],\n            [5, 18],\n            [4, 16],\n            [3, 13],\n            [3, 8],\n            [4, 5],\n            [5, 3],\n            [7, 1],\n            [9, 0],\n            [13, 0],\n            [15, 1],\n            [17, 3],\n            [18, 5],\n            [19, 8],\n            [19, 13],\n            [18, 16],\n            [17, 18],\n            [15, 20],\n            [13, 21],\n            [9, 21]\n        ]\n    },\n    'P': {\n        width: 21, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [13, 21],\n            [16, 20],\n            [17, 19],\n            [18, 17],\n            [18, 14],\n            [17, 12],\n            [16, 11],\n            [13, 10],\n            [4, 10]\n        ]\n    },\n    'Q': {\n        width: 22, points: [\n            [9, 21],\n            [7, 20],\n            [5, 18],\n            [4, 16],\n            [3, 13],\n            [3, 8],\n            [4, 5],\n            [5, 3],\n            [7, 1],\n            [9, 0],\n            [13, 0],\n            [15, 1],\n            [17, 3],\n            [18, 5],\n            [19, 8],\n            [19, 13],\n            [18, 16],\n            [17, 18],\n            [15, 20],\n            [13, 21],\n            [9, 21],\n            [-1, -1],\n            [12, 4],\n            [18, -2]\n        ]\n    },\n    'R': {\n        width: 21, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [13, 21],\n            [16, 20],\n            [17, 19],\n            [18, 17],\n            [18, 15],\n            [17, 13],\n            [16, 12],\n            [13, 11],\n            [4, 11],\n            [-1, -1],\n            [11, 11],\n            [18, 0]\n        ]\n    },\n    'S': {\n        width: 20, points: [\n            [17, 18],\n            [15, 20],\n            [12, 21],\n            [8, 21],\n            [5, 20],\n            [3, 18],\n            [3, 16],\n            [4, 14],\n            [5, 13],\n            [7, 12],\n            [13, 10],\n            [15, 9],\n            [16, 8],\n            [17, 6],\n            [17, 3],\n            [15, 1],\n            [12, 0],\n            [8, 0],\n            [5, 1],\n            [3, 3]\n        ]\n    },\n    'T': {\n        width: 16, points: [\n            [8, 21],\n            [8, 0],\n            [-1, -1],\n            [1, 21],\n            [15, 21]\n        ]\n    },\n    'U': {\n        width: 22, points: [\n            [4, 21],\n            [4, 6],\n            [5, 3],\n            [7, 1],\n            [10, 0],\n            [12, 0],\n            [15, 1],\n            [17, 3],\n            [18, 6],\n            [18, 21]\n        ]\n    },\n    'V': {\n        width: 18, points: [\n            [1, 21],\n            [9, 0],\n            [-1, -1],\n            [17, 21],\n            [9, 0]\n        ]\n    },\n    'W': {\n        width: 24, points: [\n            [2, 21],\n            [7, 0],\n            [-1, -1],\n            [12, 21],\n            [7, 0],\n            [-1, -1],\n            [12, 21],\n            [17, 0],\n            [-1, -1],\n            [22, 21],\n            [17, 0]\n        ]\n    },\n    'X': {\n        width: 20, points: [\n            [3, 21],\n            [17, 0],\n            [-1, -1],\n            [17, 21],\n            [3, 0]\n        ]\n    },\n    'Y': {\n        width: 18, points: [\n            [1, 21],\n            [9, 11],\n            [9, 0],\n            [-1, -1],\n            [17, 21],\n            [9, 11]\n        ]\n    },\n    'Z': {\n        width: 20, points: [\n            [17, 21],\n            [3, 0],\n            [-1, -1],\n            [3, 21],\n            [17, 21],\n            [-1, -1],\n            [3, 0],\n            [17, 0]\n        ]\n    },\n    '[': {\n        width: 14, points: [\n            [4, 25],\n            [4, -7],\n            [-1, -1],\n            [5, 25],\n            [5, -7],\n            [-1, -1],\n            [4, 25],\n            [11, 25],\n            [-1, -1],\n            [4, -7],\n            [11, -7]\n        ]\n    },\n    '\\\\': {\n        width: 14, points: [\n            [0, 21],\n            [14, -3]\n        ]\n    },\n    ']': {\n        width: 14, points: [\n            [9, 25],\n            [9, -7],\n            [-1, -1],\n            [10, 25],\n            [10, -7],\n            [-1, -1],\n            [3, 25],\n            [10, 25],\n            [-1, -1],\n            [3, -7],\n            [10, -7]\n        ]\n    },\n    '^': {\n        width: 16, points: [\n            [6, 15],\n            [8, 18],\n            [10, 15],\n            [-1, -1],\n            [3, 12],\n            [8, 17],\n            [13, 12],\n            [-1, -1],\n            [8, 17],\n            [8, 0]\n        ]\n    },\n    '_': {\n        width: 16, points: [\n            [0, -2],\n            [16, -2]\n        ]\n    },\n    '`': {\n        width: 10, points: [\n            [6, 21],\n            [5, 20],\n            [4, 18],\n            [4, 16],\n            [5, 15],\n            [6, 16],\n            [5, 17]\n        ]\n    },\n    'a': {\n        width: 19, points: [\n            [15, 14],\n            [15, 0],\n            [-1, -1],\n            [15, 11],\n            [13, 13],\n            [11, 14],\n            [8, 14],\n            [6, 13],\n            [4, 11],\n            [3, 8],\n            [3, 6],\n            [4, 3],\n            [6, 1],\n            [8, 0],\n            [11, 0],\n            [13, 1],\n            [15, 3]\n        ]\n    },\n    'b': {\n        width: 19, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 11],\n            [6, 13],\n            [8, 14],\n            [11, 14],\n            [13, 13],\n            [15, 11],\n            [16, 8],\n            [16, 6],\n            [15, 3],\n            [13, 1],\n            [11, 0],\n            [8, 0],\n            [6, 1],\n            [4, 3]\n        ]\n    },\n    'c': {\n        width: 18, points: [\n            [15, 11],\n            [13, 13],\n            [11, 14],\n            [8, 14],\n            [6, 13],\n            [4, 11],\n            [3, 8],\n            [3, 6],\n            [4, 3],\n            [6, 1],\n            [8, 0],\n            [11, 0],\n            [13, 1],\n            [15, 3]\n        ]\n    },\n    'd': {\n        width: 19, points: [\n            [15, 21],\n            [15, 0],\n            [-1, -1],\n            [15, 11],\n            [13, 13],\n            [11, 14],\n            [8, 14],\n            [6, 13],\n            [4, 11],\n            [3, 8],\n            [3, 6],\n            [4, 3],\n            [6, 1],\n            [8, 0],\n            [11, 0],\n            [13, 1],\n            [15, 3]\n        ]\n    },\n    'e': {\n        width: 18, points: [\n            [3, 8],\n            [15, 8],\n            [15, 10],\n            [14, 12],\n            [13, 13],\n            [11, 14],\n            [8, 14],\n            [6, 13],\n            [4, 11],\n            [3, 8],\n            [3, 6],\n            [4, 3],\n            [6, 1],\n            [8, 0],\n            [11, 0],\n            [13, 1],\n            [15, 3]\n        ]\n    },\n    'f': {\n        width: 12, points: [\n            [10, 21],\n            [8, 21],\n            [6, 20],\n            [5, 17],\n            [5, 0],\n            [-1, -1],\n            [2, 14],\n            [9, 14]\n        ]\n    },\n    'g': {\n        width: 19, points: [\n            [15, 14],\n            [15, -2],\n            [14, -5],\n            [13, -6],\n            [11, -7],\n            [8, -7],\n            [6, -6],\n            [-1, -1],\n            [15, 11],\n            [13, 13],\n            [11, 14],\n            [8, 14],\n            [6, 13],\n            [4, 11],\n            [3, 8],\n            [3, 6],\n            [4, 3],\n            [6, 1],\n            [8, 0],\n            [11, 0],\n            [13, 1],\n            [15, 3]\n        ]\n    },\n    'h': {\n        width: 19, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 10],\n            [7, 13],\n            [9, 14],\n            [12, 14],\n            [14, 13],\n            [15, 10],\n            [15, 0]\n        ]\n    },\n    'i': {\n        width: 8, points: [\n            [3, 21],\n            [4, 20],\n            [5, 21],\n            [4, 22],\n            [3, 21],\n            [-1, -1],\n            [4, 14],\n            [4, 0]\n        ]\n    },\n    'j': {\n        width: 10, points: [\n            [5, 21],\n            [6, 20],\n            [7, 21],\n            [6, 22],\n            [5, 21],\n            [-1, -1],\n            [6, 14],\n            [6, -3],\n            [5, -6],\n            [3, -7],\n            [1, -7]\n        ]\n    },\n    'k': {\n        width: 17, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [14, 14],\n            [4, 4],\n            [-1, -1],\n            [8, 8],\n            [15, 0]\n        ]\n    },\n    'l': {\n        width: 8, points: [\n            [4, 21],\n            [4, 0]\n        ]\n    },\n    'm': {\n        width: 30, points: [\n            [4, 14],\n            [4, 0],\n            [-1, -1],\n            [4, 10],\n            [7, 13],\n            [9, 14],\n            [12, 14],\n            [14, 13],\n            [15, 10],\n            [15, 0],\n            [-1, -1],\n            [15, 10],\n            [18, 13],\n            [20, 14],\n            [23, 14],\n            [25, 13],\n            [26, 10],\n            [26, 0]\n        ]\n    },\n    'n': {\n        width: 19, points: [\n            [4, 14],\n            [4, 0],\n            [-1, -1],\n            [4, 10],\n            [7, 13],\n            [9, 14],\n            [12, 14],\n            [14, 13],\n            [15, 10],\n            [15, 0]\n        ]\n    },\n    'o': {\n        width: 19, points: [\n            [8, 14],\n            [6, 13],\n            [4, 11],\n            [3, 8],\n            [3, 6],\n            [4, 3],\n            [6, 1],\n            [8, 0],\n            [11, 0],\n            [13, 1],\n            [15, 3],\n            [16, 6],\n            [16, 8],\n            [15, 11],\n            [13, 13],\n            [11, 14],\n            [8, 14]\n        ]\n    },\n    'p': {\n        width: 19, points: [\n            [4, 14],\n            [4, -7],\n            [-1, -1],\n            [4, 11],\n            [6, 13],\n            [8, 14],\n            [11, 14],\n            [13, 13],\n            [15, 11],\n            [16, 8],\n            [16, 6],\n            [15, 3],\n            [13, 1],\n            [11, 0],\n            [8, 0],\n            [6, 1],\n            [4, 3]\n        ]\n    },\n    'q': {\n        width: 19, points: [\n            [15, 14],\n            [15, -7],\n            [-1, -1],\n            [15, 11],\n            [13, 13],\n            [11, 14],\n            [8, 14],\n            [6, 13],\n            [4, 11],\n            [3, 8],\n            [3, 6],\n            [4, 3],\n            [6, 1],\n            [8, 0],\n            [11, 0],\n            [13, 1],\n            [15, 3]\n        ]\n    },\n    'r': {\n        width: 13, points: [\n            [4, 14],\n            [4, 0],\n            [-1, -1],\n            [4, 8],\n            [5, 11],\n            [7, 13],\n            [9, 14],\n            [12, 14]\n        ]\n    },\n    's': {\n        width: 17, points: [\n            [14, 11],\n            [13, 13],\n            [10, 14],\n            [7, 14],\n            [4, 13],\n            [3, 11],\n            [4, 9],\n            [6, 8],\n            [11, 7],\n            [13, 6],\n            [14, 4],\n            [14, 3],\n            [13, 1],\n            [10, 0],\n            [7, 0],\n            [4, 1],\n            [3, 3]\n        ]\n    },\n    't': {\n        width: 12, points: [\n            [5, 21],\n            [5, 4],\n            [6, 1],\n            [8, 0],\n            [10, 0],\n            [-1, -1],\n            [2, 14],\n            [9, 14]\n        ]\n    },\n    'u': {\n        width: 19, points: [\n            [4, 14],\n            [4, 4],\n            [5, 1],\n            [7, 0],\n            [10, 0],\n            [12, 1],\n            [15, 4],\n            [-1, -1],\n            [15, 14],\n            [15, 0]\n        ]\n    },\n    'v': {\n        width: 16, points: [\n            [2, 14],\n            [8, 0],\n            [-1, -1],\n            [14, 14],\n            [8, 0]\n        ]\n    },\n    'w': {\n        width: 22, points: [\n            [3, 14],\n            [7, 0],\n            [-1, -1],\n            [11, 14],\n            [7, 0],\n            [-1, -1],\n            [11, 14],\n            [15, 0],\n            [-1, -1],\n            [19, 14],\n            [15, 0]\n        ]\n    },\n    'x': {\n        width: 17, points: [\n            [3, 14],\n            [14, 0],\n            [-1, -1],\n            [14, 14],\n            [3, 0]\n        ]\n    },\n    'y': {\n        width: 16, points: [\n            [2, 14],\n            [8, 0],\n            [-1, -1],\n            [14, 14],\n            [8, 0],\n            [6, -4],\n            [4, -6],\n            [2, -7],\n            [1, -7]\n        ]\n    },\n    'z': {\n        width: 17, points: [\n            [14, 14],\n            [3, 0],\n            [-1, -1],\n            [3, 14],\n            [14, 14],\n            [-1, -1],\n            [3, 0],\n            [14, 0]\n        ]\n    },\n    '{': {\n        width: 14, points: [\n            [9, 25],\n            [7, 24],\n            [6, 23],\n            [5, 21],\n            [5, 19],\n            [6, 17],\n            [7, 16],\n            [8, 14],\n            [8, 12],\n            [6, 10],\n            [-1, -1],\n            [7, 24],\n            [6, 22],\n            [6, 20],\n            [7, 18],\n            [8, 17],\n            [9, 15],\n            [9, 13],\n            [8, 11],\n            [4, 9],\n            [8, 7],\n            [9, 5],\n            [9, 3],\n            [8, 1],\n            [7, 0],\n            [6, -2],\n            [6, -4],\n            [7, -6],\n            [-1, -1],\n            [6, 8],\n            [8, 6],\n            [8, 4],\n            [7, 2],\n            [6, 1],\n            [5, -1],\n            [5, -3],\n            [6, -5],\n            [7, -6],\n            [9, -7]\n        ]\n    },\n    '|': {\n        width: 8, points: [\n            [4, 25],\n            [4, -7]\n        ]\n    },\n    '}': {\n        width: 14, points: [\n            [5, 25],\n            [7, 24],\n            [8, 23],\n            [9, 21],\n            [9, 19],\n            [8, 17],\n            [7, 16],\n            [6, 14],\n            [6, 12],\n            [8, 10],\n            [-1, -1],\n            [7, 24],\n            [8, 22],\n            [8, 20],\n            [7, 18],\n            [6, 17],\n            [5, 15],\n            [5, 13],\n            [6, 11],\n            [10, 9],\n            [6, 7],\n            [5, 5],\n            [5, 3],\n            [6, 1],\n            [7, 0],\n            [8, -2],\n            [8, -4],\n            [7, -6],\n            [-1, -1],\n            [8, 8],\n            [6, 6],\n            [6, 4],\n            [7, 2],\n            [8, 1],\n            [9, -1],\n            [9, -3],\n            [8, -5],\n            [7, -6],\n            [5, -7]\n        ]\n    },\n    '~': {\n        width: 24, points: [\n            [3, 6],\n            [3, 8],\n            [4, 11],\n            [6, 12],\n            [8, 12],\n            [10, 11],\n            [14, 8],\n            [16, 7],\n            [18, 7],\n            [20, 8],\n            [21, 10],\n            [-1, -1],\n            [3, 8],\n            [4, 10],\n            [6, 11],\n            [8, 11],\n            [10, 10],\n            [14, 7],\n            [16, 6],\n            [18, 6],\n            [20, 7],\n            [21, 10],\n            [21, 12]\n        ]\n    }\n};\n\n/**\n * @desc Creates wireframe text-shaped geometry arrays.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a text-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildVectorTextGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const text = buildVectorTextGeometry({\n *      origin: [0,0,0],\n *      text: \"On the other side of the screen, it all looked so easy\"\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"textGeometry\",\n *      primitiveType: text.primitiveType, // Will be \"lines\"\n *      positions: text.positions,\n *      indices: text.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redTextMesh\",\n *      geometryId: \"textGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n * const xktEntity = xktModel.createEntity({\n *      entityId: \"redText\",\n *      meshIds: [\"redTextMesh\"]\n *  });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildVectorTextGeometry\n * @param {*} [cfg] Configs\n * @param {Number[]} [cfg.center]  3D point indicating the center position.\n * @param {Number[]} [cfg.origin] 3D point indicating the top left corner.\n * @param {Number} [cfg.size=1] Size of each character.\n * @param {String} [cfg.text=\"\"] The text.\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildVectorTextGeometry(cfg = {}) {\n\n    var origin = cfg.origin || [0, 0, 0];\n    var xOrigin = origin[0];\n    var yOrigin = origin[1];\n    var zOrigin = origin[2];\n    var size = cfg.size || 1;\n\n    var positions = [];\n    var indices = [];\n    var text = (\"\" + cfg.text).trim();\n    var lines = (text || \"\").split(\"\\n\");\n    var countVerts = 0;\n    var y = 0;\n    var x;\n    var str;\n    var len;\n    var c;\n    var mag = 1.0 / 25.0;\n    var penUp;\n    var p1;\n    var p2;\n    var needLine;\n    var pointsLen;\n    var a;\n\n    for (var iLine = 0; iLine < lines.length; iLine++) {\n\n        x = 0;\n        str = lines[iLine];\n        len = str.length;\n\n        for (var i = 0; i < len; i++) {\n\n            c = letters[str.charAt(i)];\n\n            if (c === '\\n') {\n                //alert(\"newline\");\n            }\n\n            if (!c) {\n                continue;\n            }\n\n            penUp = 1;\n            p1 = -1;\n            p2 = -1;\n            needLine = false;\n\n            pointsLen = c.points.length;\n\n            for (var j = 0; j < pointsLen; j++) {\n                a = c.points[j];\n\n                if (a[0] === -1 && a[1] === -1) {\n                    penUp = 1;\n                    needLine = false;\n                    continue;\n                }\n\n                positions.push((x + (a[0] * size) * mag) + xOrigin);\n                positions.push((y + (a[1] * size) * mag) + yOrigin);\n                positions.push(0 + zOrigin);\n\n                if (p1 === -1) {\n                    p1 = countVerts;\n                } else if (p2 === -1) {\n                    p2 = countVerts;\n                } else {\n                    p1 = p2;\n                    p2 = countVerts;\n                }\n                countVerts++;\n\n                if (penUp) {\n                    penUp = false;\n\n                } else {\n                    indices.push(p1);\n                    indices.push(p2);\n                }\n\n                needLine = true;\n            }\n            x += c.width * mag * size;\n\n        }\n        y -= 35 * mag * size;\n    }\n\n    return {\n        primitiveType: \"lines\",\n        positions: positions,\n        indices: indices\n    };\n}\n\n\nexport {buildVectorTextGeometry}\n",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/geometryBuilders/buildVectorTextGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 273,
    "kind": "variable",
    "name": "letters",
    "memberof": "src/geometryBuilders/buildVectorTextGeometry.js",
    "static": true,
    "longname": "src/geometryBuilders/buildVectorTextGeometry.js~letters",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/geometryBuilders/buildVectorTextGeometry.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "type": {
      "types": [
        "{\" \": *, \"!\": *, \"\"\": *, \"#\": *, \"$\": *, \"%\": *, \"&\": *, \"'\": *, \"(\": *, \")\": *, \"*\": *, \"+\": *, \",\": *, \"-\": *, \".\": *, \"/\": *, \"0\": *, \"1\": *, \"2\": *, \"3\": *, \"4\": *, \"5\": *, \"6\": *, \"7\": *, \"8\": *, \"9\": *, \":\": *, \";\": *, \"<\": *, \"=\": *, \">\": *, \"?\": *, \"@\": *, \"A\": *, \"B\": *, \"C\": *, \"D\": *, \"E\": *, \"F\": *, \"G\": *, \"H\": *, \"I\": *, \"J\": *, \"K\": *, \"L\": *, \"M\": *, \"N\": *, \"O\": *, \"P\": *, \"Q\": *, \"R\": *, \"S\": *, \"T\": *, \"U\": *, \"V\": *, \"W\": *, \"X\": *, \"Y\": *, \"Z\": *, \"[\": *, \"\\\": *, \"]\": *, \"^\": *, \"_\": *, \"`\": *, \"a\": *, \"b\": *, \"c\": *, \"d\": *, \"e\": *, \"f\": *, \"g\": *, \"h\": *, \"i\": *, \"j\": *, \"k\": *, \"l\": *, \"m\": *, \"n\": *, \"o\": *, \"p\": *, \"q\": *, \"r\": *, \"s\": *, \"t\": *, \"u\": *, \"v\": *, \"w\": *, \"x\": *, \"y\": *, \"z\": *, \"{\": *, \"|\": *, \"}\": *, \"~\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 274,
    "kind": "function",
    "name": "buildVectorTextGeometry",
    "memberof": "src/geometryBuilders/buildVectorTextGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildVectorTextGeometry.js~buildVectorTextGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/geometryBuilders/buildVectorTextGeometry.js",
    "importStyle": "{buildVectorTextGeometry}",
    "description": "Creates wireframe text-shaped geometry arrays.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a text-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildVectorTextGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst text = buildVectorTextGeometry({\n     origin: [0,0,0],\n     text: \"On the other side of the screen, it all looked so easy\"\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"textGeometry\",\n     primitiveType: text.primitiveType, // Will be \"lines\"\n     positions: text.positions,\n     indices: text.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redTextMesh\",\n     geometryId: \"textGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redText\",\n     meshIds: [\"redTextMesh\"]\n });\n\nxktModel.finalize();\n````",
    "lineNumber": 1625,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildVectorTextGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.center",
        "description": "3D point indicating the center position."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.origin",
        "description": "3D point indicating the top left corner."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.size",
        "description": "Size of each character."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "\"\"",
        "defaultRaw": "",
        "name": "cfg.text",
        "description": "The text."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 275,
    "kind": "file",
    "name": "src/lib/buildFaceNormals.js",
    "content": "import {math} from \"./math.js\";\n\n/**\n * Builds face-aligned vertex normal vectors from positions and indices.\n *\n * @private\n */\nfunction buildFaceNormals(positions, indices, normals) {\n\n    const a = math.vec3();\n    const b = math.vec3();\n    const c = math.vec3();\n\n    const normVec = math.vec3();\n\n    for (let i = 0, len = indices.length; i < len; i += 3) {\n\n        const j0 = indices[i];\n        const j1 = indices[i + 1];\n        const j2 = indices[i + 2];\n\n        a[0] = positions[j0 * 3];\n        a[1] = positions[j0 * 3 + 1];\n        a[2] = positions[j0 * 3 + 2];\n\n        b[0] = positions[j1 * 3];\n        b[1] = positions[j1 * 3 + 1];\n        b[2] = positions[j1 * 3 + 2];\n\n        c[0] = positions[j2 * 3];\n        c[1] = positions[j2 * 3 + 1];\n        c[2] = positions[j2 * 3 + 2];\n\n        triangleNormal(a,b,c, normVec);\n\n        normals[j0 * 3 + 0] = normVec[0];\n        normals[j0 * 3 + 1] = normVec[1];\n        normals[j0 * 3 + 2] = normVec[2];\n\n        normals[j1 * 3 + 0] = normVec[0];\n        normals[j1 * 3 + 1] = normVec[1];\n        normals[j1 * 3 + 2] = normVec[2];\n\n        normals[j2 * 3 + 0] = normVec[0];\n        normals[j2 * 3 + 1] = normVec[1];\n        normals[j2 * 3 + 2] = normVec[2];\n    }\n}\n\nfunction triangleNormal(a, b, c, normal = math.vec3()) {\n    const p1x = b[0] - a[0];\n    const p1y = b[1] - a[1];\n    const p1z = b[2] - a[2];\n\n    const p2x = c[0] - a[0];\n    const p2y = c[1] - a[1];\n    const p2z = c[2] - a[2];\n\n    const p3x = p1y * p2z - p1z * p2y;\n    const p3y = p1z * p2x - p1x * p2z;\n    const p3z = p1x * p2y - p1y * p2x;\n\n    const mag = Math.sqrt(p3x * p3x + p3y * p3y + p3z * p3z);\n    if (mag === 0) {\n        normal[0] = 0;\n        normal[1] = 0;\n        normal[2] = 0;\n    } else {\n        normal[0] = p3x / mag;\n        normal[1] = p3y / mag;\n        normal[2] = p3z / mag;\n    }\n\n    return normal\n}\n\nexport {buildFaceNormals};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/lib/buildFaceNormals.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 276,
    "kind": "function",
    "name": "triangleNormal",
    "memberof": "src/lib/buildFaceNormals.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/buildFaceNormals.js~triangleNormal",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/buildFaceNormals.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      },
      {
        "name": "c",
        "types": [
          "*"
        ]
      },
      {
        "name": "normal",
        "optional": true,
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 277,
    "kind": "function",
    "name": "buildFaceNormals",
    "memberof": "src/lib/buildFaceNormals.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/buildFaceNormals.js~buildFaceNormals",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/lib/buildFaceNormals.js",
    "importStyle": "{buildFaceNormals}",
    "description": "Builds face-aligned vertex normal vectors from positions and indices.",
    "lineNumber": 8,
    "ignore": true,
    "params": [
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "indices",
        "types": [
          "*"
        ]
      },
      {
        "name": "normals",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 278,
    "kind": "file",
    "name": "src/lib/buildVertexNormals.js",
    "content": "import {math} from \"./math.js\";\n\n/**\n * Builds vertex normal vectors from positions and indices.\n *\n * @private\n */\nfunction buildVertexNormals(positions, indices, normals) {\n\n    const a = math.vec3();\n    const b = math.vec3();\n    const c = math.vec3();\n    const ab = math.vec3();\n    const ac = math.vec3();\n    const crossVec = math.vec3();\n    const nvecs = new Array(positions.length / 3);\n\n    for (let i = 0, len = indices.length; i < len; i += 3) {\n\n        const j0 = indices[i];\n        const j1 = indices[i + 1];\n        const j2 = indices[i + 2];\n\n        a[0] = positions[j0 * 3];\n        a[1] = positions[j0 * 3 + 1];\n        a[2] = positions[j0 * 3 + 2];\n\n        b[0] = positions[j1 * 3];\n        b[1] = positions[j1 * 3 + 1];\n        b[2] = positions[j1 * 3 + 2];\n\n        c[0] = positions[j2 * 3];\n        c[1] = positions[j2 * 3 + 1];\n        c[2] = positions[j2 * 3 + 2];\n\n        math.subVec3(b, a, ab);\n        math.subVec3(c, a, ac);\n\n        const normVec = math.vec3();\n\n        math.normalizeVec3(math.cross3Vec3(ab, ac, crossVec), normVec);\n\n        if (!nvecs[j0]) {\n            nvecs[j0] = [];\n        }\n        if (!nvecs[j1]) {\n            nvecs[j1] = [];\n        }\n        if (!nvecs[j2]) {\n            nvecs[j2] = [];\n        }\n\n        nvecs[j0].push(normVec);\n        nvecs[j1].push(normVec);\n        nvecs[j2].push(normVec);\n    }\n\n    normals = (normals && normals.length === positions.length) ? normals : new Float32Array(positions.length);\n\n    for (let i = 0, len = nvecs.length; i < len; i++) {  // Now go through and average out everything\n\n        const count = nvecs[i].length;\n\n        let x = 0;\n        let y = 0;\n        let z = 0;\n\n        for (let j = 0; j < count; j++) {\n            x += nvecs[i][j][0];\n            y += nvecs[i][j][1];\n            z += nvecs[i][j][2];\n        }\n\n        normals[i * 3] = (x / count);\n        normals[i * 3 + 1] = (y / count);\n        normals[i * 3 + 2] = (z / count);\n    }\n\n    return normals;\n}\n\nexport {buildVertexNormals};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/lib/buildVertexNormals.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 279,
    "kind": "function",
    "name": "buildVertexNormals",
    "memberof": "src/lib/buildVertexNormals.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/buildVertexNormals.js~buildVertexNormals",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/lib/buildVertexNormals.js",
    "importStyle": "{buildVertexNormals}",
    "description": "Builds vertex normal vectors from positions and indices.",
    "lineNumber": 8,
    "ignore": true,
    "params": [
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "indices",
        "types": [
          "*"
        ]
      },
      {
        "name": "normals",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 280,
    "kind": "file",
    "name": "src/lib/earcut.js",
    "content": "/** @private */\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 1 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim);\n            triangles.push(ear.i / dim);\n            triangles.push(next.i / dim);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n                // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n                // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var p = ear.next.next;\n\n    while (p !== ear.prev) {\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // triangle bbox; min & max are calculated like this for speed\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\n        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\n        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\n        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(minTX, minTY, minX, minY, invSize),\n        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim);\n            triangles.push(p.i / dim);\n            triangles.push(b.i / dim);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize);\n                earcutLinked(c, triangles, dim, minX, minY, invSize);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        eliminateHole(queue[i], outerNode);\n        outerNode = filterPoints(outerNode, outerNode.next);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    outerNode = findHoleBridge(hole, outerNode);\n    if (outerNode) {\n        var b = splitPolygon(outerNode, hole);\n\n        // filter collinear points around the cuts\n        filterPoints(outerNode, outerNode.next);\n        filterPoints(b, b.next);\n    }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                if (x === hx) {\n                    if (hy === p.y) return p;\n                    if (hy === p.next.y) return p.next;\n                }\n                m = p.x < p.next.x ? p : p.next;\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n            pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = 32767 * (x - minX) * invSize;\n    y = 32767 * (y - minY) * invSize;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n        (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n        (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n        (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n            intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n            (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = null;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n\nexport {earcut};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/lib/earcut.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 281,
    "kind": "function",
    "name": "linkedList",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~linkedList",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "end",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      },
      {
        "name": "clockwise",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 282,
    "kind": "function",
    "name": "filterPoints",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~filterPoints",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "end",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 283,
    "kind": "function",
    "name": "earcutLinked",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~earcutLinked",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 84,
    "undocument": true,
    "params": [
      {
        "name": "ear",
        "types": [
          "*"
        ]
      },
      {
        "name": "triangles",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      },
      {
        "name": "minX",
        "types": [
          "*"
        ]
      },
      {
        "name": "minY",
        "types": [
          "*"
        ]
      },
      {
        "name": "invSize",
        "types": [
          "*"
        ]
      },
      {
        "name": "pass",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 284,
    "kind": "function",
    "name": "isEar",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~isEar",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 137,
    "undocument": true,
    "params": [
      {
        "name": "ear",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 285,
    "kind": "function",
    "name": "isEarHashed",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~isEarHashed",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 156,
    "undocument": true,
    "params": [
      {
        "name": "ear",
        "types": [
          "*"
        ]
      },
      {
        "name": "minX",
        "types": [
          "*"
        ]
      },
      {
        "name": "minY",
        "types": [
          "*"
        ]
      },
      {
        "name": "invSize",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 286,
    "kind": "function",
    "name": "cureLocalIntersections",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~cureLocalIntersections",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 209,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "triangles",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 287,
    "kind": "function",
    "name": "splitEarcut",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~splitEarcut",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 234,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "triangles",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      },
      {
        "name": "minX",
        "types": [
          "*"
        ]
      },
      {
        "name": "minY",
        "types": [
          "*"
        ]
      },
      {
        "name": "invSize",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 288,
    "kind": "function",
    "name": "eliminateHoles",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~eliminateHoles",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 260,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "holeIndices",
        "types": [
          "*"
        ]
      },
      {
        "name": "outerNode",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 289,
    "kind": "function",
    "name": "compareX",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~compareX",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 283,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 290,
    "kind": "function",
    "name": "eliminateHole",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~eliminateHole",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 288,
    "undocument": true,
    "params": [
      {
        "name": "hole",
        "types": [
          "*"
        ]
      },
      {
        "name": "outerNode",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 291,
    "kind": "function",
    "name": "findHoleBridge",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~findHoleBridge",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 300,
    "undocument": true,
    "params": [
      {
        "name": "hole",
        "types": [
          "*"
        ]
      },
      {
        "name": "outerNode",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 292,
    "kind": "function",
    "name": "sectorContainsSector",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~sectorContainsSector",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 360,
    "undocument": true,
    "params": [
      {
        "name": "m",
        "types": [
          "*"
        ]
      },
      {
        "name": "p",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 293,
    "kind": "function",
    "name": "indexCurve",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~indexCurve",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 365,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "minX",
        "types": [
          "*"
        ]
      },
      {
        "name": "minY",
        "types": [
          "*"
        ]
      },
      {
        "name": "invSize",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 294,
    "kind": "function",
    "name": "sortLinked",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~sortLinked",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 382,
    "undocument": true,
    "params": [
      {
        "name": "list",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 295,
    "kind": "function",
    "name": "zOrder",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~zOrder",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 434,
    "undocument": true,
    "params": [
      {
        "name": "x",
        "types": [
          "*"
        ]
      },
      {
        "name": "y",
        "types": [
          "*"
        ]
      },
      {
        "name": "minX",
        "types": [
          "*"
        ]
      },
      {
        "name": "minY",
        "types": [
          "*"
        ]
      },
      {
        "name": "invSize",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 296,
    "kind": "function",
    "name": "getLeftmost",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~getLeftmost",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 453,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 297,
    "kind": "function",
    "name": "pointInTriangle",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~pointInTriangle",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 465,
    "undocument": true,
    "params": [
      {
        "name": "ax",
        "types": [
          "*"
        ]
      },
      {
        "name": "ay",
        "types": [
          "*"
        ]
      },
      {
        "name": "bx",
        "types": [
          "*"
        ]
      },
      {
        "name": "by",
        "types": [
          "*"
        ]
      },
      {
        "name": "cx",
        "types": [
          "*"
        ]
      },
      {
        "name": "cy",
        "types": [
          "*"
        ]
      },
      {
        "name": "px",
        "types": [
          "*"
        ]
      },
      {
        "name": "py",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 298,
    "kind": "function",
    "name": "isValidDiagonal",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~isValidDiagonal",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 472,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 299,
    "kind": "function",
    "name": "area",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~area",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 480,
    "undocument": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      },
      {
        "name": "q",
        "types": [
          "*"
        ]
      },
      {
        "name": "r",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 300,
    "kind": "function",
    "name": "equals",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~equals",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 485,
    "undocument": true,
    "params": [
      {
        "name": "p1",
        "types": [
          "*"
        ]
      },
      {
        "name": "p2",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 301,
    "kind": "function",
    "name": "intersects",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~intersects",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 490,
    "undocument": true,
    "params": [
      {
        "name": "p1",
        "types": [
          "*"
        ]
      },
      {
        "name": "q1",
        "types": [
          "*"
        ]
      },
      {
        "name": "p2",
        "types": [
          "*"
        ]
      },
      {
        "name": "q2",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 302,
    "kind": "function",
    "name": "onSegment",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~onSegment",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 507,
    "undocument": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      },
      {
        "name": "q",
        "types": [
          "*"
        ]
      },
      {
        "name": "r",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 303,
    "kind": "function",
    "name": "sign",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~sign",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 511,
    "undocument": true,
    "params": [
      {
        "name": "num",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 304,
    "kind": "function",
    "name": "intersectsPolygon",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~intersectsPolygon",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 516,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 305,
    "kind": "function",
    "name": "locallyInside",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~locallyInside",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 528,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 306,
    "kind": "function",
    "name": "middleInside",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~middleInside",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 535,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 307,
    "kind": "function",
    "name": "splitPolygon",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~splitPolygon",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 552,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 308,
    "kind": "function",
    "name": "insertNode",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~insertNode",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 574,
    "undocument": true,
    "params": [
      {
        "name": "i",
        "types": [
          "*"
        ]
      },
      {
        "name": "x",
        "types": [
          "*"
        ]
      },
      {
        "name": "y",
        "types": [
          "*"
        ]
      },
      {
        "name": "last",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 309,
    "kind": "function",
    "name": "removeNode",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~removeNode",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 590,
    "undocument": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 310,
    "kind": "function",
    "name": "Node",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~Node",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 598,
    "undocument": true,
    "params": [
      {
        "name": "i",
        "types": [
          "*"
        ]
      },
      {
        "name": "x",
        "types": [
          "*"
        ]
      },
      {
        "name": "y",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 311,
    "kind": "function",
    "name": "deviation",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~deviation",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 623,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "holeIndices",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      },
      {
        "name": "triangles",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 312,
    "kind": "function",
    "name": "signedArea",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~signedArea",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 650,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "end",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 313,
    "kind": "function",
    "name": "flatten",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~flatten",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 660,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 314,
    "kind": "function",
    "name": "earcut",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~earcut",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": "{earcut}",
    "description": null,
    "lineNumber": 2,
    "ignore": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "holeIndices",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 315,
    "kind": "file",
    "name": "src/lib/faceToVertexNormals.js",
    "content": "import {math} from \"./math.js\";\n\n/**\n * Converts surface-perpendicular face normals to vertex normals. Assumes that the mesh contains disjoint triangles\n * that don't share vertex array elements. Works by finding groups of vertices that have the same location and\n * averaging their normal vectors.\n *\n * @returns {{positions: Array, normals: *}}\n * @private\n */\nfunction faceToVertexNormals(positions, normals, options = {}) {\n    const smoothNormalsAngleThreshold = options.smoothNormalsAngleThreshold || 20;\n    const vertexMap = {};\n    const vertexNormals = [];\n    const vertexNormalAccum = {};\n    let acc;\n    let vx;\n    let vy;\n    let vz;\n    let key;\n    const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n    const precision = 10 ** precisionPoints;\n    let posi;\n    let i;\n    let j;\n    let len;\n    let a;\n    let b;\n    let c;\n\n    for (i = 0, len = positions.length; i < len; i += 3) {\n\n        posi = i / 3;\n\n        vx = positions[i];\n        vy = positions[i + 1];\n        vz = positions[i + 2];\n\n        key = `${Math.round(vx * precision)}_${Math.round(vy * precision)}_${Math.round(vz * precision)}`;\n\n        if (vertexMap[key] === undefined) {\n            vertexMap[key] = [posi];\n        } else {\n            vertexMap[key].push(posi);\n        }\n\n        const normal = math.normalizeVec3([normals[i], normals[i + 1], normals[i + 2]]);\n\n        vertexNormals[posi] = normal;\n\n        acc = math.vec4([normal[0], normal[1], normal[2], 1]);\n\n        vertexNormalAccum[posi] = acc;\n    }\n\n    for (key in vertexMap) {\n\n        if (vertexMap.hasOwnProperty(key)) {\n\n            const vertices = vertexMap[key];\n            const numVerts = vertices.length;\n\n            for (i = 0; i < numVerts; i++) {\n\n                const ii = vertices[i];\n\n                acc = vertexNormalAccum[ii];\n\n                for (j = 0; j < numVerts; j++) {\n\n                    if (i === j) {\n                        continue;\n                    }\n\n                    const jj = vertices[j];\n\n                    a = vertexNormals[ii];\n                    b = vertexNormals[jj];\n\n                    const angle = Math.abs(math.angleVec3(a, b) / math.DEGTORAD);\n\n                    if (angle < smoothNormalsAngleThreshold) {\n\n                        acc[0] += b[0];\n                        acc[1] += b[1];\n                        acc[2] += b[2];\n                        acc[3] += 1.0;\n                    }\n                }\n            }\n        }\n    }\n\n    for (i = 0, len = normals.length; i < len; i += 3) {\n\n        acc = vertexNormalAccum[i / 3];\n\n        normals[i + 0] = acc[0] / acc[3];\n        normals[i + 1] = acc[1] / acc[3];\n        normals[i + 2] = acc[2] / acc[3];\n\n    }\n}\n\nexport {faceToVertexNormals};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/lib/faceToVertexNormals.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 316,
    "kind": "function",
    "name": "faceToVertexNormals",
    "memberof": "src/lib/faceToVertexNormals.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/faceToVertexNormals.js~faceToVertexNormals",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/lib/faceToVertexNormals.js",
    "importStyle": "{faceToVertexNormals}",
    "description": "Converts surface-perpendicular face normals to vertex normals. Assumes that the mesh contains disjoint triangles\nthat don't share vertex array elements. Works by finding groups of vertices that have the same location and\naveraging their normal vectors.",
    "lineNumber": 11,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{positions: Array, normals: *}}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{positions: Array, normals: *}"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true,
    "params": [
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "normals",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ]
  },
  {
    "__docId__": 317,
    "kind": "file",
    "name": "src/lib/math.js",
    "content": "// Some temporary vars to help avoid garbage collection\n\nconst doublePrecision = true;\nconst FloatArrayType = doublePrecision ? Float64Array : Float32Array;\n\nconst tempMat1 = new FloatArrayType(16);\nconst tempMat2 = new FloatArrayType(16);\nconst tempVec4 = new FloatArrayType(4);\n\n/**\n * @private\n */\nconst math = {\n\n    MIN_DOUBLE: -Number.MAX_SAFE_INTEGER,\n    MAX_DOUBLE:  Number.MAX_SAFE_INTEGER,\n\n    /**\n     * The number of radiians in a degree (0.0174532925).\n     * @property DEGTORAD\n     * @type {Number}\n     */\n    DEGTORAD: 0.0174532925,\n\n    /**\n     * The number of degrees in a radian.\n     * @property RADTODEG\n     * @type {Number}\n     */\n    RADTODEG: 57.295779513,\n\n    /**\n     * Returns a new, uninitialized two-element vector.\n     * @method vec2\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec2(values) {\n        return new FloatArrayType(values || 2);\n    },\n\n    /**\n     * Returns a new, uninitialized three-element vector.\n     * @method vec3\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec3(values) {\n        return new FloatArrayType(values || 3);\n    },\n\n    /**\n     * Returns a new, uninitialized four-element vector.\n     * @method vec4\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec4(values) {\n        return new FloatArrayType(values || 4);\n    },\n\n    /**\n     * Returns a new, uninitialized 3x3 matrix.\n     * @method mat3\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    mat3(values) {\n        return new FloatArrayType(values || 9);\n    },\n\n    /**\n     * Converts a 3x3 matrix to 4x4\n     * @method mat3ToMat4\n     * @param mat3 3x3 matrix.\n     * @param mat4 4x4 matrix\n     * @static\n     * @returns {Number[]}\n     */\n    mat3ToMat4(mat3, mat4 = new FloatArrayType(16)) {\n        mat4[0] = mat3[0];\n        mat4[1] = mat3[1];\n        mat4[2] = mat3[2];\n        mat4[3] = 0;\n        mat4[4] = mat3[3];\n        mat4[5] = mat3[4];\n        mat4[6] = mat3[5];\n        mat4[7] = 0;\n        mat4[8] = mat3[6];\n        mat4[9] = mat3[7];\n        mat4[10] = mat3[8];\n        mat4[11] = 0;\n        mat4[12] = 0;\n        mat4[13] = 0;\n        mat4[14] = 0;\n        mat4[15] = 1;\n        return mat4;\n    },\n\n    /**\n     * Returns a new, uninitialized 4x4 matrix.\n     * @method mat4\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    mat4(values) {\n        return new FloatArrayType(values || 16);\n    },\n\n    /**\n     * Converts a 4x4 matrix to 3x3\n     * @method mat4ToMat3\n     * @param mat4 4x4 matrix.\n     * @param mat3 3x3 matrix\n     * @static\n     * @returns {Number[]}\n     */\n    mat4ToMat3(mat4, mat3) { // TODO\n        //return new FloatArrayType(values || 9);\n    },\n\n    /**\n     * Returns a new UUID.\n     * @method createUUID\n     * @static\n     * @return string The new UUID\n     */\n    createUUID: ((() => {\n        const self = {};\n        const lut = [];\n        for (let i = 0; i < 256; i++) {\n            lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\n        }\n        return () => {\n            const d0 = Math.random() * 0xffffffff | 0;\n            const d1 = Math.random() * 0xffffffff | 0;\n            const d2 = Math.random() * 0xffffffff | 0;\n            const d3 = Math.random() * 0xffffffff | 0;\n            return `${lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff]}-${lut[d1 & 0xff]}${lut[d1 >> 8 & 0xff]}-${lut[d1 >> 16 & 0x0f | 0x40]}${lut[d1 >> 24 & 0xff]}-${lut[d2 & 0x3f | 0x80]}${lut[d2 >> 8 & 0xff]}-${lut[d2 >> 16 & 0xff]}${lut[d2 >> 24 & 0xff]}${lut[d3 & 0xff]}${lut[d3 >> 8 & 0xff]}${lut[d3 >> 16 & 0xff]}${lut[d3 >> 24 & 0xff]}`;\n        };\n    }))(),\n\n    /**\n     * Clamps a value to the given range.\n     * @param {Number} value Value to clamp.\n     * @param {Number} min Lower bound.\n     * @param {Number} max Upper bound.\n     * @returns {Number} Clamped result.\n     */\n    clamp(value, min, max) {\n        return Math.max(min, Math.min(max, value));\n    },\n\n    /**\n     * Floating-point modulus\n     * @method fmod\n     * @static\n     * @param {Number} a\n     * @param {Number} b\n     * @returns {*}\n     */\n    fmod(a, b) {\n        if (a < b) {\n            console.error(\"math.fmod : Attempting to find modulus within negative range - would be infinite loop - ignoring\");\n            return a;\n        }\n        while (b <= a) {\n            a -= b;\n        }\n        return a;\n    },\n\n    /**\n     * Negates a four-element vector.\n     * @method negateVec4\n     * @static\n     * @param {Array(Number)} v Vector to negate\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    negateVec4(v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = -v[0];\n        dest[1] = -v[1];\n        dest[2] = -v[2];\n        dest[3] = -v[3];\n        return dest;\n    },\n\n    /**\n     * Adds one four-element vector to another.\n     * @method addVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    addVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] + v[0];\n        dest[1] = u[1] + v[1];\n        dest[2] = u[2] + v[2];\n        dest[3] = u[3] + v[3];\n        return dest;\n    },\n\n    /**\n     * Adds a scalar value to each element of a four-element vector.\n     * @method addVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    addVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] + s;\n        dest[1] = v[1] + s;\n        dest[2] = v[2] + s;\n        dest[3] = v[3] + s;\n        return dest;\n    },\n\n    /**\n     * Adds one three-element vector to another.\n     * @method addVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    addVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] + v[0];\n        dest[1] = u[1] + v[1];\n        dest[2] = u[2] + v[2];\n        return dest;\n    },\n\n    /**\n     * Adds a scalar value to each element of a three-element vector.\n     * @method addVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    addVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] + s;\n        dest[1] = v[1] + s;\n        dest[2] = v[2] + s;\n        return dest;\n    },\n\n    /**\n     * Subtracts one four-element vector from another.\n     * @method subVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        dest[2] = u[2] - v[2];\n        dest[3] = u[3] - v[3];\n        return dest;\n    },\n\n    /**\n     * Subtracts one three-element vector from another.\n     * @method subVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        dest[2] = u[2] - v[2];\n        return dest;\n    },\n\n    /**\n     * Subtracts one two-element vector from another.\n     * @method subVec2\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec2(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        return dest;\n    },\n\n    /**\n     * Subtracts a scalar value from each element of a four-element vector.\n     * @method subVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    subVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] - s;\n        dest[1] = v[1] - s;\n        dest[2] = v[2] - s;\n        dest[3] = v[3] - s;\n        return dest;\n    },\n\n    /**\n     * Sets each element of a 4-element vector to a scalar value minus the value of that element.\n     * @method subScalarVec4\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    subScalarVec4(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s - v[0];\n        dest[1] = s - v[1];\n        dest[2] = s - v[2];\n        dest[3] = s - v[3];\n        return dest;\n    },\n\n    /**\n     * Multiplies one three-element vector by another.\n     * @method mulVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    mulVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] * v[0];\n        dest[1] = u[1] * v[1];\n        dest[2] = u[2] * v[2];\n        dest[3] = u[3] * v[3];\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a four-element vector by a scalar.\n     * @method mulVec34calar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        dest[2] = v[2] * s;\n        dest[3] = v[3] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a three-element vector by a scalar.\n     * @method mulVec3Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        dest[2] = v[2] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a two-element vector by a scalar.\n     * @method mulVec2Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec2Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        return dest;\n    },\n\n    /**\n     * Divides one three-element vector by another.\n     * @method divVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    divVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] / v[0];\n        dest[1] = u[1] / v[1];\n        dest[2] = u[2] / v[2];\n        return dest;\n    },\n\n    /**\n     * Divides one four-element vector by another.\n     * @method divVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    divVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] / v[0];\n        dest[1] = u[1] / v[1];\n        dest[2] = u[2] / v[2];\n        dest[3] = u[3] / v[3];\n        return dest;\n    },\n\n    /**\n     * Divides a scalar by a three-element vector, returning a new vector.\n     * @method divScalarVec3\n     * @static\n     * @param v vec3\n     * @param s scalar\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divScalarVec3(s, v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s / v[0];\n        dest[1] = s / v[1];\n        dest[2] = s / v[2];\n        return dest;\n    },\n\n    /**\n     * Divides a three-element vector by a scalar.\n     * @method divVec3Scalar\n     * @static\n     * @param v vec3\n     * @param s scalar\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] / s;\n        dest[1] = v[1] / s;\n        dest[2] = v[2] / s;\n        return dest;\n    },\n\n    /**\n     * Divides a four-element vector by a scalar.\n     * @method divVec4Scalar\n     * @static\n     * @param v vec4\n     * @param s scalar\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] / s;\n        dest[1] = v[1] / s;\n        dest[2] = v[2] / s;\n        dest[3] = v[3] / s;\n        return dest;\n    },\n\n\n    /**\n     * Divides a scalar by a four-element vector, returning a new vector.\n     * @method divScalarVec4\n     * @static\n     * @param s scalar\n     * @param v vec4\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divScalarVec4(s, v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s / v[0];\n        dest[1] = s / v[1];\n        dest[2] = s / v[2];\n        dest[3] = s / v[3];\n        return dest;\n    },\n\n    /**\n     * Returns the dot product of two four-element vectors.\n     * @method dotVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec4(u, v) {\n        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2] + u[3] * v[3]);\n    },\n\n    /**\n     * Returns the cross product of two four-element vectors.\n     * @method cross3Vec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The cross product\n     */\n    cross3Vec4(u, v) {\n        const u0 = u[0];\n        const u1 = u[1];\n        const u2 = u[2];\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        return [\n            u1 * v2 - u2 * v1,\n            u2 * v0 - u0 * v2,\n            u0 * v1 - u1 * v0,\n            0.0];\n    },\n\n    /**\n     * Returns the cross product of two three-element vectors.\n     * @method cross3Vec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The cross product\n     */\n    cross3Vec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        const x = u[0];\n        const y = u[1];\n        const z = u[2];\n        const x2 = v[0];\n        const y2 = v[1];\n        const z2 = v[2];\n        dest[0] = y * z2 - z * y2;\n        dest[1] = z * x2 - x * z2;\n        dest[2] = x * y2 - y * x2;\n        return dest;\n    },\n\n\n    sqLenVec4(v) { // TODO\n        return math.dotVec4(v, v);\n    },\n\n    /**\n     * Returns the length of a four-element vector.\n     * @method lenVec4\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec4(v) {\n        return Math.sqrt(math.sqLenVec4(v));\n    },\n\n    /**\n     * Returns the dot product of two three-element vectors.\n     * @method dotVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec3(u, v) {\n        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2]);\n    },\n\n    /**\n     * Returns the dot product of two two-element vectors.\n     * @method dotVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec2(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]);\n    },\n\n\n    sqLenVec3(v) {\n        return math.dotVec3(v, v);\n    },\n\n\n    sqLenVec2(v) {\n        return math.dotVec2(v, v);\n    },\n\n    /**\n     * Returns the length of a three-element vector.\n     * @method lenVec3\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec3(v) {\n        return Math.sqrt(math.sqLenVec3(v));\n    },\n\n    distVec3: ((() => {\n        const vec = new FloatArrayType(3);\n        return (v, w) => math.lenVec3(math.subVec3(v, w, vec));\n    }))(),\n\n    /**\n     * Returns the length of a two-element vector.\n     * @method lenVec2\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec2(v) {\n        return Math.sqrt(math.sqLenVec2(v));\n    },\n\n    distVec2: ((() => {\n        const vec = new FloatArrayType(2);\n        return (v, w) => math.lenVec2(math.subVec2(v, w, vec));\n    }))(),\n\n    /**\n     * @method rcpVec3\n     * @static\n     * @param v vec3\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     *\n     */\n    rcpVec3(v, dest) {\n        return math.divScalarVec3(1.0, v, dest);\n    },\n\n    /**\n     * Normalizes a four-element vector\n     * @method normalizeVec4\n     * @static\n     * @param v vec4\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     *\n     */\n    normalizeVec4(v, dest) {\n        const f = 1.0 / math.lenVec4(v);\n        return math.mulVec4Scalar(v, f, dest);\n    },\n\n    /**\n     * Normalizes a three-element vector\n     * @method normalizeVec4\n     * @static\n     */\n    normalizeVec3(v, dest) {\n        const f = 1.0 / math.lenVec3(v);\n        return math.mulVec3Scalar(v, f, dest);\n    },\n\n    /**\n     * Normalizes a two-element vector\n     * @method normalizeVec2\n     * @static\n     */\n    normalizeVec2(v, dest) {\n        const f = 1.0 / math.lenVec2(v);\n        return math.mulVec2Scalar(v, f, dest);\n    },\n\n    /**\n     * Gets the angle between two vectors\n     * @method angleVec3\n     * @param v\n     * @param w\n     * @returns {number}\n     */\n    angleVec3(v, w) {\n        let theta = math.dotVec3(v, w) / (Math.sqrt(math.sqLenVec3(v) * math.sqLenVec3(w)));\n        theta = theta < -1 ? -1 : (theta > 1 ? 1 : theta);  // Clamp to handle numerical problems\n        return Math.acos(theta);\n    },\n\n    /**\n     * Creates a three-element vector from the rotation part of a sixteen-element matrix.\n     * @param m\n     * @param dest\n     */\n    vec3FromMat4Scale: ((() => {\n\n        const tempVec3 = new FloatArrayType(3);\n\n        return (m, dest) => {\n\n            tempVec3[0] = m[0];\n            tempVec3[1] = m[1];\n            tempVec3[2] = m[2];\n\n            dest[0] = math.lenVec3(tempVec3);\n\n            tempVec3[0] = m[4];\n            tempVec3[1] = m[5];\n            tempVec3[2] = m[6];\n\n            dest[1] = math.lenVec3(tempVec3);\n\n            tempVec3[0] = m[8];\n            tempVec3[1] = m[9];\n            tempVec3[2] = m[10];\n\n            dest[2] = math.lenVec3(tempVec3);\n\n            return dest;\n        };\n    }))(),\n\n    /**\n     * Converts an n-element vector to a JSON-serializable\n     * array with values rounded to two decimal places.\n     */\n    vecToArray: ((() => {\n        function trunc(v) {\n            return Math.round(v * 100000) / 100000\n        }\n\n        return v => {\n            v = Array.prototype.slice.call(v);\n            for (let i = 0, len = v.length; i < len; i++) {\n                v[i] = trunc(v[i]);\n            }\n            return v;\n        };\n    }))(),\n\n    /**\n     * Converts a 3-element vector from an array to an object of the form ````{x:999, y:999, z:999}````.\n     * @param arr\n     * @returns {{x: *, y: *, z: *}}\n     */\n    xyzArrayToObject(arr) {\n        return {\"x\": arr[0], \"y\": arr[1], \"z\": arr[2]};\n    },\n\n    /**\n     * Converts a 3-element vector object of the form ````{x:999, y:999, z:999}```` to an array.\n     * @param xyz\n     * @param  [arry]\n     * @returns {*[]}\n     */\n    xyzObjectToArray(xyz, arry) {\n        arry = arry || new FloatArrayType(3);\n        arry[0] = xyz.x;\n        arry[1] = xyz.y;\n        arry[2] = xyz.z;\n        return arry;\n    },\n\n    /**\n     * Duplicates a 4x4 identity matrix.\n     * @method dupMat4\n     * @static\n     */\n    dupMat4(m) {\n        return m.slice(0, 16);\n    },\n\n    /**\n     * Extracts a 3x3 matrix from a 4x4 matrix.\n     * @method mat4To3\n     * @static\n     */\n    mat4To3(m) {\n        return [\n            m[0], m[1], m[2],\n            m[4], m[5], m[6],\n            m[8], m[9], m[10]\n        ];\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to the given scalar value.\n     * @method m4s\n     * @static\n     */\n    m4s(s) {\n        return [\n            s, s, s, s,\n            s, s, s, s,\n            s, s, s, s,\n            s, s, s, s\n        ];\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to zero.\n     * @method setMat4ToZeroes\n     * @static\n     */\n    setMat4ToZeroes() {\n        return math.m4s(0.0);\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to 1.0.\n     * @method setMat4ToOnes\n     * @static\n     */\n    setMat4ToOnes() {\n        return math.m4s(1.0);\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to 1.0.\n     * @method setMat4ToOnes\n     * @static\n     */\n    diagonalMat4v(v) {\n        return new FloatArrayType([\n            v[0], 0.0, 0.0, 0.0,\n            0.0, v[1], 0.0, 0.0,\n            0.0, 0.0, v[2], 0.0,\n            0.0, 0.0, 0.0, v[3]\n        ]);\n    },\n\n    /**\n     * Returns a 4x4 matrix with diagonal elements set to the given vector.\n     * @method diagonalMat4c\n     * @static\n     */\n    diagonalMat4c(x, y, z, w) {\n        return math.diagonalMat4v([x, y, z, w]);\n    },\n\n    /**\n     * Returns a 4x4 matrix with diagonal elements set to the given scalar.\n     * @method diagonalMat4s\n     * @static\n     */\n    diagonalMat4s(s) {\n        return math.diagonalMat4c(s, s, s, s);\n    },\n\n    /**\n     * Returns a 4x4 identity matrix.\n     * @method identityMat4\n     * @static\n     */\n    identityMat4(mat = new FloatArrayType(16)) {\n        mat[0] = 1.0;\n        mat[1] = 0.0;\n        mat[2] = 0.0;\n        mat[3] = 0.0;\n\n        mat[4] = 0.0;\n        mat[5] = 1.0;\n        mat[6] = 0.0;\n        mat[7] = 0.0;\n\n        mat[8] = 0.0;\n        mat[9] = 0.0;\n        mat[10] = 1.0;\n        mat[11] = 0.0;\n\n        mat[12] = 0.0;\n        mat[13] = 0.0;\n        mat[14] = 0.0;\n        mat[15] = 1.0;\n\n        return mat;\n    },\n\n    /**\n     * Returns a 3x3 identity matrix.\n     * @method identityMat3\n     * @static\n     */\n    identityMat3(mat = new FloatArrayType(9)) {\n        mat[0] = 1.0;\n        mat[1] = 0.0;\n        mat[2] = 0.0;\n\n        mat[3] = 0.0;\n        mat[4] = 1.0;\n        mat[5] = 0.0;\n\n        mat[6] = 0.0;\n        mat[7] = 0.0;\n        mat[8] = 1.0;\n\n        return mat;\n    },\n\n    /**\n     * Tests if the given 4x4 matrix is the identity matrix.\n     * @method isIdentityMat4\n     * @static\n     */\n    isIdentityMat4(m) {\n        if (m[0] !== 1.0 || m[1] !== 0.0 || m[2] !== 0.0 || m[3] !== 0.0 ||\n            m[4] !== 0.0 || m[5] !== 1.0 || m[6] !== 0.0 || m[7] !== 0.0 ||\n            m[8] !== 0.0 || m[9] !== 0.0 || m[10] !== 1.0 || m[11] !== 0.0 ||\n            m[12] !== 0.0 || m[13] !== 0.0 || m[14] !== 0.0 || m[15] !== 1.0) {\n            return false;\n        }\n        return true;\n    },\n\n    /**\n     * Negates the given 4x4 matrix.\n     * @method negateMat4\n     * @static\n     */\n    negateMat4(m, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = -m[0];\n        dest[1] = -m[1];\n        dest[2] = -m[2];\n        dest[3] = -m[3];\n        dest[4] = -m[4];\n        dest[5] = -m[5];\n        dest[6] = -m[6];\n        dest[7] = -m[7];\n        dest[8] = -m[8];\n        dest[9] = -m[9];\n        dest[10] = -m[10];\n        dest[11] = -m[11];\n        dest[12] = -m[12];\n        dest[13] = -m[13];\n        dest[14] = -m[14];\n        dest[15] = -m[15];\n        return dest;\n    },\n\n    /**\n     * Adds the given 4x4 matrices together.\n     * @method addMat4\n     * @static\n     */\n    addMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n        dest[0] = a[0] + b[0];\n        dest[1] = a[1] + b[1];\n        dest[2] = a[2] + b[2];\n        dest[3] = a[3] + b[3];\n        dest[4] = a[4] + b[4];\n        dest[5] = a[5] + b[5];\n        dest[6] = a[6] + b[6];\n        dest[7] = a[7] + b[7];\n        dest[8] = a[8] + b[8];\n        dest[9] = a[9] + b[9];\n        dest[10] = a[10] + b[10];\n        dest[11] = a[11] + b[11];\n        dest[12] = a[12] + b[12];\n        dest[13] = a[13] + b[13];\n        dest[14] = a[14] + b[14];\n        dest[15] = a[15] + b[15];\n        return dest;\n    },\n\n    /**\n     * Adds the given scalar to each element of the given 4x4 matrix.\n     * @method addMat4Scalar\n     * @static\n     */\n    addMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] + s;\n        dest[1] = m[1] + s;\n        dest[2] = m[2] + s;\n        dest[3] = m[3] + s;\n        dest[4] = m[4] + s;\n        dest[5] = m[5] + s;\n        dest[6] = m[6] + s;\n        dest[7] = m[7] + s;\n        dest[8] = m[8] + s;\n        dest[9] = m[9] + s;\n        dest[10] = m[10] + s;\n        dest[11] = m[11] + s;\n        dest[12] = m[12] + s;\n        dest[13] = m[13] + s;\n        dest[14] = m[14] + s;\n        dest[15] = m[15] + s;\n        return dest;\n    },\n\n    /**\n     * Adds the given scalar to each element of the given 4x4 matrix.\n     * @method addScalarMat4\n     * @static\n     */\n    addScalarMat4(s, m, dest) {\n        return math.addMat4Scalar(m, s, dest);\n    },\n\n    /**\n     * Subtracts the second 4x4 matrix from the first.\n     * @method subMat4\n     * @static\n     */\n    subMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n        dest[0] = a[0] - b[0];\n        dest[1] = a[1] - b[1];\n        dest[2] = a[2] - b[2];\n        dest[3] = a[3] - b[3];\n        dest[4] = a[4] - b[4];\n        dest[5] = a[5] - b[5];\n        dest[6] = a[6] - b[6];\n        dest[7] = a[7] - b[7];\n        dest[8] = a[8] - b[8];\n        dest[9] = a[9] - b[9];\n        dest[10] = a[10] - b[10];\n        dest[11] = a[11] - b[11];\n        dest[12] = a[12] - b[12];\n        dest[13] = a[13] - b[13];\n        dest[14] = a[14] - b[14];\n        dest[15] = a[15] - b[15];\n        return dest;\n    },\n\n    /**\n     * Subtracts the given scalar from each element of the given 4x4 matrix.\n     * @method subMat4Scalar\n     * @static\n     */\n    subMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] - s;\n        dest[1] = m[1] - s;\n        dest[2] = m[2] - s;\n        dest[3] = m[3] - s;\n        dest[4] = m[4] - s;\n        dest[5] = m[5] - s;\n        dest[6] = m[6] - s;\n        dest[7] = m[7] - s;\n        dest[8] = m[8] - s;\n        dest[9] = m[9] - s;\n        dest[10] = m[10] - s;\n        dest[11] = m[11] - s;\n        dest[12] = m[12] - s;\n        dest[13] = m[13] - s;\n        dest[14] = m[14] - s;\n        dest[15] = m[15] - s;\n        return dest;\n    },\n\n    /**\n     * Subtracts the given scalar from each element of the given 4x4 matrix.\n     * @method subScalarMat4\n     * @static\n     */\n    subScalarMat4(s, m, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = s - m[0];\n        dest[1] = s - m[1];\n        dest[2] = s - m[2];\n        dest[3] = s - m[3];\n        dest[4] = s - m[4];\n        dest[5] = s - m[5];\n        dest[6] = s - m[6];\n        dest[7] = s - m[7];\n        dest[8] = s - m[8];\n        dest[9] = s - m[9];\n        dest[10] = s - m[10];\n        dest[11] = s - m[11];\n        dest[12] = s - m[12];\n        dest[13] = s - m[13];\n        dest[14] = s - m[14];\n        dest[15] = s - m[15];\n        return dest;\n    },\n\n    /**\n     * Multiplies the two given 4x4 matrix by each other.\n     * @method mulMat4\n     * @static\n     */\n    mulMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = a[0];\n\n        const a01 = a[1];\n        const a02 = a[2];\n        const a03 = a[3];\n        const a10 = a[4];\n        const a11 = a[5];\n        const a12 = a[6];\n        const a13 = a[7];\n        const a20 = a[8];\n        const a21 = a[9];\n        const a22 = a[10];\n        const a23 = a[11];\n        const a30 = a[12];\n        const a31 = a[13];\n        const a32 = a[14];\n        const a33 = a[15];\n        const b00 = b[0];\n        const b01 = b[1];\n        const b02 = b[2];\n        const b03 = b[3];\n        const b10 = b[4];\n        const b11 = b[5];\n        const b12 = b[6];\n        const b13 = b[7];\n        const b20 = b[8];\n        const b21 = b[9];\n        const b22 = b[10];\n        const b23 = b[11];\n        const b30 = b[12];\n        const b31 = b[13];\n        const b32 = b[14];\n        const b33 = b[15];\n\n        dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;\n        dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;\n        dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;\n        dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;\n        dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;\n        dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;\n        dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;\n        dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;\n        dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;\n        dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;\n        dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;\n        dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;\n        dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;\n        dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;\n        dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;\n        dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;\n\n        return dest;\n    },\n\n    /**\n     * Multiplies the two given 3x3 matrices by each other.\n     * @method mulMat4\n     * @static\n     */\n    mulMat3(a, b, dest) {\n        if (!dest) {\n            dest = new FloatArrayType(9);\n        }\n\n        const a11 = a[0];\n        const a12 = a[3];\n        const a13 = a[6];\n        const a21 = a[1];\n        const a22 = a[4];\n        const a23 = a[7];\n        const a31 = a[2];\n        const a32 = a[5];\n        const a33 = a[8];\n        const b11 = b[0];\n        const b12 = b[3];\n        const b13 = b[6];\n        const b21 = b[1];\n        const b22 = b[4];\n        const b23 = b[7];\n        const b31 = b[2];\n        const b32 = b[5];\n        const b33 = b[8];\n\n        dest[0] = a11 * b11 + a12 * b21 + a13 * b31;\n        dest[3] = a11 * b12 + a12 * b22 + a13 * b32;\n        dest[6] = a11 * b13 + a12 * b23 + a13 * b33;\n\n        dest[1] = a21 * b11 + a22 * b21 + a23 * b31;\n        dest[4] = a21 * b12 + a22 * b22 + a23 * b32;\n        dest[7] = a21 * b13 + a22 * b23 + a23 * b33;\n\n        dest[2] = a31 * b11 + a32 * b21 + a33 * b31;\n        dest[5] = a31 * b12 + a32 * b22 + a33 * b32;\n        dest[8] = a31 * b13 + a32 * b23 + a33 * b33;\n\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of the given 4x4 matrix by the given scalar.\n     * @method mulMat4Scalar\n     * @static\n     */\n    mulMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] * s;\n        dest[1] = m[1] * s;\n        dest[2] = m[2] * s;\n        dest[3] = m[3] * s;\n        dest[4] = m[4] * s;\n        dest[5] = m[5] * s;\n        dest[6] = m[6] * s;\n        dest[7] = m[7] * s;\n        dest[8] = m[8] * s;\n        dest[9] = m[9] * s;\n        dest[10] = m[10] * s;\n        dest[11] = m[11] * s;\n        dest[12] = m[12] * s;\n        dest[13] = m[13] * s;\n        dest[14] = m[14] * s;\n        dest[15] = m[15] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies the given 4x4 matrix by the given four-element vector.\n     * @method mulMat4v4\n     * @static\n     */\n    mulMat4v4(m, v, dest = math.vec4()) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;\n        dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;\n        dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;\n        dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;\n        return dest;\n    },\n\n    /**\n     * Transposes the given 4x4 matrix.\n     * @method transposeMat4\n     * @static\n     */\n    transposeMat4(mat, dest) {\n        // If we are transposing ourselves we can skip a few steps but have to cache some values\n        const m4 = mat[4];\n\n        const m14 = mat[14];\n        const m8 = mat[8];\n        const m13 = mat[13];\n        const m12 = mat[12];\n        const m9 = mat[9];\n        if (!dest || mat === dest) {\n            const a01 = mat[1];\n            const a02 = mat[2];\n            const a03 = mat[3];\n            const a12 = mat[6];\n            const a13 = mat[7];\n            const a23 = mat[11];\n            mat[1] = m4;\n            mat[2] = m8;\n            mat[3] = m12;\n            mat[4] = a01;\n            mat[6] = m9;\n            mat[7] = m13;\n            mat[8] = a02;\n            mat[9] = a12;\n            mat[11] = m14;\n            mat[12] = a03;\n            mat[13] = a13;\n            mat[14] = a23;\n            return mat;\n        }\n        dest[0] = mat[0];\n        dest[1] = m4;\n        dest[2] = m8;\n        dest[3] = m12;\n        dest[4] = mat[1];\n        dest[5] = mat[5];\n        dest[6] = m9;\n        dest[7] = m13;\n        dest[8] = mat[2];\n        dest[9] = mat[6];\n        dest[10] = mat[10];\n        dest[11] = m14;\n        dest[12] = mat[3];\n        dest[13] = mat[7];\n        dest[14] = mat[11];\n        dest[15] = mat[15];\n        return dest;\n    },\n\n    /**\n     * Transposes the given 3x3 matrix.\n     *\n     * @method transposeMat3\n     * @static\n     */\n    transposeMat3(mat, dest) {\n        if (dest === mat) {\n            const a01 = mat[1];\n            const a02 = mat[2];\n            const a12 = mat[5];\n            dest[1] = mat[3];\n            dest[2] = mat[6];\n            dest[3] = a01;\n            dest[5] = mat[7];\n            dest[6] = a02;\n            dest[7] = a12;\n        } else {\n            dest[0] = mat[0];\n            dest[1] = mat[3];\n            dest[2] = mat[6];\n            dest[3] = mat[1];\n            dest[4] = mat[4];\n            dest[5] = mat[7];\n            dest[6] = mat[2];\n            dest[7] = mat[5];\n            dest[8] = mat[8];\n        }\n        return dest;\n    },\n\n    /**\n     * Returns the determinant of the given 4x4 matrix.\n     * @method determinantMat4\n     * @static\n     */\n    determinantMat4(mat) {\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = mat[0];\n\n        const a01 = mat[1];\n        const a02 = mat[2];\n        const a03 = mat[3];\n        const a10 = mat[4];\n        const a11 = mat[5];\n        const a12 = mat[6];\n        const a13 = mat[7];\n        const a20 = mat[8];\n        const a21 = mat[9];\n        const a22 = mat[10];\n        const a23 = mat[11];\n        const a30 = mat[12];\n        const a31 = mat[13];\n        const a32 = mat[14];\n        const a33 = mat[15];\n        return a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 +\n            a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 +\n            a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 +\n            a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 +\n            a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 +\n            a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33;\n    },\n\n    /**\n     * Returns the inverse of the given 4x4 matrix.\n     * @method inverseMat4\n     * @static\n     */\n    inverseMat4(mat, dest) {\n        if (!dest) {\n            dest = mat;\n        }\n\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = mat[0];\n\n        const a01 = mat[1];\n        const a02 = mat[2];\n        const a03 = mat[3];\n        const a10 = mat[4];\n        const a11 = mat[5];\n        const a12 = mat[6];\n        const a13 = mat[7];\n        const a20 = mat[8];\n        const a21 = mat[9];\n        const a22 = mat[10];\n        const a23 = mat[11];\n        const a30 = mat[12];\n        const a31 = mat[13];\n        const a32 = mat[14];\n        const a33 = mat[15];\n        const b00 = a00 * a11 - a01 * a10;\n        const b01 = a00 * a12 - a02 * a10;\n        const b02 = a00 * a13 - a03 * a10;\n        const b03 = a01 * a12 - a02 * a11;\n        const b04 = a01 * a13 - a03 * a11;\n        const b05 = a02 * a13 - a03 * a12;\n        const b06 = a20 * a31 - a21 * a30;\n        const b07 = a20 * a32 - a22 * a30;\n        const b08 = a20 * a33 - a23 * a30;\n        const b09 = a21 * a32 - a22 * a31;\n        const b10 = a21 * a33 - a23 * a31;\n        const b11 = a22 * a33 - a23 * a32;\n\n        // Calculate the determinant (inlined to avoid double-caching)\n        const invDet = 1 / (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);\n\n        dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;\n        dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;\n        dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;\n        dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;\n        dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;\n        dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;\n        dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;\n        dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;\n        dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;\n        dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;\n        dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;\n        dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;\n        dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;\n        dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;\n        dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;\n        dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;\n\n        return dest;\n    },\n\n    /**\n     * Returns the trace of the given 4x4 matrix.\n     * @method traceMat4\n     * @static\n     */\n    traceMat4(m) {\n        return (m[0] + m[5] + m[10] + m[15]);\n    },\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4\n     * @static\n     */\n    translationMat4v(v, dest) {\n        const m = dest || math.identityMat4();\n        m[12] = v[0];\n        m[13] = v[1];\n        m[14] = v[2];\n        return m;\n    },\n\n    /**\n     * Returns 3x3 translation matrix.\n     * @method translationMat3\n     * @static\n     */\n    translationMat3v(v, dest) {\n        const m = dest || math.identityMat3();\n        m[6] = v[0];\n        m[7] = v[1];\n        return m;\n    },\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4c\n     * @static\n     */\n    translationMat4c: ((() => {\n        const xyz = new FloatArrayType(3);\n        return (x, y, z, dest) => {\n            xyz[0] = x;\n            xyz[1] = y;\n            xyz[2] = z;\n            return math.translationMat4v(xyz, dest);\n        };\n    }))(),\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4s\n     * @static\n     */\n    translationMat4s(s, dest) {\n        return math.translationMat4c(s, s, s, dest);\n    },\n\n    /**\n     * Efficiently post-concatenates a translation to the given matrix.\n     * @param v\n     * @param m\n     */\n    translateMat4v(xyz, m) {\n        return math.translateMat4c(xyz[0], xyz[1], xyz[2], m);\n    },\n\n    /**\n     * Efficiently post-concatenates a translation to the given matrix.\n     * @param x\n     * @param y\n     * @param z\n     * @param m\n     */\n    OLDtranslateMat4c(x, y, z, m) {\n\n        const m12 = m[12];\n        m[0] += m12 * x;\n        m[4] += m12 * y;\n        m[8] += m12 * z;\n\n        const m13 = m[13];\n        m[1] += m13 * x;\n        m[5] += m13 * y;\n        m[9] += m13 * z;\n\n        const m14 = m[14];\n        m[2] += m14 * x;\n        m[6] += m14 * y;\n        m[10] += m14 * z;\n\n        const m15 = m[15];\n        m[3] += m15 * x;\n        m[7] += m15 * y;\n        m[11] += m15 * z;\n\n        return m;\n    },\n\n    translateMat4c(x, y, z, m) {\n\n        const m3 = m[3];\n        m[0] += m3 * x;\n        m[1] += m3 * y;\n        m[2] += m3 * z;\n\n        const m7 = m[7];\n        m[4] += m7 * x;\n        m[5] += m7 * y;\n        m[6] += m7 * z;\n\n        const m11 = m[11];\n        m[8] += m11 * x;\n        m[9] += m11 * y;\n        m[10] += m11 * z;\n\n        const m15 = m[15];\n        m[12] += m15 * x;\n        m[13] += m15 * y;\n        m[14] += m15 * z;\n\n        return m;\n    },\n    /**\n     * Returns 4x4 rotation matrix.\n     * @method rotationMat4v\n     * @static\n     */\n    rotationMat4v(anglerad, axis, m) {\n        const ax = math.normalizeVec4([axis[0], axis[1], axis[2], 0.0], []);\n        const s = Math.sin(anglerad);\n        const c = Math.cos(anglerad);\n        const q = 1.0 - c;\n\n        const x = ax[0];\n        const y = ax[1];\n        const z = ax[2];\n\n        let xy;\n        let yz;\n        let zx;\n        let xs;\n        let ys;\n        let zs;\n\n        //xx = x * x; used once\n        //yy = y * y; used once\n        //zz = z * z; used once\n        xy = x * y;\n        yz = y * z;\n        zx = z * x;\n        xs = x * s;\n        ys = y * s;\n        zs = z * s;\n\n        m = m || math.mat4();\n\n        m[0] = (q * x * x) + c;\n        m[1] = (q * xy) + zs;\n        m[2] = (q * zx) - ys;\n        m[3] = 0.0;\n\n        m[4] = (q * xy) - zs;\n        m[5] = (q * y * y) + c;\n        m[6] = (q * yz) + xs;\n        m[7] = 0.0;\n\n        m[8] = (q * zx) + ys;\n        m[9] = (q * yz) - xs;\n        m[10] = (q * z * z) + c;\n        m[11] = 0.0;\n\n        m[12] = 0.0;\n        m[13] = 0.0;\n        m[14] = 0.0;\n        m[15] = 1.0;\n\n        return m;\n    },\n\n    /**\n     * Returns 4x4 rotation matrix.\n     * @method rotationMat4c\n     * @static\n     */\n    rotationMat4c(anglerad, x, y, z, mat) {\n        return math.rotationMat4v(anglerad, [x, y, z], mat);\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4v\n     * @static\n     */\n    scalingMat4v(v, m = math.identityMat4()) {\n        m[0] = v[0];\n        m[5] = v[1];\n        m[10] = v[2];\n        return m;\n    },\n\n    /**\n     * Returns 3x3 scale matrix.\n     * @method scalingMat3v\n     * @static\n     */\n    scalingMat3v(v, m = math.identityMat3()) {\n        m[0] = v[0];\n        m[4] = v[1];\n        return m;\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4c\n     * @static\n     */\n    scalingMat4c: ((() => {\n        const xyz = new FloatArrayType(3);\n        return (x, y, z, dest) => {\n            xyz[0] = x;\n            xyz[1] = y;\n            xyz[2] = z;\n            return math.scalingMat4v(xyz, dest);\n        };\n    }))(),\n\n    /**\n     * Efficiently post-concatenates a scaling to the given matrix.\n     * @method scaleMat4c\n     * @param x\n     * @param y\n     * @param z\n     * @param m\n     */\n    scaleMat4c(x, y, z, m) {\n\n        m[0] *= x;\n        m[4] *= y;\n        m[8] *= z;\n\n        m[1] *= x;\n        m[5] *= y;\n        m[9] *= z;\n\n        m[2] *= x;\n        m[6] *= y;\n        m[10] *= z;\n\n        m[3] *= x;\n        m[7] *= y;\n        m[11] *= z;\n        return m;\n    },\n\n    /**\n     * Efficiently post-concatenates a scaling to the given matrix.\n     * @method scaleMat4c\n     * @param xyz\n     * @param m\n     */\n    scaleMat4v(xyz, m) {\n\n        const x = xyz[0];\n        const y = xyz[1];\n        const z = xyz[2];\n\n        m[0] *= x;\n        m[4] *= y;\n        m[8] *= z;\n        m[1] *= x;\n        m[5] *= y;\n        m[9] *= z;\n        m[2] *= x;\n        m[6] *= y;\n        m[10] *= z;\n        m[3] *= x;\n        m[7] *= y;\n        m[11] *= z;\n\n        return m;\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4s\n     * @static\n     */\n    scalingMat4s(s) {\n        return math.scalingMat4c(s, s, s);\n    },\n\n    /**\n     * Creates a matrix from a quaternion rotation and vector translation\n     *\n     * @param {Number[]} q Rotation quaternion\n     * @param {Number[]} v Translation vector\n     * @param {Number[]} dest Destination matrix\n     * @returns {Number[]} dest\n     */\n    rotationTranslationMat4(q, v, dest = math.mat4()) {\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n\n        dest[0] = 1 - (yy + zz);\n        dest[1] = xy + wz;\n        dest[2] = xz - wy;\n        dest[3] = 0;\n        dest[4] = xy - wz;\n        dest[5] = 1 - (xx + zz);\n        dest[6] = yz + wx;\n        dest[7] = 0;\n        dest[8] = xz + wy;\n        dest[9] = yz - wx;\n        dest[10] = 1 - (xx + yy);\n        dest[11] = 0;\n        dest[12] = v[0];\n        dest[13] = v[1];\n        dest[14] = v[2];\n        dest[15] = 1;\n\n        return dest;\n    },\n\n    /**\n     * Gets Euler angles from a 4x4 matrix.\n     *\n     * @param {Number[]} mat The 4x4 matrix.\n     * @param {String} order Desired Euler angle order: \"XYZ\", \"YXZ\", \"ZXY\" etc.\n     * @param {Number[]} [dest] Destination Euler angles, created by default.\n     * @returns {Number[]} The Euler angles.\n     */\n    mat4ToEuler(mat, order, dest = math.vec4()) {\n        const clamp = math.clamp;\n\n        // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n        const m11 = mat[0];\n\n        const m12 = mat[4];\n        const m13 = mat[8];\n        const m21 = mat[1];\n        const m22 = mat[5];\n        const m23 = mat[9];\n        const m31 = mat[2];\n        const m32 = mat[6];\n        const m33 = mat[10];\n\n        if (order === 'XYZ') {\n\n            dest[1] = Math.asin(clamp(m13, -1, 1));\n\n            if (Math.abs(m13) < 0.99999) {\n                dest[0] = Math.atan2(-m23, m33);\n                dest[2] = Math.atan2(-m12, m11);\n            } else {\n                dest[0] = Math.atan2(m32, m22);\n                dest[2] = 0;\n\n            }\n\n        } else if (order === 'YXZ') {\n\n            dest[0] = Math.asin(-clamp(m23, -1, 1));\n\n            if (Math.abs(m23) < 0.99999) {\n                dest[1] = Math.atan2(m13, m33);\n                dest[2] = Math.atan2(m21, m22);\n            } else {\n                dest[1] = Math.atan2(-m31, m11);\n                dest[2] = 0;\n            }\n\n        } else if (order === 'ZXY') {\n\n            dest[0] = Math.asin(clamp(m32, -1, 1));\n\n            if (Math.abs(m32) < 0.99999) {\n                dest[1] = Math.atan2(-m31, m33);\n                dest[2] = Math.atan2(-m12, m22);\n            } else {\n                dest[1] = 0;\n                dest[2] = Math.atan2(m21, m11);\n            }\n\n        } else if (order === 'ZYX') {\n\n            dest[1] = Math.asin(-clamp(m31, -1, 1));\n\n            if (Math.abs(m31) < 0.99999) {\n                dest[0] = Math.atan2(m32, m33);\n                dest[2] = Math.atan2(m21, m11);\n            } else {\n                dest[0] = 0;\n                dest[2] = Math.atan2(-m12, m22);\n            }\n\n        } else if (order === 'YZX') {\n\n            dest[2] = Math.asin(clamp(m21, -1, 1));\n\n            if (Math.abs(m21) < 0.99999) {\n                dest[0] = Math.atan2(-m23, m22);\n                dest[1] = Math.atan2(-m31, m11);\n            } else {\n                dest[0] = 0;\n                dest[1] = Math.atan2(m13, m33);\n            }\n\n        } else if (order === 'XZY') {\n\n            dest[2] = Math.asin(-clamp(m12, -1, 1));\n\n            if (Math.abs(m12) < 0.99999) {\n                dest[0] = Math.atan2(m32, m22);\n                dest[1] = Math.atan2(m13, m11);\n            } else {\n                dest[0] = Math.atan2(-m23, m33);\n                dest[1] = 0;\n            }\n        }\n\n        return dest;\n    },\n\n    composeMat4(position, quaternion, scale, mat = math.mat4()) {\n        math.quaternionToRotationMat4(quaternion, mat);\n        math.scaleMat4v(scale, mat);\n        math.translateMat4v(position, mat);\n\n        return mat;\n    },\n\n    decomposeMat4: (() => {\n\n        const vec = new FloatArrayType(3);\n        const matrix = new FloatArrayType(16);\n\n        return function decompose(mat, position, quaternion, scale) {\n\n            vec[0] = mat[0];\n            vec[1] = mat[1];\n            vec[2] = mat[2];\n\n            let sx = math.lenVec3(vec);\n\n            vec[0] = mat[4];\n            vec[1] = mat[5];\n            vec[2] = mat[6];\n\n            const sy = math.lenVec3(vec);\n\n            vec[8] = mat[8];\n            vec[9] = mat[9];\n            vec[10] = mat[10];\n\n            const sz = math.lenVec3(vec);\n\n            // if determine is negative, we need to invert one scale\n            const det = math.determinantMat4(mat);\n\n            if (det < 0) {\n                sx = -sx;\n            }\n\n            position[0] = mat[12];\n            position[1] = mat[13];\n            position[2] = mat[14];\n\n            // scale the rotation part\n            matrix.set(mat);\n\n            const invSX = 1 / sx;\n            const invSY = 1 / sy;\n            const invSZ = 1 / sz;\n\n            matrix[0] *= invSX;\n            matrix[1] *= invSX;\n            matrix[2] *= invSX;\n\n            matrix[4] *= invSY;\n            matrix[5] *= invSY;\n            matrix[6] *= invSY;\n\n            matrix[8] *= invSZ;\n            matrix[9] *= invSZ;\n            matrix[10] *= invSZ;\n\n            math.mat4ToQuaternion(matrix, quaternion);\n\n            scale[0] = sx;\n            scale[1] = sy;\n            scale[2] = sz;\n\n            return this;\n\n        };\n\n    })(),\n\n    /**\n     * Returns a 4x4 'lookat' viewing transform matrix.\n     * @method lookAtMat4v\n     * @param pos vec3 position of the viewer\n     * @param target vec3 point the viewer is looking at\n     * @param up vec3 pointing \"up\"\n     * @param dest mat4 Optional, mat4 matrix will be written into\n     *\n     * @return {mat4} dest if specified, a new mat4 otherwise\n     */\n    lookAtMat4v(pos, target, up, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n\n        const posx = pos[0];\n        const posy = pos[1];\n        const posz = pos[2];\n        const upx = up[0];\n        const upy = up[1];\n        const upz = up[2];\n        const targetx = target[0];\n        const targety = target[1];\n        const targetz = target[2];\n\n        if (posx === targetx && posy === targety && posz === targetz) {\n            return math.identityMat4();\n        }\n\n        let z0;\n        let z1;\n        let z2;\n        let x0;\n        let x1;\n        let x2;\n        let y0;\n        let y1;\n        let y2;\n        let len;\n\n        //vec3.direction(eye, center, z);\n        z0 = posx - targetx;\n        z1 = posy - targety;\n        z2 = posz - targetz;\n\n        // normalize (no check needed for 0 because of early return)\n        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n        z0 *= len;\n        z1 *= len;\n        z2 *= len;\n\n        //vec3.normalize(vec3.cross(up, z, x));\n        x0 = upy * z2 - upz * z1;\n        x1 = upz * z0 - upx * z2;\n        x2 = upx * z1 - upy * z0;\n        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n        if (!len) {\n            x0 = 0;\n            x1 = 0;\n            x2 = 0;\n        } else {\n            len = 1 / len;\n            x0 *= len;\n            x1 *= len;\n            x2 *= len;\n        }\n\n        //vec3.normalize(vec3.cross(z, x, y));\n        y0 = z1 * x2 - z2 * x1;\n        y1 = z2 * x0 - z0 * x2;\n        y2 = z0 * x1 - z1 * x0;\n\n        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n        if (!len) {\n            y0 = 0;\n            y1 = 0;\n            y2 = 0;\n        } else {\n            len = 1 / len;\n            y0 *= len;\n            y1 *= len;\n            y2 *= len;\n        }\n\n        dest[0] = x0;\n        dest[1] = y0;\n        dest[2] = z0;\n        dest[3] = 0;\n        dest[4] = x1;\n        dest[5] = y1;\n        dest[6] = z1;\n        dest[7] = 0;\n        dest[8] = x2;\n        dest[9] = y2;\n        dest[10] = z2;\n        dest[11] = 0;\n        dest[12] = -(x0 * posx + x1 * posy + x2 * posz);\n        dest[13] = -(y0 * posx + y1 * posy + y2 * posz);\n        dest[14] = -(z0 * posx + z1 * posy + z2 * posz);\n        dest[15] = 1;\n\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 'lookat' viewing transform matrix.\n     * @method lookAtMat4c\n     * @static\n     */\n    lookAtMat4c(posx, posy, posz, targetx, targety, targetz, upx, upy, upz) {\n        return math.lookAtMat4v([posx, posy, posz], [targetx, targety, targetz], [upx, upy, upz], []);\n    },\n\n    /**\n     * Returns a 4x4 orthographic projection matrix.\n     * @method orthoMat4c\n     * @static\n     */\n    orthoMat4c(left, right, bottom, top, near, far, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n        const rl = (right - left);\n        const tb = (top - bottom);\n        const fn = (far - near);\n\n        dest[0] = 2.0 / rl;\n        dest[1] = 0.0;\n        dest[2] = 0.0;\n        dest[3] = 0.0;\n\n        dest[4] = 0.0;\n        dest[5] = 2.0 / tb;\n        dest[6] = 0.0;\n        dest[7] = 0.0;\n\n        dest[8] = 0.0;\n        dest[9] = 0.0;\n        dest[10] = -2.0 / fn;\n        dest[11] = 0.0;\n\n        dest[12] = -(left + right) / rl;\n        dest[13] = -(top + bottom) / tb;\n        dest[14] = -(far + near) / fn;\n        dest[15] = 1.0;\n\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method frustumMat4v\n     * @static\n     */\n    frustumMat4v(fmin, fmax, m) {\n        if (!m) {\n            m = math.mat4();\n        }\n\n        const fmin4 = [fmin[0], fmin[1], fmin[2], 0.0];\n        const fmax4 = [fmax[0], fmax[1], fmax[2], 0.0];\n\n        math.addVec4(fmax4, fmin4, tempMat1);\n        math.subVec4(fmax4, fmin4, tempMat2);\n\n        const t = 2.0 * fmin4[2];\n\n        const tempMat20 = tempMat2[0];\n        const tempMat21 = tempMat2[1];\n        const tempMat22 = tempMat2[2];\n\n        m[0] = t / tempMat20;\n        m[1] = 0.0;\n        m[2] = 0.0;\n        m[3] = 0.0;\n\n        m[4] = 0.0;\n        m[5] = t / tempMat21;\n        m[6] = 0.0;\n        m[7] = 0.0;\n\n        m[8] = tempMat1[0] / tempMat20;\n        m[9] = tempMat1[1] / tempMat21;\n        m[10] = -tempMat1[2] / tempMat22;\n        m[11] = -1.0;\n\n        m[12] = 0.0;\n        m[13] = 0.0;\n        m[14] = -t * fmax4[2] / tempMat22;\n        m[15] = 0.0;\n\n        return m;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method frustumMat4v\n     * @static\n     */\n    frustumMat4(left, right, bottom, top, near, far, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n        const rl = (right - left);\n        const tb = (top - bottom);\n        const fn = (far - near);\n        dest[0] = (near * 2) / rl;\n        dest[1] = 0;\n        dest[2] = 0;\n        dest[3] = 0;\n        dest[4] = 0;\n        dest[5] = (near * 2) / tb;\n        dest[6] = 0;\n        dest[7] = 0;\n        dest[8] = (right + left) / rl;\n        dest[9] = (top + bottom) / tb;\n        dest[10] = -(far + near) / fn;\n        dest[11] = -1;\n        dest[12] = 0;\n        dest[13] = 0;\n        dest[14] = -(far * near * 2) / fn;\n        dest[15] = 0;\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method perspectiveMat4v\n     * @static\n     */\n    perspectiveMat4(fovyrad, aspectratio, znear, zfar, m) {\n        const pmin = [];\n        const pmax = [];\n\n        pmin[2] = znear;\n        pmax[2] = zfar;\n\n        pmax[1] = pmin[2] * Math.tan(fovyrad / 2.0);\n        pmin[1] = -pmax[1];\n\n        pmax[0] = pmax[1] * aspectratio;\n        pmin[0] = -pmax[0];\n\n        return math.frustumMat4v(pmin, pmax, m);\n    },\n\n    /**\n     * Transforms a three-element position by a 4x4 matrix.\n     * @method transformPoint3\n     * @static\n     */\n    transformPoint3(m, p, dest = math.vec3()) {\n\n        const x = p[0];\n        const y = p[1];\n        const z = p[2];\n\n        dest[0] = (m[0] * x) + (m[4] * y) + (m[8] * z) + m[12];\n        dest[1] = (m[1] * x) + (m[5] * y) + (m[9] * z) + m[13];\n        dest[2] = (m[2] * x) + (m[6] * y) + (m[10] * z) + m[14];\n\n        return dest;\n    },\n\n    /**\n     * Transforms a homogeneous coordinate by a 4x4 matrix.\n     * @method transformPoint3\n     * @static\n     */\n    transformPoint4(m, v, dest = math.vec4()) {\n        dest[0] = m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3];\n        dest[1] = m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3];\n        dest[2] = m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3];\n        dest[3] = m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3];\n\n        return dest;\n    },\n\n\n    /**\n     * Transforms an array of three-element positions by a 4x4 matrix.\n     * @method transformPoints3\n     * @static\n     */\n    transformPoints3(m, points, points2) {\n        const result = points2 || [];\n        const len = points.length;\n        let p0;\n        let p1;\n        let p2;\n        let pi;\n\n        // cache values\n        const m0 = m[0];\n\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        let r;\n\n        for (let i = 0; i < len; ++i) {\n\n            // cache values\n            pi = points[i];\n\n            p0 = pi[0];\n            p1 = pi[1];\n            p2 = pi[2];\n\n            r = result[i] || (result[i] = [0, 0, 0]);\n\n            r[0] = (m0 * p0) + (m4 * p1) + (m8 * p2) + m12;\n            r[1] = (m1 * p0) + (m5 * p1) + (m9 * p2) + m13;\n            r[2] = (m2 * p0) + (m6 * p1) + (m10 * p2) + m14;\n            r[3] = (m3 * p0) + (m7 * p1) + (m11 * p2) + m15;\n        }\n\n        result.length = len;\n\n        return result;\n    },\n\n    /**\n     * Transforms an array of positions by a 4x4 matrix.\n     * @method transformPositions3\n     * @static\n     */\n    transformPositions3(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 3) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /**\n     * Transforms an array of positions by a 4x4 matrix.\n     * @method transformPositions4\n     * @static\n     */\n    transformPositions4(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 4) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /**\n     * Transforms a three-element vector by a 4x4 matrix.\n     * @method transformVec3\n     * @static\n     */\n    transformVec3(m, v, dest) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        dest = dest || this.vec3();\n        dest[0] = (m[0] * v0) + (m[4] * v1) + (m[8] * v2);\n        dest[1] = (m[1] * v0) + (m[5] * v1) + (m[9] * v2);\n        dest[2] = (m[2] * v0) + (m[6] * v1) + (m[10] * v2);\n        return dest;\n    },\n\n    /**\n     * Transforms a four-element vector by a 4x4 matrix.\n     * @method transformVec4\n     * @static\n     */\n    transformVec4(m, v, dest) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        dest = dest || math.vec4();\n        dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;\n        dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;\n        dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;\n        dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the x-axis\n     *\n     * @method rotateVec3X\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3X(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[0];\n        r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);\n        r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the y-axis\n     *\n     * @method rotateVec3Y\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3Y(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);\n        r[1] = p[1];\n        r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the z-axis\n     *\n     * @method rotateVec3Z\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3Z(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);\n        r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);\n        r[2] = p[2];\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Transforms a four-element vector by a 4x4 projection matrix.\n     *\n     * @method projectVec4\n     * @param {Number[]} p 3D View-space coordinate\n     * @param {Number[]} q 2D Projected coordinate\n     * @returns {Number[]} 2D Projected coordinate\n     * @static\n     */\n    projectVec4(p, q) {\n        const f = 1.0 / p[3];\n        q = q || math.vec2();\n        q[0] = v[0] * f;\n        q[1] = v[1] * f;\n        return q;\n    },\n\n    /**\n     * Unprojects a three-element vector.\n     *\n     * @method unprojectVec3\n     * @param {Number[]} p 3D Projected coordinate\n     * @param {Number[]} viewMat View matrix\n     * @returns {Number[]} projMat Projection matrix\n     * @static\n     */\n    unprojectVec3: ((() => {\n        const mat = new FloatArrayType(16);\n        const mat2 = new FloatArrayType(16);\n        const mat3 = new FloatArrayType(16);\n        return function (p, viewMat, projMat, q) {\n            return this.transformVec3(this.mulMat4(this.inverseMat4(viewMat, mat), this.inverseMat4(projMat, mat2), mat3), p, q)\n        };\n    }))(),\n\n    /**\n     * Linearly interpolates between two 3D vectors.\n     * @method lerpVec3\n     * @static\n     */\n    lerpVec3(t, t1, t2, p1, p2, dest) {\n        const result = dest || math.vec3();\n        const f = (t - t1) / (t2 - t1);\n        result[0] = p1[0] + (f * (p2[0] - p1[0]));\n        result[1] = p1[1] + (f * (p2[1] - p1[1]));\n        result[2] = p1[2] + (f * (p2[2] - p1[2]));\n        return result;\n    },\n\n\n    /**\n     * Flattens a two-dimensional array into a one-dimensional array.\n     *\n     * @method flatten\n     * @static\n     * @param {Array of Arrays} a A 2D array\n     * @returns Flattened 1D array\n     */\n    flatten(a) {\n\n        const result = [];\n\n        let i;\n        let leni;\n        let j;\n        let lenj;\n        let item;\n\n        for (i = 0, leni = a.length; i < leni; i++) {\n            item = a[i];\n            for (j = 0, lenj = item.length; j < lenj; j++) {\n                result.push(item[j]);\n            }\n        }\n\n        return result;\n    },\n\n\n    identityQuaternion(dest = math.vec4()) {\n        dest[0] = 0.0;\n        dest[1] = 0.0;\n        dest[2] = 0.0;\n        dest[3] = 1.0;\n        return dest;\n    },\n\n    /**\n     * Initializes a quaternion from Euler angles.\n     *\n     * @param {Number[]} euler The Euler angles.\n     * @param {String} order Euler angle order: \"XYZ\", \"YXZ\", \"ZXY\" etc.\n     * @param {Number[]} [dest] Destination quaternion, created by default.\n     * @returns {Number[]} The quaternion.\n     */\n    eulerToQuaternion(euler, order, dest = math.vec4()) {\n        // http://www.mathworks.com/matlabcentral/fileexchange/\n        // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n        //\tcontent/SpinCalc.m\n\n        const a = (euler[0] * math.DEGTORAD) / 2;\n        const b = (euler[1] * math.DEGTORAD) / 2;\n        const c = (euler[2] * math.DEGTORAD) / 2;\n\n        const c1 = Math.cos(a);\n        const c2 = Math.cos(b);\n        const c3 = Math.cos(c);\n        const s1 = Math.sin(a);\n        const s2 = Math.sin(b);\n        const s3 = Math.sin(c);\n\n        if (order === 'XYZ') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'YXZ') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n\n        } else if (order === 'ZXY') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'ZYX') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n\n        } else if (order === 'YZX') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'XZY') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n        }\n\n        return dest;\n    },\n\n    mat4ToQuaternion(m, dest = math.vec4()) {\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n        // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n        const m11 = m[0];\n        const m12 = m[4];\n        const m13 = m[8];\n        const m21 = m[1];\n        const m22 = m[5];\n        const m23 = m[9];\n        const m31 = m[2];\n        const m32 = m[6];\n        const m33 = m[10];\n        let s;\n\n        const trace = m11 + m22 + m33;\n\n        if (trace > 0) {\n\n            s = 0.5 / Math.sqrt(trace + 1.0);\n\n            dest[3] = 0.25 / s;\n            dest[0] = (m32 - m23) * s;\n            dest[1] = (m13 - m31) * s;\n            dest[2] = (m21 - m12) * s;\n\n        } else if (m11 > m22 && m11 > m33) {\n\n            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n\n            dest[3] = (m32 - m23) / s;\n            dest[0] = 0.25 * s;\n            dest[1] = (m12 + m21) / s;\n            dest[2] = (m13 + m31) / s;\n\n        } else if (m22 > m33) {\n\n            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n\n            dest[3] = (m13 - m31) / s;\n            dest[0] = (m12 + m21) / s;\n            dest[1] = 0.25 * s;\n            dest[2] = (m23 + m32) / s;\n\n        } else {\n\n            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n\n            dest[3] = (m21 - m12) / s;\n            dest[0] = (m13 + m31) / s;\n            dest[1] = (m23 + m32) / s;\n            dest[2] = 0.25 * s;\n        }\n\n        return dest;\n    },\n\n    vec3PairToQuaternion(u, v, dest = math.vec4()) {\n        const norm_u_norm_v = Math.sqrt(math.dotVec3(u, u) * math.dotVec3(v, v));\n        let real_part = norm_u_norm_v + math.dotVec3(u, v);\n\n        if (real_part < 0.00000001 * norm_u_norm_v) {\n\n            // If u and v are exactly opposite, rotate 180 degrees\n            // around an arbitrary orthogonal axis. Axis normalisation\n            // can happen later, when we normalise the quaternion.\n\n            real_part = 0.0;\n\n            if (Math.abs(u[0]) > Math.abs(u[2])) {\n\n                dest[0] = -u[1];\n                dest[1] = u[0];\n                dest[2] = 0;\n\n            } else {\n                dest[0] = 0;\n                dest[1] = -u[2];\n                dest[2] = u[1]\n            }\n\n        } else {\n\n            // Otherwise, build quaternion the standard way.\n            math.cross3Vec3(u, v, dest);\n        }\n\n        dest[3] = real_part;\n\n        return math.normalizeQuaternion(dest);\n    },\n\n    angleAxisToQuaternion(angleAxis, dest = math.vec4()) {\n        const halfAngle = angleAxis[3] / 2.0;\n        const fsin = Math.sin(halfAngle);\n        dest[0] = fsin * angleAxis[0];\n        dest[1] = fsin * angleAxis[1];\n        dest[2] = fsin * angleAxis[2];\n        dest[3] = Math.cos(halfAngle);\n        return dest;\n    },\n\n    quaternionToEuler: ((() => {\n        const mat = new FloatArrayType(16);\n        return (q, order, dest) => {\n            dest = dest || math.vec3();\n            math.quaternionToRotationMat4(q, mat);\n            math.mat4ToEuler(mat, order, dest);\n            return dest;\n        };\n    }))(),\n\n    mulQuaternions(p, q, dest = math.vec4()) {\n        const p0 = p[0];\n        const p1 = p[1];\n        const p2 = p[2];\n        const p3 = p[3];\n        const q0 = q[0];\n        const q1 = q[1];\n        const q2 = q[2];\n        const q3 = q[3];\n        dest[0] = p3 * q0 + p0 * q3 + p1 * q2 - p2 * q1;\n        dest[1] = p3 * q1 + p1 * q3 + p2 * q0 - p0 * q2;\n        dest[2] = p3 * q2 + p2 * q3 + p0 * q1 - p1 * q0;\n        dest[3] = p3 * q3 - p0 * q0 - p1 * q1 - p2 * q2;\n        return dest;\n    },\n\n    vec3ApplyQuaternion(q, vec, dest = math.vec3()) {\n        const x = vec[0];\n        const y = vec[1];\n        const z = vec[2];\n\n        const qx = q[0];\n        const qy = q[1];\n        const qz = q[2];\n        const qw = q[3];\n\n        // calculate quat * vector\n\n        const ix = qw * x + qy * z - qz * y;\n        const iy = qw * y + qz * x - qx * z;\n        const iz = qw * z + qx * y - qy * x;\n        const iw = -qx * x - qy * y - qz * z;\n\n        // calculate result * inverse quat\n\n        dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n        dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n        dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n        return dest;\n    },\n\n    quaternionToMat4(q, dest) {\n\n        dest = math.identityMat4(dest);\n\n        const q0 = q[0];  //x\n        const q1 = q[1];  //y\n        const q2 = q[2];  //z\n        const q3 = q[3];  //w\n\n        const tx = 2.0 * q0;\n        const ty = 2.0 * q1;\n        const tz = 2.0 * q2;\n\n        const twx = tx * q3;\n        const twy = ty * q3;\n        const twz = tz * q3;\n\n        const txx = tx * q0;\n        const txy = ty * q0;\n        const txz = tz * q0;\n\n        const tyy = ty * q1;\n        const tyz = tz * q1;\n        const tzz = tz * q2;\n\n        dest[0] = 1.0 - (tyy + tzz);\n        dest[1] = txy + twz;\n        dest[2] = txz - twy;\n\n        dest[4] = txy - twz;\n        dest[5] = 1.0 - (txx + tzz);\n        dest[6] = tyz + twx;\n\n        dest[8] = txz + twy;\n        dest[9] = tyz - twx;\n\n        dest[10] = 1.0 - (txx + tyy);\n\n        return dest;\n    },\n\n    quaternionToRotationMat4(q, m) {\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n\n        m[0] = 1 - (yy + zz);\n        m[4] = xy - wz;\n        m[8] = xz + wy;\n\n        m[1] = xy + wz;\n        m[5] = 1 - (xx + zz);\n        m[9] = yz - wx;\n\n        m[2] = xz - wy;\n        m[6] = yz + wx;\n        m[10] = 1 - (xx + yy);\n\n        // last column\n        m[3] = 0;\n        m[7] = 0;\n        m[11] = 0;\n\n        // bottom row\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = 0;\n        m[15] = 1;\n\n        return m;\n    },\n\n    normalizeQuaternion(q, dest = q) {\n        const len = math.lenVec4([q[0], q[1], q[2], q[3]]);\n        dest[0] = q[0] / len;\n        dest[1] = q[1] / len;\n        dest[2] = q[2] / len;\n        dest[3] = q[3] / len;\n        return dest;\n    },\n\n    conjugateQuaternion(q, dest = q) {\n        dest[0] = -q[0];\n        dest[1] = -q[1];\n        dest[2] = -q[2];\n        dest[3] = q[3];\n        return dest;\n    },\n\n    inverseQuaternion(q, dest) {\n        return math.normalizeQuaternion(math.conjugateQuaternion(q, dest));\n    },\n\n    quaternionToAngleAxis(q, angleAxis = math.vec4()) {\n        q = math.normalizeQuaternion(q, tempVec4);\n        const q3 = q[3];\n        const angle = 2 * Math.acos(q3);\n        const s = Math.sqrt(1 - q3 * q3);\n        if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt\n            angleAxis[0] = q[0];\n            angleAxis[1] = q[1];\n            angleAxis[2] = q[2];\n        } else {\n            angleAxis[0] = q[0] / s;\n            angleAxis[1] = q[1] / s;\n            angleAxis[2] = q[2] / s;\n        }\n        angleAxis[3] = angle; // * 57.295779579;\n        return angleAxis;\n    },\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Boundaries\n    //------------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Returns a new, uninitialized 3D axis-aligned bounding box.\n     *\n     * @private\n     */\n    AABB3(values) {\n        return new FloatArrayType(values || 6);\n    },\n\n    /**\n     * Returns a new, uninitialized 2D axis-aligned bounding box.\n     *\n     * @private\n     */\n    AABB2(values) {\n        return new FloatArrayType(values || 4);\n    },\n\n    /**\n     * Returns a new, uninitialized 3D oriented bounding box (OBB).\n     *\n     * @private\n     */\n    OBB3(values) {\n        return new FloatArrayType(values || 32);\n    },\n\n    /**\n     * Returns a new, uninitialized 2D oriented bounding box (OBB).\n     *\n     * @private\n     */\n    OBB2(values) {\n        return new FloatArrayType(values || 16);\n    },\n\n    /** Returns a new 3D bounding sphere */\n    Sphere3(x, y, z, r) {\n        return new FloatArrayType([x, y, z, r]);\n    },\n\n    /**\n     * Transforms an OBB3 by a 4x4 matrix.\n     *\n     * @private\n     */\n    transformOBB3(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 4) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /** Returns true if the first AABB contains the second AABB.\n     * @param aabb1\n     * @param aabb2\n     * @returns {boolean}\n     */\n    containsAABB3: function (aabb1, aabb2) {\n        const result = (\n            aabb1[0] <= aabb2[0] && aabb2[3] <= aabb1[3] &&\n            aabb1[1] <= aabb2[1] && aabb2[4] <= aabb1[4] &&\n            aabb1[2] <= aabb2[2] && aabb2[5] <= aabb1[5]);\n        return result;\n    },\n\n    /**\n     * Gets the diagonal size of an AABB3 given as minima and maxima.\n     *\n     * @private\n     */\n    getAABB3Diag: ((() => {\n\n        const min = new FloatArrayType(3);\n        const max = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return aabb => {\n\n            min[0] = aabb[0];\n            min[1] = aabb[1];\n            min[2] = aabb[2];\n\n            max[0] = aabb[3];\n            max[1] = aabb[4];\n            max[2] = aabb[5];\n\n            math.subVec3(max, min, tempVec3);\n\n            return Math.abs(math.lenVec3(tempVec3));\n        };\n    }))(),\n\n    /**\n     * Get a diagonal boundary size that is symmetrical about the given point.\n     *\n     * @private\n     */\n    getAABB3DiagPoint: ((() => {\n\n        const min = new FloatArrayType(3);\n        const max = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return (aabb, p) => {\n\n            min[0] = aabb[0];\n            min[1] = aabb[1];\n            min[2] = aabb[2];\n\n            max[0] = aabb[3];\n            max[1] = aabb[4];\n            max[2] = aabb[5];\n\n            const diagVec = math.subVec3(max, min, tempVec3);\n\n            const xneg = p[0] - aabb[0];\n            const xpos = aabb[3] - p[0];\n            const yneg = p[1] - aabb[1];\n            const ypos = aabb[4] - p[1];\n            const zneg = p[2] - aabb[2];\n            const zpos = aabb[5] - p[2];\n\n            diagVec[0] += (xneg > xpos) ? xneg : xpos;\n            diagVec[1] += (yneg > ypos) ? yneg : ypos;\n            diagVec[2] += (zneg > zpos) ? zneg : zpos;\n\n            return Math.abs(math.lenVec3(diagVec));\n        };\n    }))(),\n\n    /**\n     * Gets the center of an AABB.\n     *\n     * @private\n     */\n    getAABB3Center(aabb, dest) {\n        const r = dest || math.vec3();\n\n        r[0] = (aabb[0] + aabb[3]) / 2;\n        r[1] = (aabb[1] + aabb[4]) / 2;\n        r[2] = (aabb[2] + aabb[5]) / 2;\n\n        return r;\n    },\n\n    /**\n     * Gets the center of a 2D AABB.\n     *\n     * @private\n     */\n    getAABB2Center(aabb, dest) {\n        const r = dest || math.vec2();\n\n        r[0] = (aabb[2] + aabb[0]) / 2;\n        r[1] = (aabb[3] + aabb[1]) / 2;\n\n        return r;\n    },\n\n    /**\n     * Collapses a 3D axis-aligned boundary, ready to expand to fit 3D points.\n     * Creates new AABB if none supplied.\n     *\n     * @private\n     */\n    collapseAABB3(aabb = math.AABB3()) {\n        aabb[0] = math.MAX_DOUBLE;\n        aabb[1] = math.MAX_DOUBLE;\n        aabb[2] = math.MAX_DOUBLE;\n        aabb[3] = -math.MAX_DOUBLE;\n        aabb[4] = -math.MAX_DOUBLE;\n        aabb[5] = -math.MAX_DOUBLE;\n\n        return aabb;\n    },\n\n    /**\n     * Converts an axis-aligned 3D boundary into an oriented boundary consisting of\n     * an array of eight 3D positions, one for each corner of the boundary.\n     *\n     * @private\n     */\n    AABB3ToOBB3(aabb, obb = math.OBB3()) {\n        obb[0] = aabb[0];\n        obb[1] = aabb[1];\n        obb[2] = aabb[2];\n        obb[3] = 1;\n\n        obb[4] = aabb[3];\n        obb[5] = aabb[1];\n        obb[6] = aabb[2];\n        obb[7] = 1;\n\n        obb[8] = aabb[3];\n        obb[9] = aabb[4];\n        obb[10] = aabb[2];\n        obb[11] = 1;\n\n        obb[12] = aabb[0];\n        obb[13] = aabb[4];\n        obb[14] = aabb[2];\n        obb[15] = 1;\n\n        obb[16] = aabb[0];\n        obb[17] = aabb[1];\n        obb[18] = aabb[5];\n        obb[19] = 1;\n\n        obb[20] = aabb[3];\n        obb[21] = aabb[1];\n        obb[22] = aabb[5];\n        obb[23] = 1;\n\n        obb[24] = aabb[3];\n        obb[25] = aabb[4];\n        obb[26] = aabb[5];\n        obb[27] = 1;\n\n        obb[28] = aabb[0];\n        obb[29] = aabb[4];\n        obb[30] = aabb[5];\n        obb[31] = 1;\n\n        return obb;\n    },\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n     *\n     * @private\n     */\n    positions3ToAABB3: ((() => {\n\n        const p = new FloatArrayType(3);\n\n        return (positions, aabb, positionsDecodeMatrix) => {\n            aabb = aabb || math.AABB3();\n\n            let xmin = math.MAX_DOUBLE;\n            let ymin = math.MAX_DOUBLE;\n            let zmin = math.MAX_DOUBLE;\n            let xmax = -math.MAX_DOUBLE;\n            let ymax = -math.MAX_DOUBLE;\n            let zmax = -math.MAX_DOUBLE;\n\n            let x;\n            let y;\n            let z;\n\n            for (let i = 0, len = positions.length; i < len; i += 3) {\n\n                if (positionsDecodeMatrix) {\n\n                    p[0] = positions[i + 0];\n                    p[1] = positions[i + 1];\n                    p[2] = positions[i + 2];\n\n                    math.decompressPosition(p, positionsDecodeMatrix, p);\n\n                    x = p[0];\n                    y = p[1];\n                    z = p[2];\n\n                } else {\n                    x = positions[i + 0];\n                    y = positions[i + 1];\n                    z = positions[i + 2];\n                }\n\n                if (x < xmin) {\n                    xmin = x;\n                }\n\n                if (y < ymin) {\n                    ymin = y;\n                }\n\n                if (z < zmin) {\n                    zmin = z;\n                }\n\n                if (x > xmax) {\n                    xmax = x;\n                }\n\n                if (y > ymax) {\n                    ymax = y;\n                }\n\n                if (z > zmax) {\n                    zmax = z;\n                }\n            }\n\n            aabb[0] = xmin;\n            aabb[1] = ymin;\n            aabb[2] = zmin;\n            aabb[3] = xmax;\n            aabb[4] = ymax;\n            aabb[5] = zmax;\n\n            return aabb;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n     *\n     * @private\n     */\n    OBB3ToAABB3(obb, aabb = math.AABB3()) {\n        let xmin = math.MAX_DOUBLE;\n        let ymin = math.MAX_DOUBLE;\n        let zmin = math.MAX_DOUBLE;\n        let xmax = -math.MAX_DOUBLE;\n        let ymax = -math.MAX_DOUBLE;\n        let zmax = -math.MAX_DOUBLE;\n\n        let x;\n        let y;\n        let z;\n\n        for (let i = 0, len = obb.length; i < len; i += 4) {\n\n            x = obb[i + 0];\n            y = obb[i + 1];\n            z = obb[i + 2];\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (z < zmin) {\n                zmin = z;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n\n            if (z > zmax) {\n                zmax = z;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = zmin;\n        aabb[3] = xmax;\n        aabb[4] = ymax;\n        aabb[5] = zmax;\n\n        return aabb;\n    },\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the given 3D points.\n     *\n     * @private\n     */\n    points3ToAABB3(points, aabb = math.AABB3()) {\n        let xmin = math.MAX_DOUBLE;\n        let ymin = math.MAX_DOUBLE;\n        let zmin = math.MAX_DOUBLE;\n        let xmax = -math.MAX_DOUBLE;\n        let ymax = -math.MAX_DOUBLE;\n        let zmax = -math.MAX_DOUBLE;\n\n        let x;\n        let y;\n        let z;\n\n        for (let i = 0, len = points.length; i < len; i++) {\n\n            x = points[i][0];\n            y = points[i][1];\n            z = points[i][2];\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (z < zmin) {\n                zmin = z;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n\n            if (z > zmax) {\n                zmax = z;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = zmin;\n        aabb[3] = xmax;\n        aabb[4] = ymax;\n        aabb[5] = zmax;\n\n        return aabb;\n    },\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D points.\n     *\n     * @private\n     */\n    points3ToSphere3: ((() => {\n\n        const tempVec3 = new FloatArrayType(3);\n\n        return (points, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const numPoints = points.length;\n\n            for (i = 0; i < numPoints; i++) {\n                x += points[i][0];\n                y += points[i][1];\n                z += points[i][2];\n            }\n\n            sphere[0] = x / numPoints;\n            sphere[1] = y / numPoints;\n            sphere[2] = z / numPoints;\n\n            let radius = 0;\n            let dist;\n\n            for (i = 0; i < numPoints; i++) {\n\n                dist = Math.abs(math.lenVec3(math.subVec3(points[i], sphere, tempVec3)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D positions.\n     *\n     * @private\n     */\n    positions3ToSphere3: ((() => {\n\n        const tempVec3a = new FloatArrayType(3);\n        const tempVec3b = new FloatArrayType(3);\n\n        return (positions, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const lenPositions = positions.length;\n            let radius = 0;\n\n            for (i = 0; i < lenPositions; i += 3) {\n                x += positions[i];\n                y += positions[i + 1];\n                z += positions[i + 2];\n            }\n\n            const numPositions = lenPositions / 3;\n\n            sphere[0] = x / numPositions;\n            sphere[1] = y / numPositions;\n            sphere[2] = z / numPositions;\n\n            let dist;\n\n            for (i = 0; i < lenPositions; i += 3) {\n\n                tempVec3a[0] = positions[i];\n                tempVec3a[1] = positions[i + 1];\n                tempVec3a[2] = positions[i + 2];\n\n                dist = Math.abs(math.lenVec3(math.subVec3(tempVec3a, sphere, tempVec3b)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D points.\n     *\n     * @private\n     */\n    OBB3ToSphere3: ((() => {\n\n        const point = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return (points, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const lenPoints = points.length;\n            const numPoints = lenPoints / 4;\n\n            for (i = 0; i < lenPoints; i += 4) {\n                x += points[i + 0];\n                y += points[i + 1];\n                z += points[i + 2];\n            }\n\n            sphere[0] = x / numPoints;\n            sphere[1] = y / numPoints;\n            sphere[2] = z / numPoints;\n\n            let radius = 0;\n            let dist;\n\n            for (i = 0; i < lenPoints; i += 4) {\n\n                point[0] = points[i + 0];\n                point[1] = points[i + 1];\n                point[2] = points[i + 2];\n\n                dist = Math.abs(math.lenVec3(math.subVec3(point, sphere, tempVec3)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Gets the center of a bounding sphere.\n     *\n     * @private\n     */\n    getSphere3Center(sphere, dest = math.vec3()) {\n        dest[0] = sphere[0];\n        dest[1] = sphere[1];\n        dest[2] = sphere[2];\n\n        return dest;\n    },\n\n    /**\n     * Expands the first axis-aligned 3D boundary to enclose the second, if required.\n     *\n     * @private\n     */\n    expandAABB3(aabb1, aabb2) {\n\n        if (aabb1[0] > aabb2[0]) {\n            aabb1[0] = aabb2[0];\n        }\n\n        if (aabb1[1] > aabb2[1]) {\n            aabb1[1] = aabb2[1];\n        }\n\n        if (aabb1[2] > aabb2[2]) {\n            aabb1[2] = aabb2[2];\n        }\n\n        if (aabb1[3] < aabb2[3]) {\n            aabb1[3] = aabb2[3];\n        }\n\n        if (aabb1[4] < aabb2[4]) {\n            aabb1[4] = aabb2[4];\n        }\n\n        if (aabb1[5] < aabb2[5]) {\n            aabb1[5] = aabb2[5];\n        }\n\n        return aabb1;\n    },\n\n    /**\n     * Expands an axis-aligned 3D boundary to enclose the given point, if needed.\n     *\n     * @private\n     */\n    expandAABB3Point3(aabb, p) {\n\n        if (aabb[0] > p[0]) {\n            aabb[0] = p[0];\n        }\n\n        if (aabb[1] > p[1]) {\n            aabb[1] = p[1];\n        }\n\n        if (aabb[2] > p[2]) {\n            aabb[2] = p[2];\n        }\n\n        if (aabb[3] < p[0]) {\n            aabb[3] = p[0];\n        }\n\n        if (aabb[4] < p[1]) {\n            aabb[4] = p[1];\n        }\n\n        if (aabb[5] < p[2]) {\n            aabb[5] = p[2];\n        }\n\n        return aabb;\n    },\n\n    /**\n     * Calculates the normal vector of a triangle.\n     *\n     * @private\n     */\n    triangleNormal(a, b, c, normal = math.vec3()) {\n        const p1x = b[0] - a[0];\n        const p1y = b[1] - a[1];\n        const p1z = b[2] - a[2];\n\n        const p2x = c[0] - a[0];\n        const p2y = c[1] - a[1];\n        const p2z = c[2] - a[2];\n\n        const p3x = p1y * p2z - p1z * p2y;\n        const p3y = p1z * p2x - p1x * p2z;\n        const p3z = p1x * p2y - p1y * p2x;\n\n        const mag = Math.sqrt(p3x * p3x + p3y * p3y + p3z * p3z);\n        if (mag === 0) {\n            normal[0] = 0;\n            normal[1] = 0;\n            normal[2] = 0;\n        } else {\n            normal[0] = p3x / mag;\n            normal[1] = p3y / mag;\n            normal[2] = p3z / mag;\n        }\n\n        return normal\n    }\n};\n\nexport {math};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/lib/math.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 318,
    "kind": "variable",
    "name": "doublePrecision",
    "memberof": "src/lib/math.js",
    "static": true,
    "longname": "src/lib/math.js~doublePrecision",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 319,
    "kind": "variable",
    "name": "FloatArrayType",
    "memberof": "src/lib/math.js",
    "static": true,
    "longname": "src/lib/math.js~FloatArrayType",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 320,
    "kind": "variable",
    "name": "tempMat1",
    "memberof": "src/lib/math.js",
    "static": true,
    "longname": "src/lib/math.js~tempMat1",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 321,
    "kind": "variable",
    "name": "tempMat2",
    "memberof": "src/lib/math.js",
    "static": true,
    "longname": "src/lib/math.js~tempMat2",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 322,
    "kind": "variable",
    "name": "tempVec4",
    "memberof": "src/lib/math.js",
    "static": true,
    "longname": "src/lib/math.js~tempVec4",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 323,
    "kind": "variable",
    "name": "math",
    "memberof": "src/lib/math.js",
    "static": true,
    "longname": "src/lib/math.js~math",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/lib/math.js",
    "importStyle": "{math}",
    "description": "",
    "lineNumber": 13,
    "ignore": true,
    "type": {
      "types": [
        "{\"MIN_DOUBLE\": *, \"MAX_DOUBLE\": *, \"DEGTORAD\": number, \"RADTODEG\": number, \"vec2\": function, \"vec3\": function, \"vec4\": function, \"mat3\": function, \"mat3ToMat4\": function, \"mat4\": function, \"mat4ToMat3\": function, \"createUUID\": *, \"clamp\": function, \"fmod\": function, \"negateVec4\": function, \"addVec4\": function, \"addVec4Scalar\": function, \"addVec3\": function, \"addVec3Scalar\": function, \"subVec4\": function, \"subVec3\": function, \"subVec2\": function, \"subVec4Scalar\": function, \"subScalarVec4\": function, \"mulVec4\": function, \"mulVec4Scalar\": function, \"mulVec3Scalar\": function, \"mulVec2Scalar\": function, \"divVec3\": function, \"divVec4\": function, \"divScalarVec3\": function, \"divVec3Scalar\": function, \"divVec4Scalar\": function, \"divScalarVec4\": function, \"dotVec4\": function, \"cross3Vec4\": function, \"cross3Vec3\": function, \"sqLenVec4\": function, \"lenVec4\": function, \"dotVec3\": function, \"dotVec2\": function, \"sqLenVec3\": function, \"sqLenVec2\": function, \"lenVec3\": function, \"distVec3\": *, \"lenVec2\": function, \"distVec2\": *, \"rcpVec3\": function, \"normalizeVec4\": function, \"normalizeVec3\": function, \"normalizeVec2\": function, \"angleVec3\": function, \"vec3FromMat4Scale\": *, \"vecToArray\": *, \"xyzArrayToObject\": function, \"xyzObjectToArray\": function, \"dupMat4\": function, \"mat4To3\": function, \"m4s\": function, \"setMat4ToZeroes\": function, \"setMat4ToOnes\": function, \"diagonalMat4v\": function, \"diagonalMat4c\": function, \"diagonalMat4s\": function, \"identityMat4\": function, \"identityMat3\": function, \"isIdentityMat4\": function, \"negateMat4\": function, \"addMat4\": function, \"addMat4Scalar\": function, \"addScalarMat4\": function, \"subMat4\": function, \"subMat4Scalar\": function, \"subScalarMat4\": function, \"mulMat4\": function, \"mulMat3\": function, \"mulMat4Scalar\": function, \"mulMat4v4\": function, \"transposeMat4\": function, \"transposeMat3\": function, \"determinantMat4\": function, \"inverseMat4\": function, \"traceMat4\": function, \"translationMat4v\": function, \"translationMat3v\": function, \"translationMat4c\": *, \"translationMat4s\": function, \"translateMat4v\": function, \"OLDtranslateMat4c\": function, \"translateMat4c\": function, \"rotationMat4v\": function, \"rotationMat4c\": function, \"scalingMat4v\": function, \"scalingMat3v\": function, \"scalingMat4c\": *, \"scaleMat4c\": function, \"scaleMat4v\": function, \"scalingMat4s\": function, \"rotationTranslationMat4\": function, \"mat4ToEuler\": function, \"composeMat4\": function, \"decomposeMat4\": *, \"lookAtMat4v\": function, \"lookAtMat4c\": function, \"orthoMat4c\": function, \"frustumMat4v\": function, \"frustumMat4\": function, \"perspectiveMat4\": function, \"transformPoint3\": function, \"transformPoint4\": function, \"transformPoints3\": function, \"transformPositions3\": function, \"transformPositions4\": function, \"transformVec3\": function, \"transformVec4\": function, \"rotateVec3X\": function, \"rotateVec3Y\": function, \"rotateVec3Z\": function, \"projectVec4\": function, \"unprojectVec3\": *, \"lerpVec3\": function, \"flatten\": function, \"identityQuaternion\": function, \"eulerToQuaternion\": function, \"mat4ToQuaternion\": function, \"vec3PairToQuaternion\": function, \"angleAxisToQuaternion\": function, \"quaternionToEuler\": *, \"mulQuaternions\": function, \"vec3ApplyQuaternion\": function, \"quaternionToMat4\": function, \"quaternionToRotationMat4\": function, \"normalizeQuaternion\": function, \"conjugateQuaternion\": function, \"inverseQuaternion\": function, \"quaternionToAngleAxis\": function, \"AABB3\": function, \"AABB2\": function, \"OBB3\": function, \"OBB2\": function, \"Sphere3\": function, \"transformOBB3\": function, \"containsAABB3\": *, \"getAABB3Diag\": *, \"getAABB3DiagPoint\": *, \"getAABB3Center\": function, \"getAABB2Center\": function, \"collapseAABB3\": function, \"AABB3ToOBB3\": function, \"positions3ToAABB3\": *, \"OBB3ToAABB3\": function, \"points3ToAABB3\": function, \"points3ToSphere3\": *, \"positions3ToSphere3\": *, \"OBB3ToSphere3\": *, \"getSphere3Center\": function, \"expandAABB3\": function, \"expandAABB3Point3\": function, \"triangleNormal\": function}"
      ]
    }
  },
  {
    "__docId__": 324,
    "kind": "file",
    "name": "src/lib/mergeVertices.js",
    "content": "/**\n * Given geometry defined as an array of positions, optional normals, option uv and an array of indices, returns\n * modified arrays that have duplicate vertices removed.\n *\n * @private\n */\nfunction mergeVertices(positions, indices, mergedPositions, mergedIndices) {\n    const positionsMap = {};\n    const indicesLookup = [];\n    const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n    const precision = 10 ** precisionPoints;\n    let uvi = 0;\n    for (let i = 0, len = positions.length; i < len; i += 3) {\n        const vx = positions[i];\n        const vy = positions[i + 1];\n        const vz = positions[i + 2];\n        const key = `${Math.round(vx * precision)}_${Math.round(vy * precision)}_${Math.round(vz * precision)}`;\n        if (positionsMap[key] === undefined) {\n            positionsMap[key] = mergedPositions.length / 3;\n            mergedPositions.push(vx);\n            mergedPositions.push(vy);\n            mergedPositions.push(vz);\n        }\n        indicesLookup[i / 3] = positionsMap[key];\n        uvi += 2;\n    }\n    for (let i = 0, len = indices.length; i < len; i++) {\n        mergedIndices[i] = indicesLookup[indices[i]];\n    }\n}\n\nexport {mergeVertices};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/lib/mergeVertices.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 325,
    "kind": "function",
    "name": "mergeVertices",
    "memberof": "src/lib/mergeVertices.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/mergeVertices.js~mergeVertices",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/lib/mergeVertices.js",
    "importStyle": "{mergeVertices}",
    "description": "Given geometry defined as an array of positions, optional normals, option uv and an array of indices, returns\nmodified arrays that have duplicate vertices removed.",
    "lineNumber": 7,
    "ignore": true,
    "params": [
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "indices",
        "types": [
          "*"
        ]
      },
      {
        "name": "mergedPositions",
        "types": [
          "*"
        ]
      },
      {
        "name": "mergedIndices",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 326,
    "kind": "file",
    "name": "src/parsers/ZIPArchive.js",
    "content": "import JSZip from \"jszip\";\n\n/**\n * @private\n */\nclass ZIPArchive {\n\n    constructor(domParser) {\n        this._zip = new JSZip();\n        this._domParser = domParser;\n    }\n\n    init(blob) {\n        return this._zip.loadAsync(blob);\n    }\n\n    async getFile(src) {\n        const fileText = await this._zip.file(src).async(\"string\");\n        if (!fileText) {\n            const errMsg = \"ZIP entry not found: \" + src;\n            console.error(errMsg);\n            return;\n        }\n        const xmlDoc = this._domParser.parseFromString(fileText, \"text/xml\");\n        const json = xmlToJSON(xmlDoc, {});\n        return {xmlDoc, json};\n    }\n\n    destroy() {\n\n    }\n}\n\nfunction xmlToJSON(node, attributeRenamer) {\n    if (node.nodeType === node.TEXT_NODE) {\n        const v = node.nodeValue;\n        if (v.match(/^\\s+$/) === null) {\n            return v;\n        }\n    } else if (node.nodeType === node.ELEMENT_NODE ||\n        node.nodeType === node.DOCUMENT_NODE) {\n        const json = {type: node.nodeName, children: []};\n        if (node.nodeType === node.ELEMENT_NODE) {\n            for (let i = 0, len = node.attributes.length; i < len; i++) {\n                const attribute = node.attributes[i];\n                const nm = attributeRenamer[attribute.nodeName] || attribute.nodeName;\n                json[nm] = attribute.nodeValue;\n            }\n        }\n        for (let i = 0, len = node.childNodes.length; i < len; i++) {\n            const item = node.childNodes[i];\n            const jsonPortion = xmlToJSON(item, attributeRenamer);\n            if (jsonPortion) {\n                json.children.push(jsonPortion);\n            }\n        }\n        return json;\n    }\n}\n\nexport {ZIPArchive};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/parsers/ZIPArchive.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 327,
    "kind": "function",
    "name": "xmlToJSON",
    "memberof": "src/parsers/ZIPArchive.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/ZIPArchive.js~xmlToJSON",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/ZIPArchive.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "params": [
      {
        "name": "node",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributeRenamer",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 328,
    "kind": "class",
    "name": "ZIPArchive",
    "memberof": "src/parsers/ZIPArchive.js",
    "static": true,
    "longname": "src/parsers/ZIPArchive.js~ZIPArchive",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/parsers/ZIPArchive.js",
    "importStyle": "{ZIPArchive}",
    "description": "",
    "lineNumber": 6,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 329,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/parsers/ZIPArchive.js~ZIPArchive",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/parsers/ZIPArchive.js~ZIPArchive#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 8,
    "undocument": true
  },
  {
    "__docId__": 330,
    "kind": "member",
    "name": "_zip",
    "memberof": "src/parsers/ZIPArchive.js~ZIPArchive",
    "static": false,
    "longname": "src/parsers/ZIPArchive.js~ZIPArchive#_zip",
    "access": "private",
    "description": null,
    "lineNumber": 9,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 331,
    "kind": "member",
    "name": "_domParser",
    "memberof": "src/parsers/ZIPArchive.js~ZIPArchive",
    "static": false,
    "longname": "src/parsers/ZIPArchive.js~ZIPArchive#_domParser",
    "access": "private",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 332,
    "kind": "method",
    "name": "init",
    "memberof": "src/parsers/ZIPArchive.js~ZIPArchive",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/parsers/ZIPArchive.js~ZIPArchive#init",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "params": [
      {
        "name": "blob",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 333,
    "kind": "method",
    "name": "getFile",
    "memberof": "src/parsers/ZIPArchive.js~ZIPArchive",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/parsers/ZIPArchive.js~ZIPArchive#getFile",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "params": [
      {
        "name": "src",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"xmlDoc\": *, \"json\": *}"
      ]
    }
  },
  {
    "__docId__": 334,
    "kind": "method",
    "name": "destroy",
    "memberof": "src/parsers/ZIPArchive.js~ZIPArchive",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/parsers/ZIPArchive.js~ZIPArchive#destroy",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 335,
    "kind": "file",
    "name": "src/parsers/parse3DXMLIntoXKTModel.js",
    "content": "import {ZIPArchive} from \"./ZIPArchive.js\";\nimport {math} from \"../lib/math.js\";\n\nconst supportedSchemas = [\"4.2\"];\n\n/**\n * @desc Loads 3DXML into an {@link XKTModel}.\n *\n * Supports 3DXML Schema 4.2.\n *\n * @param {Object} params Parsing parameters.\n * @param {ArrayBuffer} params.data 3DXML BLOB data.\n * @param {DOMParser} params.domParser A DOMParser implementation (eg. ````xmldom````), required when\n * we're not running in a browser and ````window.DOMParser```` is not available.\n * @param {XKTModel} params.xktModel XKTModel to parse into.\n * @param {Boolean} [params.autoNormals=false] When true, the parser will ignore the 3DXML geometry normals, and the 3DXML\n * data will rely on the xeokit ````Viewer```` to automatically generate them. This has the limitation that the\n * normals will be face-aligned, and therefore the ````Viewer```` will only be able to render a flat-shaded representation\n * of the 3DXML model. This is ````false```` by default because CAD models tend to prefer smooth shading.\n * @param {Object} [params.stats] Collects statistics.\n * @param {function} [params.log] Logging callback.\n */\nfunction parse3DXMLIntoXKTModel({data, domParser, xktModel, autoNormals = false, stats = {}, log}) {\n\n    return new Promise(function (resolve, reject) {\n\n        const isBrowser = (typeof window !== 'undefined');\n\n        if (isBrowser) {\n            domParser = new DOMParser();\n\n        } else if (!domParser) {\n            reject(\"Config expected: domParser (needed when running in node.js)\");\n            return;\n        }\n\n        if (!data) {\n            reject(\"Config expected: data\");\n            return;\n        }\n\n        if (!xktModel) {\n            reject(\"Config expected: xktModel\");\n            return;\n        }\n\n        const zipArchive = new ZIPArchive(domParser);\n\n        zipArchive.init(data).then(() => {\n\n            const rootMetaObjectId = math.createUUID();\n\n            xktModel.createMetaObject({\n                metaObjectId: rootMetaObjectId,\n                metaObjectType: \"Model\",\n                metaObjectName: \"Model\"\n            });\n\n            const modelMetaObjectId = math.createUUID();\n\n            xktModel.createMetaObject({\n                metaObjectId: modelMetaObjectId,\n                metaObjectType: \"3DXML\",\n                metaObjectName: \"3DXML\",\n                parentMetaObjectId: rootMetaObjectId\n            });\n\n            const ctx = {\n                rootMetaObjectId: modelMetaObjectId,\n                zipArchive: zipArchive,\n                edgeThreshold: 10,\n                xktModel: xktModel,\n                autoNormals: autoNormals,\n                info: {\n                    references: {}\n                },\n                log: (msg) => {\n                    if (log) {\n                        log(msg);\n                    }\n                },\n                warn: (msg) => {\n                    if (log) {\n                        log(\"Warning: \" + msg);\n                    }\n                },\n                error: (msg) => {\n                    if (log) {\n                        log(\"Error: \" + msg);\n                    }\n                },\n                nextId: 0,\n                materials: {},\n                stats: {\n                    numObjects: 0,\n                    numGeometries: 0,\n                    numTriangles: 0,\n                    numVertices: 0,\n\n                    sourceFormat: \"3DXML\",\n                    schemaVersion: \"\",\n                    title: \"\",\n                    author: \"\",\n                    created: \"\"\n                }\n            };\n\n            parseDocument(ctx).then(() => {\n                ctx.log(\"Converted drawable objects: \" + ctx.stats.numObjects);\n                ctx.log(\"Converted geometries: \" + ctx.stats.numGeometries);\n                ctx.log(\"Converted triangles: \" + ctx.stats.numTriangles);\n                ctx.log(\"Converted vertices: \" + ctx.stats.numVertices);\n\n                if (stats) {\n                    stats.numTriangles = ctx.stats.numTriangles;\n                    stats.numVertices = ctx.stats.numVertices;\n                    stats.numObjects = ctx.stats.numObjects;\n                    stats.numGeometries = ctx.stats.numGeometries;\n                }\n\n                resolve();\n            });\n\n\n        }, (errMsg) => {\n            reject(errMsg);\n        });\n    });\n}\n\nasync function parseDocument(ctx) {\n    const files = await ctx.zipArchive.getFile(\"Manifest.xml\");\n    const node = files.json;\n    const children = node.children;\n    for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        switch (child.type) {\n            case \"Manifest\":\n                await parseManifest(ctx, child);\n                break;\n        }\n    }\n}\n\nasync function parseManifest(ctx, manifest) {\n    const children = manifest.children;\n    for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        switch (child.type) {\n            case \"Root\":\n                const rootFileSrc = child.children[0];\n                const files = await ctx.zipArchive.getFile(rootFileSrc);\n                const json = files.json;\n                await parseRoot(ctx, json);\n                break;\n        }\n    }\n}\n\nasync function parseRoot(ctx, node) {\n    const children = node.children;\n    for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        switch (child.type) {\n            case \"Model_3dxml\":\n                await parseModel(ctx, child);\n                break;\n        }\n    }\n}\n\nasync function parseModel(ctx, node) {\n    const children = node.children;\n    for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        switch (child.type) {\n            case \"Header\":\n                parseHeader(ctx, child);\n                break;\n            case \"ProductStructure\":\n                await parseProductStructure(ctx, child);\n                break;\n            case \"DefaultView\":\n                parseDefaultView(ctx, child);\n                break;\n        }\n    }\n}\n\nfunction parseHeader(ctx, node) {\n    const children = node.children;\n    const metaData = {};\n    for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        switch (child.type) {\n            case \"SchemaVersion\":\n                ctx.stats.schemaVersion = child.children[0];\n                if (!isSchemaVersionSupported(ctx, ctx.stats.schemaVersion)) {\n                    ctx.error(\"3DXML schema version not supported: \" + ctx.stats.schemaVersion + \" - supported versions are: \" + supportedSchemas.join(\",\"));\n                } else {\n                    ctx.log(\"Parsing 3DXML schema version: \" + ctx.stats.schemaVersion);\n                }\n                break;\n            case \"Title\":\n                ctx.stats.title = child.children[0];\n                break;\n            case \"Author\":\n                ctx.stats.author = child.children[0];\n                break;\n            case \"Created\":\n                ctx.stats.created = child.children[0];\n                break;\n        }\n    }\n}\n\nfunction isSchemaVersionSupported(ctx, schemaVersion) {\n    for (let i = 0, len = supportedSchemas.length; i < len; i++) {\n        if (schemaVersion === supportedSchemas[i]) {\n            return true;\n        }\n    }\n    return false;\n}\n\nasync function parseProductStructure(ctx, productStructureNode) {\n\n    const referenceReps = await parseReferenceReps(ctx, productStructureNode);\n\n    // Parse out an intermediate scene DAG representation, that we can then\n    // recursive descend through to build the XKTModel.\n\n    const children = productStructureNode.children;\n\n    const reference3Ds = {};\n    const instanceReps = {};\n    const instance3Ds = {};\n\n    // Map all the elements\n\n    for (let i = 0, len = children.length; i < len; i++) {\n\n        const child = children[i];\n\n        let isAggregatedBy;\n        let isInstanceOf;\n        let relativeMatrix;\n\n        switch (child.type) {\n            case \"Reference3D\":\n                reference3Ds[child.id] = {\n                    type: \"Reference3D\",\n                    id: child.id,\n                    name: child.name,\n                    instance3Ds: {},\n                    instanceReps: {}\n                };\n                break;\n\n            case \"InstanceRep\":\n                for (let j = 0, lenj = child.children.length; j < lenj; j++) {\n                    const child2 = child.children[j];\n                    switch (child2.type) {\n                        case \"IsAggregatedBy\":\n                            isAggregatedBy = child2.children[0];\n                            break;\n                        case \"IsInstanceOf\":\n                            isInstanceOf = child2.children[0];\n                            break;\n                    }\n                }\n                instanceReps[child.id] = {\n                    type: \"InstanceRep\",\n                    id: child.id,\n                    name: child.name,\n                    isAggregatedBy: isAggregatedBy,\n                    isInstanceOf: isInstanceOf,\n                    referenceReps: {}\n                };\n                break;\n\n            case \"Instance3D\":\n                for (let j = 0, lenj = child.children.length; j < lenj; j++) {\n                    const child2 = child.children[j];\n                    switch (child2.type) {\n                        case \"IsAggregatedBy\":\n                            isAggregatedBy = child2.children[0];\n                            break;\n                        case \"IsInstanceOf\":\n                            isInstanceOf = child2.children[0];\n                            break;\n                        case \"RelativeMatrix\":\n                            relativeMatrix = child2.children[0];\n                            break;\n                    }\n                }\n                instance3Ds[child.id] = {\n                    type: \"Instance3D\",\n                    id: child.id,\n                    name: child.name,\n                    isAggregatedBy: isAggregatedBy,\n                    isInstanceOf: isInstanceOf,\n                    relativeMatrix: relativeMatrix,\n                    reference3Ds: {}\n                };\n                break;\n        }\n    }\n\n    // Connect Reference3Ds to the Instance3Ds they aggregate\n\n    for (let id in instance3Ds) {\n        const instance3D = instance3Ds[id];\n        const reference3D = reference3Ds[instance3D.isAggregatedBy];\n        if (reference3D) {\n            reference3D.instance3Ds[instance3D.id] = instance3D;\n        } else {\n        }\n    }\n\n    // Connect Instance3Ds to the Reference3Ds they instantiate\n\n    for (let id in instance3Ds) {\n        const instance3D = instance3Ds[id];\n        const reference3D = reference3Ds[instance3D.isInstanceOf];\n        instance3D.reference3Ds[reference3D.id] = reference3D;\n        reference3D.instance3D = instance3D;\n    }\n\n    // Connect InstanceReps to the ReferenceReps they instantiate\n\n    for (let id in instanceReps) {\n        const instanceRep = instanceReps[id];\n        const referenceRep = referenceReps[instanceRep.isInstanceOf];\n        if (referenceRep) {\n            instanceRep.referenceReps[referenceRep.id] = referenceRep;\n        }\n    }\n\n    // Connect Reference3Ds to the InstanceReps they aggregate\n\n    for (let id in instanceReps) {\n        const instanceRep = instanceReps[id];\n        const reference3D = reference3Ds[instanceRep.isAggregatedBy];\n        if (reference3D) {\n            reference3D.instanceReps[instanceRep.id] = instanceRep;\n        }\n    }\n\n    // Find the root Reference3D\n\n    const parentMatrix = math.identityMat4();\n\n    for (let id in reference3Ds) {\n        const reference3D = reference3Ds[id];\n        if (!reference3D.instance3D) {\n            parseReference3D(ctx, reference3D, ctx.rootMetaObjectId, parentMatrix);\n            return;\n        }\n    }\n\n    ctx.error(\"No root Reference3D element found in this modelNode - can't load 3DXML file.\");\n\n}\n\nfunction parseInstance3D(ctx, instance3D, parentMetaObjectId, parentMatrix) {\n\n    const objectId = ctx.nextId++;\n\n    const rotationMatrix = math.identityMat4();\n    const translationMatrix = math.identityMat4();\n    const localMatrix = math.identityMat4();\n    const worldMatrix = math.identityMat4();\n\n    if (instance3D.relativeMatrix) {\n\n        const relativeMatrix = parseFloatArray(instance3D.relativeMatrix, 12);\n\n        const translate = [relativeMatrix[9], relativeMatrix[10], relativeMatrix[11]];\n\n        math.translationMat4v(translate, translationMatrix)\n        math.mat3ToMat4(relativeMatrix.slice(0, 9), rotationMatrix);\n        math.mulMat4(rotationMatrix, translationMatrix, localMatrix);\n\n        math.mulMat4(parentMatrix, localMatrix, worldMatrix);\n\n        ctx.xktModel.createMetaObject({\n            metaObjectId: objectId,\n            metaObjectType: \"Default\",\n            metaObjectName: instance3D.name,\n            parentMetaObjectId: parentMetaObjectId\n        });\n\n        for (let id in instance3D.reference3Ds) {\n            parseReference3D(ctx, instance3D.reference3Ds[id], objectId, worldMatrix);\n        }\n\n    } else {\n\n        ctx.xktModel.createMetaObject({\n            metaObjectId: objectId,\n            metaObjectType: \"Default\",\n            metaObjectName: instance3D.name,\n            parentMetaObjectId: parentMetaObjectId\n        });\n\n        for (let id in instance3D.reference3Ds) {\n            parseReference3D(ctx, instance3D.reference3Ds[id], objectId, parentMatrix);\n        }\n    }\n}\n\nfunction parseReference3D(ctx, reference3D, parentMetaObjectId, parentMatrix) {\n    for (let id in reference3D.instance3Ds) {\n        parseInstance3D(ctx, reference3D.instance3Ds[id], parentMetaObjectId, parentMatrix);\n    }\n    for (let id in reference3D.instanceReps) {\n        parseInstanceRep(ctx, reference3D.instanceReps[id], parentMetaObjectId, parentMatrix);\n    }\n}\n\nfunction parseInstanceRep(ctx, instanceRep, parentMetaObjectId, parentMatrix) {\n\n    if (instanceRep.referenceReps) {\n\n        for (let id in instanceRep.referenceReps) {\n\n            const referenceRep = instanceRep.referenceReps[id];\n\n            for (let id2 in referenceRep) {\n                if (id2 === \"id\") {\n                    continue; // HACK\n                }\n                const meshCfg = referenceRep[id2];\n                const colorize = meshCfg.color;\n\n                const meshId = \"\" + ctx.nextId++;\n                const entityId = \"\" + ctx.nextId++;\n\n                ctx.xktModel.createMesh({\n                    meshId: meshId,\n                    geometryId: meshCfg.geometryId,\n                    matrix: parentMatrix,\n                    color: colorize\n                });\n\n                ctx.xktModel.createEntity({\n                    entityId: entityId,\n                    meshIds: [meshId]\n                });\n\n                ctx.stats.numObjects++;\n\n                ctx.xktModel.createMetaObject({\n                    metaObjectId: entityId,\n                    metaObjectType: \"Default\",\n                    metaObjectName: instanceRep.name,\n                    parentMetaObjectId: parentMetaObjectId\n                });\n            }\n        }\n    }\n}\n\nasync function parseReferenceReps(ctx, node) {\n    const referenceReps = {};\n    const children = node.children;\n    for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        switch (child.type) {\n            case \"ReferenceRep\":\n                if (child.associatedFile) {\n                    const src = stripURN(child.associatedFile);\n                    const childId = child.id;\n                    const file = await ctx.zipArchive.getFile(src);\n                    const materialIds = file.xmlDoc.getElementsByTagName(\"MaterialId\");\n                    await loadCATMaterialRefDocuments(ctx, materialIds);\n                    const referenceRep = {\n                        id: childId\n                    };\n                    parse3DRepDocument(ctx, file.json, referenceRep);\n                    referenceReps[childId] = referenceRep;\n                }\n                break;\n        }\n    }\n    return referenceReps;\n}\n\nfunction parseDefaultView(ctx, node) {\n    const children = node.children;\n    for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        switch (child.type) {\n            case \"Viewpoint\":\n                const children2 = child.children;\n                ctx.viewpoint = {};\n                for (let i2 = 0, len2 = children2.length; i2 < len2; i2++) {\n                    const child2 = children2[i];\n                    switch (child2.type) {\n                        case \"Position\":\n                            ctx.viewpoint.eye = parseFloatArray(child2.children[0], 3);\n                            break;\n                        case \"Sight\":\n                            ctx.viewpoint.look = parseFloatArray(child2.children[0], 3);\n                            break;\n                        case \"Up\":\n                            ctx.viewpoint.up = parseFloatArray(child2.children[0], 3);\n                            break;\n                    }\n                }\n                break;\n            case \"DefaultViewProperty\":\n                break;\n        }\n    }\n}\n\nfunction parse3DRepDocument(ctx, node, result) {\n    const children = node.children;\n    for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        switch (child.type) {\n            case \"XMLRepresentation\":\n                parseXMLRepresentation(ctx, child, result);\n                break;\n        }\n    }\n}\n\nfunction parseXMLRepresentation(ctx, node, result) {\n    const children = node.children;\n    for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        switch (child.type) {\n            case \"Root\":\n                parse3DRepRoot(ctx, child, result);\n                break;\n        }\n    }\n}\n\nfunction parse3DRepRoot(ctx, node, result) {\n    switch (node[\"xsi:type\"]) {\n        case \"BagRepType\":\n            break;\n        case \"PolygonalRepType\":\n            break;\n    }\n    const children = node.children;\n    for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        switch (child.type) {\n            case \"Rep\":\n                parse3DRepRep(ctx, child, result);\n                break;\n        }\n    }\n}\n\nfunction parse3DRepRep(ctx, node, result) {\n\n    switch (node[\"xsi:type\"]) {\n        case \"BagRepType\":\n            break;\n        case \"PolygonalRepType\":\n            break;\n    }\n\n    const meshesResult = {};\n    const children = node.children;\n\n    for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        switch (child.type) {\n            case \"Rep\":\n                parse3DRepRep(ctx, child, result);\n                break;\n            case \"Edges\": // Ignoring edges because we auto-generate them\n                break;\n            case \"Faces\":\n                meshesResult.primitive = \"triangles\";\n                parseFaces(ctx, child, meshesResult);\n                break;\n            case \"VertexBuffer\":\n                parseVertexBuffer(ctx, child, meshesResult);\n                break;\n            case \"SurfaceAttributes\":\n                parseSurfaceAttributes(ctx, child, meshesResult);\n                break;\n        }\n    }\n\n    if (meshesResult.positions) {\n\n        const geometryId = \"\" + ctx.nextId++;\n\n        ctx.xktModel.createGeometry({\n            geometryId: geometryId,\n            primitiveType: meshesResult.primitive,\n            positions: meshesResult.positions,\n            normals: meshesResult.normals,\n            indices: meshesResult.indices,\n        });\n\n        result[geometryId] = {\n            geometryId: geometryId,\n            color: meshesResult.color || [1.0, 1.0, 1.0, 1.0],\n            materialId: meshesResult.materialId\n        };\n\n        ctx.stats.numGeometries++;\n        ctx.stats.numVertices += meshesResult.positions ? meshesResult.positions.length / 3 : 0;\n        ctx.stats.numTriangles += meshesResult.indices ? meshesResult.indices.length / 3 : 0;\n    }\n}\n\nfunction parseFaces(ctx, node, result) {\n    const children = node.children;\n    for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        switch (child.type) {\n            case \"Face\":\n                parseFace(ctx, child, result);\n                break;\n        }\n    }\n}\n\nfunction parseFace(ctx, node, result) {\n    const strips = node.strips;\n    if (strips) {\n        const arrays = parseIntArrays(strips);\n        if (arrays.length > 0) {\n            result.primitive = \"triangles\";\n            const indices = [];\n            for (let i = 0, len = arrays.length; i < len; i++) {\n                const array = convertTriangleStrip(arrays[i]);\n                for (let j = 0, lenj = array.length; j < lenj; j++) {\n                    indices.push(array[j]);\n                }\n            }\n            result.indices = indices; // TODO\n        }\n    } else {\n        const triangles = node.triangles;\n        if (triangles) {\n            result.primitive = \"triangles\";\n            result.indices = parseIntArray(triangles);\n        }\n    }\n    const children = node.children; // Material\n    for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        switch (child.type) {\n            case \"SurfaceAttributes\":\n                parseSurfaceAttributes(ctx, child, result);\n                break;\n        }\n    }\n}\n\nfunction convertTriangleStrip(indices) {\n    const ccw = false;\n    const indices2 = [];\n    for (let i = 0, len = indices.length; i < len - 2; i++) {\n        if (ccw) {\n            if (i & 1) { //\n                indices2.push(indices[i]);\n                indices2.push(indices[i + 1]);\n                indices2.push(indices[i + 2]);\n            } else {\n                indices2.push(indices[i]);\n                indices2.push(indices[i + 2]);\n                indices2.push(indices[i + 1]);\n            }\n        } else {\n            if (i & 1) { //\n                indices2.push(indices[i]);\n                indices2.push(indices[i + 2]);\n                indices2.push(indices[i + 1]);\n            } else {\n                indices2.push(indices[i]);\n                indices2.push(indices[i + 1]);\n                indices2.push(indices[i + 2]);\n            }\n        }\n    }\n    return indices2;\n}\n\nfunction parseVertexBuffer(ctx, node, result) {\n    const children = node.children;\n    for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        switch (child.type) {\n            case \"Positions\":\n                result.positions = parseFloatArray(child.children[0], 3);\n                break;\n            case \"Normals\":\n                if (!ctx.autoNormals) {\n                    result.normals = parseFloatArray(child.children[0], 3);\n                }\n                break;\n            case \"TextureCoordinates\": // TODO: Support dimension and channel?\n                result.uv = parseFloatArray(child.children[0], 2);\n                break;\n        }\n    }\n}\n\nfunction parseIntArrays(str) {\n    const coordStrings = str.split(\",\");\n    const array = [];\n    for (let i = 0, len = coordStrings.length; i < len; i++) {\n        const coordStr = coordStrings[i].trim();\n        if (coordStr.length > 0) {\n            const elemStrings = coordStr.trim().split(\" \");\n            const arr = new Int16Array(elemStrings.length);\n            let arrIdx = 0;\n            for (let j = 0, lenj = elemStrings.length; j < lenj; j++) {\n                if (elemStrings[j] !== \"\") {\n                    arr[arrIdx++] = parseInt(elemStrings[j]);\n                }\n            }\n            array.push(arr);\n        }\n    }\n    return array;\n}\n\nfunction parseFloatArray(str, numElems) {\n    str = str.split(\",\");\n    const arr = new Float64Array(str.length * numElems);\n    let arrIdx = 0;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const value = str[i].split(\" \");\n        for (let j = 0, lenj = value.length; j < lenj; j++) {\n            if (value[j] !== \"\") {\n                arr[arrIdx++] = parseFloat(value[j]);\n            }\n        }\n    }\n    return arr;\n}\n\nfunction parseIntArray(str) {\n    str = str.trim().split(\" \");\n    const arr = new Int32Array(str.length);\n    let arrIdx = 0;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const value = str[i];\n        arr[arrIdx++] = parseInt(value);\n    }\n    return arr;\n}\n\nfunction parseSurfaceAttributes(ctx, node, result) {\n    result.color = [1, 1, 1, 1];\n    const children = node.children;\n    for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        switch (child.type) {\n            case \"Color\":\n                result.color[0] = child.red;\n                result.color[1] = child.green;\n                result.color[2] = child.blue;\n                result.color[3] = child.alpha;\n                break;\n            case \"MaterialApplication\":\n                const children2 = child.children;\n                for (let j = 0, lenj = children2.length; j < lenj; j++) {\n                    const child2 = children2[j];\n                    switch (child2.type) {\n                        case \"MaterialId\":\n                            const materialId = getIDFromURI(child2.id);\n                            const material = ctx.materials[materialId];\n                            if (!material) {\n                                ctx.error(\"material  not found: \" + materialId);\n                            }\n                            result.materialId = materialId;\n                            break;\n                    }\n                }\n                break;\n        }\n    }\n}\n\nasync function loadCATMaterialRefDocuments(ctx, materialIds) {\n    const loaded = {};\n\n    async function load(i) {\n        if (i >= materialIds.length) {\n            return;\n        }\n        const materialId = materialIds[i];\n        const colonIdx = src.lastIndexOf(\":\");\n        let src = materialId.id;\n        if (colonIdx > 0) {\n            src = src.substring(colonIdx + 1);\n        }\n        const hashIdx = src.lastIndexOf(\"#\");\n        if (hashIdx > 0) {\n            src = src.substring(0, hashIdx);\n        }\n        if (!loaded[src]) {\n            await loadCATMaterialRefDocument(ctx, src);\n            loaded[src] = true;\n            await load(i + 1);\n        } else {\n            await load(i + 1);\n        }\n    }\n\n    await load(0);\n}\n\nasync function loadCATMaterialRefDocument(ctx, src) { // Loads CATMaterialRef.3dxml\n    const fileData = await ctx.zipArchive.getFile(src);\n    await parseCATMaterialRefDocument(ctx, fileData.json);\n}\n\nasync function parseCATMaterialRefDocument(ctx, node) { // Parse CATMaterialRef.3dxml\n    const children = node.children;\n    for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        if (child.type === \"Model_3dxml\") {\n            await parseModel_3dxml(ctx, child);\n        }\n    }\n}\n\nasync function parseModel_3dxml(ctx, node) { // Parse CATMaterialRef.3dxml\n    const children = node.children;\n    for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        if (child.type === \"CATMaterialRef\") {\n            await parseCATMaterialRef(ctx, child);\n        }\n    }\n}\n\nasync function parseCATMaterialRef(ctx, node) {\n\n    const domainToReferenceMap = {};\n    const children = node.children;\n\n    for (let j = 0, lenj = children.length; j < lenj; j++) {\n        const child2 = children[j];\n        switch (child2.type) {\n            case \"MaterialDomainInstance\":\n                let isAggregatedBy;\n                let isInstanceOf;\n                for (let k = 0, lenk = child2.children.length; k < lenk; k++) {\n                    const child3 = child2.children[k];\n                    switch (child3.type) {\n                        case \"IsAggregatedBy\":\n                            isAggregatedBy = child3.children[0];\n                            break;\n                        case \"IsInstanceOf\":\n                            isInstanceOf = child3.children[0];\n                            break;\n                    }\n                }\n                domainToReferenceMap[isInstanceOf] = isAggregatedBy;\n                break;\n        }\n    }\n\n    for (let j = 0, lenj = children.length; j < lenj; j++) {\n        const child2 = children[j];\n        switch (child2.type) {\n            case \"MaterialDomain\":\n                if (child2.associatedFile) {\n                    const childId = child2.id;\n                    const src = stripURN(child2.associatedFile);\n                    const fileData = await ctx.zipArchive.getFile(src);\n                    ctx.materials[domainToReferenceMap[childId]] = parseMaterialDefDocument(ctx, fileData.json);\n                }\n        }\n    }\n}\n\nfunction parseMaterialDefDocument(ctx, node) {\n    const children = node.children;\n    for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        switch (child.type) {\n            case \"Osm\":\n                return parseMaterialDefDocumentOsm(ctx, child);\n        }\n    }\n    return {};\n}\n\nfunction parseMaterialDefDocumentOsm(ctx, node) {\n    const materialCfg = {};\n    const children = node.children;\n    for (let i = 0, len = children.length; i < len; i++) {\n        const child = children[i];\n        switch (child.type) {\n            case \"RenderingRootFeature\":\n                break;\n            case \"Feature\":\n                if (child.Alias === \"RenderingFeature\") {\n                    // Parse the coefficients, then parse the colors, scaling those by their coefficients.\n                    const coeffs = {};\n                    const children2 = child.children;\n                    for (let j = 0, lenj = children2.length; j < lenj; j++) {\n                        const child2 = children2[j];\n                        switch (child2.Name) {\n                            case \"AmbientCoef\":\n                                coeffs.ambient = parseFloat(child2.Value);\n                                break;\n                            case \"DiffuseCoef\":\n                                coeffs.diffuse = parseFloat(child2.Value);\n                                break;\n                            case \"EmissiveCoef\":\n                                coeffs.emissive = parseFloat(child2.Value);\n                                break;\n                            case \"SpecularExponent\":\n                                coeffs.specular = parseFloat(child2.Value);\n                                break;\n                        }\n                    }\n                    for (let j = 0, lenj = children2.length; j < lenj; j++) {\n                        const child2 = children2[j];\n                        switch (child2.Name) {\n                            case \"AmbientColor\":\n                                materialCfg.ambient = parseRGB(child2.Value, coeffs.ambient);\n                                break;\n                            case \"DiffuseColor\":\n                                materialCfg.diffuse = parseRGB(child2.Value, coeffs.diffuse);\n                                break;\n                            case \"EmissiveColor\":\n                                materialCfg.emissive = parseRGB(child2.Value, coeffs.emissive);\n                                break;\n                            case \"SpecularColor\":\n                                materialCfg.specular = parseRGB(child2.Value, coeffs.specular);\n                                break;\n                            case \"Transparency\":\n                                const alpha = 1.0 - parseFloat(child2.Value); // Degree of transparency, not degree of opacity\n                                if (alpha < 1.0) {\n                                    materialCfg.alpha = alpha;\n                                    materialCfg.alphaMode = \"blend\";\n                                }\n                                break;\n                        }\n                    }\n                }\n                break;\n        }\n    }\n    return materialCfg;\n}\n\nfunction parseRGB(str, coeff) {\n    coeff = (coeff !== undefined) ? coeff : 0.5;\n    const openBracketIndex = str.indexOf(\"[\");\n    const closeBracketIndex = str.indexOf(\"]\");\n    str = str.substring(openBracketIndex + 1, closeBracketIndex - openBracketIndex);\n    str = str.split(\",\");\n    const arr = new Float32Array(str.length);\n    let arrIdx = 0;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const value = str[i].trim().split(\" \");\n        for (let j = 0, lenj = value.length; j < lenj; j++) {\n            if (value[j] !== \"\") {\n                arr[arrIdx++] = parseFloat(value[j]) * coeff;\n            }\n        }\n    }\n    return arr;\n}\n\nfunction stripURN(str) {\n    const subStr = \"urn:3DXML:\";\n    return (str.indexOf(subStr) === 0) ? str.substring(subStr.length) : str;\n}\n\nfunction getIDFromURI(str) {\n    const hashIdx = str.lastIndexOf(\"#\");\n    return hashIdx !== -1 ? str.substring(hashIdx + 1) : str;\n}\n\nexport {parse3DXMLIntoXKTModel};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/parsers/parse3DXMLIntoXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 336,
    "kind": "variable",
    "name": "supportedSchemas",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~supportedSchemas",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "string[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 337,
    "kind": "function",
    "name": "parseDocument",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseDocument",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 131,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 338,
    "kind": "function",
    "name": "parseManifest",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseManifest",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 145,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "manifest",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 339,
    "kind": "function",
    "name": "parseRoot",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseRoot",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 160,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "node",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 340,
    "kind": "function",
    "name": "parseModel",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseModel",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 172,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "node",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 341,
    "kind": "function",
    "name": "parseHeader",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseHeader",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 190,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "node",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 342,
    "kind": "function",
    "name": "isSchemaVersionSupported",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~isSchemaVersionSupported",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 217,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "schemaVersion",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 343,
    "kind": "function",
    "name": "parseProductStructure",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseProductStructure",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 226,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "productStructureNode",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 344,
    "kind": "function",
    "name": "parseInstance3D",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseInstance3D",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 366,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "instance3D",
        "types": [
          "*"
        ]
      },
      {
        "name": "parentMetaObjectId",
        "types": [
          "*"
        ]
      },
      {
        "name": "parentMatrix",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 345,
    "kind": "function",
    "name": "parseReference3D",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseReference3D",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 413,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "reference3D",
        "types": [
          "*"
        ]
      },
      {
        "name": "parentMetaObjectId",
        "types": [
          "*"
        ]
      },
      {
        "name": "parentMatrix",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 346,
    "kind": "function",
    "name": "parseInstanceRep",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseInstanceRep",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 422,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "instanceRep",
        "types": [
          "*"
        ]
      },
      {
        "name": "parentMetaObjectId",
        "types": [
          "*"
        ]
      },
      {
        "name": "parentMatrix",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 347,
    "kind": "function",
    "name": "parseReferenceReps",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseReferenceReps",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 465,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "node",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 348,
    "kind": "function",
    "name": "parseDefaultView",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseDefaultView",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 490,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "node",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 349,
    "kind": "function",
    "name": "parse3DRepDocument",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parse3DRepDocument",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 519,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "node",
        "types": [
          "*"
        ]
      },
      {
        "name": "result",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 350,
    "kind": "function",
    "name": "parseXMLRepresentation",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseXMLRepresentation",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 531,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "node",
        "types": [
          "*"
        ]
      },
      {
        "name": "result",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 351,
    "kind": "function",
    "name": "parse3DRepRoot",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parse3DRepRoot",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 543,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "node",
        "types": [
          "*"
        ]
      },
      {
        "name": "result",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 352,
    "kind": "function",
    "name": "parse3DRepRep",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parse3DRepRep",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 561,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "node",
        "types": [
          "*"
        ]
      },
      {
        "name": "result",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 353,
    "kind": "function",
    "name": "parseFaces",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseFaces",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 618,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "node",
        "types": [
          "*"
        ]
      },
      {
        "name": "result",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 354,
    "kind": "function",
    "name": "parseFace",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseFace",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 630,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "node",
        "types": [
          "*"
        ]
      },
      {
        "name": "result",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 355,
    "kind": "function",
    "name": "convertTriangleStrip",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~convertTriangleStrip",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 663,
    "undocument": true,
    "params": [
      {
        "name": "indices",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 356,
    "kind": "function",
    "name": "parseVertexBuffer",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseVertexBuffer",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 692,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "node",
        "types": [
          "*"
        ]
      },
      {
        "name": "result",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 357,
    "kind": "function",
    "name": "parseIntArrays",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseIntArrays",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 712,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 358,
    "kind": "function",
    "name": "parseFloatArray",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseFloatArray",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 732,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      },
      {
        "name": "numElems",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 359,
    "kind": "function",
    "name": "parseIntArray",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseIntArray",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 747,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 360,
    "kind": "function",
    "name": "parseSurfaceAttributes",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseSurfaceAttributes",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 758,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "node",
        "types": [
          "*"
        ]
      },
      {
        "name": "result",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 361,
    "kind": "function",
    "name": "loadCATMaterialRefDocuments",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~loadCATMaterialRefDocuments",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 790,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "materialIds",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 362,
    "kind": "function",
    "name": "loadCATMaterialRefDocument",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~loadCATMaterialRefDocument",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 819,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "src",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 363,
    "kind": "function",
    "name": "parseCATMaterialRefDocument",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseCATMaterialRefDocument",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 824,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "node",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 364,
    "kind": "function",
    "name": "parseModel_3dxml",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseModel_3dxml",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 834,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "node",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 365,
    "kind": "function",
    "name": "parseCATMaterialRef",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseCATMaterialRef",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 844,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "node",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 366,
    "kind": "function",
    "name": "parseMaterialDefDocument",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseMaterialDefDocument",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 885,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "node",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 367,
    "kind": "function",
    "name": "parseMaterialDefDocumentOsm",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseMaterialDefDocumentOsm",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 897,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "node",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 368,
    "kind": "function",
    "name": "parseRGB",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parseRGB",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 958,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      },
      {
        "name": "coeff",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 369,
    "kind": "function",
    "name": "stripURN",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~stripURN",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 977,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 370,
    "kind": "function",
    "name": "getIDFromURI",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~getIDFromURI",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 982,
    "undocument": true,
    "params": [
      {
        "name": "str",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 371,
    "kind": "function",
    "name": "parse3DXMLIntoXKTModel",
    "memberof": "src/parsers/parse3DXMLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parse3DXMLIntoXKTModel.js~parse3DXMLIntoXKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parse3DXMLIntoXKTModel.js",
    "importStyle": "{parse3DXMLIntoXKTModel}",
    "description": "Loads 3DXML into an {@link XKTModel}.\n\nSupports 3DXML Schema 4.2.",
    "lineNumber": 23,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Parsing parameters."
      },
      {
        "nullable": null,
        "types": [
          "ArrayBuffer"
        ],
        "spread": false,
        "optional": false,
        "name": "params.data",
        "description": "3DXML BLOB data."
      },
      {
        "nullable": null,
        "types": [
          "DOMParser"
        ],
        "spread": false,
        "optional": false,
        "name": "params.domParser",
        "description": "A DOMParser implementation (eg. ````xmldom````), required when\nwe're not running in a browser and ````window.DOMParser```` is not available."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "params.xktModel",
        "description": "XKTModel to parse into."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "params.autoNormals",
        "description": "When true, the parser will ignore the 3DXML geometry normals, and the 3DXML\ndata will rely on the xeokit ````Viewer```` to automatically generate them. This has the limitation that the\nnormals will be face-aligned, and therefore the ````Viewer```` will only be able to render a flat-shaded representation\nof the 3DXML model. This is ````false```` by default because CAD models tend to prefer smooth shading."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "params.stats",
        "description": "Collects statistics."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.log",
        "description": "Logging callback."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 372,
    "kind": "file",
    "name": "src/parsers/parseCityJSONIntoXKTModel.js",
    "content": "import {earcut} from './../lib/earcut';\nimport {math} from \"./../lib/math.js\";\n\nconst tempVec2a = math.vec2();\nconst tempVec3a = math.vec3();\nconst tempVec3b = math.vec3();\nconst tempVec3c = math.vec3();\n\n/**\n * @desc Parses a CityJSON model into an {@link XKTModel}.\n *\n * [CityJSON](https://www.cityjson.org) is a JSON-based encoding for a subset of the CityGML data model (version 2.0.0),\n * which is an open standardised data model and exchange format to store digital 3D models of cities and\n * landscapes. CityGML is an official standard of the [Open Geospatial Consortium](https://www.ogc.org/).\n *\n * This converter function supports most of the [CityJSON 1.0.2 Specification](https://www.cityjson.org/specs/1.0.2),\n * with the following limitations:\n *\n * * Does not (yet) support CityJSON semantics for geometry primitives.\n * * Does not (yet) support textured geometries.\n * * Does not (yet) support geometry templates.\n * * When the CityJSON file provides multiple *themes* for a geometry, then we parse only the first of the provided themes for that geometry.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then load a CityJSON model into it.\n *\n * ````javascript\n * utils.loadJSON(\"./models/cityjson/DenHaag.json\", async (data) => {\n *\n *     const xktModel = new XKTModel();\n *\n *     parseCityJSONIntoXKTModel({\n *          data,\n *          xktModel,\n *          log: (msg) => { console.log(msg); }\n *     }).then(()=>{\n *        xktModel.finalize();\n *     },\n *     (msg) => {\n *         console.error(msg);\n *     });\n * });\n * ````\n *\n * @param {Object} params Parsing params.\n * @param {Object} params.data CityJSON data.\n * @param {XKTModel} params.xktModel XKTModel to parse into.\n * @param {Object} [params.stats] Collects statistics.\n * @param {function} [params.log] Logging callback.\n * @returns {Promise}\n */\nfunction parseCityJSONIntoXKTModel({data, xktModel, stats = {}, log}) {\n\n    return new Promise(function (resolve, reject) {\n\n        if (!data) {\n            reject(\"Argument expected: data\");\n            return;\n        }\n\n        if (data.type !== \"CityJSON\") {\n            reject(\"Invalid argument: data is not a CityJSON file\");\n            return;\n        }\n\n        if (!xktModel) {\n            reject(\"Argument expected: xktModel\");\n            return;\n        }\n\n        const vertices = data.transform // Avoid side effects - don't modify the CityJSON data\n            ? transformVertices(data.vertices, data.transform)\n            : data.vertices;\n\n        stats.sourceFormat = data.type || \"\";\n        stats.schemaVersion = data.version || \"\";\n        stats.title = \"\";\n        stats.author = \"\";\n        stats.created = \"\";\n        stats.numMetaObjects = 0;\n        stats.numPropertySets = 0;\n        stats.numTriangles = 0;\n        stats.numVertices = 0;\n        stats.numObjects = 0;\n        stats.numGeometries = 0;\n\n        const rootMetaObjectId = math.createUUID();\n\n        xktModel.createMetaObject({\n            metaObjectId: rootMetaObjectId,\n            metaObjectType: \"Model\",\n            metaObjectName: \"Model\"\n        });\n\n        stats.numMetaObjects++;\n\n        const modelMetaObjectId = math.createUUID();\n\n        xktModel.createMetaObject({\n            metaObjectId: modelMetaObjectId,\n            metaObjectType: \"CityJSON\",\n            metaObjectName: \"CityJSON\",\n            parentMetaObjectId: rootMetaObjectId\n        });\n\n        stats.numMetaObjects++;\n\n        const ctx = {\n            data,\n            vertices,\n            xktModel,\n            rootMetaObjectId: modelMetaObjectId,\n            log: (log || function (msg) {\n            }),\n            nextId: 0,\n            stats\n        };\n\n        ctx.xktModel.schema = data.type + \" \" + data.version;\n\n        ctx.log(\"Converting \" + ctx.xktModel.schema);\n\n        parseCityJSON(ctx);\n\n        resolve();\n    });\n}\n\nfunction transformVertices(vertices, transform) {\n    const transformedVertices = [];\n    const scale = transform.scale || math.vec3([1, 1, 1]);\n    const translate = transform.translate || math.vec3([0, 0, 0]);\n    for (let i = 0, j = 0; i < vertices.length; i++, j += 3) {\n        const x = (vertices[i][0] * scale[0]) + translate[0];\n        const y = (vertices[i][1] * scale[1]) + translate[1];\n        const z = (vertices[i][2] * scale[2]) + translate[2];\n        transformedVertices.push([x, y, z]);\n    }\n    return transformedVertices;\n}\n\nfunction parseCityJSON(ctx) {\n\n    const data = ctx.data;\n    const cityObjects = data.CityObjects;\n\n    for (const objectId in cityObjects) {\n        if (cityObjects.hasOwnProperty(objectId)) {\n            const cityObject = cityObjects[objectId];\n            parseCityObject(ctx, cityObject, objectId);\n        }\n    }\n}\n\nfunction parseCityObject(ctx, cityObject, objectId) {\n\n    const xktModel = ctx.xktModel;\n    const data = ctx.data;\n    const metaObjectId = objectId;\n    const metaObjectType = cityObject.type;\n    const metaObjectName = metaObjectType + \" : \" + objectId;\n\n    const parentMetaObjectId = cityObject.parents ? cityObject.parents[0] : ctx.rootMetaObjectId;\n\n    xktModel.createMetaObject({\n        metaObjectId,\n        metaObjectName,\n        metaObjectType,\n        parentMetaObjectId\n    });\n\n    ctx.stats.numMetaObjects++;\n\n    if (!(cityObject.geometry && cityObject.geometry.length > 0)) {\n        return;\n    }\n\n    const meshIds = [];\n\n    for (let i = 0, len = cityObject.geometry.length; i < len; i++) {\n\n        const geometry = cityObject.geometry[i];\n\n        let objectMaterial;\n        let surfaceMaterials;\n\n        const appearance = data.appearance;\n        if (appearance) {\n            const materials = appearance.materials;\n            if (materials) {\n                const geometryMaterial = geometry.material;\n                if (geometryMaterial) {\n                    const themeIds = Object.keys(geometryMaterial);\n                    if (themeIds.length > 0) {\n                        const themeId = themeIds[0];\n                        const theme = geometryMaterial[themeId];\n                        if (theme.value !== undefined) {\n                            objectMaterial = materials[theme.value];\n                        } else {\n                            const values = theme.values;\n                            if (values) {\n                                surfaceMaterials = [];\n                                for (let j = 0, lenj = values.length; j < lenj; j++) {\n                                    const value = values[i];\n                                    const surfaceMaterial = materials[value];\n                                    surfaceMaterials.push(surfaceMaterial);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (surfaceMaterials) {\n            parseGeometrySurfacesWithOwnMaterials(ctx, geometry, surfaceMaterials, meshIds);\n\n        } else {\n            parseGeometrySurfacesWithSharedMaterial(ctx, geometry, objectMaterial, meshIds);\n        }\n    }\n\n    if (meshIds.length > 0) {\n        xktModel.createEntity({\n            entityId: objectId,\n            meshIds: meshIds\n        });\n\n        ctx.stats.numObjects++;\n    }\n}\n\nfunction parseGeometrySurfacesWithOwnMaterials(ctx, geometry, surfaceMaterials, meshIds) {\n\n    const geomType = geometry.type;\n\n    switch (geomType) {\n\n        case \"MultiPoint\":\n            break;\n\n        case \"MultiLineString\":\n            break;\n\n        case \"MultiSurface\":\n\n        case \"CompositeSurface\":\n            const surfaces = geometry.boundaries;\n            parseSurfacesWithOwnMaterials(ctx, surfaceMaterials, surfaces, meshIds);\n            break;\n\n        case \"Solid\":\n            const shells = geometry.boundaries;\n            for (let j = 0; j < shells.length; j++) {\n                const surfaces = shells[j];\n                parseSurfacesWithOwnMaterials(ctx, surfaceMaterials, surfaces, meshIds);\n            }\n            break;\n\n        case \"MultiSolid\":\n\n        case \"CompositeSolid\":\n            const solids = geometry.boundaries;\n            for (let j = 0; j < solids.length; j++) {\n                for (let k = 0; k < solids[j].length; k++) {\n                    const surfaces = solids[j][k];\n                    parseSurfacesWithOwnMaterials(ctx, surfaceMaterials, surfaces, meshIds);\n                }\n            }\n            break;\n\n        case \"GeometryInstance\":\n            break;\n    }\n}\n\nfunction parseSurfacesWithOwnMaterials(ctx, surfaceMaterials, surfaces, meshIds) {\n\n    const vertices = ctx.vertices;\n    const xktModel = ctx.xktModel;\n\n    for (let i = 0; i < surfaces.length; i++) {\n\n        const surface = surfaces[i];\n        const surfaceMaterial = surfaceMaterials[i] || {diffuseColor: [0.8, 0.8, 0.8], transparency: 1.0};\n\n        const face = [];\n        const holes = [];\n\n        const sharedIndices = [];\n\n        const geometryCfg = {\n            positions: [],\n            indices: []\n        };\n\n        for (let j = 0; j < surface.length; j++) {\n\n            if (face.length > 0) {\n                holes.push(face.length);\n            }\n\n            const newFace = extractLocalIndices(ctx, surface[j], sharedIndices, geometryCfg);\n\n            face.push(...newFace);\n        }\n\n        if (face.length === 3) { // Triangle\n\n            geometryCfg.indices.push(face[0]);\n            geometryCfg.indices.push(face[1]);\n            geometryCfg.indices.push(face[2]);\n\n        } else if (face.length > 3) { // Polygon\n\n            // Prepare to triangulate\n\n            const pList = [];\n\n            for (let k = 0; k < face.length; k++) {\n                pList.push({\n                    x: vertices[sharedIndices[face[k]]][0],\n                    y: vertices[sharedIndices[face[k]]][1],\n                    z: vertices[sharedIndices[face[k]]][2]\n                });\n            }\n\n            const normal = getNormalOfPositions(pList, math.vec3());\n\n            // Convert to 2D\n\n            let pv = [];\n\n            for (let k = 0; k < pList.length; k++) {\n\n                to2D(pList[k], normal, tempVec2a);\n\n                pv.unshift(tempVec2a[0]);\n                pv.unshift(tempVec2a[1]);\n            }\n\n            // Triangulate\n\n            const tr = earcut(pv, holes, 2);\n\n            // Create triangles\n\n            for (let k = 0; k < tr.length; k += 3) {\n                geometryCfg.indices.unshift(face[tr[k]]);\n                geometryCfg.indices.unshift(face[tr[k + 1]]);\n                geometryCfg.indices.unshift(face[tr[k + 2]]);\n            }\n        }\n\n        const geometryId = \"\" + ctx.nextId++;\n        const meshId = \"\" + ctx.nextId++;\n\n        xktModel.createGeometry({\n            geometryId: geometryId,\n            primitiveType: \"triangles\",\n            positions: geometryCfg.positions,\n            indices: geometryCfg.indices\n        });\n\n        xktModel.createMesh({\n            meshId: meshId,\n            geometryId: geometryId,\n            color: (surfaceMaterial && surfaceMaterial.diffuseColor) ? surfaceMaterial.diffuseColor : [0.8, 0.8, 0.8],\n            opacity: 1.0\n            //opacity: (surfaceMaterial && surfaceMaterial.transparency !== undefined) ? (1.0 - surfaceMaterial.transparency) : 1.0\n        });\n\n        meshIds.push(meshId);\n\n        ctx.stats.numGeometries++;\n        ctx.stats.numVertices += geometryCfg.positions.length / 3;\n        ctx.stats.numTriangles += geometryCfg.indices.length / 3;\n    }\n}\n\nfunction parseGeometrySurfacesWithSharedMaterial(ctx, geometry, objectMaterial, meshIds) {\n\n    const xktModel = ctx.xktModel;\n    const sharedIndices = [];\n    const geometryCfg = {\n        positions: [],\n        indices: []\n    };\n\n    const geomType = geometry.type;\n\n    switch (geomType) {\n        case \"MultiPoint\":\n            break;\n\n        case \"MultiLineString\":\n            break;\n\n        case \"MultiSurface\":\n        case \"CompositeSurface\":\n            const surfaces = geometry.boundaries;\n            parseSurfacesWithSharedMaterial(ctx, surfaces, sharedIndices, geometryCfg);\n            break;\n\n        case \"Solid\":\n            const shells = geometry.boundaries;\n            for (let j = 0; j < shells.length; j++) {\n                const surfaces = shells[j];\n                parseSurfacesWithSharedMaterial(ctx, surfaces, sharedIndices, geometryCfg);\n            }\n            break;\n\n        case \"MultiSolid\":\n        case \"CompositeSolid\":\n            const solids = geometry.boundaries;\n            for (let j = 0; j < solids.length; j++) {\n                for (let k = 0; k < solids[j].length; k++) {\n                    const surfaces = solids[j][k];\n                    parseSurfacesWithSharedMaterial(ctx, surfaces, sharedIndices, geometryCfg);\n                }\n            }\n            break;\n\n        case \"GeometryInstance\":\n            break;\n    }\n\n    const geometryId = \"\" + ctx.nextId++;\n    const meshId = \"\" + ctx.nextId++;\n\n    xktModel.createGeometry({\n        geometryId: geometryId,\n        primitiveType: \"triangles\",\n        positions: geometryCfg.positions,\n        indices: geometryCfg.indices\n    });\n\n    xktModel.createMesh({\n        meshId: meshId,\n        geometryId: geometryId,\n        color: (objectMaterial && objectMaterial.diffuseColor) ? objectMaterial.diffuseColor : [0.8, 0.8, 0.8],\n        opacity: 1.0\n        //opacity: (objectMaterial && objectMaterial.transparency !== undefined) ? (1.0 - objectMaterial.transparency) : 1.0\n    });\n\n    meshIds.push(meshId);\n\n    ctx.stats.numGeometries++;\n    ctx.stats.numVertices += geometryCfg.positions.length / 3;\n    ctx.stats.numTriangles += geometryCfg.indices.length / 3;\n}\n\nfunction parseSurfacesWithSharedMaterial(ctx, surfaces, sharedIndices, primitiveCfg) {\n\n    const vertices = ctx.vertices;\n\n    for (let i = 0; i < surfaces.length; i++) {\n\n        let boundary = [];\n        let holes = [];\n\n        for (let j = 0; j < surfaces[i].length; j++) {\n            if (boundary.length > 0) {\n                holes.push(boundary.length);\n            }\n            const newBoundary = extractLocalIndices(ctx, surfaces[i][j], sharedIndices, primitiveCfg);\n            boundary.push(...newBoundary);\n        }\n\n        if (boundary.length === 3) { // Triangle\n\n            primitiveCfg.indices.push(boundary[0]);\n            primitiveCfg.indices.push(boundary[1]);\n            primitiveCfg.indices.push(boundary[2]);\n\n        } else if (boundary.length > 3) { // Polygon\n\n            let pList = [];\n\n            for (let k = 0; k < boundary.length; k++) {\n                pList.push({\n                    x: vertices[sharedIndices[boundary[k]]][0],\n                    y: vertices[sharedIndices[boundary[k]]][1],\n                    z: vertices[sharedIndices[boundary[k]]][2]\n                });\n            }\n\n            const normal = getNormalOfPositions(pList, math.vec3());\n            let pv = [];\n\n            for (let k = 0; k < pList.length; k++) {\n                to2D(pList[k], normal, tempVec2a);\n                pv.unshift(tempVec2a[0]);\n                pv.unshift(tempVec2a[1]);\n            }\n\n            const tr = earcut(pv, holes, 2);\n\n            for (let k = 0; k < tr.length; k += 3) {\n                primitiveCfg.indices.unshift(boundary[tr[k]]);\n                primitiveCfg.indices.unshift(boundary[tr[k + 1]]);\n                primitiveCfg.indices.unshift(boundary[tr[k + 2]]);\n            }\n        }\n    }\n}\n\nfunction extractLocalIndices(ctx, boundary, sharedIndices, geometryCfg) {\n\n    const vertices = ctx.vertices;\n    const newBoundary = []\n\n    for (let i = 0, len = boundary.length; i < len; i++) {\n\n        const index = boundary[i];\n\n        if (sharedIndices.includes(index)) {\n            const vertexIndex = sharedIndices.indexOf(index);\n            newBoundary.push(vertexIndex);\n\n        } else {\n            geometryCfg.positions.push(vertices[index][0]);\n            geometryCfg.positions.push(vertices[index][1]);\n            geometryCfg.positions.push(vertices[index][2]);\n\n            newBoundary.push(sharedIndices.length);\n\n            sharedIndices.push(index);\n        }\n    }\n\n    return newBoundary\n}\n\nfunction getNormalOfPositions(positions, normal) {\n\n    for (let i = 0; i < positions.length; i++) {\n\n        let nexti = i + 1;\n        if (nexti === positions.length) {\n            nexti = 0;\n        }\n\n        normal[0] += ((positions[i].y - positions[nexti].y) * (positions[i].z + positions[nexti].z));\n        normal[1] += ((positions[i].z - positions[nexti].z) * (positions[i].x + positions[nexti].x));\n        normal[2] += ((positions[i].x - positions[nexti].x) * (positions[i].y + positions[nexti].y));\n    }\n\n    return math.normalizeVec3(normal);\n}\n\nfunction to2D(_p, _n, re) {\n\n    const p = tempVec3a;\n    const n = tempVec3b;\n    const x3 = tempVec3c;\n\n    p[0] = _p.x;\n    p[1] = _p.y;\n    p[2] = _p.z;\n\n    n[0] = _n.x;\n    n[1] = _n.y;\n    n[2] = _n.z;\n\n    x3[0] = 1.1;\n    x3[1] = 1.1;\n    x3[2] = 1.1;\n\n    const dist = math.lenVec3(math.subVec3(x3, n));\n\n    if (dist < 0.01) {\n        x3[0] += 1.0;\n        x3[1] += 2.0;\n        x3[2] += 3.0;\n    }\n\n    const dot = math.dotVec3(x3, n);\n    const tmp2 = math.mulVec3Scalar(n, dot, math.vec3());\n\n    x3[0] -= tmp2[0];\n    x3[1] -= tmp2[1];\n    x3[2] -= tmp2[2];\n\n    math.normalizeVec3(x3);\n\n    const y3 = math.cross3Vec3(n, x3, math.vec3());\n    const x = math.dotVec3(p, x3);\n    const y = math.dotVec3(p, y3);\n\n    re[0] = x;\n    re[1] = y;\n}\n\nexport {parseCityJSONIntoXKTModel};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/parsers/parseCityJSONIntoXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 373,
    "kind": "variable",
    "name": "tempVec2a",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~tempVec2a",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 374,
    "kind": "variable",
    "name": "tempVec3a",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~tempVec3a",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 375,
    "kind": "variable",
    "name": "tempVec3b",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~tempVec3b",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 376,
    "kind": "variable",
    "name": "tempVec3c",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~tempVec3c",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 377,
    "kind": "function",
    "name": "transformVertices",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~transformVertices",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 130,
    "undocument": true,
    "params": [
      {
        "name": "vertices",
        "types": [
          "*"
        ]
      },
      {
        "name": "transform",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 378,
    "kind": "function",
    "name": "parseCityJSON",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~parseCityJSON",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 143,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 379,
    "kind": "function",
    "name": "parseCityObject",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~parseCityObject",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 156,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "cityObject",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectId",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 380,
    "kind": "function",
    "name": "parseGeometrySurfacesWithOwnMaterials",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~parseGeometrySurfacesWithOwnMaterials",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 234,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "geometry",
        "types": [
          "*"
        ]
      },
      {
        "name": "surfaceMaterials",
        "types": [
          "*"
        ]
      },
      {
        "name": "meshIds",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 381,
    "kind": "function",
    "name": "parseSurfacesWithOwnMaterials",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~parseSurfacesWithOwnMaterials",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 278,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "surfaceMaterials",
        "types": [
          "*"
        ]
      },
      {
        "name": "surfaces",
        "types": [
          "*"
        ]
      },
      {
        "name": "meshIds",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 382,
    "kind": "function",
    "name": "parseGeometrySurfacesWithSharedMaterial",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~parseGeometrySurfacesWithSharedMaterial",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 382,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "geometry",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectMaterial",
        "types": [
          "*"
        ]
      },
      {
        "name": "meshIds",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 383,
    "kind": "function",
    "name": "parseSurfacesWithSharedMaterial",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~parseSurfacesWithSharedMaterial",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 454,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "surfaces",
        "types": [
          "*"
        ]
      },
      {
        "name": "sharedIndices",
        "types": [
          "*"
        ]
      },
      {
        "name": "primitiveCfg",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 384,
    "kind": "function",
    "name": "extractLocalIndices",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~extractLocalIndices",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 509,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "boundary",
        "types": [
          "*"
        ]
      },
      {
        "name": "sharedIndices",
        "types": [
          "*"
        ]
      },
      {
        "name": "geometryCfg",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 385,
    "kind": "function",
    "name": "getNormalOfPositions",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~getNormalOfPositions",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 536,
    "undocument": true,
    "params": [
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "normal",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 386,
    "kind": "function",
    "name": "to2D",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~to2D",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 553,
    "undocument": true,
    "params": [
      {
        "name": "_p",
        "types": [
          "*"
        ]
      },
      {
        "name": "_n",
        "types": [
          "*"
        ]
      },
      {
        "name": "re",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 387,
    "kind": "function",
    "name": "parseCityJSONIntoXKTModel",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~parseCityJSONIntoXKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": "{parseCityJSONIntoXKTModel}",
    "description": "Parses a CityJSON model into an {@link XKTModel}.\n\n[CityJSON](https://www.cityjson.org) is a JSON-based encoding for a subset of the CityGML data model (version 2.0.0),\nwhich is an open standardised data model and exchange format to store digital 3D models of cities and\nlandscapes. CityGML is an official standard of the [Open Geospatial Consortium](https://www.ogc.org/).\n\nThis converter function supports most of the [CityJSON 1.0.2 Specification](https://www.cityjson.org/specs/1.0.2),\nwith the following limitations:\n\n* Does not (yet) support CityJSON semantics for geometry primitives.\n* Does not (yet) support textured geometries.\n* Does not (yet) support geometry templates.\n* When the CityJSON file provides multiple *themes* for a geometry, then we parse only the first of the provided themes for that geometry.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then load a CityJSON model into it.\n\n````javascript\nutils.loadJSON(\"./models/cityjson/DenHaag.json\", async (data) => {\n\n    const xktModel = new XKTModel();\n\n    parseCityJSONIntoXKTModel({\n         data,\n         xktModel,\n         log: (msg) => { console.log(msg); }\n    }).then(()=>{\n       xktModel.finalize();\n    },\n    (msg) => {\n        console.error(msg);\n    });\n});\n````",
    "lineNumber": 53,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Parsing params."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.data",
        "description": "CityJSON data."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "params.xktModel",
        "description": "XKTModel to parse into."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "params.stats",
        "description": "Collects statistics."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.log",
        "description": "Logging callback."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 388,
    "kind": "file",
    "name": "src/parsers/parseGLTFIntoXKTModel.js",
    "content": "import {utils} from \"../XKTModel/lib/utils.js\";\nimport {math} from \"../lib/math.js\";\n\nconst atob2 = (typeof atob !== 'undefined') ? atob : a => Buffer.from(a, 'base64').toString('binary');\n\nconst WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n};\n\nconst WEBGL_TYPE_SIZES = {\n    'SCALAR': 1,\n    'VEC2': 2,\n    'VEC3': 3,\n    'VEC4': 4,\n    'MAT2': 4,\n    'MAT3': 9,\n    'MAT4': 16\n};\n\n/**\n * @desc Parses glTF JSON into an {@link XKTModel}.\n *\n * * Supports glTF 2.\n * * Provides option to reduce XKT file size by ignoring STL normals and relying on xeokit to auto-generate them.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then load a glTF model into it.\n *\n * ````javascript\n * utils.loadJSON(\"./models/gltf/duplex/scene.gltf\", async (data) => {\n *\n *     const xktModel = new XKTModel();\n *\n *     parseGLTFIntoXKTModel({\n *          data,\n *          xktModel,\n *          log: (msg) => { console.log(msg); }\n *     }).then(()=>{\n *        xktModel.finalize();\n *     },\n *     (msg) => {\n *         console.error(msg);\n *     });\n * });\n * ````\n *\n * @param {Object} params Parsing parameters.\n * @param {Object} params.data The glTF JSON.\n * @param {Object} [params.metaModelData] Metamodel JSON. If this is provided, then parsing is able to ensure that the XKTObjects it creates will fit the metadata properly.\n * @param {XKTModel} params.xktModel XKTModel to parse into.\n * @param {Boolean} [params.autoNormals=false] When true, the parser will ignore the glTF geometry normals, and the glTF\n * data will rely on the xeokit ````Viewer```` to automatically generate them. This has the limitation that the\n * normals will be face-aligned, and therefore the ````Viewer```` will only be able to render a flat-shaded representation\n * of the glTF.\n * @param {Boolean} [params.reuseGeometries=true] Whether to enable geometry reuse within the XKTModel.\n * @param {function} [params.getAttachment] Callback through which to fetch attachments, if the glTF has them.\n * @param {Object} [params.stats] Collects statistics.\n * @param {function} [params.log] Logging callback.\n * @returns {Promise}\n */\nfunction parseGLTFIntoXKTModel({\n                                   data,\n                                   xktModel,\n                                   metaModelData,\n                                   autoNormals,\n                                   reuseGeometries,\n                                   getAttachment,\n                                   stats = {},\n                                   log\n                               }) {\n\n    return new Promise(function (resolve, reject) {\n\n        if (!data) {\n            reject(\"Argument expected: data\");\n            return;\n        }\n\n        if (!xktModel) {\n            reject(\"Argument expected: xktModel\");\n            return;\n        }\n\n        stats.sourceFormat = \"glTF\";\n        stats.schemaVersion = \"2.0\";\n        stats.title = \"\";\n        stats.author = \"\";\n        stats.created = \"\";\n        stats.numTriangles = 0;\n        stats.numVertices = 0;\n        stats.numObjects = 0;\n        stats.numGeometries = 0;\n\n        const ctx = {\n            gltf: data,\n            metaModelCorrections: metaModelData ? getMetaModelCorrections(metaModelData) : null,\n            getAttachment: getAttachment || (() => {\n                throw new Error('You must define getAttachment() method to convert glTF with external resources')\n            }),\n            log: (log || function (msg) {\n            }),\n            xktModel: xktModel,\n            autoNormals: autoNormals,\n            createXKTGeometryIds: {},\n            nextMeshId: 0,\n            reuseGeometries: (reuseGeometries !== false),\n            stats\n        };\n\n        parseBuffers(ctx).then(() => {\n\n            parseBufferViews(ctx);\n            freeBuffers(ctx);\n            parseMaterials(ctx);\n            parseDefaultScene(ctx);\n\n            resolve();\n\n        }, (errMsg) => {\n            reject(errMsg);\n        });\n    });\n}\n\nfunction getMetaModelCorrections(metaModelData) {\n    const eachRootStats = {};\n    const eachChildRoot = {};\n    const metaObjects = metaModelData.metaObjects || [];\n    const metaObjectsMap = {};\n    for (let i = 0, len = metaObjects.length; i < len; i++) {\n        const metaObject = metaObjects[i];\n        metaObjectsMap[metaObject.id] = metaObject;\n    }\n    for (let i = 0, len = metaObjects.length; i < len; i++) {\n        const metaObject = metaObjects[i];\n        if (metaObject.parent !== undefined && metaObject.parent !== null) {\n            const metaObjectParent = metaObjectsMap[metaObject.parent];\n            if (metaObject.type === metaObjectParent.type) {\n                let rootMetaObject = metaObjectParent;\n                while (rootMetaObject.parent && metaObjectsMap[rootMetaObject.parent].type === rootMetaObject.type) {\n                    rootMetaObject = metaObjectsMap[rootMetaObject.parent];\n                }\n                const rootStats = eachRootStats[rootMetaObject.id] || (eachRootStats[rootMetaObject.id] = {\n                    numChildren: 0,\n                    countChildren: 0\n                });\n                rootStats.numChildren++;\n                eachChildRoot[metaObject.id] = rootMetaObject;\n            } else {\n\n            }\n        }\n    }\n    const metaModelCorrections = {\n        metaObjectsMap,\n        eachRootStats,\n        eachChildRoot\n    };\n    return metaModelCorrections;\n}\n\nfunction parseBuffers(ctx) {  // Parses geometry buffers into temporary  \"_buffer\" Unit8Array properties on the glTF \"buffer\" elements\n    const buffers = ctx.gltf.buffers;\n    if (buffers) {\n        return Promise.all(buffers.map(buffer => parseBuffer(ctx, buffer)));\n    } else {\n        return new Promise(function (resolve, reject) {\n            resolve();\n        });\n    }\n}\n\nfunction parseBuffer(ctx, bufferInfo) {\n    return new Promise(function (resolve, reject) {\n        // Allow a shortcut where the glTF buffer is \"enrichened\" with direct\n        // access to the data-arrayBuffer, w/out needing to either:\n        // - read the file indicated by the \".uri\" component of the buffer\n        // - base64-decode the encoded data in the \".uri\" component\n        if (bufferInfo._arrayBuffer) {\n            bufferInfo._buffer = bufferInfo._arrayBuffer;\n            resolve(bufferInfo);\n            return;\n        }\n        // Otherwise, proceed with \"standard-glTF\" .uri component.\n        const uri = bufferInfo.uri;\n        if (!uri) {\n            reject('gltf/handleBuffer missing uri in ' + JSON.stringify(bufferInfo));\n            return;\n        }\n        parseArrayBuffer(ctx, uri).then((arrayBuffer) => {\n            bufferInfo._buffer = arrayBuffer;\n            resolve(arrayBuffer);\n        }, (errMsg) => {\n            reject(errMsg);\n        })\n    });\n}\n\nfunction parseArrayBuffer(ctx, uri) {\n    return new Promise(function (resolve, reject) {\n        const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/; // Check for data: URI\n        const dataUriRegexResult = uri.match(dataUriRegex);\n        if (dataUriRegexResult) { // Safari can't handle data URIs through XMLHttpRequest\n            const isBase64 = !!dataUriRegexResult[2];\n            let data = dataUriRegexResult[3];\n            data = decodeURIComponent(data);\n            if (isBase64) {\n                data = atob2(data);\n            }\n            const buffer = new ArrayBuffer(data.length);\n            const view = new Uint8Array(buffer);\n            for (let i = 0; i < data.length; i++) {\n                view[i] = data.charCodeAt(i);\n            }\n            resolve(buffer);\n        } else { // Uri is a path to a file\n            ctx.getAttachment(uri).then(\n                (arrayBuffer) => {\n                    resolve(arrayBuffer);\n                },\n                (errMsg) => {\n                    reject(errMsg);\n                });\n        }\n    });\n}\n\nfunction parseBufferViews(ctx) { // Parses our temporary \"_buffer\" properties into \"_buffer\" properties on glTF \"bufferView\" elements\n    const bufferViewsInfo = ctx.gltf.bufferViews;\n    if (bufferViewsInfo) {\n        for (let i = 0, len = bufferViewsInfo.length; i < len; i++) {\n            parseBufferView(ctx, bufferViewsInfo[i]);\n        }\n    }\n}\n\nfunction parseBufferView(ctx, bufferViewInfo) {\n    const buffer = ctx.gltf.buffers[bufferViewInfo.buffer];\n    bufferViewInfo._typedArray = null;\n    const byteLength = bufferViewInfo.byteLength || 0;\n    const byteOffset = bufferViewInfo.byteOffset || 0;\n    bufferViewInfo._buffer = buffer._buffer.slice(byteOffset, byteOffset + byteLength);\n}\n\nfunction freeBuffers(ctx) { // Deletes the \"_buffer\" properties from the glTF \"buffer\" elements, to save memory\n    const buffers = ctx.gltf.buffers;\n    if (buffers) {\n        for (let i = 0, len = buffers.length; i < len; i++) {\n            buffers[i]._buffer = null;\n        }\n    }\n}\n\nfunction parseMaterials(ctx) {\n    const materialsInfo = ctx.gltf.materials;\n    if (materialsInfo) {\n        for (let i = 0, len = materialsInfo.length; i < len; i++) {\n            const materialInfo = materialsInfo[i];\n            const material = parseMaterial(ctx, materialInfo);\n            materialInfo._materialData = material;\n        }\n    }\n}\n\nfunction parseMaterial(ctx, materialInfo) { // Attempts to extract an RGBA color for a glTF material\n    const material = {\n        color: new Float32Array([1, 1, 1]),\n        opacity: 1.0,\n        metallic: 0,\n        roughness: 1\n    };\n    const extensions = materialInfo.extensions;\n    if (extensions) {\n        const specularPBR = extensions[\"KHR_materials_pbrSpecularGlossiness\"];\n        if (specularPBR) {\n            const diffuseFactor = specularPBR.diffuseFactor;\n            if (diffuseFactor !== null && diffuseFactor !== undefined) {\n                material.color[0] = diffuseFactor[0];\n                material.color[1] = diffuseFactor[1];\n                material.color[2] = diffuseFactor[2];\n            }\n        }\n        const common = extensions[\"KHR_materials_common\"];\n        if (common) {\n            const technique = common.technique;\n            const values = common.values || {};\n            const blinn = technique === \"BLINN\";\n            const phong = technique === \"PHONG\";\n            const lambert = technique === \"LAMBERT\";\n            const diffuse = values.diffuse;\n            if (diffuse && (blinn || phong || lambert)) {\n                if (!utils.isString(diffuse)) {\n                    material.color[0] = diffuse[0];\n                    material.color[1] = diffuse[1];\n                    material.color[2] = diffuse[2];\n                }\n            }\n            const transparency = values.transparency;\n            if (transparency !== null && transparency !== undefined) {\n                material.opacity = transparency;\n            }\n            const transparent = values.transparent;\n            if (transparent !== null && transparent !== undefined) {\n                material.opacity = transparent;\n            }\n        }\n    }\n    const metallicPBR = materialInfo.pbrMetallicRoughness;\n    if (metallicPBR) {\n        const baseColorFactor = metallicPBR.baseColorFactor;\n        if (baseColorFactor) {\n            material.color[0] = baseColorFactor[0];\n            material.color[1] = baseColorFactor[1];\n            material.color[2] = baseColorFactor[2];\n            material.opacity = baseColorFactor[3];\n        }\n        const metallicFactor = metallicPBR.metallicFactor;\n        if (metallicFactor !== null && metallicFactor !== undefined) {\n            material.metallic = metallicFactor;\n        }\n        const roughnessFactor = metallicPBR.roughnessFactor;\n        if (roughnessFactor !== null && roughnessFactor !== undefined) {\n            material.roughness = roughnessFactor;\n        }\n    }\n    return material;\n}\n\nfunction parseDefaultScene(ctx) {\n    const scene = ctx.gltf.scene || 0;\n    const defaultSceneInfo = ctx.gltf.scenes[scene];\n    if (!defaultSceneInfo) {\n        throw new Error(\"glTF has no default scene\");\n    }\n    parseScene(ctx, defaultSceneInfo);\n}\n\n\nfunction parseScene(ctx, sceneInfo) {\n    const nodes = sceneInfo.nodes;\n    if (!nodes) {\n        return;\n    }\n    for (let i = 0, len = nodes.length; i < len; i++) {\n        const glTFNode = ctx.gltf.nodes[nodes[i]];\n        if (glTFNode) {\n            parseNode(ctx, glTFNode, null);\n        }\n    }\n}\n\nlet deferredMeshIds = [];\n\nfunction parseNode(ctx, glTFNode, matrix) {\n\n    const gltf = ctx.gltf;\n    const xktModel = ctx.xktModel;\n\n    let localMatrix;\n\n    if (glTFNode.matrix) {\n        localMatrix = glTFNode.matrix;\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, math.mat4());\n        } else {\n            matrix = localMatrix;\n        }\n    }\n\n    if (glTFNode.translation) {\n        localMatrix = math.translationMat4v(glTFNode.translation);\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, localMatrix);\n        } else {\n            matrix = localMatrix;\n        }\n    }\n\n    if (glTFNode.rotation) {\n        localMatrix = math.quaternionToMat4(glTFNode.rotation);\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, localMatrix);\n        } else {\n            matrix = localMatrix;\n        }\n    }\n\n    if (glTFNode.scale) {\n        localMatrix = math.scalingMat4v(glTFNode.scale);\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, localMatrix);\n        } else {\n            matrix = localMatrix;\n        }\n    }\n\n    const gltfMeshId = glTFNode.mesh;\n\n    if (gltfMeshId !== undefined) {\n\n        const meshInfo = gltf.meshes[gltfMeshId];\n\n        if (meshInfo) {\n\n            const numPrimitivesInMesh = meshInfo.primitives.length;\n\n            if (numPrimitivesInMesh > 0) {\n\n                for (let i = 0; i < numPrimitivesInMesh; i++) {\n\n                    const primitiveInfo = meshInfo.primitives[i];\n\n                    const geometryHash = createPrimitiveGeometryHash(primitiveInfo);\n\n                    let xktGeometryId = ctx.createXKTGeometryIds[geometryHash];\n\n                    if ((!ctx.reuseGeometries) || !xktGeometryId) {\n\n                        xktGeometryId = \"geometry-\" + ctx.nextMeshId++\n\n                        const geometryArrays = {};\n\n                        parsePrimitiveGeometry(ctx, primitiveInfo, geometryArrays);\n\n                        const colors = geometryArrays.colors;\n\n                        let colorsCompressed;\n\n                        if (geometryArrays.colors) {\n                            colorsCompressed = [];\n                            for (let j = 0, lenj = colors.length; j < lenj; j += 4) {\n                                colorsCompressed.push(colors[j + 0]);\n                                colorsCompressed.push(colors[j + 1]);\n                                colorsCompressed.push(colors[j + 2]);\n                                colorsCompressed.push(255);\n                            }\n                        }\n\n                        xktModel.createGeometry({\n                            geometryId: xktGeometryId,\n                            primitiveType: geometryArrays.primitive,\n                            positions: geometryArrays.positions,\n                            normals: ctx.autoNormals ? null : geometryArrays.normals,\n                            colorsCompressed: colorsCompressed,\n                            indices: geometryArrays.indices\n                        });\n\n                        ctx.stats.numGeometries++;\n                        ctx.stats.numVertices += geometryArrays.positions ? geometryArrays.positions.length / 3 : 0;\n                        ctx.stats.numTriangles += geometryArrays.indices ? geometryArrays.indices.length / 3 : 0;\n\n                        ctx.createXKTGeometryIds[geometryHash] = xktGeometryId;\n                    } else {\n// Geometry reused\n                    }\n\n                    const materialIndex = primitiveInfo.material;\n                    const materialInfo = (materialIndex !== null && materialIndex !== undefined) ? gltf.materials[materialIndex] : null;\n                    const color = materialInfo ? materialInfo._materialData.color : new Float32Array([1.0, 1.0, 1.0, 1.0]);\n                    const opacity = materialInfo ? materialInfo._materialData.opacity : 1.0;\n                    const metallic = materialInfo ? materialInfo._materialData.metallic : 0.0;\n                    const roughness = materialInfo ? materialInfo._materialData.roughness : 1.0;\n\n                    const xktMeshId = \"mesh-\" + ctx.nextMeshId++;\n\n                    xktModel.createMesh({\n                        meshId: xktMeshId,\n                        geometryId: xktGeometryId,\n                        matrix: matrix ? matrix.slice() : math.identityMat4(),\n                        color: color,\n                        opacity: opacity,\n                        metallic: metallic,\n                        roughness: roughness\n                    });\n\n                    deferredMeshIds.push(xktMeshId);\n                }\n            }\n        }\n    }\n\n\n    if (glTFNode.children) {\n        const children = glTFNode.children;\n        for (let i = 0, len = children.length; i < len; i++) {\n            const childNodeIdx = children[i];\n            const childGLTFNode = gltf.nodes[childNodeIdx];\n            if (!childGLTFNode) {\n                console.warn('Node not found: ' + i);\n                continue;\n            }\n            parseNode(ctx, childGLTFNode, matrix);\n        }\n    }\n\n    // Post-order visit scene node\n\n    const nodeName = glTFNode.name;\n\n    if (nodeName !== undefined && nodeName !== null && nodeName !== \"\" && deferredMeshIds.length > 0) {\n        const xktEntityId = nodeName;\n        if (ctx.metaModelCorrections) {  // Merging meshes into XKTObjects that map to metaobjects\n            const rootMetaObject = ctx.metaModelCorrections.eachChildRoot[xktEntityId];\n            if (rootMetaObject) {\n                const rootMetaObjectStats = ctx.metaModelCorrections.eachRootStats[rootMetaObject.id];\n                rootMetaObjectStats.countChildren++;\n                if (rootMetaObjectStats.countChildren >= rootMetaObjectStats.numChildren) {\n                    xktModel.createEntity({\n                        entityId: rootMetaObject.id,\n                        meshIds: deferredMeshIds\n                    });\n                    ctx.stats.numObjects++;\n                    deferredMeshIds = [];\n                }\n            } else {\n                const metaObject = ctx.metaModelCorrections.metaObjectsMap[xktEntityId];\n                if (metaObject) {\n                    xktModel.createEntity({\n                        entityId: xktEntityId,\n                        meshIds: deferredMeshIds\n                    });\n                    ctx.stats.numObjects++;\n                    deferredMeshIds = [];\n                }\n            }\n        } else { // Create an XKTObject from the meshes at each named glTF node, don't care about metaobjects\n            xktModel.createEntity({\n                entityId: xktEntityId,\n                meshIds: deferredMeshIds\n            });\n            ctx.stats.numObjects++;\n            deferredMeshIds = [];\n        }\n    }\n}\n\nfunction createPrimitiveGeometryHash(primitiveInfo) {\n    const attributes = primitiveInfo.attributes;\n    if (!attributes) {\n        return \"empty\";\n    }\n    const mode = primitiveInfo.mode;\n    const material = primitiveInfo.material;\n    const indices = primitiveInfo.indices;\n    const positions = primitiveInfo.attributes.POSITION;\n    const normals = primitiveInfo.attributes.NORMAL;\n    const colors = primitiveInfo.attributes.COLOR_0;\n    const uv = primitiveInfo.attributes.TEXCOORD_0;\n    return [\n        mode,\n        //  material,\n        (indices !== null && indices !== undefined) ? indices : \"-\",\n        (positions !== null && positions !== undefined) ? positions : \"-\",\n        (normals !== null && normals !== undefined) ? normals : \"-\",\n        (colors !== null && colors !== undefined) ? colors : \"-\",\n        (uv !== null && uv !== undefined) ? uv : \"-\"\n    ].join(\";\");\n}\n\nfunction parsePrimitiveGeometry(ctx, primitiveInfo, geometryArrays) {\n    const attributes = primitiveInfo.attributes;\n    if (!attributes) {\n        return;\n    }\n    switch (primitiveInfo.mode) {\n        case 0: // POINTS\n            geometryArrays.primitive = \"points\";\n            break;\n        case 1: // LINES\n            geometryArrays.primitive = \"lines\";\n            break;\n        case 2: // LINE_LOOP\n            // TODO: convert\n            geometryArrays.primitive = \"lines\";\n            break;\n        case 3: // LINE_STRIP\n            // TODO: convert\n            geometryArrays.primitive = \"lines\";\n            break;\n        case 4: // TRIANGLES\n            geometryArrays.primitive = \"triangles\";\n            break;\n        case 5: // TRIANGLE_STRIP\n            // TODO: convert\n            console.log(\"TRIANGLE_STRIP\");\n            geometryArrays.primitive = \"triangles\";\n            break;\n        case 6: // TRIANGLE_FAN\n            // TODO: convert\n            console.log(\"TRIANGLE_FAN\");\n            geometryArrays.primitive = \"triangles\";\n            break;\n        default:\n            geometryArrays.primitive = \"triangles\";\n    }\n    const accessors = ctx.gltf.accessors;\n    const indicesIndex = primitiveInfo.indices;\n    if (indicesIndex !== null && indicesIndex !== undefined) {\n        const accessorInfo = accessors[indicesIndex];\n        geometryArrays.indices = parseAccessorTypedArray(ctx, accessorInfo);\n    }\n    const positionsIndex = attributes.POSITION;\n    if (positionsIndex !== null && positionsIndex !== undefined) {\n        const accessorInfo = accessors[positionsIndex];\n        geometryArrays.positions = parseAccessorTypedArray(ctx, accessorInfo);\n    }\n    const normalsIndex = attributes.NORMAL;\n    if (normalsIndex !== null && normalsIndex !== undefined) {\n        const accessorInfo = accessors[normalsIndex];\n        geometryArrays.normals = parseAccessorTypedArray(ctx, accessorInfo);\n    }\n    const colorsIndex = attributes.COLOR_0;\n    if (colorsIndex !== null && colorsIndex !== undefined) {\n        const accessorInfo = accessors[colorsIndex];\n        geometryArrays.colors = parseAccessorTypedArray(ctx, accessorInfo);\n    }\n}\n\nfunction parseAccessorTypedArray(ctx, accessorInfo) {\n    const bufferView = ctx.gltf.bufferViews[accessorInfo.bufferView];\n    const itemSize = WEBGL_TYPE_SIZES[accessorInfo.type];\n    const TypedArray = WEBGL_COMPONENT_TYPES[accessorInfo.componentType];\n    const elementBytes = TypedArray.BYTES_PER_ELEMENT; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n    const itemBytes = elementBytes * itemSize;\n    if (accessorInfo.byteStride && accessorInfo.byteStride !== itemBytes) { // The buffer is not interleaved if the stride is the item size in bytes.\n        throw new Error(\"interleaved buffer!\"); // TODO\n    } else {\n        return new TypedArray(bufferView._buffer, accessorInfo.byteOffset || 0, accessorInfo.count * itemSize);\n    }\n}\n\nexport {parseGLTFIntoXKTModel};\n",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/parsers/parseGLTFIntoXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 389,
    "kind": "variable",
    "name": "atob2",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~atob2",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 390,
    "kind": "variable",
    "name": "WEBGL_COMPONENT_TYPES",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~WEBGL_COMPONENT_TYPES",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "{\"5120\": *, \"5121\": *, \"5122\": *, \"5123\": *, \"5125\": *, \"5126\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 391,
    "kind": "variable",
    "name": "WEBGL_TYPE_SIZES",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~WEBGL_TYPE_SIZES",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "{\"SCALAR\": number, \"VEC2\": number, \"VEC3\": number, \"VEC4\": number, \"MAT2\": number, \"MAT3\": number, \"MAT4\": number}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 392,
    "kind": "function",
    "name": "getMetaModelCorrections",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~getMetaModelCorrections",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 131,
    "undocument": true,
    "params": [
      {
        "name": "metaModelData",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 393,
    "kind": "function",
    "name": "parseBuffers",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseBuffers",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 168,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 394,
    "kind": "function",
    "name": "parseBuffer",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseBuffer",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 179,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "bufferInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 395,
    "kind": "function",
    "name": "parseArrayBuffer",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseArrayBuffer",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 205,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "uri",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 396,
    "kind": "function",
    "name": "parseBufferViews",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseBufferViews",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 234,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 397,
    "kind": "function",
    "name": "parseBufferView",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseBufferView",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 243,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "bufferViewInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 398,
    "kind": "function",
    "name": "freeBuffers",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~freeBuffers",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 251,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 399,
    "kind": "function",
    "name": "parseMaterials",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseMaterials",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 260,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 400,
    "kind": "function",
    "name": "parseMaterial",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseMaterial",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 271,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "materialInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 401,
    "kind": "function",
    "name": "parseDefaultScene",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseDefaultScene",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 335,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 402,
    "kind": "function",
    "name": "parseScene",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseScene",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 345,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "sceneInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 403,
    "kind": "variable",
    "name": "deferredMeshIds",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~deferredMeshIds",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 358,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 404,
    "kind": "function",
    "name": "parseNode",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseNode",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 360,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "glTFNode",
        "types": [
          "*"
        ]
      },
      {
        "name": "matrix",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 405,
    "kind": "function",
    "name": "createPrimitiveGeometryHash",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~createPrimitiveGeometryHash",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 543,
    "undocument": true,
    "params": [
      {
        "name": "primitiveInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 406,
    "kind": "function",
    "name": "parsePrimitiveGeometry",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parsePrimitiveGeometry",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 566,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "primitiveInfo",
        "types": [
          "*"
        ]
      },
      {
        "name": "geometryArrays",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 407,
    "kind": "function",
    "name": "parseAccessorTypedArray",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseAccessorTypedArray",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 625,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "accessorInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 408,
    "kind": "function",
    "name": "parseGLTFIntoXKTModel",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseGLTFIntoXKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": "{parseGLTFIntoXKTModel}",
    "description": "Parses glTF JSON into an {@link XKTModel}.\n\n* Supports glTF 2.\n* Provides option to reduce XKT file size by ignoring STL normals and relying on xeokit to auto-generate them.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then load a glTF model into it.\n\n````javascript\nutils.loadJSON(\"./models/gltf/duplex/scene.gltf\", async (data) => {\n\n    const xktModel = new XKTModel();\n\n    parseGLTFIntoXKTModel({\n         data,\n         xktModel,\n         log: (msg) => { console.log(msg); }\n    }).then(()=>{\n       xktModel.finalize();\n    },\n    (msg) => {\n        console.error(msg);\n    });\n});\n````",
    "lineNumber": 67,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Parsing parameters."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.data",
        "description": "The glTF JSON."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "params.metaModelData",
        "description": "Metamodel JSON. If this is provided, then parsing is able to ensure that the XKTObjects it creates will fit the metadata properly."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "params.xktModel",
        "description": "XKTModel to parse into."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "params.autoNormals",
        "description": "When true, the parser will ignore the glTF geometry normals, and the glTF\ndata will rely on the xeokit ````Viewer```` to automatically generate them. This has the limitation that the\nnormals will be face-aligned, and therefore the ````Viewer```` will only be able to render a flat-shaded representation\nof the glTF."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "params.reuseGeometries",
        "description": "Whether to enable geometry reuse within the XKTModel."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.getAttachment",
        "description": "Callback through which to fetch attachments, if the glTF has them."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "params.stats",
        "description": "Collects statistics."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.log",
        "description": "Logging callback."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 409,
    "kind": "file",
    "name": "src/parsers/parseGLTFIntoXKTModel2.js",
    "content": "import {utils} from \"../XKTModel/lib/utils.js\";\nimport {math} from \"../lib/math.js\";\n\nimport {parse} from '@loaders.gl/core';\nimport {GLTFLoader} from '@loaders.gl/gltf';\n\n/**\n * @desc Experimental function that uses loaders.gl to parse glTF into an {@link XKTModel}.\n *\n * > This only works in the Browser's JavaScript execution environment at the moment, so should be considered\n * > experimental. The loaders.gl library is not quite working right for us in NodeJS, until we fix some polyfills.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then load a binary glTF model into it.\n *\n * ````javascript\n * utils.loadArraybuffer(\"../assets/models/gltf/HousePlan/glTF-Binary/HousePlan.glb\", async (data) => {\n *\n *     const xktModel = new XKTModel();\n *\n *     parseGLTFIntoXKTModel({\n *          data,\n *          xktModel,\n *          log: (msg) => { console.log(msg); }\n *     }).then(()=>{\n *        xktModel.finalize();\n *     },\n *     (msg) => {\n *         console.error(msg);\n *     });\n * });\n * ````\n *\n * @param {Object} params Parsing parameters.\n * @param {Arraybuffer} params.data The glTF.\n * @param {String} [params.baseUri] The base URI used to load this glTF, if any. For resolving relative uris to linked resources.\n * @param {Object} [params.metaModelData] Metamodel JSON. If this is provided, then parsing is able to ensure that the XKTObjects it creates will fit the metadata properly.\n * @param {XKTModel} params.xktModel XKTModel to parse into.\n * @param {Boolean} [params.autoNormals=false] When true, the parser will ignore the glTF geometry normals, and the glTF\n * data will rely on the xeokit ````Viewer```` to automatically generate them. This has the limitation that the\n * normals will be face-aligned, and therefore the ````Viewer```` will only be able to render a flat-shaded representation\n * of the glTF.\n * @param {Object} [params.stats] Collects statistics.\n * @param {function} [params.log] Logging callback.\n * @returns {Promise}\n */\nfunction parseGLTFIntoXKTModel2({data, baseUri, xktModel, metaModelData, autoNormals, getAttachment, stats = {}, log}) {\n\n    return new Promise(function (resolve, reject) {\n\n        if (!data) {\n            reject(\"Argument expected: data\");\n            return;\n        }\n\n        if (!xktModel) {\n            reject(\"Argument expected: xktModel\");\n            return;\n        }\n\n        stats.sourceFormat = \"glTF\";\n        stats.schemaVersion = \"2.0\";\n        stats.title = \"\";\n        stats.author = \"\";\n        stats.created = \"\";\n        stats.numTriangles = 0;\n        stats.numVertices = 0;\n        stats.numObjects = 0;\n        stats.numGeometries = 0;\n\n        parse(data, GLTFLoader, {\n            baseUri\n        }).then((gltfData) => {\n\n            const ctx = {\n                gltfData,\n                metaModelCorrections: metaModelData ? getMetaModelCorrections(metaModelData) : null,\n                log: (log || function (msg) {\n                }),\n                error: function (msg) {\n                    console.error(msg);\n                },\n                xktModel,\n                autoNormals,\n                nextId: 0,\n                stats\n            };\n\n            parseMaterials(ctx);\n            parseDefaultScene(ctx);\n\n            resolve();\n\n        }, (errMsg) => {\n            reject(errMsg);\n        });\n    });\n}\n\nfunction getMetaModelCorrections(metaModelData) {\n    const eachRootStats = {};\n    const eachChildRoot = {};\n    const metaObjects = metaModelData.metaObjects || [];\n    const metaObjectsMap = {};\n    for (let i = 0, len = metaObjects.length; i < len; i++) {\n        const metaObject = metaObjects[i];\n        metaObjectsMap[metaObject.id] = metaObject;\n    }\n    for (let i = 0, len = metaObjects.length; i < len; i++) {\n        const metaObject = metaObjects[i];\n        if (metaObject.parent !== undefined && metaObject.parent !== null) {\n            const metaObjectParent = metaObjectsMap[metaObject.parent];\n            if (metaObject.type === metaObjectParent.type) {\n                let rootMetaObject = metaObjectParent;\n                while (rootMetaObject.parent && metaObjectsMap[rootMetaObject.parent].type === rootMetaObject.type) {\n                    rootMetaObject = metaObjectsMap[rootMetaObject.parent];\n                }\n                const rootStats = eachRootStats[rootMetaObject.id] || (eachRootStats[rootMetaObject.id] = {\n                    numChildren: 0,\n                    countChildren: 0\n                });\n                rootStats.numChildren++;\n                eachChildRoot[metaObject.id] = rootMetaObject;\n            } else {\n\n            }\n        }\n    }\n    const metaModelCorrections = {\n        metaObjectsMap,\n        eachRootStats,\n        eachChildRoot\n    };\n    return metaModelCorrections;\n}\n\nfunction parseMaterials(ctx) {\n    const gltfData = ctx.gltfData;\n    const materials = gltfData.materials;\n    if (materials) {\n        for (let i = 0, len = materials.length; i < len; i++) {\n            const material = materials[i];\n            //           material._textureSetId = parseTextureSet(ctx, material);\n            material._attributes = parseMaterialAttributes(ctx, material);\n        }\n    }\n}\n\nfunction parseMaterialAttributes(ctx, material) { // Substitute RGBA for material, to use fast flat shading instead\n    const extensions = material.extensions;\n    const materialAttributes = {\n        color: new Float32Array([1, 1, 1, 1]),\n        opacity: 1,\n        metallic: 0,\n        roughness: 1\n    };\n    if (extensions) {\n        const specularPBR = extensions[\"KHR_materials_pbrSpecularGlossiness\"];\n        if (specularPBR) {\n            const diffuseFactor = specularPBR.diffuseFactor;\n            if (diffuseFactor !== null && diffuseFactor !== undefined) {\n                materialAttributes.color.set(diffuseFactor);\n            }\n        }\n        const common = extensions[\"KHR_materials_common\"];\n        if (common) {\n            const technique = common.technique;\n            const values = common.values || {};\n            const blinn = technique === \"BLINN\";\n            const phong = technique === \"PHONG\";\n            const lambert = technique === \"LAMBERT\";\n            const diffuse = values.diffuse;\n            if (diffuse && (blinn || phong || lambert)) {\n                if (!utils.isString(diffuse)) {\n                    materialAttributes.color.set(diffuse);\n                }\n            }\n            const transparency = values.transparency;\n            if (transparency !== null && transparency !== undefined) {\n                materialAttributes.opacity = transparency;\n            }\n            const transparent = values.transparent;\n            if (transparent !== null && transparent !== undefined) {\n                materialAttributes.opacity = transparent;\n            }\n        }\n    }\n    const metallicPBR = material.pbrMetallicRoughness;\n    if (metallicPBR) {\n        const baseColorFactor = metallicPBR.baseColorFactor;\n        if (baseColorFactor) {\n            materialAttributes.color[0] = baseColorFactor[0];\n            materialAttributes.color[1] = baseColorFactor[1];\n            materialAttributes.color[2] = baseColorFactor[2];\n            materialAttributes.opacity = baseColorFactor[3];\n        }\n        const metallicFactor = metallicPBR.metallicFactor;\n        if (metallicFactor !== null && metallicFactor !== undefined) {\n            materialAttributes.metallic = metallicFactor;\n        }\n        const roughnessFactor = metallicPBR.roughnessFactor;\n        if (roughnessFactor !== null && roughnessFactor !== undefined) {\n            materialAttributes.roughness = roughnessFactor;\n        }\n    }\n    return materialAttributes;\n}\n\nfunction parseDefaultScene(ctx) {\n    const gltfData = ctx.gltfData;\n    const scene = gltfData.scene || gltfData.scenes[0];\n    if (!scene) {\n        ctx.error(\"glTF has no default scene\");\n        return;\n    }\n    parseScene(ctx, scene);\n}\n\nfunction parseScene(ctx, scene) {\n    const nodes = scene.nodes;\n    if (!nodes) {\n        return;\n    }\n    for (let i = 0, len = nodes.length; i < len; i++) {\n        const node = nodes[i];\n        countMeshUsage(ctx, node);\n    }\n    for (let i = 0, len = nodes.length; i < len; i++) {\n        const node = nodes[i];\n        parseNode(ctx, node, null);\n    }\n}\n\nfunction countMeshUsage(ctx, node) {\n    const mesh = node.mesh;\n    if (mesh) {\n        mesh.instances = mesh.instances ? mesh.instances + 1 : 1;\n    }\n    if (node.children) {\n        const children = node.children;\n        for (let i = 0, len = children.length; i < len; i++) {\n            const childNode = children[i];\n            if (!childNode) {\n                ctx.error(\"Node not found: \" + i);\n                continue;\n            }\n            countMeshUsage(ctx, childNode);\n        }\n    }\n}\n\nconst deferredMeshIds = [];\n\nfunction parseNode(ctx, node, matrix) {\n\n    const xktModel = ctx.xktModel;\n\n    // Pre-order visit scene node\n\n    let localMatrix;\n    if (node.matrix) {\n        localMatrix = node.matrix;\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, math.mat4());\n        } else {\n            matrix = localMatrix;\n        }\n    }\n    if (node.translation) {\n        localMatrix = math.translationMat4v(node.translation);\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, math.mat4());\n        } else {\n            matrix = localMatrix;\n        }\n    }\n    if (node.rotation) {\n        localMatrix = math.quaternionToMat4(node.rotation);\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, math.mat4());\n        } else {\n            matrix = localMatrix;\n        }\n    }\n    if (node.scale) {\n        localMatrix = math.scalingMat4v(node.scale);\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, math.mat4());\n        } else {\n            matrix = localMatrix;\n        }\n    }\n\n    if (node.mesh) {\n\n        const mesh = node.mesh;\n        const numPrimitives = mesh.primitives.length;\n\n        if (numPrimitives > 0) {\n            for (let i = 0; i < numPrimitives; i++) {\n                const primitive = mesh.primitives[i];\n                if (!primitive._xktGeometryId) {\n                    const xktGeometryId = \"geometry-\" + ctx.nextId++;\n                    const geometryCfg = {\n                        geometryId: xktGeometryId\n                    };\n                    switch (primitive.mode) {\n                        case 0: // POINTS\n                            geometryCfg.primitiveType = \"points\";\n                            break;\n                        case 1: // LINES\n                            geometryCfg.primitiveType = \"lines\";\n                            break;\n                        case 2: // LINE_LOOP\n                            geometryCfg.primitiveType = \"lines\";\n                            break;\n                        case 3: // LINE_STRIP\n                            geometryCfg.primitiveType = \"lines\";\n                            break;\n                        case 4: // TRIANGLES\n                            geometryCfg.primitiveType = \"triangles\";\n                            break;\n                        case 5: // TRIANGLE_STRIP\n                            geometryCfg.primitiveType = \"triangles\";\n                            break;\n                        case 6: // TRIANGLE_FAN\n                            geometryCfg.primitiveType = \"triangles\";\n                            break;\n                        default:\n                            geometryCfg.primitiveType = \"triangles\";\n                    }\n                    const POSITION = primitive.attributes.POSITION;\n                    if (!POSITION) {\n                        continue;\n                    }\n                    geometryCfg.positions = primitive.attributes.POSITION.value;\n                    if (!ctx.autoNormals) {\n                        if (primitive.attributes.NORMAL) {\n                            geometryCfg.normals = primitive.attributes.NORMAL.value;\n                        }\n                    }\n                    if (primitive.attributes.COLOR_0) {\n                        geometryCfg.colorsCompressed = primitive.attributes.COLOR_0.value;\n                    }\n                    if (primitive.attributes.TEXCOORD_0) {\n                        geometryCfg.uv = primitive.attributes.TEXCOORD_0.value;\n                    }\n                    if (primitive.indices) {\n                        geometryCfg.indices = primitive.indices.value;\n                    }\n                    xktModel.createGeometry(geometryCfg);\n                    primitive._xktGeometryId = xktGeometryId;\n                }\n\n                const xktMeshId = ctx.nextId++;\n                const meshCfg = {\n                    meshId: xktMeshId,\n                    geometryId: primitive._xktGeometryId,\n                    matrix: matrix ? matrix.slice() : math.identityMat4()\n                };\n                const material = primitive.material;\n                if (material) {\n                    meshCfg.color = material._attributes.color;\n                    meshCfg.opacity = material._attributes.opacity;\n                    meshCfg.metallic = material._attributes.metallic;\n                    meshCfg.roughness = material._attributes.roughness;\n                } else {\n                    meshCfg.color = [1.0, 1.0, 1.0];\n                    meshCfg.opacity = 1.0;\n                }\n                xktModel.createMesh(meshCfg);\n                deferredMeshIds.push(xktMeshId);\n            }\n        }\n    }\n\n    // Visit child scene nodes\n\n    if (node.children) {\n        const children = node.children;\n        for (let i = 0, len = children.length; i < len; i++) {\n            const childNode = children[i];\n            parseNode(ctx, childNode, matrix);\n        }\n    }\n\n    // Post-order visit scene node\n\n    const nodeName = node.name;\n    if (nodeName !== undefined && nodeName !== null && deferredMeshIds.length > 0) {\n        let xktEntityId = nodeName;\n        if (xktModel.entities[xktEntityId]) {\n            ctx.error(\"Two or more glTF nodes found with same 'name' attribute: '\" + nodeName + \"'\");\n        }\n        while (!xktEntityId || xktModel.entities[xktEntityId]) {\n            xktEntityId = \"entity-\" + ctx.nextId++;\n        }\n        if (ctx.metaModelCorrections) {\n            // Merging meshes into XKTObjects that map to metaobjects\n            const rootMetaObject = ctx.metaModelCorrections.eachChildRoot[xktEntityId];\n            if (rootMetaObject) {\n                const rootMetaObjectStats = ctx.metaModelCorrections.eachRootStats[rootMetaObject.id];\n                rootMetaObjectStats.countChildren++;\n                if (rootMetaObjectStats.countChildren >= rootMetaObjectStats.numChildren) {\n                    xktModel.createEntity({\n                        entityId: rootMetaObject.id,\n                        meshIds: deferredMeshIds\n                    });\n                    ctx.stats.numObjects++;\n                    deferredMeshIds.length = 0;\n                }\n            } else {\n                const metaObject = ctx.metaModelCorrections.metaObjectsMap[xktEntityId];\n                if (metaObject) {\n                    xktModel.createEntity({\n                        entityId: xktEntityId,\n                        meshIds: deferredMeshIds\n                    });\n                    ctx.stats.numObjects++;\n                    deferredMeshIds.length = 0;\n                }\n            }\n        } else {\n            // Create an XKTObject from the meshes at each named glTF node, don't care about metaobjects\n            xktModel.createEntity({\n                entityId: xktEntityId,\n                meshIds: deferredMeshIds\n            });\n            ctx.stats.numObjects++;\n            deferredMeshIds.length = 0;\n        }\n    }\n}\n\nexport {parseGLTFIntoXKTModel2};\n",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/parsers/parseGLTFIntoXKTModel2.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 410,
    "kind": "function",
    "name": "getMetaModelCorrections",
    "memberof": "src/parsers/parseGLTFIntoXKTModel2.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel2.js~getMetaModelCorrections",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel2.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 101,
    "undocument": true,
    "params": [
      {
        "name": "metaModelData",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 411,
    "kind": "function",
    "name": "parseMaterials",
    "memberof": "src/parsers/parseGLTFIntoXKTModel2.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel2.js~parseMaterials",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel2.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 138,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 412,
    "kind": "function",
    "name": "parseMaterialAttributes",
    "memberof": "src/parsers/parseGLTFIntoXKTModel2.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel2.js~parseMaterialAttributes",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel2.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 150,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "material",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 413,
    "kind": "function",
    "name": "parseDefaultScene",
    "memberof": "src/parsers/parseGLTFIntoXKTModel2.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel2.js~parseDefaultScene",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel2.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 210,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 414,
    "kind": "function",
    "name": "parseScene",
    "memberof": "src/parsers/parseGLTFIntoXKTModel2.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel2.js~parseScene",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel2.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 220,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "scene",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 415,
    "kind": "function",
    "name": "countMeshUsage",
    "memberof": "src/parsers/parseGLTFIntoXKTModel2.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel2.js~countMeshUsage",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel2.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 235,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "node",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 416,
    "kind": "variable",
    "name": "deferredMeshIds",
    "memberof": "src/parsers/parseGLTFIntoXKTModel2.js",
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel2.js~deferredMeshIds",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel2.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 253,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 417,
    "kind": "function",
    "name": "parseNode",
    "memberof": "src/parsers/parseGLTFIntoXKTModel2.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel2.js~parseNode",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel2.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 255,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "node",
        "types": [
          "*"
        ]
      },
      {
        "name": "matrix",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 418,
    "kind": "function",
    "name": "parseGLTFIntoXKTModel2",
    "memberof": "src/parsers/parseGLTFIntoXKTModel2.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel2.js~parseGLTFIntoXKTModel2",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel2.js",
    "importStyle": "{parseGLTFIntoXKTModel2}",
    "description": "Experimental function that uses loaders.gl to parse glTF into an {@link XKTModel}.\n\n> This only works in the Browser's JavaScript execution environment at the moment, so should be considered\n> experimental. The loaders.gl library is not quite working right for us in NodeJS, until we fix some polyfills.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then load a binary glTF model into it.\n\n````javascript\nutils.loadArraybuffer(\"../assets/models/gltf/HousePlan/glTF-Binary/HousePlan.glb\", async (data) => {\n\n    const xktModel = new XKTModel();\n\n    parseGLTFIntoXKTModel({\n         data,\n         xktModel,\n         log: (msg) => { console.log(msg); }\n    }).then(()=>{\n       xktModel.finalize();\n    },\n    (msg) => {\n        console.error(msg);\n    });\n});\n````",
    "lineNumber": 48,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Parsing parameters."
      },
      {
        "nullable": null,
        "types": [
          "Arraybuffer"
        ],
        "spread": false,
        "optional": false,
        "name": "params.data",
        "description": "The glTF."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "params.baseUri",
        "description": "The base URI used to load this glTF, if any. For resolving relative uris to linked resources."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "params.metaModelData",
        "description": "Metamodel JSON. If this is provided, then parsing is able to ensure that the XKTObjects it creates will fit the metadata properly."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "params.xktModel",
        "description": "XKTModel to parse into."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "params.autoNormals",
        "description": "When true, the parser will ignore the glTF geometry normals, and the glTF\ndata will rely on the xeokit ````Viewer```` to automatically generate them. This has the limitation that the\nnormals will be face-aligned, and therefore the ````Viewer```` will only be able to render a flat-shaded representation\nof the glTF."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "params.stats",
        "description": "Collects statistics."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.log",
        "description": "Logging callback."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 419,
    "kind": "file",
    "name": "src/parsers/parseIFCIntoXKTModel.js",
    "content": "import * as WebIFC from \"web-ifc/web-ifc-api.js\";\n\n/**\n * @desc Parses IFC STEP file data into an {@link XKTModel}.\n *\n * Internally, this function uses [web-ifc](https://github.com/tomvandig/web-ifc) to parse the IFC, which relies on a\n * WASM file to do the parsing.\n *\n * Depending on how we use this function, we may need to provide it with a path to the directory where that WASM file is stored.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then load an IFC model into it.\n *\n * ````javascript\n * utils.loadArraybuffer(\"./models/ifc/rac_advanced_sample_project.ifc\", async (data) => {\n *\n *     const xktModel = new XKTModel();\n *\n *     parseIFCIntoXKTModel({\n *          data,\n *          xktModel,\n *          wasmPath: \"../dist/\",\n *          autoNormals: true,\n *          log: (msg) => { console.log(msg); }\n *     }).then(()=>{\n *        xktModel.finalize();\n *     },\n *     (msg) => {\n *         console.error(msg);\n *     });\n * });\n * ````\n *\n * @param {Object} params Parsing params.\n * @param {ArrayBuffer} [params.data] IFC file data.\n * @param {XKTModel} [params.xktModel] XKTModel to parse into.\n * @param {Boolean} [params.autoNormals=true] When true, the parser will ignore the IFC geometry normals, and the IFC\n * data will rely on the xeokit ````Viewer```` to automatically generate them. This has the limitation that the\n * normals will be face-aligned, and therefore the ````Viewer```` will only be able to render a flat-shaded representation\n * of the IFC model. This is ````true```` by default, because IFC models tend to look acceptable with flat-shading,\n * and we always want to minimize IFC model size wherever possible.\n * @param {String} params.wasmPath Path to ````web-ifc.wasm````, required by this function.\n * @param {Object} [params.stats] Collects statistics.\n * @param {function} [params.log] Logging callback.\n */\nfunction parseIFCIntoXKTModel({\n                                  data,\n                                  xktModel,\n                                  autoNormals = true,\n                                  includeTypes,\n                                  excludeTypes,\n                                  wasmPath,\n                                  stats = {},\n                                  log\n                              }) {\n\n    return new Promise(function (resolve, reject) {\n\n        if (!data) {\n            reject(\"Argument expected: data\");\n            return;\n        }\n\n        if (!xktModel) {\n            reject(\"Argument expected: xktModel\");\n            return;\n        }\n\n        if (!wasmPath) {\n            reject(\"Argument expected: wasmPath\");\n            return;\n        }\n\n        const ifcAPI = new WebIFC.IfcAPI();\n\n        if (wasmPath) {\n            ifcAPI.SetWasmPath(wasmPath);\n        }\n\n        ifcAPI.Init().then(() => {\n\n            const dataArray = new Uint8Array(data);\n\n            const modelID = ifcAPI.OpenModel(dataArray);\n\n            stats.sourceFormat = \"IFC\";\n            stats.schemaVersion = \"\";\n            stats.title = \"\";\n            stats.author = \"\";\n            stats.created = \"\";\n            stats.numMetaObjects = 0;\n            stats.numPropertySets = 0;\n            stats.numObjects = 0;\n            stats.numGeometries = 0;\n            stats.numTriangles = 0;\n            stats.numVertices = 0;\n\n            const ctx = {\n                modelID,\n                ifcAPI,\n                xktModel,\n                autoNormals,\n                log: (log || function (msg) {\n                }),\n                nextId: 0,\n                stats\n            };\n\n            if (includeTypes) {\n                ctx.includeTypes = {};\n                for (let i = 0, len = includeTypes.length; i < len; i++) {\n                    ctx.includeTypes[includeTypes[i]] = true;\n                }\n            }\n\n            if (excludeTypes) {\n                ctx.excludeTypes = {};\n                for (let i = 0, len = excludeTypes.length; i < len; i++) {\n                    ctx.excludeTypes[excludeTypes[i]] = true;\n                }\n            }\n\n            const lines = ctx.ifcAPI.GetLineIDsWithType(modelID, WebIFC.IFCPROJECT);\n            const ifcProjectId = lines.get(0);\n            const ifcProject = ctx.ifcAPI.GetLine(modelID, ifcProjectId);\n\n            ctx.xktModel.schema = \"\";\n            ctx.xktModel.modelId = \"\" + modelID;\n            ctx.xktModel.projectId = \"\" + ifcProjectId;\n\n            parseMetadata(ctx);\n            parseGeometry(ctx);\n            parsePropertySets(ctx);\n\n            resolve();\n\n        }).catch((e) => {\n\n            reject(e);\n        })\n    });\n}\n\nfunction parsePropertySets(ctx) {\n\n    const lines = ctx.ifcAPI.GetLineIDsWithType(ctx.modelID, WebIFC.IFCRELDEFINESBYPROPERTIES);\n\n    for (let i = 0; i < lines.size(); i++) {\n\n        let relID = lines.get(i);\n\n        let rel = ctx.ifcAPI.GetLine(ctx.modelID, relID, true);\n\n        if (rel) {\n            \n            const relatingPropertyDefinition = rel.RelatingPropertyDefinition;\n            if (!relatingPropertyDefinition) {\n                continue;\n            }\n\n            const propertySetId = relatingPropertyDefinition.GlobalId.value;\n\n            const relatedObjects = rel.RelatedObjects;\n            if (relatedObjects) {\n                for (let i = 0, len = relatedObjects.length; i < len; i++) {\n                    const relatedObject = relatedObjects[i];\n                    const metaObjectId = relatedObject.GlobalId.value;\n                    const metaObject = ctx.xktModel.metaObjects[metaObjectId];\n                    if (metaObject) {\n                        if (!metaObject.propertySetIds) {\n                            metaObject.propertySetIds = [];\n                        }\n                        metaObject.propertySetIds.push(propertySetId);\n                    }\n                }\n            }\n\n            const props = relatingPropertyDefinition.HasProperties;\n            if (props && props.length > 0) {\n                const propertySetType = \"Default\";\n                const propertySetName = relatingPropertyDefinition.Name.value;\n                const properties = [];\n                for (let i = 0, len = props.length; i < len; i++) {\n                    const prop = props[i];\n                    const name = prop.Name;\n                    const nominalValue = prop.NominalValue;\n                    if (name && nominalValue) {\n                        const property = {\n                            name: name.value,\n                            type: nominalValue.type,\n                            value: nominalValue.value,\n                            valueType: nominalValue.valueType\n                        };\n                        if (prop.Description) {\n                            property.description = prop.Description.value;\n                        } else if (nominalValue.description) {\n                            property.description = nominalValue.description;\n                        }\n                        properties.push(property);\n                    }\n                }\n                ctx.xktModel.createPropertySet({propertySetId, propertySetType, propertySetName, properties});\n                ctx.stats.numPropertySets++;\n            }\n        }\n    }\n}\n\nfunction parseMetadata(ctx) {\n\n    const lines = ctx.ifcAPI.GetLineIDsWithType(ctx.modelID, WebIFC.IFCPROJECT);\n    const ifcProjectId = lines.get(0);\n    const ifcProject = ctx.ifcAPI.GetLine(ctx.modelID, ifcProjectId);\n\n    parseSpatialChildren(ctx, ifcProject);\n}\n\nfunction parseSpatialChildren(ctx, ifcElement, parentMetaObjectId) {\n\n    const metaObjectType = ifcElement.__proto__.constructor.name;\n\n    if (ctx.includeTypes && (!ctx.includeTypes[metaObjectType])) {\n        return;\n    }\n\n    if (ctx.excludeTypes && ctx.excludeTypes[metaObjectType]) {\n        return;\n    }\n\n    createMetaObject(ctx, ifcElement, parentMetaObjectId);\n\n    const metaObjectId = ifcElement.GlobalId.value;\n\n    parseRelatedItemsOfType(\n        ctx,\n        ifcElement.expressID,\n        'RelatingObject',\n        'RelatedObjects',\n        WebIFC.IFCRELAGGREGATES,\n        metaObjectId);\n\n    parseRelatedItemsOfType(\n        ctx,\n        ifcElement.expressID,\n        'RelatingStructure',\n        'RelatedElements',\n        WebIFC.IFCRELCONTAINEDINSPATIALSTRUCTURE,\n        metaObjectId);\n}\n\nfunction createMetaObject(ctx, ifcElement, parentMetaObjectId) {\n\n    const metaObjectId = ifcElement.GlobalId.value;\n    const propertySetIds = null;\n    const metaObjectType = ifcElement.__proto__.constructor.name;\n    const metaObjectName = (ifcElement.Name && ifcElement.Name.value !== \"\") ? ifcElement.Name.value : metaObjectType;\n\n    ctx.xktModel.createMetaObject({metaObjectId, propertySetIds, metaObjectType, metaObjectName, parentMetaObjectId});\n    ctx.stats.numMetaObjects++;\n}\n\nfunction parseRelatedItemsOfType(ctx, id, relation, related, type, parentMetaObjectId) {\n\n    const lines = ctx.ifcAPI.GetLineIDsWithType(ctx.modelID, type);\n\n    for (let i = 0; i < lines.size(); i++) {\n\n        const relID = lines.get(i);\n        const rel = ctx.ifcAPI.GetLine(ctx.modelID, relID);\n        const relatedItems = rel[relation];\n\n        let foundElement = false;\n\n        if (Array.isArray(relatedItems)) {\n            const values = relatedItems.map((item) => item.value);\n            foundElement = values.includes(id);\n\n        } else {\n            foundElement = (relatedItems.value === id);\n        }\n\n        if (foundElement) {\n\n            const element = rel[related];\n\n            if (!Array.isArray(element)) {\n\n                const ifcElement = ctx.ifcAPI.GetLine(ctx.modelID, element.value);\n\n                parseSpatialChildren(ctx, ifcElement, parentMetaObjectId);\n\n            } else {\n\n                element.forEach((element2) => {\n\n                    const ifcElement = ctx.ifcAPI.GetLine(ctx.modelID, element2.value);\n\n                    parseSpatialChildren(ctx, ifcElement, parentMetaObjectId);\n                });\n            }\n        }\n    }\n}\n\nfunction parseGeometry(ctx) {\n\n    // Parses the geometry and materials in the IFC, creates\n    // XKTEntity, XKTMesh and XKTGeometry components within the XKTModel.\n\n    const flatMeshes = ctx.ifcAPI.LoadAllGeometry(ctx.modelID);\n\n    for (let i = 0, len = flatMeshes.size(); i < len; i++) {\n\n        const flatMesh = flatMeshes.get(i);\n        const flatMeshExpressID = flatMesh.expressID;\n        const placedGeometries = flatMesh.geometries;\n\n        const meshIds = [];\n\n        const properties = ctx.ifcAPI.GetLine(ctx.modelID, flatMeshExpressID);\n        const entityId = properties.GlobalId.value;\n\n        const metaObjectId = entityId;\n        const metaObject = ctx.xktModel.metaObjects[metaObjectId];\n\n        if (ctx.includeTypes && (!metaObject || (!ctx.includeTypes[metaObject.metaObjectType]))) {\n            return;\n        }\n\n        if (ctx.excludeTypes && (!metaObject || ctx.excludeTypes[metaObject.metaObjectType])) {\n            console.log(\"excluding: \" + metaObjectId)\n            return;\n        }\n\n        for (let j = 0, lenj = placedGeometries.size(); j < lenj; j++) {\n\n            const placedGeometry = placedGeometries.get(j);\n            const geometryId = \"\" + placedGeometry.geometryExpressID;\n\n            if (!ctx.xktModel.geometries[geometryId]) {\n\n                const geometry = ctx.ifcAPI.GetGeometry(ctx.modelID, placedGeometry.geometryExpressID);\n                const vertexData = ctx.ifcAPI.GetVertexArray(geometry.GetVertexData(), geometry.GetVertexDataSize());\n                const indices = ctx.ifcAPI.GetIndexArray(geometry.GetIndexData(), geometry.GetIndexDataSize());\n\n                // De-interleave vertex arrays\n\n                const positions = [];\n                const normals = [];\n\n                for (let k = 0, lenk = vertexData.length / 6; k < lenk; k++) {\n                    positions.push(vertexData[k * 6 + 0]);\n                    positions.push(vertexData[k * 6 + 1]);\n                    positions.push(vertexData[k * 6 + 2]);\n                }\n\n                if (!ctx.autoNormals) {\n                    for (let k = 0, lenk = vertexData.length / 6; k < lenk; k++) {\n                        normals.push(vertexData[k * 6 + 3]);\n                        normals.push(vertexData[k * 6 + 4]);\n                        normals.push(vertexData[k * 6 + 5]);\n                    }\n                }\n\n                ctx.xktModel.createGeometry({\n                    geometryId: geometryId,\n                    primitiveType: \"triangles\",\n                    positions: positions,\n                    normals: ctx.autoNormals ? null : normals,\n                    indices: indices\n                });\n\n                ctx.stats.numGeometries++;\n                ctx.stats.numVertices += (positions.length / 3);\n                ctx.stats.numTriangles += (indices.length / 3);\n            }\n\n            const meshId = (\"mesh\" + ctx.nextId++);\n\n            ctx.xktModel.createMesh({\n                meshId: meshId,\n                geometryId: geometryId,\n                matrix: new Float32Array(placedGeometry.flatTransformation),\n                color: [placedGeometry.color.x, placedGeometry.color.y, placedGeometry.color.z],\n                opacity: placedGeometry.color.w\n            });\n\n            meshIds.push(meshId);\n        }\n\n        ctx.xktModel.createEntity({\n            entityId: entityId,\n            meshIds: meshIds\n        });\n\n        ctx.stats.numObjects++;\n    }\n}\n\nexport {parseIFCIntoXKTModel};\n",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/parsers/parseIFCIntoXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 420,
    "kind": "function",
    "name": "parsePropertySets",
    "memberof": "src/parsers/parseIFCIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseIFCIntoXKTModel.js~parsePropertySets",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseIFCIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 145,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 421,
    "kind": "function",
    "name": "parseMetadata",
    "memberof": "src/parsers/parseIFCIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseIFCIntoXKTModel.js~parseMetadata",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseIFCIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 210,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 422,
    "kind": "function",
    "name": "parseSpatialChildren",
    "memberof": "src/parsers/parseIFCIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseIFCIntoXKTModel.js~parseSpatialChildren",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseIFCIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 219,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "ifcElement",
        "types": [
          "*"
        ]
      },
      {
        "name": "parentMetaObjectId",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 423,
    "kind": "function",
    "name": "createMetaObject",
    "memberof": "src/parsers/parseIFCIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseIFCIntoXKTModel.js~createMetaObject",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseIFCIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 252,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "ifcElement",
        "types": [
          "*"
        ]
      },
      {
        "name": "parentMetaObjectId",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 424,
    "kind": "function",
    "name": "parseRelatedItemsOfType",
    "memberof": "src/parsers/parseIFCIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseIFCIntoXKTModel.js~parseRelatedItemsOfType",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseIFCIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 263,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "id",
        "types": [
          "*"
        ]
      },
      {
        "name": "relation",
        "types": [
          "*"
        ]
      },
      {
        "name": "related",
        "types": [
          "*"
        ]
      },
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "parentMetaObjectId",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 425,
    "kind": "function",
    "name": "parseGeometry",
    "memberof": "src/parsers/parseIFCIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseIFCIntoXKTModel.js~parseGeometry",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseIFCIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 306,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 426,
    "kind": "function",
    "name": "parseIFCIntoXKTModel",
    "memberof": "src/parsers/parseIFCIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseIFCIntoXKTModel.js~parseIFCIntoXKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseIFCIntoXKTModel.js",
    "importStyle": "{parseIFCIntoXKTModel}",
    "description": "Parses IFC STEP file data into an {@link XKTModel}.\n\nInternally, this function uses [web-ifc](https://github.com/tomvandig/web-ifc) to parse the IFC, which relies on a\nWASM file to do the parsing.\n\nDepending on how we use this function, we may need to provide it with a path to the directory where that WASM file is stored.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then load an IFC model into it.\n\n````javascript\nutils.loadArraybuffer(\"./models/ifc/rac_advanced_sample_project.ifc\", async (data) => {\n\n    const xktModel = new XKTModel();\n\n    parseIFCIntoXKTModel({\n         data,\n         xktModel,\n         wasmPath: \"../dist/\",\n         autoNormals: true,\n         log: (msg) => { console.log(msg); }\n    }).then(()=>{\n       xktModel.finalize();\n    },\n    (msg) => {\n        console.error(msg);\n    });\n});\n````",
    "lineNumber": 47,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Parsing params."
      },
      {
        "nullable": null,
        "types": [
          "ArrayBuffer"
        ],
        "spread": false,
        "optional": true,
        "name": "params.data",
        "description": "IFC file data."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": true,
        "name": "params.xktModel",
        "description": "XKTModel to parse into."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "params.autoNormals",
        "description": "When true, the parser will ignore the IFC geometry normals, and the IFC\ndata will rely on the xeokit ````Viewer```` to automatically generate them. This has the limitation that the\nnormals will be face-aligned, and therefore the ````Viewer```` will only be able to render a flat-shaded representation\nof the IFC model. This is ````true```` by default, because IFC models tend to look acceptable with flat-shading,\nand we always want to minimize IFC model size wherever possible."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "params.wasmPath",
        "description": "Path to ````web-ifc.wasm````, required by this function."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "params.stats",
        "description": "Collects statistics."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.log",
        "description": "Logging callback."
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 427,
    "kind": "file",
    "name": "src/parsers/parseLASIntoXKTModel.js",
    "content": "import {parse} from '@loaders.gl/core';\nimport {LASLoader} from '@loaders.gl/las';\nimport {math} from \"../lib/math.js\";\n\n\n/**\n * @desc Parses LAS and LAZ point cloud data into an {@link XKTModel}.\n *\n * This parser handles both the LASER file format (LAS) and its compressed version (LAZ),\n * a public format for the interchange of 3-dimensional point cloud data data, developed\n * for LIDAR mapping purposes.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then load an LAZ point cloud model into it.\n *\n * ````javascript\n * utils.loadArraybuffer(\"./models/laz/autzen.laz\", async (data) => {\n *\n *     const xktModel = new XKTModel();\n *\n *     await parseLASIntoXKTModel({\n *          data,\n *          xktModel,\n *          rotateX: true,\n *          log: (msg) => { console.log(msg); }\n *     }).then(()=>{\n *        xktModel.finalize();\n *     },\n *     (msg) => {\n *         console.error(msg);\n *     });\n * });\n * ````\n *\n * @param {Object} params Parsing params.\n * @param {ArrayBuffer} params.data LAS/LAZ file data.\n * @param {XKTModel} params.xktModel XKTModel to parse into.\n * @param {Boolean} [params.rotateX=false] Whether to rotate the model 90 degrees about the X axis to make the Y axis \"up\", if necessary.\n * @param {Number|String} [params.colorDepth=8] Whether colors encoded using 8 or 16 bits. Can be set to 'auto'. LAS specification recommends 16 bits.\n * @param {Number} [params.skip=1] Read one from every n points.\n * @param {Object} [params.stats] Collects statistics.\n * @param {function} [params.log] Logging callback.\n */\nasync function parseLASIntoXKTModel({\n                                        data,\n                                        xktModel,\n                                        rotateX = false,\n                                        colorDepth = 8,\n                                        skip = 1,\n                                        stats,\n                                        log = () => {\n                                        }\n                                    }) {\n\n    if (!data) {\n        throw \"Argument expected: data\";\n    }\n\n    if (!xktModel) {\n        throw \"Argument expected: xktModel\";\n    }\n\n    if (log) {\n        log(\"Converting LAZ/LAS\");\n        if (rotateX) {\n            log(\"Rotating model 90 degrees about X-axis\");\n        }\n    }\n\n    let parsedData;\n    try {\n        parsedData = await parse(data, LASLoader, {las: {colorDepth, skip}});\n    } catch (e) {\n        if (log) {\n            log(\"Error: \" + e);\n        }\n        return;\n    }\n\n    const loaderData = parsedData.loaderData;\n    const loaderDataHeader = loaderData.header;\n    const pointsFormatId = loaderDataHeader.pointsFormatId;\n\n    const attributes = parsedData.attributes;\n\n    if (!attributes.POSITION) {\n        log(\"No positions found in file (expected for all LAS point formats)\");\n        return;\n    }\n\n    let positionsValue\n    let colorsCompressed;\n\n    switch (pointsFormatId) {\n        case 0:\n            if (!attributes.intensity) {\n                log(\"No intensities found in file (expected for LAS point format 0)\");\n                return;\n            }\n            positionsValue = readPositions(attributes.POSITION, rotateX);\n            colorsCompressed = readIntensities(attributes.intensity);\n            break;\n        case 1:\n            if (!attributes.intensity) {\n                log(\"No intensities found in file (expected for LAS point format 1)\");\n                return;\n            }\n            positionsValue = readPositions(attributes.POSITION, rotateX);\n            colorsCompressed = readIntensities(attributes.intensity);\n            break;\n        case 2:\n            if (!attributes.intensity) {\n                log(\"No intensities found in file (expected for LAS point format 2)\");\n                return;\n            }\n            positionsValue = readPositions(attributes.POSITION, rotateX);\n            colorsCompressed = readColorsAndIntensities(attributes.COLOR_0, attributes.intensity);\n            break;\n        case 3:\n            if (!attributes.intensity) {\n                log(\"No intensities found in file (expected for LAS point format 3)\");\n                return;\n            }\n            positionsValue = readPositions(attributes.POSITION, rotateX);\n            colorsCompressed = readColorsAndIntensities(attributes.COLOR_0, attributes.intensity);\n            break;\n    }\n\n    xktModel.createGeometry({\n        geometryId: \"pointsGeometry\",\n        primitiveType: \"points\",\n        positions: positionsValue,\n        colorsCompressed: colorsCompressed\n    });\n\n    xktModel.createMesh({\n        meshId: \"pointsMesh\",\n        geometryId: \"pointsGeometry\"\n    });\n\n    const entityId = math.createUUID();\n\n    xktModel.createEntity({\n        entityId: entityId,\n        meshIds: [\"pointsMesh\"]\n    });\n\n    const rootMetaObjectId = math.createUUID();\n\n    xktModel.createMetaObject({\n        metaObjectId: rootMetaObjectId,\n        metaObjectType: \"Model\",\n        metaObjectName: \"Model\"\n    });\n\n    xktModel.createMetaObject({\n        metaObjectId: entityId,\n        metaObjectType: \"PointCloud\",\n        metaObjectName: \"PointCloud (LAZ)\",\n        parentMetaObjectId: rootMetaObjectId\n    });\n\n    if (stats) {\n        stats.sourceFormat = \"LAS\";\n        stats.schemaVersion = \"\";\n        stats.title = \"\";\n        stats.author = \"\";\n        stats.created = \"\";\n        stats.numMetaObjects = 2;\n        stats.numPropertySets = 0;\n        stats.numObjects = 1;\n        stats.numGeometries = 1;\n        stats.numVertices = positionsValue.length / 3;\n    }\n}\n\nfunction readPositions(attributesPosition, rotateX) {\n    const positionsValue = attributesPosition.value;\n    if (rotateX) {\n        if (positionsValue) {\n            for (let i = 0, len = positionsValue.length; i < len; i += 3) {\n                const temp = positionsValue[i + 1];\n                positionsValue[i + 1] = positionsValue[i + 2];\n                positionsValue[i + 2] = temp;\n            }\n        }\n    }\n    return positionsValue;\n}\n\nfunction readColorsAndIntensities(attributesColor, attributesIntensity) {\n    const colors = attributesColor.value;\n    const colorSize = attributesColor.size;\n    const intensities = attributesIntensity.value;\n    const colorsCompressedSize = intensities.length * 4;\n    const colorsCompressed = new Uint8Array(colorsCompressedSize);\n    for (let i = 0, j = 0, k = 0, len = intensities.length; i < len; i++, k += colorSize, j += 4) {\n        colorsCompressed[j + 0] = colors[k + 0];\n        colorsCompressed[j + 1] = colors[k + 1];\n        colorsCompressed[j + 2] = colors[k + 2];\n        colorsCompressed[j + 3] = Math.round((intensities[i] / 65536) * 255);\n    }\n    return colorsCompressed;\n}\n\nfunction readIntensities(attributesIntensity) {\n    const intensities = attributesIntensity.intensity;\n    const colorsCompressedSize = intensities.length * 4;\n    const colorsCompressed = new Uint8Array(colorsCompressedSize);\n    for (let i = 0, j = 0, k = 0, len = intensities.length; i < len; i++, k += 3, j += 4) {\n        colorsCompressed[j + 0] = 0;\n        colorsCompressed[j + 1] = 0;\n        colorsCompressed[j + 2] = 0;\n        colorsCompressed[j + 3] = Math.round((intensities[i] / 65536) * 255);\n    }\n    return colorsCompressed;\n}\n\nexport {parseLASIntoXKTModel};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/parsers/parseLASIntoXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 428,
    "kind": "function",
    "name": "readPositions",
    "memberof": "src/parsers/parseLASIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseLASIntoXKTModel.js~readPositions",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseLASIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 178,
    "undocument": true,
    "params": [
      {
        "name": "attributesPosition",
        "types": [
          "*"
        ]
      },
      {
        "name": "rotateX",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 429,
    "kind": "function",
    "name": "readColorsAndIntensities",
    "memberof": "src/parsers/parseLASIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseLASIntoXKTModel.js~readColorsAndIntensities",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseLASIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 192,
    "undocument": true,
    "params": [
      {
        "name": "attributesColor",
        "types": [
          "*"
        ]
      },
      {
        "name": "attributesIntensity",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 430,
    "kind": "function",
    "name": "readIntensities",
    "memberof": "src/parsers/parseLASIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseLASIntoXKTModel.js~readIntensities",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseLASIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 207,
    "undocument": true,
    "params": [
      {
        "name": "attributesIntensity",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 431,
    "kind": "function",
    "name": "parseLASIntoXKTModel",
    "memberof": "src/parsers/parseLASIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/parsers/parseLASIntoXKTModel.js~parseLASIntoXKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseLASIntoXKTModel.js",
    "importStyle": "{parseLASIntoXKTModel}",
    "description": "Parses LAS and LAZ point cloud data into an {@link XKTModel}.\n\nThis parser handles both the LASER file format (LAS) and its compressed version (LAZ),\na public format for the interchange of 3-dimensional point cloud data data, developed\nfor LIDAR mapping purposes.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then load an LAZ point cloud model into it.\n\n````javascript\nutils.loadArraybuffer(\"./models/laz/autzen.laz\", async (data) => {\n\n    const xktModel = new XKTModel();\n\n    await parseLASIntoXKTModel({\n         data,\n         xktModel,\n         rotateX: true,\n         log: (msg) => { console.log(msg); }\n    }).then(()=>{\n       xktModel.finalize();\n    },\n    (msg) => {\n        console.error(msg);\n    });\n});\n````",
    "lineNumber": 45,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Parsing params."
      },
      {
        "nullable": null,
        "types": [
          "ArrayBuffer"
        ],
        "spread": false,
        "optional": false,
        "name": "params.data",
        "description": "LAS/LAZ file data."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "params.xktModel",
        "description": "XKTModel to parse into."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "params.rotateX",
        "description": "Whether to rotate the model 90 degrees about the X axis to make the Y axis \"up\", if necessary."
      },
      {
        "nullable": null,
        "types": [
          "Number",
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "8",
        "defaultRaw": 8,
        "name": "params.colorDepth",
        "description": "Whether colors encoded using 8 or 16 bits. Can be set to 'auto'. LAS specification recommends 16 bits."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "params.skip",
        "description": "Read one from every n points."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "params.stats",
        "description": "Collects statistics."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.log",
        "description": "Logging callback."
      }
    ],
    "return": null
  },
  {
    "__docId__": 432,
    "kind": "file",
    "name": "src/parsers/parseMetaModelIntoXKTModel.js",
    "content": "/**\n * @desc Parses JSON metamodel into an {@link XKTModel}.\n *\n * @param {Object} params Parsing parameters.\n * @param {JSON} params.metaModelData Metamodel data.\n * @param {String[]} [params.excludeTypes] Types to exclude from parsing.\n * @param {String[]} [params.includeTypes] Types to include in parsing.\n * @param {XKTModel} params.xktModel XKTModel to parse into.\n * @param {function} [params.log] Logging callback.\n * @returns {Promise}\n */\nfunction parseMetaModelIntoXKTModel({metaModelData, xktModel, includeTypes, excludeTypes, log}) {\n\n    return new Promise(function (resolve, reject) {\n\n        const metaObjects = metaModelData.metaObjects || [];\n        const propertySets = metaModelData.propertySets || [];\n\n        xktModel.modelId = metaModelData.revisionId || \"\"; // HACK\n        xktModel.projectId = metaModelData.projectId || \"\";\n        xktModel.revisionId = metaModelData.revisionId || \"\";\n        xktModel.author = metaModelData.author || \"\";\n        xktModel.createdAt = metaModelData.createdAt || \"\";\n        xktModel.creatingApplication = metaModelData.creatingApplication || \"\";\n        xktModel.schema = metaModelData.schema || \"\";\n        \n        for (let i = 0, len = propertySets.length; i < len; i++) {\n\n            const propertySet = propertySets[i];\n            \n            xktModel.createPropertySet({\n                propertySetId: propertySet.id,\n                propertySetName: propertySet.name,\n                propertySetType: propertySet.type,\n                properties: propertySet.properties\n            });\n        }\n        \n        let includeTypesMap;\n        if (includeTypes) {\n            includeTypesMap = {};\n            for (let i = 0, len = includeTypes.length; i < len; i++) {\n                includeTypesMap[includeTypes[i]] = true;\n            }\n        }\n\n        let excludeTypesMap;\n        if (excludeTypes) {\n            excludeTypesMap = {};\n            for (let i = 0, len = excludeTypes.length; i < len; i++) {\n                excludeTypesMap[excludeTypes[i]] = true;\n            }\n        }\n\n        const metaObjectsMap = {};\n\n        for (let i = 0, len = metaObjects.length; i < len; i++) {\n            const newObject = metaObjects[i];\n            metaObjectsMap[newObject.id] = newObject;\n        }\n\n        let countMetaObjects = 0;\n\n        for (let i = 0, len = metaObjects.length; i < len; i++) {\n\n            const metaObject = metaObjects[i];\n            const type = metaObject.type;\n\n            if (excludeTypesMap && excludeTypesMap[type]) {\n                continue;\n            }\n\n            if (includeTypesMap && !includeTypesMap[type]) {\n                continue;\n            }\n\n            if (metaObject.parent !== undefined && metaObject.parent !== null) {\n                const metaObjectParent = metaObjectsMap[metaObject.parent];\n                if (metaObject.type === metaObjectParent.type) { // Don't create redundant sub-objects\n                   continue\n                }\n            }\n\n            xktModel.createMetaObject({\n                metaObjectId: metaObject.id,\n                metaObjectType: metaObject.type,\n                metaObjectName: metaObject.name,\n                parentMetaObjectId: metaObject.parent,\n                propertySetIds: metaObject.propertySetIds || metaObject.propertySetId ? [metaObject.propertySetId] : null\n            });\n\n            countMetaObjects++;\n        }\n\n        if (log) {\n            log(\"Converted meta objects: \" + countMetaObjects);\n        }\n\n        resolve();\n    });\n}\n\nexport {parseMetaModelIntoXKTModel};\n",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/parsers/parseMetaModelIntoXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 433,
    "kind": "function",
    "name": "parseMetaModelIntoXKTModel",
    "memberof": "src/parsers/parseMetaModelIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseMetaModelIntoXKTModel.js~parseMetaModelIntoXKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseMetaModelIntoXKTModel.js",
    "importStyle": "{parseMetaModelIntoXKTModel}",
    "description": "Parses JSON metamodel into an {@link XKTModel}.",
    "lineNumber": 12,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Parsing parameters."
      },
      {
        "nullable": null,
        "types": [
          "JSON"
        ],
        "spread": false,
        "optional": false,
        "name": "params.metaModelData",
        "description": "Metamodel data."
      },
      {
        "nullable": null,
        "types": [
          "String[]"
        ],
        "spread": false,
        "optional": true,
        "name": "params.excludeTypes",
        "description": "Types to exclude from parsing."
      },
      {
        "nullable": null,
        "types": [
          "String[]"
        ],
        "spread": false,
        "optional": true,
        "name": "params.includeTypes",
        "description": "Types to include in parsing."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "params.xktModel",
        "description": "XKTModel to parse into."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.log",
        "description": "Logging callback."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 434,
    "kind": "file",
    "name": "src/parsers/parsePCDIntoXKTModel.js",
    "content": "/**\n * @desc Parses PCD point cloud data into an {@link XKTModel}.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then load an LAZ point cloud model into it.\n *\n * ````javascript\n * utils.loadArraybuffer(\"\"./models/pcd/ism_test_cat.pcd\"\", async (data) => {\n *\n *     const xktModel = new XKTModel();\n *\n *     await parsePCDIntoXKTModel({\n *          data,\n *          xktModel,\n *          log: (msg) => { console.log(msg); }\n *     }).then(()=>{\n *        xktModel.finalize();\n *     },\n *     (msg) => {\n *         console.error(msg);\n *     });\n * });\n * ````\n *\n * @param {Object} params Parsing params.\n * @param {ArrayBuffer} params.data PCD file data.\n * @param {Boolean} [params.littleEndian=true] Whether PCD binary data is Little-Endian or Big-Endian.\n * @param {XKTModel} params.xktModel XKTModel to parse into.\n * @param {Object} [params.stats] Collects statistics.\n * @param {function} [params.log] Logging callback.\n * @returns {Promise}\n */\nfunction parsePCDIntoXKTModel({data, xktModel, littleEndian = true, stats, log}) {\n\n    return new Promise(function(resolve, reject) {\n\n        const textData = decodeText(new Uint8Array(data));\n\n        const header = parseHeader(textData);\n\n        const positions = [];\n        const normals = [];\n        const colors = [];\n\n        if (header.data === 'ascii') {\n\n            const offset = header.offset;\n            const data = textData.substr(header.headerLen);\n            const lines = data.split('\\n');\n\n            for (let i = 0, l = lines.length; i < l; i++) {\n\n                if (lines[i] === '') {\n                    continue;\n                }\n\n                const line = lines[i].split(' ');\n\n                if (offset.x !== undefined) {\n                    positions.push(parseFloat(line[offset.x]));\n                    positions.push(parseFloat(line[offset.y]));\n                    positions.push(parseFloat(line[offset.z]));\n                }\n\n                if (offset.rgb !== undefined) {\n                    const rgb = parseFloat(line[offset.rgb]);\n                    const r = (rgb >> 16) & 0x0000ff;\n                    const g = (rgb >> 8) & 0x0000ff;\n                    const b = (rgb >> 0) & 0x0000ff;\n                    colors.push(r, g, b, 255);\n                } else {\n                    colors.push(255);\n                    colors.push(255);\n                    colors.push(255);\n                }\n            }\n        }\n\n        if (header.data === 'binary_compressed') {\n\n            const sizes = new Uint32Array(data.slice(header.headerLen, header.headerLen + 8));\n            const compressedSize = sizes[0];\n            const decompressedSize = sizes[1];\n            const decompressed = decompressLZF(new Uint8Array(data, header.headerLen + 8, compressedSize), decompressedSize);\n            const dataview = new DataView(decompressed.buffer);\n            const offset = header.offset;\n\n            for (let i = 0; i < header.points; i++) {\n\n                if (offset.x !== undefined) {\n                    positions.push(dataview.getFloat32((header.points * offset.x) + header.size[0] * i, littleEndian));\n                    positions.push(dataview.getFloat32((header.points * offset.y) + header.size[1] * i, littleEndian));\n                    positions.push(dataview.getFloat32((header.points * offset.z) + header.size[2] * i, littleEndian));\n                }\n\n                if (offset.rgb !== undefined) {\n                    colors.push(dataview.getUint8((header.points * offset.rgb) + header.size[3] * i + 0));\n                    colors.push(dataview.getUint8((header.points * offset.rgb) + header.size[3] * i + 1));\n                    colors.push(dataview.getUint8((header.points * offset.rgb) + header.size[3] * i + 2));\n                    //    colors.push(255);\n                } else {\n                    colors.push(1);\n                    colors.push(1);\n                    colors.push(1);\n                }\n            }\n        }\n\n        if (header.data === 'binary') {\n\n            const dataview = new DataView(data, header.headerLen);\n            const offset = header.offset;\n\n            for (let i = 0, row = 0; i < header.points; i++, row += header.rowSize) {\n                if (offset.x !== undefined) {\n                    positions.push(dataview.getFloat32(row + offset.x, littleEndian));\n                    positions.push(dataview.getFloat32(row + offset.y, littleEndian));\n                    positions.push(dataview.getFloat32(row + offset.z, littleEndian));\n                }\n\n                if (offset.rgb !== undefined) {\n                    colors.push(dataview.getUint8(row + offset.rgb + 2));\n                    colors.push(dataview.getUint8(row + offset.rgb + 1));\n                    colors.push(dataview.getUint8(row + offset.rgb + 0));\n                } else {\n                    colors.push(255);\n                    colors.push(255);\n                    colors.push(255);\n                }\n            }\n        }\n\n        xktModel.createGeometry({\n            geometryId: \"pointsGeometry\",\n            primitiveType: \"points\",\n            positions: positions,\n            colors: colors && colors.length > 0 ? colors : null\n        });\n\n        xktModel.createMesh({\n            meshId: \"pointsMesh\",\n            geometryId: \"pointsGeometry\"\n        });\n\n        xktModel.createEntity({\n            entityId: \"geometries\",\n            meshIds: [\"pointsMesh\"]\n        });\n\n        if (log) {\n            log(\"Converted drawable objects: 1\");\n            log(\"Converted geometries: 1\");\n            log(\"Converted vertices: \" + positions.length / 3);\n        }\n\n        if (stats) {\n            stats.sourceFormat = \"PCD\";\n            stats.schemaVersion = \"\";\n            stats.title = \"\";\n            stats.author = \"\";\n            stats.created = \"\";\n            stats.numObjects = 1;\n            stats.numGeometries = 1;\n            stats.numVertices = positions.length / 3;\n        }\n\n        resolve();\n    });\n}\n\nfunction parseHeader(data) {\n    const header = {};\n    const result1 = data.search(/[\\r\\n]DATA\\s(\\S*)\\s/i);\n    const result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec(data.substr(result1 - 1));\n    header.data = result2[1];\n    header.headerLen = result2[0].length + result1;\n    header.str = data.substr(0, header.headerLen);\n    header.str = header.str.replace(/\\#.*/gi, '');     // Strip comments\n    header.version = /VERSION (.*)/i.exec(header.str); // Parse\n    header.fields = /FIELDS (.*)/i.exec(header.str);\n    header.size = /SIZE (.*)/i.exec(header.str);\n    header.type = /TYPE (.*)/i.exec(header.str);\n    header.count = /COUNT (.*)/i.exec(header.str);\n    header.width = /WIDTH (.*)/i.exec(header.str);\n    header.height = /HEIGHT (.*)/i.exec(header.str);\n    header.viewpoint = /VIEWPOINT (.*)/i.exec(header.str);\n    header.points = /POINTS (.*)/i.exec(header.str);\n    if (header.version !== null) {\n        header.version = parseFloat(header.version[1]);\n    }\n    if (header.fields !== null) {\n        header.fields = header.fields[1].split(' ');\n    }\n    if (header.type !== null) {\n        header.type = header.type[1].split(' ');\n    }\n    if (header.width !== null) {\n        header.width = parseInt(header.width[1]);\n    }\n    if (header.height !== null) {\n        header.height = parseInt(header.height[1]);\n    }\n    if (header.viewpoint !== null) {\n        header.viewpoint = header.viewpoint[1];\n    }\n    if (header.points !== null) {\n        header.points = parseInt(header.points[1], 10);\n    }\n    if (header.points === null) {\n        header.points = header.width * header.height;\n    }\n    if (header.size !== null) {\n        header.size = header.size[1].split(' ').map(function (x) {\n            return parseInt(x, 10);\n        });\n    }\n    if (header.count !== null) {\n        header.count = header.count[1].split(' ').map(function (x) {\n            return parseInt(x, 10);\n        });\n    } else {\n        header.count = [];\n        for (let i = 0, l = header.fields.length; i < l; i++) {\n            header.count.push(1);\n        }\n    }\n    header.offset = {};\n    let sizeSum = 0;\n    for (let i = 0, l = header.fields.length; i < l; i++) {\n        if (header.data === 'ascii') {\n            header.offset[header.fields[i]] = i;\n        } else {\n            header.offset[header.fields[i]] = sizeSum;\n            sizeSum += header.size[i] * header.count[i];\n        }\n    }\n    header.rowSize = sizeSum; // For binary only\n    return header;\n}\n\nfunction decodeText(array) {\n    if (typeof TextDecoder !== 'undefined') {\n        return new TextDecoder().decode(array);\n    }\n    let s = '';\n    for (let i = 0, il = array.length; i < il; i++) {\n        s += String.fromCharCode(array[i]);\n    }\n    try {\n        return decodeURIComponent(escape(s));\n    } catch (e) {\n        return s;\n    }\n}\n\nfunction decompressLZF(inData, outLength) { // https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js\n    const inLength = inData.length;\n    const outData = new Uint8Array(outLength);\n    let inPtr = 0;\n    let outPtr = 0;\n    let ctrl;\n    let len;\n    let ref;\n    do {\n        ctrl = inData[inPtr++];\n        if (ctrl < (1 << 5)) {\n            ctrl++;\n            if (outPtr + ctrl > outLength) throw new Error('Output buffer is not large enough');\n            if (inPtr + ctrl > inLength) throw new Error('Invalid compressed data');\n            do {\n                outData[outPtr++] = inData[inPtr++];\n            } while (--ctrl);\n        } else {\n            len = ctrl >> 5;\n            ref = outPtr - ((ctrl & 0x1f) << 8) - 1;\n            if (inPtr >= inLength) throw new Error('Invalid compressed data');\n            if (len === 7) {\n                len += inData[inPtr++];\n                if (inPtr >= inLength) throw new Error('Invalid compressed data');\n            }\n            ref -= inData[inPtr++];\n            if (outPtr + len + 2 > outLength) throw new Error('Output buffer is not large enough');\n            if (ref < 0) throw new Error('Invalid compressed data');\n            if (ref >= outPtr) throw new Error('Invalid compressed data');\n            do {\n                outData[outPtr++] = outData[ref++];\n            } while (--len + 2);\n        }\n    } while (inPtr < inLength);\n    return outData;\n}\n\nexport {parsePCDIntoXKTModel};",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/parsers/parsePCDIntoXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 435,
    "kind": "function",
    "name": "parseHeader",
    "memberof": "src/parsers/parsePCDIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parsePCDIntoXKTModel.js~parseHeader",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parsePCDIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 172,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 436,
    "kind": "function",
    "name": "decodeText",
    "memberof": "src/parsers/parsePCDIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parsePCDIntoXKTModel.js~decodeText",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parsePCDIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 242,
    "undocument": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 437,
    "kind": "function",
    "name": "decompressLZF",
    "memberof": "src/parsers/parsePCDIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parsePCDIntoXKTModel.js~decompressLZF",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parsePCDIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 257,
    "undocument": true,
    "params": [
      {
        "name": "inData",
        "types": [
          "*"
        ]
      },
      {
        "name": "outLength",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 438,
    "kind": "function",
    "name": "parsePCDIntoXKTModel",
    "memberof": "src/parsers/parsePCDIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parsePCDIntoXKTModel.js~parsePCDIntoXKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parsePCDIntoXKTModel.js",
    "importStyle": "{parsePCDIntoXKTModel}",
    "description": "Parses PCD point cloud data into an {@link XKTModel}.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then load an LAZ point cloud model into it.\n\n````javascript\nutils.loadArraybuffer(\"\"./models/pcd/ism_test_cat.pcd\"\", async (data) => {\n\n    const xktModel = new XKTModel();\n\n    await parsePCDIntoXKTModel({\n         data,\n         xktModel,\n         log: (msg) => { console.log(msg); }\n    }).then(()=>{\n       xktModel.finalize();\n    },\n    (msg) => {\n        console.error(msg);\n    });\n});\n````",
    "lineNumber": 34,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Parsing params."
      },
      {
        "nullable": null,
        "types": [
          "ArrayBuffer"
        ],
        "spread": false,
        "optional": false,
        "name": "params.data",
        "description": "PCD file data."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "params.littleEndian",
        "description": "Whether PCD binary data is Little-Endian or Big-Endian."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "params.xktModel",
        "description": "XKTModel to parse into."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "params.stats",
        "description": "Collects statistics."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.log",
        "description": "Logging callback."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 439,
    "kind": "file",
    "name": "src/parsers/parsePLYIntoXKTModel.js",
    "content": "import {parse} from '@loaders.gl/core';\nimport {PLYLoader} from '@loaders.gl/ply';\n\n/**\n * @desc Parses PLY file data into an {@link XKTModel}.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then load a PLY model into it.\n *\n * ````javascript\n * utils.loadArraybuffer(\"./models/ply/test.ply\", async (data) => {\n *\n *     const xktModel = new XKTModel();\n *\n *     parsePLYIntoXKTModel({data, xktModel}).then(()=>{\n *        xktModel.finalize();\n *     },\n *     (msg) => {\n *         console.error(msg);\n *     });\n * });\n * ````\n *\n * @param {Object} params Parsing params.\n * @param {ArrayBuffer} params.data PLY file data.\n * @param {XKTModel} params.xktModel XKTModel to parse into.\n * @param {Object} [params.stats] Collects statistics.\n * @param {function} [params.log] Logging callback.\n * @returns {Promise}\n */\nasync function parsePLYIntoXKTModel({data, xktModel, stats, log}) {\n\n    if (!data) {\n        throw \"Argument expected: data\";\n    }\n\n    if (!xktModel) {\n        throw \"Argument expected: xktModel\";\n    }\n\n    let parsedData;\n    try {\n        parsedData = await parse(data, PLYLoader);\n    } catch (e) {\n        if (log) {\n            log(\"Error: \" + e);\n        }\n        return;\n    }\n\n    const attributes = parsedData.attributes;\n    const hasColors = !!attributes.COLOR_0;\n\n    if (hasColors) {\n        const colorsValue = hasColors ? attributes.COLOR_0.value : null;\n        const colorsCompressed = [];\n        for (let i = 0, len = colorsValue.length; i < len; i += 4) {\n            colorsCompressed.push(colorsValue[i]);\n            colorsCompressed.push(colorsValue[i + 1]);\n            colorsCompressed.push(colorsValue[i + 2]);\n        }\n        xktModel.createGeometry({\n            geometryId: \"plyGeometry\",\n            primitiveType: \"triangles\",\n            positions: attributes.POSITION.value,\n            indices: parsedData.indices ? parsedData.indices.value : [],\n            colorsCompressed: colorsCompressed\n        });\n    } else {\n        xktModel.createGeometry({\n            geometryId: \"plyGeometry\",\n            primitiveType: \"triangles\",\n            positions: attributes.POSITION.value,\n            indices: parsedData.indices ? parsedData.indices.value : []\n        });\n    }\n\n    xktModel.createMesh({\n        meshId: \"plyMesh\",\n        geometryId: \"plyGeometry\",\n        color: (!hasColors) ? [1, 1, 1] : null\n    });\n\n    xktModel.createEntity({\n        entityId: \"ply\",\n        meshIds: [\"plyMesh\"]\n    });\n\n    if (stats) {\n        stats.sourceFormat = \"PLY\";\n        stats.schemaVersion = \"\";\n        stats.title = \"\";\n        stats.author = \"\";\n        stats.created = \"\";\n        stats.numMetaObjects = 2;\n        stats.numPropertySets = 0;\n        stats.numObjects = 1;\n        stats.numGeometries = 1;\n        stats.numVertices = attributes.POSITION.value.length / 3;\n    }\n}\n\nexport {parsePLYIntoXKTModel};\n",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/parsers/parsePLYIntoXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 440,
    "kind": "function",
    "name": "parsePLYIntoXKTModel",
    "memberof": "src/parsers/parsePLYIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/parsers/parsePLYIntoXKTModel.js~parsePLYIntoXKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parsePLYIntoXKTModel.js",
    "importStyle": "{parsePLYIntoXKTModel}",
    "description": "Parses PLY file data into an {@link XKTModel}.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then load a PLY model into it.\n\n````javascript\nutils.loadArraybuffer(\"./models/ply/test.ply\", async (data) => {\n\n    const xktModel = new XKTModel();\n\n    parsePLYIntoXKTModel({data, xktModel}).then(()=>{\n       xktModel.finalize();\n    },\n    (msg) => {\n        console.error(msg);\n    });\n});\n````",
    "lineNumber": 32,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Parsing params."
      },
      {
        "nullable": null,
        "types": [
          "ArrayBuffer"
        ],
        "spread": false,
        "optional": false,
        "name": "params.data",
        "description": "PLY file data."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "params.xktModel",
        "description": "XKTModel to parse into."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "params.stats",
        "description": "Collects statistics."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.log",
        "description": "Logging callback."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 441,
    "kind": "file",
    "name": "src/parsers/parseSTLIntoXKTModel.js",
    "content": "import {faceToVertexNormals} from \"../lib/faceToVertexNormals.js\";\nimport {math} from \"../lib/math.js\";\n\n/**\n * @desc Parses STL file data into an {@link XKTModel}.\n *\n * * Supports binary and ASCII STL formats.\n * * Option to create a separate {@link XKTEntity} for each group of faces that share the same vertex colors.\n * * Option to smooth face-aligned normals loaded from STL.\n * * Option to reduce XKT file size by ignoring STL normals and relying on xeokit to auto-generate them.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then load an STL model into it.\n *\n * ````javascript\n * utils.loadArraybuffer(\"./models/stl/binary/spurGear.stl\", async (data) => {\n *\n *     const xktModel = new XKTModel();\n *\n *     parseSTLIntoXKTModel({data, xktModel});\n *\n *     xktModel.finalize();\n * });\n * ````\n *\n * @param {Object} params Parsing params.\n * @param {ArrayBuffer|String} [params.data] STL file data. Can be binary or string.\n * @param {Boolean} [params.autoNormals=false] When true, the parser will ignore the STL geometry normals, and the STL\n * data will rely on the xeokit ````Viewer```` to automatically generate them. This has the limitation that the\n * normals will be face-aligned, and therefore the ````Viewer```` will only be able to render a flat-shaded representation\n * of the STL.\n * Overrides ````smoothNormals```` when ````true````. This ignores the normals in the STL, and loads no\n * normals from the STL into the {@link XKTModel}, resulting in the XKT file storing no normals for the STL model. The\n * xeokit-sdk will then automatically generate the normals within its shaders. The disadvantages are that auto-normals\n * may slow rendering down a little bit, and that the normals can only be face-aligned (and thus rendered using flat\n * shading). The advantages, however, are a smaller XKT file size, and the ability to apply certain geometry optimizations\n * during parsing, such as removing duplicated STL vertex positions, that are not possible when normals are loaded\n * for the STL vertices.\n * @param {Boolean} [params.smoothNormals=true] When true, automatically converts face-oriented STL normals to vertex normals, for a smooth appearance. Ignored if ````autoNormals```` is ````true````.\n * @param {Number} [params.smoothNormalsAngleThreshold=20] This is the threshold angle between normals of adjacent triangles, below which their shared wireframe edge is not drawn.\n * @param {Boolean} [params.splitMeshes=true] When true, creates a separate {@link XKTEntity} for each group of faces that share the same vertex colors. Only works with binary STL (ie. when ````data```` is an ArrayBuffer).\n * @param {XKTModel} [params.xktModel] XKTModel to parse into.\n * @param {Object} [params.stats] Collects statistics.\n * @param {function} [params.log] Logging callback.\n * @returns {Promise}\n */\nasync function parseSTLIntoXKTModel({\n                                        data,\n                                        splitMeshes,\n                                        autoNormals,\n                                        smoothNormals,\n                                        smoothNormalsAngleThreshold,\n                                        xktModel,\n                                        stats,\n                                        log\n                                    }) {\n\n    return new Promise(function (resolve, reject) {\n\n        if (!data) {\n            reject(\"Argument expected: data\");\n            return;\n        }\n\n        if (!xktModel) {\n            reject(\"Argument expected: xktModel\");\n            return;\n        }\n\n        const rootMetaObjectId = math.createUUID();\n\n        const rootMetaObject = xktModel.createMetaObject({\n            metaObjectId: rootMetaObjectId,\n            metaObjectType: \"Model\",\n            metaObjectName: \"Model\"\n        });\n\n        const ctx = {\n            data,\n            splitMeshes,\n            autoNormals,\n            smoothNormals,\n            smoothNormalsAngleThreshold,\n            xktModel,\n            rootMetaObject,\n            nextId: 0,\n            log: (log || function (msg) {\n            }),\n            stats: {\n                numObjects: 0,\n                numGeometries: 0,\n                numTriangles: 0,\n                numVertices: 0\n            }\n        };\n\n        const binData = ensureBinary(data);\n\n        if (isBinary(binData)) {\n            parseBinary(ctx, binData);\n        } else {\n            parseASCII(ctx, ensureString(data));\n        }\n\n        if (stats) {\n            stats.sourceFormat = \"STL\";\n            stats.schemaVersion = \"\";\n            stats.title = \"\";\n            stats.author = \"\";\n            stats.created = \"\";\n            stats.numMetaObjects = 2;\n            stats.numPropertySets = 0;\n            stats.numObjects = 1;\n            stats.numGeometries = 1;\n            stats.numTriangles = ctx.stats.numTriangles;\n            stats.numVertices = ctx.stats.numVertices;\n        }\n\n        resolve();\n    });\n}\n\nfunction isBinary(data) {\n    const reader = new DataView(data);\n    const numFaces = reader.getUint32(80, true);\n    const faceSize = (32 / 8 * 3) + ((32 / 8 * 3) * 3) + (16 / 8);\n    const numExpectedBytes = 80 + (32 / 8) + (numFaces * faceSize);\n    if (numExpectedBytes === reader.byteLength) {\n        return true;\n    }\n    const solid = [115, 111, 108, 105, 100];\n    for (let i = 0; i < 5; i++) {\n        if (solid[i] !== reader.getUint8(i, false)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction parseBinary(ctx, data) {\n    const reader = new DataView(data);\n    const faces = reader.getUint32(80, true);\n    let r;\n    let g;\n    let b;\n    let hasColors = false;\n    let colors;\n    let defaultR;\n    let defaultG;\n    let defaultB;\n    let lastR = null;\n    let lastG = null;\n    let lastB = null;\n    let newMesh = false;\n    let alpha;\n    for (let index = 0; index < 80 - 10; index++) {\n        if ((reader.getUint32(index, false) === 0x434F4C4F /*COLO*/) &&\n            (reader.getUint8(index + 4) === 0x52 /*'R'*/) &&\n            (reader.getUint8(index + 5) === 0x3D /*'='*/)) {\n            hasColors = true;\n            colors = [];\n            defaultR = reader.getUint8(index + 6) / 255;\n            defaultG = reader.getUint8(index + 7) / 255;\n            defaultB = reader.getUint8(index + 8) / 255;\n            alpha = reader.getUint8(index + 9) / 255;\n        }\n    }\n    let dataOffset = 84;\n    let faceLength = 12 * 4 + 2;\n    let positions = [];\n    let normals = [];\n    let splitMeshes = ctx.splitMeshes;\n    for (let face = 0; face < faces; face++) {\n        let start = dataOffset + face * faceLength;\n        let normalX = reader.getFloat32(start, true);\n        let normalY = reader.getFloat32(start + 4, true);\n        let normalZ = reader.getFloat32(start + 8, true);\n        if (hasColors) {\n            let packedColor = reader.getUint16(start + 48, true);\n            if ((packedColor & 0x8000) === 0) {\n                r = (packedColor & 0x1F) / 31;\n                g = ((packedColor >> 5) & 0x1F) / 31;\n                b = ((packedColor >> 10) & 0x1F) / 31;\n            } else {\n                r = defaultR;\n                g = defaultG;\n                b = defaultB;\n            }\n            if (splitMeshes && r !== lastR || g !== lastG || b !== lastB) {\n                if (lastR !== null) {\n                    newMesh = true;\n                }\n                lastR = r;\n                lastG = g;\n                lastB = b;\n            }\n        }\n        for (let i = 1; i <= 3; i++) {\n            let vertexstart = start + i * 12;\n            positions.push(reader.getFloat32(vertexstart, true));\n            positions.push(reader.getFloat32(vertexstart + 4, true));\n            positions.push(reader.getFloat32(vertexstart + 8, true));\n            if (!ctx.autoNormals) {\n                normals.push(normalX, normalY, normalZ);\n            }\n            if (hasColors) {\n                colors.push(r, g, b, 1); // TODO: handle alpha\n            }\n        }\n        if (splitMeshes && newMesh) {\n            addMesh(ctx, positions, normals, colors);\n            positions = [];\n            normals = [];\n            colors = colors ? [] : null;\n            newMesh = false;\n        }\n    }\n    if (positions.length > 0) {\n        addMesh(ctx, positions, normals, colors);\n    }\n}\n\nfunction parseASCII(ctx, data) {\n    const faceRegex = /facet([\\s\\S]*?)endfacet/g;\n    let faceCounter = 0;\n    const floatRegex = /[\\s]+([+-]?(?:\\d+.\\d+|\\d+.|\\d+|.\\d+)(?:[eE][+-]?\\d+)?)/.source;\n    const vertexRegex = new RegExp('vertex' + floatRegex + floatRegex + floatRegex, 'g');\n    const normalRegex = new RegExp('normal' + floatRegex + floatRegex + floatRegex, 'g');\n    const positions = [];\n    const normals = [];\n    const colors = null;\n    let normalx;\n    let normaly;\n    let normalz;\n    let result;\n    let verticesPerFace;\n    let normalsPerFace;\n    let text;\n    while ((result = faceRegex.exec(data)) !== null) {\n        verticesPerFace = 0;\n        normalsPerFace = 0;\n        text = result[0];\n        while ((result = normalRegex.exec(text)) !== null) {\n            normalx = parseFloat(result[1]);\n            normaly = parseFloat(result[2]);\n            normalz = parseFloat(result[3]);\n            normalsPerFace++;\n        }\n        while ((result = vertexRegex.exec(text)) !== null) {\n            positions.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));\n            normals.push(normalx, normaly, normalz);\n            verticesPerFace++;\n        }\n        if (normalsPerFace !== 1) {\n            ctx.log(\"Error in normal of face \" + faceCounter);\n            return -1;\n        }\n        if (verticesPerFace !== 3) {\n            ctx.log(\"Error in positions of face \" + faceCounter);\n            return -1;\n        }\n        faceCounter++;\n    }\n    addMesh(ctx, positions, normals, colors);\n}\n\nlet nextGeometryId = 0;\n\nfunction addMesh(ctx, positions, normals, colors) {\n\n    const indices = new Int32Array(positions.length / 3);\n    for (let ni = 0, len = indices.length; ni < len; ni++) {\n        indices[ni] = ni;\n    }\n\n    normals = normals && normals.length > 0 ? normals : null;\n    colors = colors && colors.length > 0 ? colors : null;\n\n    if (!ctx.autoNormals && ctx.smoothNormals) {\n        faceToVertexNormals(positions, normals, {smoothNormalsAngleThreshold: ctx.smoothNormalsAngleThreshold});\n    }\n\n    const geometryId = \"\" + nextGeometryId++;\n    const meshId = \"\" + nextGeometryId++;\n    const entityId = \"\" + nextGeometryId++;\n\n    ctx.xktModel.createGeometry({\n        geometryId: geometryId,\n        primitiveType: \"triangles\",\n        positions: positions,\n        normals: (!ctx.autoNormals) ? normals : null,\n        colors: colors,\n        indices: indices\n    });\n\n    ctx.xktModel.createMesh({\n        meshId: meshId,\n        geometryId: geometryId,\n        color: colors ? null : [1, 1, 1],\n        metallic: 0.9,\n        roughness: 0.1\n    });\n\n    ctx.xktModel.createEntity({\n        entityId: entityId,\n        meshIds: [meshId]\n    });\n\n    ctx.xktModel.createMetaObject({\n        metaObjectId: entityId,\n        metaObjectType: \"Default\",\n        metaObjectName: \"STL Mesh\",\n        parentMetaObjectId: ctx.rootMetaObject.metaObjectId\n    });\n\n    ctx.stats.numGeometries++;\n    ctx.stats.numObjects++;\n    ctx.stats.numVertices += positions.length / 3;\n    ctx.stats.numTriangles += indices.length / 3;\n}\n\nfunction ensureString(buffer) {\n    if (typeof buffer !== 'string') {\n        return decodeText(new Uint8Array(buffer));\n    }\n    return buffer;\n}\n\nfunction ensureBinary(buffer) {\n    if (typeof buffer === 'string') {\n        const arrayBuffer = new Uint8Array(buffer.length);\n        for (let i = 0; i < buffer.length; i++) {\n            arrayBuffer[i] = buffer.charCodeAt(i) & 0xff; // implicitly assumes little-endian\n        }\n        return arrayBuffer.buffer || arrayBuffer;\n    } else {\n        return buffer;\n    }\n}\n\nfunction decodeText(array) {\n    if (typeof TextDecoder !== 'undefined') {\n        return new TextDecoder().decode(array);\n    }\n    let s = '';\n    for (let i = 0, il = array.length; i < il; i++) {\n        s += String.fromCharCode(array[i]); // Implicitly assumes little-endian.\n    }\n    return decodeURIComponent(escape(s));\n}\n\nexport {parseSTLIntoXKTModel};\n",
    "static": true,
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/src/parsers/parseSTLIntoXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 442,
    "kind": "function",
    "name": "isBinary",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~isBinary",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 124,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 443,
    "kind": "function",
    "name": "parseBinary",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~parseBinary",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 141,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 444,
    "kind": "function",
    "name": "parseASCII",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~parseASCII",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 224,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 445,
    "kind": "variable",
    "name": "nextGeometryId",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~nextGeometryId",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 268,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 446,
    "kind": "function",
    "name": "addMesh",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~addMesh",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 270,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "normals",
        "types": [
          "*"
        ]
      },
      {
        "name": "colors",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 447,
    "kind": "function",
    "name": "ensureString",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~ensureString",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 323,
    "undocument": true,
    "params": [
      {
        "name": "buffer",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 448,
    "kind": "function",
    "name": "ensureBinary",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~ensureBinary",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 330,
    "undocument": true,
    "params": [
      {
        "name": "buffer",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 449,
    "kind": "function",
    "name": "decodeText",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~decodeText",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 342,
    "undocument": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 450,
    "kind": "function",
    "name": "parseSTLIntoXKTModel",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~parseSTLIntoXKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": "{parseSTLIntoXKTModel}",
    "description": "Parses STL file data into an {@link XKTModel}.\n\n* Supports binary and ASCII STL formats.\n* Option to create a separate {@link XKTEntity} for each group of faces that share the same vertex colors.\n* Option to smooth face-aligned normals loaded from STL.\n* Option to reduce XKT file size by ignoring STL normals and relying on xeokit to auto-generate them.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then load an STL model into it.\n\n````javascript\nutils.loadArraybuffer(\"./models/stl/binary/spurGear.stl\", async (data) => {\n\n    const xktModel = new XKTModel();\n\n    parseSTLIntoXKTModel({data, xktModel});\n\n    xktModel.finalize();\n});\n````",
    "lineNumber": 48,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Parsing params."
      },
      {
        "nullable": null,
        "types": [
          "ArrayBuffer",
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "params.data",
        "description": "STL file data. Can be binary or string."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "params.autoNormals",
        "description": "When true, the parser will ignore the STL geometry normals, and the STL\ndata will rely on the xeokit ````Viewer```` to automatically generate them. This has the limitation that the\nnormals will be face-aligned, and therefore the ````Viewer```` will only be able to render a flat-shaded representation\nof the STL.\nOverrides ````smoothNormals```` when ````true````. This ignores the normals in the STL, and loads no\nnormals from the STL into the {@link XKTModel}, resulting in the XKT file storing no normals for the STL model. The\nxeokit-sdk will then automatically generate the normals within its shaders. The disadvantages are that auto-normals\nmay slow rendering down a little bit, and that the normals can only be face-aligned (and thus rendered using flat\nshading). The advantages, however, are a smaller XKT file size, and the ability to apply certain geometry optimizations\nduring parsing, such as removing duplicated STL vertex positions, that are not possible when normals are loaded\nfor the STL vertices."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "params.smoothNormals",
        "description": "When true, automatically converts face-oriented STL normals to vertex normals, for a smooth appearance. Ignored if ````autoNormals```` is ````true````."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "20",
        "defaultRaw": 20,
        "name": "params.smoothNormalsAngleThreshold",
        "description": "This is the threshold angle between normals of adjacent triangles, below which their shared wireframe edge is not drawn."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "params.splitMeshes",
        "description": "When true, creates a separate {@link XKTEntity} for each group of faces that share the same vertex colors. Only works with binary STL (ie. when ````data```` is an ArrayBuffer)."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": true,
        "name": "params.xktModel",
        "description": "XKTModel to parse into."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "params.stats",
        "description": "Collects statistics."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.log",
        "description": "Logging callback."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "kind": "index",
    "content": "# xeokit-convert\n\n[![Twitter Follow](https://img.shields.io/twitter/follow/xeolabs?style=social)](https://twitter.com/xeolabs)\n[![This project is using Percy.io for visual regression testing.](https://percy.io/static/images/percy-badge.svg)](https://percy.io/73524691/xeokit-convert)\n[![npm version](https://badge.fury.io/js/%40xeokit%2Fxeokit-convert.svg)](https://badge.fury.io/js/%40xeokit%2Fxeokit-convert)\n\nUse **xeokit-convert** to:\n\n* Convert BIM and AEC models directly into XKT files for super fast loading into [xeokit](https://xeokit.io)\n* Generate XKT files with JavaScript\n\n> xeokit-convert replaces [xeokit-gltf-to-xkt](https://github.com/xeokit/xeokit-gltf-to-xkt) and [xeokit-xkt-utils](https://github.com/xeokit/xeokit-xkt-utils), which are deprecated.\n\n> CAUTION: Direct IFC conversion is an alpha status feature, since it depends\non  [web-ifc](https://github.com/tomvandig/web-ifc), a 3rd-party library, which is also alpha at this time. As such,\nsome IFC models may not convert properly. If this is the case for your models, consider using\nour [standard conversion setup](https://www.notion.so/xeokit/Converting-IFC-Models-using-3rd-Party-Open-Source-Tools-c373e48bc4094ff5b6e5c5700ff580ee)\nuntil issues have been resolved.\n\n[![View Revit Sample IFC in xeokit](https://xeokit.github.io/xeokit-ifc-to-xkt/assets/rac_advanced_sample_project.png)](https://xeokit.github.io/xeokit-convert/demos/demoXKT.html?xktSrc=.././assets/models/xkt/ifc_rac_advanced_sample_project/model.xkt)\n\n* [[View this XKT model](https://xeokit.github.io/xeokit-convert/demos/demoXKT.html?xktSrc=.././assets/models/xkt/ifc_rac_advanced_sample_project/model.xkt)]\n\n---\n\n# Contents\n\n- [Introduction](#introduction)\n- [Acknowledgements](#acknowledgements)\n- [Resources](#resources)\n- [Features](#features)\n- [Installing](#installing)\n- [Components](#components)\n- [Using ````convert2xkt````](#using-----convert2xkt----)\n  + [Converting an IFC file into an XKT file on the command line](#converting-an-ifc-file-into-an-xkt-file-on-the-command-line)\n  + [Viewing the XKT file with xeokit](#viewing-the-xkt-file-with-xeokit)\n  + [Querying the XKT version in Node.js](#querying-the-xkt-version-in-nodejs)\n  + [Converting an IFC file into an XKT file in Node.js](#converting-an-ifc-file-into-an-xkt-file-in-nodejs)\n  + [Converting IFC file data into XKT data in Node.js](#converting-ifc-file-data-into-xkt-data-in-nodejs)\n- [Using ````XKTModel````](#using-----xktmodel----)\n  + [Programmatically Building an XKT File](#programmatically-building-an-xkt-file)\n  + [Serializing the XKTModel to an ArrayBuffer](#serializing-the-xktmodel-to-an-arraybuffer)\n  + [Loading the ArrayBuffer into a Viewer](#loading-the-arraybuffer-into-a-viewer)\n  + [Loading IFC into an XKTModel](#loading-ifc-into-an-xktmodel)\n  + [Loading LAS into an XKTModel](#loading-las-into-an-xktmodel)\n  + [Loading glTF into an XKTModel](#loading-gltf-into-an-xktmodel)\n  + [Loading STL into an XKTModel](#loading-stl-into-an-xktmodel)\n- [Building](#building)\n  + [Building Binaries](#building-binaries)\n  + [Building Tests](#building-tests)\n\n---\n\n# Introduction\n\n[````xeokit-convert````](https://github.com/xeokit/xeokit-convert) provides the means to convert 3D BIM and AEC models\ninto XKT files for super fast loading into [xeokit](https://xeokit.io), along with programming tools to generate XKT\nfiles with JavaScript on Node.js.\n\nThe [XKT format](https://github.com/xeokit/xeokit-convert/tree/master/specs) compresses large double-precision models to\na compact payload that loads quickly over the Web into a xeokit viewer running in the browser. We can use xeokit-convert\nto convert several source formats into XKT, such as IFC, glTF, 3DXML and CityJSON.\n\n# Acknowledgements\n\nOur thanks to the authors of these open source libraries, which we use internally within ````xeokit-convert````:\n\n* [loaders.gl](https://loaders.gl) - Copyright (C) 2015 Uber Technologies,\n  Inc. ([MIT License](http://www.opensource.org/licenses/mit-license.php))\n* [Pako](https://github.com/nodeca/pako) - Copyright (C) 2014-2017 by Vitaly Puzrin and Andrei\n  Tuputcyn ([MIT License](http://www.opensource.org/licenses/mit-license.php))\n* [zip.js](https://github.com/gildas-lormeau/zip.js) - Copyright (C) 2021 Gildas\n  Lormeau ([BSD 3-Clause License](https://opensource.org/licenses/BSD-3-Clause))\n* [earcut](https://github.com/mapbox/earcut) - Copyright (C) 2016,\n  Mapbox ([ISC License](https://opensource.org/licenses/ISC))\n* [web-ifc](https://github.com/tomvandig/web-ifc) - Copyright (C) 2020-2021 web-ifc contributors (Mozilla Public License\n  Version 2.0)\n\n# Resources\n\n* [npm](https://www.npmjs.com/package/@xeokit/xeokit-convert)\n* [API Docs](https://xeokit.github.io/xeokit-convert/docs)\n* [Source Code](https://github.com/xeokit/xeokit-convert)\n* [Performance Benchmarks](https://xeokit.github.io/xeokit-convert/perfTests)\n* [XKT Specifications](https://xeokit.github.io/xeokit-convert/specs/)\n\n# Features\n\n* A Node-based CLI tool to convert various 3D model formats to XKT files.\n* A JavaScript toolkit of components for loading, generating and saving XKT files.\n\n# Installing\n\n````bash\nnpm i @xeokit/xeokit-convert\n````\n\nIf you get ````RuntimeError: memory access out of bounds```` while converting IFC, then you'll need to compile the \n3rd-party web-ifc WASM module for your system - see [Building Binaries](#building-binaries).\n# Components\n\nThe table below lists the components provided by ````xeokit-convert````.\n\nAt the center of the toolkit, we've got the converter tool, provided as both a Node.js function and CLI executable.\n\nBundled with the converter, we've got the XKT document model, a bunch of loaders for different formats, and a function\nto serialize the document model to a BLOB. We use these components within the converter tool, and also provide them as\npart of the public API for extensibility.\n\n| Component | Description |\n| --- | --- |\n| [convert2xkt](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-convert2xkt) (function)<br> [convert2xkt](https://github.com/xeokit/xeokit-convert/blob/master/convert2xkt.js) (Node script)| A Node-based JavaScript function and CLI tool that converts various AEC model formats into xeokit's native, super-fast-loading XKT format. |\n| [XKTModel](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) | A JavaScript document model that represents the contents of an XKT file in memory. Using this, we can programmatically build a document model in JavaScript, adding geometries, materials, objects etc, then serialize it to an XKT file. |\n| [parseIFCIntoXKTModel](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-parseIFCIntoXKTModel) | Parses IFC data into an ````XKTModel````. This is an alpha-status feature.  |\n| [parseGLTFIntoXKTModel](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-parseGLTFIntoXKTModel) |  Parses glTF into an ````XKTModel```` |\n| [parse3DXMLIntoXKTModel](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-parse3DXMLIntoXKTModel) |  Parses 3DXML into an ````XKTModel```` |\n| [parseCityJSONIntoXKTModel](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-parseJSONIntoXKTModel) |  Parses CityJSON into an ````XKTModel```` |\n| [parseLASIntoXKTModel](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-parseLASIntoXKTModel) | Parses LAS and LAZ into an ````XKTModel```` |\n| [parseSTLIntoXKTModel](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-parseSTLIntoXKTModel) | Parses STL into an ````XKTModel```` |\n| [writeXKTModelToArrayBuffer](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-writeXKTModelToArrayBuffer) | Serializes an ````XKTModel```` to an XKT file |\n\n# Using ````convert2xkt````\n\nThe ````convert2xkt```` tool converts various model formats into xeokit's native XKT format, which is designed to load\nsuper fast over the Web into a xeokit viewer. We provide this tool as both a [CLI script]() and as\na [function](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-convert2xkt) to use within\nour own Node scripts.\n\n````bash\nnode convert2xkt.js -h\n\nUsage: convert2xkt [options]\n\nOptions:\n\n    -v, --version           output the version number of xeokit-convert\n    -s, --source [file]     path to source file\n    -f, --format [string]   source file format (optional); supported formats are gltf, ifc, laz, las, stl and cityjson\n    -m, --metamodel [file]  path to source metamodel JSON file (optional)\n    -i, --include [types]   only convert these types (optional)\n    -x, --exclude [types]   never convert these types (optional)\n    -r, --rotatex           rotate model 90 degrees about X axis (for las and cityjson)\n    -o, --output [file]     path to target .xkt file; creates directories on path automatically if not existing\n    -l, --log               enable logging\n    -h, --help              output usage information\n\n````\n\n### Converting an IFC file into an XKT file on the command line\n\nLet's use the [convert2xkt](https://github.com/xeokit/xeokit-convert/blob/master/convert2xkt.js) Node script to convert\nan IFC file to XKT on the command line.\n\n````bash\nnode convert2xkt.js -s rme_advanced_sample_project.ifc -o rme_advanced_sample_project.ifc.xkt -l\n\nReading input file: rme_advanced_sample_project.ifc\nInput file size: 35309.94 kB\nConverting...\nConverted objects: 6442\nConverted geometries: 3897\nWriting XKT file: rme_advanced_sample_project.ifc.xkt\nXKT version: 9\nXKT size: 1632.98 kB\nCompression ratio: 21.62\nConversion time: 54.41 s\n````\n\n### Viewing the XKT file with xeokit\n\nNow that we've got an XKT file, we can now view it in the browser using a\nxeokit [Viewer](https://xeokit.github.io/xeokit-sdk/docs/class/src/viewer/Viewer.js~Viewer.html) configured with\nan [XKTLoaderPlugin](https://xeokit.github.io/xeokit-sdk/docs/class/src/plugins/XKTLoaderPlugin/XKTLoaderPlugin.js~XKTLoaderPlugin.html)\n.\n\n````javascript\nimport {Viewer, XKTLoaderPlugin} from\n          \"https://cdn.jsdelivr.net/npm/@xeokit/xeokit-sdk@1/dist/xeokit-sdk.es.min.js\";\n\nconst viewer = new Viewer({\n  canvasId: \"myCanvas\"\n});\n\nconst xktLoader = new XKTLoaderPlugin(viewer);\n\nconst modelNode = xktLoader.load({\n  id: \"myModel\",\n  src: \"./rme_sample_project.ifc.xkt\"\n});\n````\n\n### Querying the XKT version in Node.js\n\nFrom with a Node script, we can query which XKT version ````xeokit-convert```` currently generates:\n\n````javascript\nconst {XKT_INFO} = require(\"./dist/xeokit-convert.cjs.js\");\n\nconst xktVersion = XKT_INFO.xktVersion; // Unsigned integer\nconsole.log(`XKT version: ${xktVersion}`);\n````\n\n### Converting an IFC file into an XKT file in Node.js\n\nWe can use\nthe [convert2xkt](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-convert2xkt)\nfunction from within our Nodejs scripts to programmatically convert files to XKT.\n\nThis is awesome for automated model conversion, and\nour [performance test suite](https://github.com/xeokit/xeokit-convert/tree/master/perfTests).\n\n````javascript\nconst convert2xkt = require(\"@xeokit/xeokit-convert/dist/convert2xkt.cjs.js\");\n\nconvert2xkt({\n  source: \"rme_advanced_sample_project.ifc\",\n  output: \"rme_advanced_sample_project.ifc.xkt\",\n  log: (msg) => {\n    console.log(msg)\n  }\n}).then(() => {\n  console.log(\"Converted.\");\n}, (errMsg) => {\n  console.error(\"Conversion failed: \" + errMsg)\n});\n````\n\n### Converting IFC file data into XKT data in Node.js\n\nWhen using\nthe [convert2xkt](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-convert2xkt)\nfunction in our Node scripts, we can manage all file data in memory.\n\nThis is great for when we want more control over where we read and write the files.\n\n````javascript\nconst convert2xkt = require(\"@xeokit/xeokit-convert/dist/convert2xkt.cjs.js\");\nconst fs = require('fs');\n\nconvert2xkt({\n  sourceData: fs.readFileSync(\"rme_advanced_sample_project.ifc\"),\n  outputXKT: (xtkArrayBuffer) => {\n    fs.writeFileSync(\"rme_advanced_sample_project.ifc.xkt\", xtkArrayBuffer);\n  }\n}).then(() => {\n  console.log(\"Converted.\");\n}, (errMsg) => {\n  console.error(\"Conversion failed: \" + errMsg)\n});\n````\n\nWhen using\nthe [convert2xkt](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-convert2xkt)\nfunction in our Node scripts, we can manage all file data in memory.\n\nThis is great for when we want more control over where we read and write the files.\n\n````javascript\nconst convert2xkt = require(\"@xeokit/xeokit-convert/dist/convert2xkt.cjs.js\");\nconst fs = require('fs');\n\nconvert2xkt({\n  sourceData: fs.readFileSync(\"rme_advanced_sample_project.ifc\"),\n  outputXKT: (xtkArrayBuffer) => {\n    fs.writeFileSync(\"rme_advanced_sample_project.ifc.xkt\", xtkArrayBuffer);\n  }\n}).then(() => {\n  console.log(\"Converted.\");\n}, (errMsg) => {\n  console.error(\"Conversion failed: \" + errMsg)\n});\n````\n\n# Using ````XKTModel````\n\n````XKTModel```` is a JavaScript class that represents the contents of an XKT file in memory.\n\nIt's a sort of *XKT document model*, with methods to build 3D objects within it, functions to import various model\nformats, and a function to serialize it to an XKT file.\n\nWe can use these tools to:\n\n* programmatically XKT files,\n* combine multiple models into an XKT file, from different formats,\n* develop custom XKT converters, and\n* extend ````convert2xkt```` to support more formats.\n\n### Programmatically Building an XKT File\n\nTo demonstrate the API, let's\nuse [````XKTModel````](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) 's\nbuilder methods to programmatically build a model that resembles the screenshot below. Then we'll serialize\nthe ````XKTModel```` to an\n````ArrayBuffer````, which we'll finally load that into a\nxeokit [````Viewer````](https://xeokit.github.io/xeokit-sdk/docs/class/src/viewer/Viewer.js~Viewer.html)\nusing [````XKTLoaderPlugin````](https://xeokit.github.io/xeokit-sdk/docs/class/src/plugins/XKTLoaderPlugin/XKTLoaderPlugin.js~XKTLoaderPlugin.html)\n.\n\nWe'll code this example to run in the browser, using the ES module\nin [xeokit-convert.es.js](./dist/xeokit-convert.es.js). We could also code it to run on node, using the CommonJS module\nin [xeokit-convert.cjs.js](./dist/xeokit-convert.cjs.js).\n\n![XKTModel Example](http://xeokit.io/img/docs/PerformanceModel/PerformanceModel.png)\n\n````javascript\nconst {\n  XKTModel,\n  writeXKTModelToArrayBuffer\n} = require(\"@xeokit/xeokit-convert/dist/xeokit-convert.cjs.js\");\nconst fs = require('fs');\n\nconst xktModel = new XKTModel();\n\n// Create metamodel - this part is optional\n\n// Create property sets to hold info about the model\n\nxktModel.createPropertySet({\n  propertySetId: \"tableTopPropSet\",\n  propertySetType: \"Default\",\n  propertySetName: \"Table Top\",\n  properties: [\n    {\n      id: \"tableTopMaterial\",\n      type: \"Default\",\n      name: \"Table top material\",\n      value: \"Marble\"\n    },\n    {\n      id: \"tableTopDimensions\",\n      type: \"Default\",\n      name: \"Table top dimensions\",\n      value: \"90x90x3 cm\"\n    }\n  ]\n});\n\nxktModel.createPropertySet({\n  propertySetId: \"tableLegPropSet\",\n  propertySetType: \"Default\",\n  propertySetName: \"Table Leg\",\n  properties: [\n    {\n      id: \"tableLegMaterial\",\n      type: \"Default\",\n      name: \"Table leg material\",\n      value: \"Pine\"\n    },\n    {\n      id: \"tableLegDimensions\",\n      type: \"Default\",\n      name: \"Table leg dimensions\",\n      value: \"5x5x50 cm\"\n    }\n  ]\n});\n\n// Create a hierarchy of metaobjects to describe the structure of the model\n\nxktModel.createMetaObject({ // Root XKTMetaObject, has no XKTEntity\n  metaObjectId: \"table\",\n  metaObjectName: \"The Table\",\n  metaObjectType: \"furniture\"\n});\n\nxktModel.createMetaObject({\n  metaObjectId: \"redLeg\",\n  metaObjectName: \"Red Table Leg\",\n  metaObjectType: \"furniturePart\",\n  parentMetaObjectId: \"table\",\n  propertySetIds: [\"tableLegPropSet\"]\n});\n\nxktModel.createMetaObject({\n  metaObjectId: \"greenLeg\",\n  metaObjectName: \"Green Table Leg\",\n  metaObjectType: \"furniturePart\",\n  parentMetaObjectId: \"table\",\n  propertySetIds: [\"tableLegPropSet\"]\n});\n\nxktModel.createMetaObject({\n  metaObjectId: \"blueLeg\",\n  metaObjectName: \"Blue Table Leg\",\n  metaObjectType: \"furniturePart\",\n  parentMetaObjectId: \"table\",\n  propertySetIds: [\"tableLegPropSet\"]\n});\n\nxktModel.createMetaObject({\n  metaObjectId: \"yellowLeg\",\n  metaObjectName: \"Yellow Table Leg\",\n  metaObjectType: \"furniturePart\",\n  parentMetaObjectId: \"table\",\n  propertySetIds: [\"tableLegPropSet\"]\n});\n\nxktModel.createMetaObject({\n  metaObjectId: \"pinkTop\",\n  metaObjectName: \"The Pink Table Top\",\n  metaObjectType: \"furniturePart\",\n  parentMetaObjectId: \"table\",\n  propertySetIds: [\"tableTopPropSet\"]\n});\n\n// Create an XKTGeometry that defines a box shape, as a triangle mesh \n\nxktModel.createGeometry({\n  geometryId: \"boxGeometry\",\n  primitiveType: \"triangles\", // Also \"lines\" and \"points\"\n  positions: [\n    1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, -1, 1,\n    -1, -1, 1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1,\n    -1, -1, -1, -1, -1, 1, -1, 1, 1, -1\n  ],\n  normals: [ // Only for \"triangles\"\n    0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,\n    -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0, -1, 0, 0,\n    -1, 0, 0, -1\n  ],\n  indices: [\n    0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19,\n    20, 21, 22, 20, 22, 23\n  ]\n});\n\n// Create five XKTMeshes, which represent the table top and legs.\n// Each XKTMesh has its own color, position, orientation and size, \n// and uses the XKTGeometry to define its shape.  \n// An XKTGeometry can be used by multiple XKTMeshes.\n\nxktModel.createMesh({\n  meshId: \"redLegMesh\",\n  geometryId: \"boxGeometry\",\n  position: [-4, -6, -4],\n  scale: [1, 3, 1],\n  rotation: [0, 0, 0],\n  color: [1, 0, 0],\n  opacity: 1\n});\n\nxktModel.createMesh({\n  meshId: \"greenLegMesh\",\n  geometryId: \"boxGeometry\",\n  position: [4, -6, -4],\n  scale: [1, 3, 1],\n  rotation: [0, 0, 0],\n  color: [0, 1, 0],\n  opacity: 1\n});\n\nxktModel.createMesh({\n  meshId: \"blueLegMesh\",\n  geometryId: \"boxGeometry\",\n  position: [4, -6, 4],\n  scale: [1, 3, 1],\n  rotation: [0, 0, 0],\n  color: [0, 0, 1],\n  opacity: 1\n});\n\nxktModel.createMesh({\n  meshId: \"yellowLegMesh\",\n  geometryId: \"boxGeometry\",\n  position: [-4, -6, 4],\n  scale: [1, 3, 1],\n  rotation: [0, 0, 0],\n  color: [1, 1, 0],\n  opacity: 1\n});\n\nxktModel.createMesh({\n  meshId: \"pinkTopMesh\",\n  geometryId: \"boxGeometry\",\n  position: [0, -3, 0],\n  scale: [6, 0.5, 6],\n  rotation: [0, 0, 0],\n  color: [1, 0, 1],\n  opacity: 1\n});\n\n// Create five XKTEntities, which represent abstract, named objects in the model. \n// Each XKTEntity has an XKTMesh.\n// An XKTEntity can have multiple XKTMeshes. \n// An XKTMesh can only belong to one XKTEntity.\n\nxktModel.createEntity({\n  entityId: \"redLeg\",\n  meshIds: [\"redLegMesh\"]\n});\n\nxktModel.createEntity({\n  entityId: \"greenLeg\",\n  meshIds: [\"greenLegMesh\"]\n});\n\nxktModel.createEntity({\n  entityId: \"blueLeg\",\n  meshIds: [\"blueLegMesh\"]\n});\n\nxktModel.createEntity({\n  entityId: \"yellowLeg\",\n  meshIds: [\"yellowLegMesh\"]\n});\n\nxktModel.createEntity({\n  entityId: \"pinkTop\",\n  meshIds: [\"pinkTopMesh\"]\n});\n````\n\nOnce we've built\nour [````XKTModel````](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) we\nneed to finalize it. Then it's ready to use.\n\n````javascript\nxktModel.finalize();\n````\n\n### Serializing the XKTModel to an ArrayBuffer\n\nNext, we'll\nuse  [````writeXKTModelToArrayBuffer````](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-writeXKTModelToArrayBuffer)\nto serialize\nour [````XKTModel````](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) to\nan ````ArrayBuffer````.\n\n````javascript\nconst xktArrayBuffer = writeXKTModelToArrayBuffer(xktModel);\n\nfs.writeFileSync(\"./myModel.xkt\", xktArrayBuffer);\n````\n\n### Loading the ArrayBuffer into a Viewer\n\nLet's now create a [````Viewer````](https://xeokit.github.io/xeokit-sdk/docs/class/src/viewer/Viewer.js~Viewer.html),\nthen load the ````ArrayBuffer```` into it using\nan [````XKTLoaderPlugin````](https://xeokit.github.io/xeokit-sdk/docs/class/src/plugins/XKTLoaderPlugin/XKTLoaderPlugin.js~XKTLoaderPlugin.html)\n.\n\n````javascript\nconst viewer = new Viewer({\n  canvasId: \"myCanvas\"\n});\n\nconst xktLoader = new XKTLoaderPlugin(viewer);\n\nconst model = xktLoader.load({\n  id: \"myModel\",\n  src: \"./myModel.xkt\"\n});\n````\n\nFinally, when the model has loaded, let's fit it in view.\n\n````javascript\nmodel.on(\"loaded\", () => {\n  viewer.cameraFlight.flyTo(model);\n});\n````\n\n### Loading IFC into an XKTModel\n\nLet's\nuse [````parseIFCIntoXKTModel````](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-parseIFCIntoXKTModel)\nto import IFC into\nan [````XKTModel````](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html).\n\nAs before, we'll also use the classes and functions introduced in the previous examples to serialize\nthe [````XKTModel````](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) to\nan ````ArrayBuffer````, then load it into\na [````Viewer````](https://xeokit.github.io/xeokit-sdk/docs/class/src/viewer/Viewer.js~Viewer.html).\n\n````javascript\nconst viewer = new Viewer({\n  canvasId: \"myCanvas\"\n});\n\nconst xktLoader = new XKTLoaderPlugin(viewer);\n\nutils.loadArraybuffer(\"./assets/models/ifc/rac_advanced_sample_project.ifc\", async (data) => {\n\n          const xktModel = new XKTModel();\n\n          parseIFCIntoXKTModel({data, xktModel, wasmPath: \"../dist/\"}).then(() => {\n\n            xktModel.finalize();\n\n            const xktArrayBuffer = writeXKTModelToArrayBuffer(xktModel);\n\n            xktLoader.load({\n              id: \"myModel\",\n              xkt: xktArrayBuffer,\n              edges: true\n            });\n\n            viewer.cameraFlight.flyTo(viewer.scene);\n          });\n        },\n        (errMsg) => {\n        });\n````\n\n### Loading LAS into an XKTModel\n\nLet's\nuse [````parseLASIntoXKTModel````](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-parseLASIntoXKTModel)\nto import LAS into\nan [````XKTModel````](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html).\n\nAs before, we'll also use the classes and functions introduced in the previous examples to serialize\nthe [````XKTModel````](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) to\nan ````ArrayBuffer````, then load it into\na [````Viewer````](https://xeokit.github.io/xeokit-sdk/docs/class/src/viewer/Viewer.js~Viewer.html).\n\n````javascript\nconst viewer = new Viewer({\n  canvasId: \"myCanvas\"\n});\n\nconst xktLoader = new XKTLoaderPlugin(viewer);\n\nutils.loadArraybuffer(\"./assets/models/laz/indoor.0.1.laz\", async (data) => {\n\n          const xktModel = new XKTModel();\n\n          parseLASIntoXKTModel({data, xktModel, rotateX; true }).then(() => {\n\n            xktModel.finalize();\n\n            const xktArrayBuffer = writeXKTModelToArrayBuffer(xktModel);\n\n            xktLoader.load({\n              id: \"myModel\",\n              xkt: xktArrayBuffer,\n              edges: true\n            });\n\n            viewer.cameraFlight.flyTo(viewer.scene);\n          });\n        },\n        (errMsg) => {\n        });\n````\n\n### Loading glTF into an XKTModel\n\nLet's\nuse [````parseGLTFIntoXKTModel````](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-parseGLTFIntoXKTModel)\nto import glTF into\nan [````XKTModel````](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html).\n\nWe'll also use the classes and functions introduced in the previous examples to serialize\nthe [````XKTModel````](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) to\nan ````ArrayBuffer````, then validate the ````ArrayBuffer```` and load it into\na [````Viewer````](https://xeokit.github.io/xeokit-sdk/docs/class/src/viewer/Viewer.js~Viewer.html).\n\n````javascript\nconst viewer = new Viewer({\n  canvasId: \"myCanvas\"\n});\n\nconst xktLoader = new XKTLoaderPlugin(viewer);\n\nutils.loadArraybuffer(\"./assets/models/gltf/MAP/glTF-Embedded/MAP.gltf\", (gltf) => {\n\n          const xktModel = new XKTModel();\n\n          parseGLTFIntoXKTModel({data: gltf, xktModel: xktModel}).then(() => {\n\n            xktModel.finalize();\n\n            const xktArrayBuffer = writeXKTModelToArrayBuffer(xktModel);\n\n            xktLoader.load({\n              id: \"myModel\",\n              xkt: xktArrayBuffer\n            });\n\n            viewer.cameraFlight.flyTo(viewer.scene);\n          });\n        },\n        (errMsg) => {\n        });\n````\n\n### Loading STL into an XKTModel\n\nLet's\nuse [````parseSTLIntoXKTModel````](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-parseSTLIntoXKTModel)\nto import STL into\nan [````XKTModel````](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html).\n\nAs before, we'll also use the classes and functions introduced in the previous examples to serialize\nthe [````XKTModel````](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) to\nan ````ArrayBuffer````, then load it into\na [````Viewer````](https://xeokit.github.io/xeokit-sdk/docs/class/src/viewer/Viewer.js~Viewer.html).\n\n````javascript\nconst viewer = new Viewer({\n  canvasId: \"myCanvas\"\n});\n\nconst xktLoader = new XKTLoaderPlugin(viewer);\n\nutils.loadJSON(\"./assets/models/stl/binary/spurGear.stl\", (json) => {\n\n          const xktModel = new XKTModel();\n\n          parseSTLIntoXKTModel({stlData: json, xktModel: xktModel}).then(() => {\n\n            xktModel.finalize();\n\n            const xktArrayBuffer = writeXKTModelToArrayBuffer(xktModel);\n\n            xktLoader.load({\n              id: \"myModel\",\n              xkt: xktArrayBuffer\n            });\n\n            viewer.cameraFlight.flyTo(viewer.scene);\n          });\n        },\n        (errMsg) => {\n        });\n````\n\n# Building\n\n### Building Binaries\n\nBuilding the binaries in [````./dist````](https://github.com/xeokit/xeokit-convert/tree/main/dist):\n\n````bash\nnpm update\nnpm run build\n````\n\nThis will build:\n\n* [./dist/convert2xkt.cjs.js](./dist/convert2xkt.cjs.js) - Nodejs CLI converter tool\n* [./dist/xeokit-convert.cjs.js](./dist/xeokit-convert.cjs.js) - CommonJS module\n* [./dist/xeokit-convert.es.js](./dist/xeokit-convert.es.js) - ES module\n* [./dist/web-ifc.wasm](./dist/web-ifc.wasm) - 3rd-party web-ifc WASM module\n\nBuilding the JavaScript API documentation in [````./docs````](https://xeokit.github.io/xeokit-convert/docs):\n\n````bash\nnpm run docs\n````\n\n### RuntimeError: memory access out of bounds\n\nWith luck, the WASM module already be compiled appropriately for your target x86 system. \n\nHowever, if you get this error:\n\n````bash\nRuntimeError: memory access out of bounds\n````\nthen you will need to compile that WASM module for your target system. Please follow the instructions for that on the \n[web-ifc](https://github.com/tomvandig/web-ifc) project page, then replace [./dist/web-ifc.wasm](./dist/web-ifc.wasm) with your compiled binary.\n\n### Building Tests\n\nInstall Firefox for Puppeteer:\n\n````bash\nPUPPETEER_PRODUCT=firefox npm i puppeteer\n````\n\nRun the tests using Firefox:\n\n````bash\nnpm build-tests\n````\n\n",
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"@xeokit/xeokit-convert\",\n  \"version\": \"1.0.8-beta-2\",\n  \"description\": \"JavaScript utilities to create .XKT files\",\n  \"main\": \"index.js\",\n  \"bin\": \"/convert2xkt.js\",\n  \"directories\": {},\n  \"scripts\": {\n    \"build-tests\": \"rollup --config rollup.config.tests.js\",\n    \"build\": \"rollup --config rollup.config.pako.js; rollup --config rollup.config.dist.js; rollup --config rollup.config.convert2xkt.js;\",\n    \"test\": \"node ./perfTests/perfTests.js; percy exec -- node ./visualTests/visualTests.js\",\n    \"perf-tests\": \"rollup --config rollup.config.pako.js; rollup --config rollup.config.dist.js; rollup --config rollup.config.convert2xkt.js; rollup --config rollup.config.tests.js; node ./perfTests/perfTests.js\",\n    \"visual-tests\": \"percy exec -- node ./visualTests/visualTests.js\",\n    \"docs\": \"rm -Rf ./docs/*; ./node_modules/.bin/esdoc\",\n    \"publish\": \"npm publish --access public\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/xeokit/xeokit-convert.git\"\n  },\n  \"keywords\": [\n    \"xeolabs\",\n    \"xeokit\",\n    \"bim\",\n    \"opensource\",\n    \"ifc\",\n    \"webgl\",\n    \"xkt\",\n    \"gltf\",\n    \"cityjson\",\n    \"laz\",\n    \"gis\"\n  ],\n  \"author\": \"Lindsay Kay\",\n  \"license\": \"LICENSE\",\n  \"bugs\": {\n    \"url\": \"https://github.com/xeokit/xeokit-convert/issues\"\n  },\n  \"homepage\": \"https://github.com/xeokit/xeokit-convert#readme\",\n  \"dependencies\": {\n    \"@loaders.gl/core\": \"^3.1.8\",\n    \"@loaders.gl/json\": \"^3.1.8\",\n    \"@loaders.gl/las\": \"^3.1.8\",\n    \"@loaders.gl/obj\": \"^3.1.8\",\n    \"@loaders.gl/ply\": \"^3.1.8\",\n    \"@loaders.gl/polyfills\": \"^3.1.8\",\n    \"@loaders.gl/gltf\": \"^3.1.8\",\n    \"@zip.js/zip.js\": \"^2.2.38\",\n    \"earcut\": \"^2.2.2\",\n    \"fs\": \"0.0.1-security\",\n    \"jszip\": \"^3.6.0\",\n    \"jszip-sync\": \"^3.2.1-sync\",\n    \"path\": \"^0.12.7\",\n    \"request\": \"^2.79.0\",\n    \"web-ifc\": \"^0.0.34\",\n    \"xmldom\": \"^0.6.0\"\n  },\n  \"devDependencies\": {\n    \"@percy/script\": \"^1.1.0\",\n    \"@rollup/plugin-commonjs\": \"^15.1.0\",\n    \"@xeokit/xeokit-sdk\": \"2.2.1\",\n    \"autoprefixer\": \"^9.8.5\",\n    \"esdoc\": \"^1.1.0\",\n    \"esdoc-node\": \"^1.0.5\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"http-server\": \"^0.12.3\",\n    \"puppeteer\": \"^10.4.0\",\n    \"puppeteer-firefox\": \"^0.5.1\",\n    \"rimraf\": \"^3.0.2\",\n    \"rollup\": \"^2.46.0\",\n    \"rollup-plugin-commonjs\": \"^10.1.0\",\n    \"rollup-plugin-copy\": \"^3.4.0\",\n    \"rollup-plugin-minify-es\": \"^1.1.1\",\n    \"rollup-plugin-node-resolve\": \"^5.2.0\"\n  },\n  \"files\": [\n    \"/dist\",\n    \"/convert2xkt.js\"\n  ]\n}\n",
    "longname": "/home/lindsay/WebstormProjects/xeokit-convert-loadersgl/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]