[
  {
    "__docId__": 1,
    "kind": "external",
    "name": "Infinity",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Infinity",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Infinity",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 2,
    "kind": "external",
    "name": "NaN",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NaN",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~NaN",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 3,
    "kind": "external",
    "name": "undefined",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~undefined",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 4,
    "kind": "external",
    "name": "null",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~null",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 5,
    "kind": "external",
    "name": "Object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 6,
    "kind": "external",
    "name": "object",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~object",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 7,
    "kind": "external",
    "name": "Function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 8,
    "kind": "external",
    "name": "function",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~function",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 9,
    "kind": "external",
    "name": "Boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 10,
    "kind": "external",
    "name": "boolean",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Boolean",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~boolean",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 11,
    "kind": "external",
    "name": "Symbol",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Symbol",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 12,
    "kind": "external",
    "name": "Error",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Error",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 13,
    "kind": "external",
    "name": "EvalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/EvalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~EvalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 14,
    "kind": "external",
    "name": "InternalError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/InternalError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~InternalError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 15,
    "kind": "external",
    "name": "RangeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RangeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RangeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 16,
    "kind": "external",
    "name": "ReferenceError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ReferenceError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ReferenceError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 17,
    "kind": "external",
    "name": "SyntaxError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~SyntaxError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 18,
    "kind": "external",
    "name": "TypeError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypeError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~TypeError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 19,
    "kind": "external",
    "name": "URIError",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/URIError",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~URIError",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 20,
    "kind": "external",
    "name": "Number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 21,
    "kind": "external",
    "name": "number",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~number",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 22,
    "kind": "external",
    "name": "Date",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Date",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 23,
    "kind": "external",
    "name": "String",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~String",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 24,
    "kind": "external",
    "name": "string",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~string",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 25,
    "kind": "external",
    "name": "RegExp",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~RegExp",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 26,
    "kind": "external",
    "name": "Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 27,
    "kind": "external",
    "name": "Int8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 28,
    "kind": "external",
    "name": "Uint8Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 29,
    "kind": "external",
    "name": "Uint8ClampedArray",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8ClampedArray",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint8ClampedArray",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 30,
    "kind": "external",
    "name": "Int16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 31,
    "kind": "external",
    "name": "Uint16Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint16Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint16Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 32,
    "kind": "external",
    "name": "Int32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Int32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Int32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 33,
    "kind": "external",
    "name": "Uint32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Uint32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 34,
    "kind": "external",
    "name": "Float32Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float32Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float32Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 35,
    "kind": "external",
    "name": "Float64Array",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Float64Array",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Float64Array",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 36,
    "kind": "external",
    "name": "Map",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Map",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 37,
    "kind": "external",
    "name": "Set",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Set",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 38,
    "kind": "external",
    "name": "WeakMap",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakMap",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakMap",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 39,
    "kind": "external",
    "name": "WeakSet",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/WeakSet",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~WeakSet",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 40,
    "kind": "external",
    "name": "ArrayBuffer",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/ArrayBuffer",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~ArrayBuffer",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 41,
    "kind": "external",
    "name": "DataView",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/DataView",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~DataView",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 42,
    "kind": "external",
    "name": "JSON",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~JSON",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 43,
    "kind": "external",
    "name": "Promise",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Promise",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 44,
    "kind": "external",
    "name": "Generator",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Generator",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 45,
    "kind": "external",
    "name": "GeneratorFunction",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/GeneratorFunction",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~GeneratorFunction",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 46,
    "kind": "external",
    "name": "Reflect",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Reflect",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 47,
    "kind": "external",
    "name": "Proxy",
    "externalLink": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
    "memberof": "src/.external-ecmascript.js",
    "static": true,
    "longname": "src/.external-ecmascript.js~Proxy",
    "access": "public",
    "description": "",
    "builtinExternal": true
  },
  {
    "__docId__": 48,
    "kind": "file",
    "name": "src/XKTModel/KDNode.js",
    "content": "/**\n * A kd-Tree node, used internally by {@link XKTModel}.\n *\n * @private\n */\nclass KDNode {\n\n    /**\n     * Create a KDNode with an axis-aligned 3D World-space boundary.\n     */\n    constructor(aabb) {\n\n        /**\n         * The axis-aligned 3D World-space boundary of this KDNode.\n         *\n         * @type {Float64Array}\n         */\n        this.aabb = aabb;\n\n        /**\n         * The {@link XKTEntity}s within this KDNode.\n         */\n        this.entities = null;\n\n        /**\n         * The left child KDNode.\n         */\n        this.left = null;\n\n        /**\n         * The right child KDNode.\n         */\n        this.right = null;\n    }\n}\n\nexport {KDNode};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/KDNode.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 49,
    "kind": "class",
    "name": "KDNode",
    "memberof": "src/XKTModel/KDNode.js",
    "static": true,
    "longname": "src/XKTModel/KDNode.js~KDNode",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/KDNode.js",
    "importStyle": "{KDNode}",
    "description": "A kd-Tree node, used internally by {@link XKTModel}.",
    "lineNumber": 6,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 50,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/KDNode.js~KDNode",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/KDNode.js~KDNode#constructor",
    "access": "public",
    "description": "Create a KDNode with an axis-aligned 3D World-space boundary.",
    "lineNumber": 11
  },
  {
    "__docId__": 51,
    "kind": "member",
    "name": "aabb",
    "memberof": "src/XKTModel/KDNode.js~KDNode",
    "static": false,
    "longname": "src/XKTModel/KDNode.js~KDNode#aabb",
    "access": "public",
    "description": "The axis-aligned 3D World-space boundary of this KDNode.",
    "lineNumber": 18,
    "type": {
      "nullable": null,
      "types": [
        "Float64Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 52,
    "kind": "member",
    "name": "entities",
    "memberof": "src/XKTModel/KDNode.js~KDNode",
    "static": false,
    "longname": "src/XKTModel/KDNode.js~KDNode#entities",
    "access": "public",
    "description": "The {@link XKTEntity}s within this KDNode.",
    "lineNumber": 23,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 53,
    "kind": "member",
    "name": "left",
    "memberof": "src/XKTModel/KDNode.js~KDNode",
    "static": false,
    "longname": "src/XKTModel/KDNode.js~KDNode#left",
    "access": "public",
    "description": "The left child KDNode.",
    "lineNumber": 28,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 54,
    "kind": "member",
    "name": "right",
    "memberof": "src/XKTModel/KDNode.js~KDNode",
    "static": false,
    "longname": "src/XKTModel/KDNode.js~KDNode#right",
    "access": "public",
    "description": "The right child KDNode.",
    "lineNumber": 33,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "file",
    "name": "src/XKTModel/MockXKTModel.js",
    "content": "import {math} from \"../lib/math.js\";\nimport {geometryCompression} from \"./lib/geometryCompression.js\";\nimport {buildEdgeIndices} from \"./lib/buildEdgeIndices.js\";\n\nconst tempVec4a = math.vec4([0, 0, 0, 1]);\nconst tempVec4b = math.vec4([0, 0, 0, 1]);\nconst tempMat4 = math.mat4();\nconst tempMat4b = math.mat4();\n\n/**\n * A mock {@link XKTModel} that creates {@link Mesh}es and {@link Geometry}s to visualize the output of {@link parseGLTFIntoXKTModel}.\n *\n * @private\n */\nclass MockXKTModel {\n\n    /**\n     *\n     * @param cfg\n     */\n    constructor(cfg={}) {\n\n        if (!cfg.handlePrimitive) {\n            throw \"Expected config: handlePrimitive\";\n        }\n\n        if (!cfg.handleEntity) {\n            throw \"Expected config: handleEntity\";\n        }\n\n        this._handlePrimitive = cfg.handlePrimitive;\n        this._handleEntity = cfg.handleEntity;\n\n        this.geometries = {};\n    }\n\n    createGeometry(params) {\n\n        const geometryId = params.geometryId;\n        const primitiveType = params.primitiveType;\n        const reused = params.reused;\n        const primitiveModelingMatrix = params.primitiveModelingMatrix ? params.primitiveModelingMatrix.slice : math.identityMat4();\n        const color = params.color;\n        const opacity = params.opacity;\n        const positions = params.positions.slice();\n        const normals = params.normals.slice();\n        const indices = params.indices;\n\n        const positions2 = positions.slice();\n\n        const edgeIndices = buildEdgeIndices(positions, indices, null, 10);\n\n        if (!reused) {\n\n            // Bake single-use geometry's positions into World-space\n\n            for (let i = 0, len = positions.length; i < len; i += 3) {\n\n                tempVec4a[0] = positions[i + 0];\n                tempVec4a[1] = positions[i + 1];\n                tempVec4a[2] = positions[i + 2];\n\n                math.transformPoint4(primitiveModelingMatrix, tempVec4a, tempVec4b);\n\n                positions2[i + 0] = tempVec4b[0];\n                positions2[i + 1] = tempVec4b[1];\n                positions2[i + 2] = tempVec4b[2];\n            }\n        }\n\n        const modelNormalMatrix = math.inverseMat4(math.transposeMat4(primitiveModelingMatrix, tempMat4b), tempMat4);\n        const normalsOctEncoded = new Int8Array(normals.length);\n\n        geometryCompression.transformAndOctEncodeNormals(modelNormalMatrix, normals, normals.length, normalsOctEncoded, 0);\n\n        const primitive = new VBOGeometry(this.scene, {\n            id: geometryId,\n            primitive: \"triangles\",\n            positions: positions2,\n            normals: normals,\n            indices: indices,\n            edgeIndices: edgeIndices\n        });\n\n        this.geometries[geometryId] = primitive;\n    }\n\n    createEntity(params) {\n\n        const entityId = params.entityId;\n        const entityModelingMatrix = params.entityModelingMatrix ? params.entityModelingMatrix.slice() : math.identityMat4();\n        const primitiveIds = params.primitiveIds;\n\n        for (let primitiveIdIdx = 0, primitiveIdLen = primitiveIds.length; primitiveIdIdx < primitiveIdLen; primitiveIdIdx++) {\n\n            const geometryId = primitiveIds[primitiveIdIdx];\n            const primitive = this.geometries[geometryId];\n\n            if (!primitive) {\n                console.error(\"primitive not found: \" + geometryId);\n                continue;\n            }\n\n            new Mesh(this.scene, {\n                id: entityId,\n                geometry: primitive,\n                matrix: entityModelingMatrix,\n                edges: true\n            });\n        }\n    }\n\n    finalize() {\n    }\n}\n\nexport {MockXKTModel};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/MockXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 56,
    "kind": "variable",
    "name": "tempVec4a",
    "memberof": "src/XKTModel/MockXKTModel.js",
    "static": true,
    "longname": "src/XKTModel/MockXKTModel.js~tempVec4a",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/MockXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 57,
    "kind": "variable",
    "name": "tempVec4b",
    "memberof": "src/XKTModel/MockXKTModel.js",
    "static": true,
    "longname": "src/XKTModel/MockXKTModel.js~tempVec4b",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/MockXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 58,
    "kind": "variable",
    "name": "tempMat4",
    "memberof": "src/XKTModel/MockXKTModel.js",
    "static": true,
    "longname": "src/XKTModel/MockXKTModel.js~tempMat4",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/MockXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 59,
    "kind": "variable",
    "name": "tempMat4b",
    "memberof": "src/XKTModel/MockXKTModel.js",
    "static": true,
    "longname": "src/XKTModel/MockXKTModel.js~tempMat4b",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/MockXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 60,
    "kind": "class",
    "name": "MockXKTModel",
    "memberof": "src/XKTModel/MockXKTModel.js",
    "static": true,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/MockXKTModel.js",
    "importStyle": "{MockXKTModel}",
    "description": "A mock {@link XKTModel} that creates {@link Mesh}es and {@link Geometry}s to visualize the output of {@link parseGLTFIntoXKTModel}.",
    "lineNumber": 15,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 61,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 21,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 62,
    "kind": "member",
    "name": "_handlePrimitive",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#_handlePrimitive",
    "access": "private",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 63,
    "kind": "member",
    "name": "_handleEntity",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#_handleEntity",
    "access": "private",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 64,
    "kind": "member",
    "name": "geometries",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#geometries",
    "access": "public",
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    }
  },
  {
    "__docId__": 65,
    "kind": "method",
    "name": "createGeometry",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#createGeometry",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "params": [
      {
        "name": "params",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 66,
    "kind": "method",
    "name": "createEntity",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#createEntity",
    "access": "public",
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "params": [
      {
        "name": "params",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 67,
    "kind": "method",
    "name": "finalize",
    "memberof": "src/XKTModel/MockXKTModel.js~MockXKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/MockXKTModel.js~MockXKTModel#finalize",
    "access": "public",
    "description": null,
    "lineNumber": 113,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 68,
    "kind": "file",
    "name": "src/XKTModel/XKTEntity.js",
    "content": "import {math} from \"../lib/math.js\";\n\n/**\n * An object within an {@link XKTModel}.\n *\n * * Created by {@link XKTModel#createEntity}\n * * Stored in {@link XKTModel#entities} and {@link XKTModel#entitiesList}\n * * Has one or more {@link XKTMesh}s, each having an {@link XKTGeometry}\n *\n * @class XKTEntity\n */\nclass XKTEntity {\n\n    /**\n     * @private\n     * @param entityId\n     * @param meshes\n     */\n    constructor(entityId,  meshes) {\n\n        /**\n         * Unique ID of this ````XKTEntity```` in {@link XKTModel#entities}.\n         *\n         * For a BIM model, this will be an IFC product ID.\n         *\n         * We can also use {@link XKTModel#createMetaObject} to create an {@link XKTMetaObject} to specify metadata for\n         * this ````XKTEntity````. To associate the {@link XKTMetaObject} with our {@link XKTEntity}, we give\n         * {@link XKTMetaObject#metaObjectId} the same value as {@link XKTEntity#entityId}.\n         *\n         * @type {String}\n         */\n        this.entityId = entityId;\n\n        /**\n         * Index of this ````XKTEntity```` in {@link XKTModel#entitiesList}.\n         *\n         * Set by {@link XKTModel#finalize}.\n         *\n         * @type {Number}\n         */\n        this.entityIndex = null;\n\n        /**\n         * A list of {@link XKTMesh}s that indicate which {@link XKTGeometry}s are used by this Entity.\n         *\n         * @type {XKTMesh[]}\n         */\n        this.meshes = meshes;\n\n        /**\n         * World-space axis-aligned bounding box (AABB) that encloses the {@link XKTGeometry#positions} of\n         * the {@link XKTGeometry}s that are used by this ````XKTEntity````.\n         *\n         * Set by {@link XKTModel#finalize}.\n         *\n         * @type {Float32Array}\n         */\n        this.aabb = math.AABB3();\n\n        /**\n         * Indicates if this ````XKTEntity```` shares {@link XKTGeometry}s with other {@link XKTEntity}'s.\n         *\n         * Set by {@link XKTModel#finalize}.\n         *\n         * Note that when an ````XKTEntity```` shares ````XKTGeometrys````, it shares **all** of its ````XKTGeometrys````. An ````XKTEntity````\n         * never shares only some of its ````XKTGeometrys```` - it always shares either the whole set or none at all.\n         *\n         * @type {Boolean}\n         */\n        this.hasReusedGeometries = false;\n    }\n}\n\nexport {XKTEntity};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/XKTEntity.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 69,
    "kind": "class",
    "name": "XKTEntity",
    "memberof": "src/XKTModel/XKTEntity.js",
    "static": true,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTEntity.js",
    "importStyle": "{XKTEntity}",
    "description": "An object within an {@link XKTModel}.\n\n* Created by {@link XKTModel#createEntity}\n* Stored in {@link XKTModel#entities} and {@link XKTModel#entitiesList}\n* Has one or more {@link XKTMesh}s, each having an {@link XKTGeometry}",
    "lineNumber": 12,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTEntity"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 70,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 19,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "entityId",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "meshes",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 71,
    "kind": "member",
    "name": "entityId",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#entityId",
    "access": "public",
    "description": "Unique ID of this ````XKTEntity```` in {@link XKTModel#entities}.\n\nFor a BIM model, this will be an IFC product ID.\n\nWe can also use {@link XKTModel#createMetaObject} to create an {@link XKTMetaObject} to specify metadata for\nthis ````XKTEntity````. To associate the {@link XKTMetaObject} with our {@link XKTEntity}, we give\n{@link XKTMetaObject#metaObjectId} the same value as {@link XKTEntity#entityId}.",
    "lineNumber": 32,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 72,
    "kind": "member",
    "name": "entityIndex",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#entityIndex",
    "access": "public",
    "description": "Index of this ````XKTEntity```` in {@link XKTModel#entitiesList}.\n\nSet by {@link XKTModel#finalize}.",
    "lineNumber": 41,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 73,
    "kind": "member",
    "name": "meshes",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#meshes",
    "access": "public",
    "description": "A list of {@link XKTMesh}s that indicate which {@link XKTGeometry}s are used by this Entity.",
    "lineNumber": 48,
    "type": {
      "nullable": null,
      "types": [
        "XKTMesh[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 74,
    "kind": "member",
    "name": "aabb",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#aabb",
    "access": "public",
    "description": "World-space axis-aligned bounding box (AABB) that encloses the {@link XKTGeometry#positions} of\nthe {@link XKTGeometry}s that are used by this ````XKTEntity````.\n\nSet by {@link XKTModel#finalize}.",
    "lineNumber": 58,
    "type": {
      "nullable": null,
      "types": [
        "Float32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 75,
    "kind": "member",
    "name": "hasReusedGeometries",
    "memberof": "src/XKTModel/XKTEntity.js~XKTEntity",
    "static": false,
    "longname": "src/XKTModel/XKTEntity.js~XKTEntity#hasReusedGeometries",
    "access": "public",
    "description": "Indicates if this ````XKTEntity```` shares {@link XKTGeometry}s with other {@link XKTEntity}'s.\n\nSet by {@link XKTModel#finalize}.\n\nNote that when an ````XKTEntity```` shares ````XKTGeometrys````, it shares **all** of its ````XKTGeometrys````. An ````XKTEntity````\nnever shares only some of its ````XKTGeometrys```` - it always shares either the whole set or none at all.",
    "lineNumber": 70,
    "type": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 76,
    "kind": "file",
    "name": "src/XKTModel/XKTGeometry.js",
    "content": "/**\n * An element of reusable geometry within an {@link XKTModel}.\n *\n * * Created by {@link XKTModel#createGeometry}\n * * Stored in {@link XKTModel#geometries} and {@link XKTModel#geometriesList}\n * * Referenced by {@link XKTMesh}s, which belong to {@link XKTEntity}s\n *\n * @class XKTGeometry\n */\nclass XKTGeometry {\n\n    /**\n     * @private\n     * @param {*} cfg Configuration for the XKTGeometry.\n     * @param {Number} cfg.geometryId Unique ID of the geometry in {@link XKTModel#geometries}.\n     * @param {String} cfg.primitiveType Type of this geometry - \"triangles\", \"points\" or \"lines\" so far.\n     * @param {Number} cfg.geometryIndex Index of this XKTGeometry in {@link XKTModel#geometriesList}.\n     * @param {Float64Array} cfg.positions Non-quantized 3D vertex positions.\n     * @param {Float32Array} cfg.normals Non-compressed vertex normals.\n     * @param {Uint8Array} cfg.colorsCompressed Unsigned 8-bit integer RGBA vertex colors.\n     * @param {Float32Array} cfg.uvs Non-compressed vertex UV coordinates.\n     * @param {Uint32Array} cfg.indices Indices to organize the vertex positions and normals into triangles.\n     * @param {Uint32Array} cfg.edgeIndices Indices to organize the vertex positions into edges.\n     */\n    constructor(cfg) {\n\n        /**\n         * Unique ID of this XKTGeometry in {@link XKTModel#geometries}.\n         *\n         * @type {Number}\n         */\n        this.geometryId = cfg.geometryId;\n\n        /**\n         * The type of primitive - \"triangles\" | \"points\" | \"lines\".\n         *\n         * @type {String}\n         */\n        this.primitiveType = cfg.primitiveType;\n\n        /**\n         * Index of this XKTGeometry in {@link XKTModel#geometriesList}.\n         *\n         * @type {Number}\n         */\n        this.geometryIndex = cfg.geometryIndex;\n\n        /**\n         * The number of {@link XKTMesh}s that reference this XKTGeometry.\n         *\n         * @type {Number}\n         */\n        this.numInstances = 0;\n\n        /**\n         * Non-quantized 3D vertex positions.\n         *\n         * Defined for all primitive types.\n         *\n         * @type {Float64Array}\n         */\n        this.positions = cfg.positions;\n\n        /**\n         * Quantized vertex positions.\n         *\n         * Defined for all primitive types.\n         *\n         * This array is later created from {@link XKTGeometry#positions} by {@link XKTModel#finalize}.\n         *\n         * @type {Uint16Array}\n         */\n        this.positionsQuantized = new Uint16Array(cfg.positions.length);\n\n        /**\n         * Non-compressed 3D vertex normals.\n         *\n         * Defined only for triangle primitives. Can be null if we want xeokit to auto-generate them. Ignored for points and lines.\n         *\n         * @type {Float32Array}\n         */\n        this.normals = cfg.normals;\n\n        /**\n         * Compressed vertex normals.\n         *\n         * Defined only for triangle primitives. Ignored for points and lines.\n         *\n         * This array is later created from {@link XKTGeometry#normals} by {@link XKTModel#finalize}.\n         *\n         * Will be null if {@link XKTGeometry#normals} is also null.\n         *\n         * @type {Int8Array}\n         */\n        this.normalsOctEncoded = null;\n\n        /**\n         * Compressed RGBA vertex colors.\n         *\n         * Defined only for point primitives. Ignored for triangles and lines.\n         *\n         * @type {Uint8Array}\n         */\n        this.colorsCompressed = cfg.colorsCompressed;\n\n        /**\n         * Non-compressed vertex UVs.\n         *\n         * @type {Float32Array}\n         */\n        this.uvs = cfg.uvs;\n\n        /**\n         * Compressed vertex UVs.\n         *\n         * @type {Uint16Array}\n         */\n        this.uvsCompressed = cfg.uvsCompressed;\n\n        /**\n         * Indices that organize the vertex positions and normals as triangles.\n         *\n         * Defined only for triangle and lines primitives. Ignored for points.\n         *\n         * @type {Uint32Array}\n         */\n        this.indices = cfg.indices;\n\n        /**\n         * Indices that organize the vertex positions as edges.\n         *\n         * Defined only for triangle primitives. Ignored for points and lines.\n         *\n         * @type {Uint32Array}\n         */\n        this.edgeIndices = cfg.edgeIndices;\n\n        /**\n         * When {@link XKTGeometry#primitiveType} is \"triangles\", this is ````true```` when this geometry is a watertight mesh.\n         *\n         * Defined only for triangle primitives. Ignored for points and lines.\n         *\n         * Set by {@link XKTModel#finalize}.\n         *\n         * @type {boolean}\n         */\n        this.solid = false;\n    }\n\n    /**\n     * Convenience property that is ````true```` when {@link XKTGeometry#numInstances} is greater that one.\n     * @returns {boolean}\n     */\n    get reused() {\n        return (this.numInstances > 1);\n    }\n}\n\nexport {XKTGeometry};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/XKTGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 77,
    "kind": "class",
    "name": "XKTGeometry",
    "memberof": "src/XKTModel/XKTGeometry.js",
    "static": true,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTGeometry.js",
    "importStyle": "{XKTGeometry}",
    "description": "An element of reusable geometry within an {@link XKTModel}.\n\n* Created by {@link XKTModel#createGeometry}\n* Stored in {@link XKTModel#geometries} and {@link XKTModel#geometriesList}\n* Referenced by {@link XKTMesh}s, which belong to {@link XKTEntity}s",
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTGeometry"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 78,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 25,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg",
        "description": "Configuration for the XKTGeometry."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.geometryId",
        "description": "Unique ID of the geometry in {@link XKTModel#geometries}."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.primitiveType",
        "description": "Type of this geometry - \"triangles\", \"points\" or \"lines\" so far."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.geometryIndex",
        "description": "Index of this XKTGeometry in {@link XKTModel#geometriesList}."
      },
      {
        "nullable": null,
        "types": [
          "Float64Array"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.positions",
        "description": "Non-quantized 3D vertex positions."
      },
      {
        "nullable": null,
        "types": [
          "Float32Array"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.normals",
        "description": "Non-compressed vertex normals."
      },
      {
        "nullable": null,
        "types": [
          "Uint8Array"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.colorsCompressed",
        "description": "Unsigned 8-bit integer RGBA vertex colors."
      },
      {
        "nullable": null,
        "types": [
          "Float32Array"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.uvs",
        "description": "Non-compressed vertex UV coordinates."
      },
      {
        "nullable": null,
        "types": [
          "Uint32Array"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.indices",
        "description": "Indices to organize the vertex positions and normals into triangles."
      },
      {
        "nullable": null,
        "types": [
          "Uint32Array"
        ],
        "spread": false,
        "optional": false,
        "name": "cfg.edgeIndices",
        "description": "Indices to organize the vertex positions into edges."
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 79,
    "kind": "member",
    "name": "geometryId",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#geometryId",
    "access": "public",
    "description": "Unique ID of this XKTGeometry in {@link XKTModel#geometries}.",
    "lineNumber": 32,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 80,
    "kind": "member",
    "name": "primitiveType",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#primitiveType",
    "access": "public",
    "description": "The type of primitive - \"triangles\" | \"points\" | \"lines\".",
    "lineNumber": 39,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 81,
    "kind": "member",
    "name": "geometryIndex",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#geometryIndex",
    "access": "public",
    "description": "Index of this XKTGeometry in {@link XKTModel#geometriesList}.",
    "lineNumber": 46,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 82,
    "kind": "member",
    "name": "numInstances",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#numInstances",
    "access": "public",
    "description": "The number of {@link XKTMesh}s that reference this XKTGeometry.",
    "lineNumber": 53,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 83,
    "kind": "member",
    "name": "positions",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#positions",
    "access": "public",
    "description": "Non-quantized 3D vertex positions.\n\nDefined for all primitive types.",
    "lineNumber": 62,
    "type": {
      "nullable": null,
      "types": [
        "Float64Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 84,
    "kind": "member",
    "name": "positionsQuantized",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#positionsQuantized",
    "access": "public",
    "description": "Quantized vertex positions.\n\nDefined for all primitive types.\n\nThis array is later created from {@link XKTGeometry#positions} by {@link XKTModel#finalize}.",
    "lineNumber": 73,
    "type": {
      "nullable": null,
      "types": [
        "Uint16Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 85,
    "kind": "member",
    "name": "normals",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#normals",
    "access": "public",
    "description": "Non-compressed 3D vertex normals.\n\nDefined only for triangle primitives. Can be null if we want xeokit to auto-generate them. Ignored for points and lines.",
    "lineNumber": 82,
    "type": {
      "nullable": null,
      "types": [
        "Float32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 86,
    "kind": "member",
    "name": "normalsOctEncoded",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#normalsOctEncoded",
    "access": "public",
    "description": "Compressed vertex normals.\n\nDefined only for triangle primitives. Ignored for points and lines.\n\nThis array is later created from {@link XKTGeometry#normals} by {@link XKTModel#finalize}.\n\nWill be null if {@link XKTGeometry#normals} is also null.",
    "lineNumber": 95,
    "type": {
      "nullable": null,
      "types": [
        "Int8Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 87,
    "kind": "member",
    "name": "colorsCompressed",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#colorsCompressed",
    "access": "public",
    "description": "Compressed RGBA vertex colors.\n\nDefined only for point primitives. Ignored for triangles and lines.",
    "lineNumber": 104,
    "type": {
      "nullable": null,
      "types": [
        "Uint8Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 88,
    "kind": "member",
    "name": "uvs",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#uvs",
    "access": "public",
    "description": "Non-compressed vertex UVs.",
    "lineNumber": 111,
    "type": {
      "nullable": null,
      "types": [
        "Float32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 89,
    "kind": "member",
    "name": "uvsCompressed",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#uvsCompressed",
    "access": "public",
    "description": "Compressed vertex UVs.",
    "lineNumber": 118,
    "type": {
      "nullable": null,
      "types": [
        "Uint16Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 90,
    "kind": "member",
    "name": "indices",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#indices",
    "access": "public",
    "description": "Indices that organize the vertex positions and normals as triangles.\n\nDefined only for triangle and lines primitives. Ignored for points.",
    "lineNumber": 127,
    "type": {
      "nullable": null,
      "types": [
        "Uint32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 91,
    "kind": "member",
    "name": "edgeIndices",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#edgeIndices",
    "access": "public",
    "description": "Indices that organize the vertex positions as edges.\n\nDefined only for triangle primitives. Ignored for points and lines.",
    "lineNumber": 136,
    "type": {
      "nullable": null,
      "types": [
        "Uint32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 92,
    "kind": "member",
    "name": "solid",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#solid",
    "access": "public",
    "description": "When {@link XKTGeometry#primitiveType} is \"triangles\", this is ````true```` when this geometry is a watertight mesh.\n\nDefined only for triangle primitives. Ignored for points and lines.\n\nSet by {@link XKTModel#finalize}.",
    "lineNumber": 147,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 93,
    "kind": "get",
    "name": "reused",
    "memberof": "src/XKTModel/XKTGeometry.js~XKTGeometry",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTGeometry.js~XKTGeometry#reused",
    "access": "public",
    "description": "Convenience property that is ````true```` when {@link XKTGeometry#numInstances} is greater that one.",
    "lineNumber": 154,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{boolean}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": ""
    },
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 94,
    "kind": "file",
    "name": "src/XKTModel/XKTMesh.js",
    "content": "/**\n * Represents the usage of a {@link XKTGeometry} by an {@link XKTEntity}.\n *\n * * Created by {@link XKTModel#createEntity}\n * * Stored in {@link XKTEntity#meshes} and {@link XKTModel#meshesList}\n * * Has an {@link XKTGeometry}, and an optional {@link XKTTextureSet}, both of which it can share with other {@link XKTMesh}es\n * * Has {@link XKTMesh#color}, {@link XKTMesh#opacity}, {@link XKTMesh#metallic} and {@link XKTMesh#roughness} PBR attributes\n * @class XKTMesh\n */\nclass XKTMesh {\n\n    /**\n     * @private\n     */\n    constructor(cfg) {\n\n        /**\n         * Unique ID of this XKTMesh in {@link XKTModel#meshes}.\n         *\n         * @type {Number}\n         */\n        this.meshId = cfg.meshId;\n\n        /**\n         * Index of this XKTMesh in {@link XKTModel#meshesList};\n         *\n         * @type {Number}\n         */\n        this.meshIndex = cfg.meshIndex;\n\n        /**\n         * The 4x4 modeling transform matrix.\n         *\n         * Transform is relative to the center of the {@link XKTTile} that contains this XKTMesh's {@link XKTEntity},\n         * which is given in {@link XKTMesh#entity}.\n         *\n         * When the ````XKTEntity```` shares its {@link XKTGeometry}s with other ````XKTEntity````s, this matrix is used\n         * to transform this XKTMesh's XKTGeometry into World-space. When this XKTMesh does not share its ````XKTGeometry````,\n         * then this matrix is ignored.\n         *\n         * @type {Number[]}\n         */\n        this.matrix = cfg.matrix;\n\n        /**\n         * The instanced {@link XKTGeometry}.\n         *\n         * @type {XKTGeometry}\n         */\n        this.geometry = cfg.geometry;\n\n        /**\n         * RGB color of this XKTMesh.\n         *\n         * @type {Float32Array}\n         */\n        this.color = cfg.color || new Float32Array([1, 1, 1]);\n\n        /**\n         * PBR metallness of this XKTMesh.\n         *\n         * @type {Number}\n         */\n        this.metallic = (cfg.metallic !== null && cfg.metallic !== undefined) ? cfg.metallic : 0;\n\n        /**\n         * PBR roughness of this XKTMesh.\n         * The {@link XKTTextureSet} that defines the appearance of this XKTMesh.\n         *\n         * @type {Number}\n         * @type {XKTTextureSet}\n         */\n        this.roughness = (cfg.roughness !== null && cfg.roughness !== undefined) ? cfg.roughness : 1;\n\n        /**\n         * Opacity of this XKTMesh.\n         *\n         * @type {Number}\n         */\n        this.opacity = (cfg.opacity !== undefined && cfg.opacity !== null) ? cfg.opacity : 1.0;\n\n        /**\n         * The {@link XKTTextureSet} that defines the appearance of this XKTMesh.\n         *\n         * @type {XKTTextureSet}\n         */\n        this.textureSet = cfg.textureSet;\n\n        /**\n         * The owner {@link XKTEntity}.\n         *\n         * Set by {@link XKTModel#createEntity}.\n         *\n         * @type {XKTEntity}\n         */\n        this.entity = null; // Set after instantiation, when the Entity is known\n    }\n}\n\nexport {XKTMesh};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/XKTMesh.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 95,
    "kind": "class",
    "name": "XKTMesh",
    "memberof": "src/XKTModel/XKTMesh.js",
    "static": true,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTMesh.js",
    "importStyle": "{XKTMesh}",
    "description": "Represents the usage of a {@link XKTGeometry} by an {@link XKTEntity}.\n\n* Created by {@link XKTModel#createEntity}\n* Stored in {@link XKTEntity#meshes} and {@link XKTModel#meshesList}\n* Has an {@link XKTGeometry}, and an optional {@link XKTTextureSet}, both of which it can share with other {@link XKTMesh}es\n* Has {@link XKTMesh#color}, {@link XKTMesh#opacity}, {@link XKTMesh#metallic} and {@link XKTMesh#roughness} PBR attributes",
    "lineNumber": 10,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTMesh"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 96,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 15,
    "ignore": true
  },
  {
    "__docId__": 97,
    "kind": "member",
    "name": "meshId",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#meshId",
    "access": "public",
    "description": "Unique ID of this XKTMesh in {@link XKTModel#meshes}.",
    "lineNumber": 22,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 98,
    "kind": "member",
    "name": "meshIndex",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#meshIndex",
    "access": "public",
    "description": "Index of this XKTMesh in {@link XKTModel#meshesList};",
    "lineNumber": 29,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 99,
    "kind": "member",
    "name": "matrix",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#matrix",
    "access": "public",
    "description": "The 4x4 modeling transform matrix.\n\nTransform is relative to the center of the {@link XKTTile} that contains this XKTMesh's {@link XKTEntity},\nwhich is given in {@link XKTMesh#entity}.\n\nWhen the ````XKTEntity```` shares its {@link XKTGeometry}s with other ````XKTEntity````s, this matrix is used\nto transform this XKTMesh's XKTGeometry into World-space. When this XKTMesh does not share its ````XKTGeometry````,\nthen this matrix is ignored.",
    "lineNumber": 43,
    "type": {
      "nullable": null,
      "types": [
        "Number[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 100,
    "kind": "member",
    "name": "geometry",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#geometry",
    "access": "public",
    "description": "The instanced {@link XKTGeometry}.",
    "lineNumber": 50,
    "type": {
      "nullable": null,
      "types": [
        "XKTGeometry"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 101,
    "kind": "member",
    "name": "color",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#color",
    "access": "public",
    "description": "RGB color of this XKTMesh.",
    "lineNumber": 57,
    "type": {
      "nullable": null,
      "types": [
        "Float32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 102,
    "kind": "member",
    "name": "metallic",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#metallic",
    "access": "public",
    "description": "PBR metallness of this XKTMesh.",
    "lineNumber": 64,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 103,
    "kind": "member",
    "name": "roughness",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#roughness",
    "access": "public",
    "description": "PBR roughness of this XKTMesh.\nThe {@link XKTTextureSet} that defines the appearance of this XKTMesh.",
    "lineNumber": 73,
    "type": {
      "nullable": null,
      "types": [
        "XKTTextureSet"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 104,
    "kind": "member",
    "name": "opacity",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#opacity",
    "access": "public",
    "description": "Opacity of this XKTMesh.",
    "lineNumber": 80,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 105,
    "kind": "member",
    "name": "textureSet",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#textureSet",
    "access": "public",
    "description": "The {@link XKTTextureSet} that defines the appearance of this XKTMesh.",
    "lineNumber": 87,
    "type": {
      "nullable": null,
      "types": [
        "XKTTextureSet"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 106,
    "kind": "member",
    "name": "entity",
    "memberof": "src/XKTModel/XKTMesh.js~XKTMesh",
    "static": false,
    "longname": "src/XKTModel/XKTMesh.js~XKTMesh#entity",
    "access": "public",
    "description": "The owner {@link XKTEntity}.\n\nSet by {@link XKTModel#createEntity}.",
    "lineNumber": 96,
    "type": {
      "nullable": null,
      "types": [
        "XKTEntity"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 107,
    "kind": "file",
    "name": "src/XKTModel/XKTMetaObject.js",
    "content": "/**\n * A meta object within an {@link XKTModel}.\n *\n * These are plugged together into a parent-child hierarchy to represent structural\n * metadata for the {@link XKTModel}.\n *\n * The leaf XKTMetaObjects are usually associated with\n * an {@link XKTEntity}, which they do so by sharing the same ID,\n * ie. where {@link XKTMetaObject#metaObjectId} == {@link XKTEntity#entityId}.\n *\n * * Created by {@link XKTModel#createMetaObject}\n * * Stored in {@link XKTModel#metaObjects} and {@link XKTModel#metaObjectsList}\n * * Has an ID, a type, and a human-readable name\n * * May have a parent {@link XKTMetaObject}\n * * When no children, is usually associated with an {@link XKTEntity}\n *\n * @class XKTMetaObject\n */\nclass XKTMetaObject {\n\n    /**\n     * @private\n     * @param metaObjectId\n     * @param propertySetIds\n     * @param metaObjectType\n     * @param metaObjectName\n     * @param parentMetaObjectId\n     */\n    constructor(metaObjectId, propertySetIds, metaObjectType, metaObjectName, parentMetaObjectId) {\n\n        /**\n         * Unique ID of this ````XKTMetaObject```` in {@link XKTModel#metaObjects}.\n         *\n         * For a BIM model, this will be an IFC product ID.\n         *\n         * If this is a leaf XKTMetaObject, where it is not a parent to any other XKTMetaObject,\n         * then this will be equal to the ID of an {@link XKTEntity} in {@link XKTModel#entities},\n         * ie. where {@link XKTMetaObject#metaObjectId} == {@link XKTEntity#entityId}.\n         *\n         * @type {String}\n         */\n        this.metaObjectId = metaObjectId;\n\n        /**\n         * Unique ID of one or more property sets that contains additional metadata about this\n         * {@link XKTMetaObject}. The property sets can be stored in an external system, or\n         * within the {@link XKTModel}, as {@link XKTPropertySet}s within {@link XKTModel#propertySets}.\n         *\n         * @type {String[]}\n         */\n        this.propertySetIds = propertySetIds;\n\n        /**\n         * Indicates the XKTMetaObject meta object type.\n         *\n         * This defaults to \"default\".\n         *\n         * @type {string}\n         */\n        this.metaObjectType = metaObjectType;\n\n        /**\n         * Indicates the XKTMetaObject meta object name.\n         *\n         * This defaults to {@link XKTMetaObject#metaObjectId}.\n         *\n         * @type {string}\n         */\n        this.metaObjectName = metaObjectName;\n\n        /**\n         * The parent XKTMetaObject, if any.\n         *\n         * Will be null if there is no parent.\n         *\n         * @type {String}\n         */\n        this.parentMetaObjectId = parentMetaObjectId;\n    }\n}\n\nexport {XKTMetaObject};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/XKTMetaObject.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 108,
    "kind": "class",
    "name": "XKTMetaObject",
    "memberof": "src/XKTModel/XKTMetaObject.js",
    "static": true,
    "longname": "src/XKTModel/XKTMetaObject.js~XKTMetaObject",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTMetaObject.js",
    "importStyle": "{XKTMetaObject}",
    "description": "A meta object within an {@link XKTModel}.\n\nThese are plugged together into a parent-child hierarchy to represent structural\nmetadata for the {@link XKTModel}.\n\nThe leaf XKTMetaObjects are usually associated with\nan {@link XKTEntity}, which they do so by sharing the same ID,\nie. where {@link XKTMetaObject#metaObjectId} == {@link XKTEntity#entityId}.\n\n* Created by {@link XKTModel#createMetaObject}\n* Stored in {@link XKTModel#metaObjects} and {@link XKTModel#metaObjectsList}\n* Has an ID, a type, and a human-readable name\n* May have a parent {@link XKTMetaObject}\n* When no children, is usually associated with an {@link XKTEntity}",
    "lineNumber": 19,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTMetaObject"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 109,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTMetaObject.js~XKTMetaObject",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTMetaObject.js~XKTMetaObject#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 29,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "metaObjectId",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "propertySetIds",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "metaObjectType",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "metaObjectName",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "parentMetaObjectId",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 110,
    "kind": "member",
    "name": "metaObjectId",
    "memberof": "src/XKTModel/XKTMetaObject.js~XKTMetaObject",
    "static": false,
    "longname": "src/XKTModel/XKTMetaObject.js~XKTMetaObject#metaObjectId",
    "access": "public",
    "description": "Unique ID of this ````XKTMetaObject```` in {@link XKTModel#metaObjects}.\n\nFor a BIM model, this will be an IFC product ID.\n\nIf this is a leaf XKTMetaObject, where it is not a parent to any other XKTMetaObject,\nthen this will be equal to the ID of an {@link XKTEntity} in {@link XKTModel#entities},\nie. where {@link XKTMetaObject#metaObjectId} == {@link XKTEntity#entityId}.",
    "lineNumber": 42,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 111,
    "kind": "member",
    "name": "propertySetIds",
    "memberof": "src/XKTModel/XKTMetaObject.js~XKTMetaObject",
    "static": false,
    "longname": "src/XKTModel/XKTMetaObject.js~XKTMetaObject#propertySetIds",
    "access": "public",
    "description": "Unique ID of one or more property sets that contains additional metadata about this\n{@link XKTMetaObject}. The property sets can be stored in an external system, or\nwithin the {@link XKTModel}, as {@link XKTPropertySet}s within {@link XKTModel#propertySets}.",
    "lineNumber": 51,
    "type": {
      "nullable": null,
      "types": [
        "String[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 112,
    "kind": "member",
    "name": "metaObjectType",
    "memberof": "src/XKTModel/XKTMetaObject.js~XKTMetaObject",
    "static": false,
    "longname": "src/XKTModel/XKTMetaObject.js~XKTMetaObject#metaObjectType",
    "access": "public",
    "description": "Indicates the XKTMetaObject meta object type.\n\nThis defaults to \"default\".",
    "lineNumber": 60,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 113,
    "kind": "member",
    "name": "metaObjectName",
    "memberof": "src/XKTModel/XKTMetaObject.js~XKTMetaObject",
    "static": false,
    "longname": "src/XKTModel/XKTMetaObject.js~XKTMetaObject#metaObjectName",
    "access": "public",
    "description": "Indicates the XKTMetaObject meta object name.\n\nThis defaults to {@link XKTMetaObject#metaObjectId}.",
    "lineNumber": 69,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 114,
    "kind": "member",
    "name": "parentMetaObjectId",
    "memberof": "src/XKTModel/XKTMetaObject.js~XKTMetaObject",
    "static": false,
    "longname": "src/XKTModel/XKTMetaObject.js~XKTMetaObject#parentMetaObjectId",
    "access": "public",
    "description": "The parent XKTMetaObject, if any.\n\nWill be null if there is no parent.",
    "lineNumber": 78,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 115,
    "kind": "file",
    "name": "src/XKTModel/XKTModel.js",
    "content": "import {math} from \"../lib/math.js\";\nimport {geometryCompression} from \"./lib/geometryCompression.js\";\nimport {buildEdgeIndices} from \"./lib/buildEdgeIndices.js\";\nimport {isTriangleMeshSolid} from \"./lib/isTriangleMeshSolid.js\";\n\nimport {XKTMesh} from './XKTMesh.js';\nimport {XKTGeometry} from './XKTGeometry.js';\nimport {XKTEntity} from './XKTEntity.js';\nimport {XKTTile} from './XKTTile.js';\nimport {KDNode} from \"./KDNode.js\";\nimport {XKTMetaObject} from \"./XKTMetaObject.js\";\nimport {XKTPropertySet} from \"./XKTPropertySet.js\";\nimport {mergeVertices} from \"../lib/mergeVertices.js\";\nimport {XKT_INFO} from \"../XKT_INFO.js\";\nimport {XKTTexture} from \"./XKTTexture\";\nimport {XKTTextureSet} from \"./XKTTextureSet\";\nimport {encode, load} from \"@loaders.gl/core\";\nimport {KTX2BasisWriter} from \"@loaders.gl/textures\";\nimport {ImageLoader} from '@loaders.gl/images';\n\nconst tempVec4a = math.vec4([0, 0, 0, 1]);\nconst tempVec4b = math.vec4([0, 0, 0, 1]);\n\nconst tempMat4 = math.mat4();\nconst tempMat4b = math.mat4();\n\nconst kdTreeDimLength = new Float64Array(3);\n\n// XKT texture types\n\nconst COLOR_TEXTURE = 0;\nconst METALLIC_ROUGHNESS_TEXTURE = 1;\nconst NORMALS_TEXTURE = 2;\nconst EMISSIVE_TEXTURE = 3;\nconst OCCLUSION_TEXTURE = 4;\n\n// KTX2 encoding options for each texture type\n\nconst TEXTURE_ENCODING_OPTIONS = {}\nTEXTURE_ENCODING_OPTIONS[COLOR_TEXTURE] = {\n    useSRGB: true,\n    qualityLevel: 50,\n    encodeUASTC: true,\n    mipmaps: true\n};\nTEXTURE_ENCODING_OPTIONS[EMISSIVE_TEXTURE] = {\n    useSRGB: true,\n    encodeUASTC: true,\n    qualityLevel: 10,\n    mipmaps: false\n};\nTEXTURE_ENCODING_OPTIONS[METALLIC_ROUGHNESS_TEXTURE] = {\n    useSRGB: false,\n    encodeUASTC: true,\n    qualityLevel: 50,\n    mipmaps: true // Needed for GGX roughness shading\n};\nTEXTURE_ENCODING_OPTIONS[NORMALS_TEXTURE] = {\n    useSRGB: false,\n    encodeUASTC: true,\n    qualityLevel: 10,\n    mipmaps: false\n};\nTEXTURE_ENCODING_OPTIONS[OCCLUSION_TEXTURE] = {\n    useSRGB: false,\n    encodeUASTC: true,\n    qualityLevel: 10,\n    mipmaps: false\n};\n\n/**\n * A document model that represents the contents of an .XKT file.\n *\n * * An XKTModel contains {@link XKTTile}s, which spatially subdivide the model into axis-aligned, box-shaped regions.\n * * Each {@link XKTTile} contains {@link XKTEntity}s, which represent the objects within its region.\n * * Each {@link XKTEntity} has {@link XKTMesh}s, which each have a {@link XKTGeometry}. Each {@link XKTGeometry} can be shared by multiple {@link XKTMesh}s.\n * * Import models into an XKTModel using {@link parseGLTFJSONIntoXKTModel}, {@link parseIFCIntoXKTModel}, {@link parseCityJSONIntoXKTModel} etc.\n * * Build an XKTModel programmatically using {@link XKTModel#createGeometry}, {@link XKTModel#createMesh} and {@link XKTModel#createEntity}.\n * * Serialize an XKTModel to an ArrayBuffer using {@link writeXKTModelToArrayBuffer}.\n *\n * ## Usage\n *\n * See [main docs page](/docs/#javascript-api) for usage examples.\n *\n * @class XKTModel\n */\nclass XKTModel {\n\n    /**\n     * Constructs a new XKTModel.\n     *\n     * @param {*} [cfg] Configuration\n     * @param {Number} [cfg.edgeThreshold=10]\n     * @param {Number} [cfg.minTileSize=500]\n     */\n    constructor(cfg = {}) {\n\n        /**\n         * The model's ID, if available.\n         *\n         * Will be \"default\" by default.\n         *\n         * @type {String}\n         */\n        this.modelId = cfg.modelId || \"default\";\n\n        /**\n         * The project ID, if available.\n         *\n         * Will be an empty string by default.\n         *\n         * @type {String}\n         */\n        this.projectId = cfg.projectId || \"\";\n\n        /**\n         * The revision ID, if available.\n         *\n         * Will be an empty string by default.\n         *\n         * @type {String}\n         */\n        this.revisionId = cfg.revisionId || \"\";\n\n        /**\n         * The model author, if available.\n         *\n         * Will be an empty string by default.\n         *\n         * @property author\n         * @type {String}\n         */\n        this.author = cfg.author || \"\";\n\n        /**\n         * The date the model was created, if available.\n         *\n         * Will be an empty string by default.\n         *\n         * @property createdAt\n         * @type {String}\n         */\n        this.createdAt = cfg.createdAt || \"\";\n\n        /**\n         * The application that created the model, if available.\n         *\n         * Will be an empty string by default.\n         *\n         * @property creatingApplication\n         * @type {String}\n         */\n        this.creatingApplication = cfg.creatingApplication || \"\";\n\n        /**\n         * The model schema version, if available.\n         *\n         * In the case of IFC, this could be \"IFC2x3\" or \"IFC4\", for example.\n         *\n         * Will be an empty string by default.\n         *\n         * @property schema\n         * @type {String}\n         */\n        this.schema = cfg.schema || \"\";\n\n        /**\n         * The XKT format version.\n         *\n         * @property xktVersion;\n         * @type {number}\n         */\n        this.xktVersion = XKT_INFO.xktVersion;\n\n        /**\n         *\n         * @type {Number|number}\n         */\n        this.edgeThreshold = cfg.edgeThreshold || 10;\n\n        /**\n         * Minimum diagonal size of the boundary of an {@link XKTTile}.\n         *\n         * @type {Number|number}\n         */\n        this.minTileSize = cfg.minTileSize || 500;\n\n        /**\n         * Optional overall AABB that contains all the {@link XKTEntity}s we'll create in this model, if previously known.\n         *\n         * This is the AABB of a complete set of input files that are provided as a split-model set for conversion.\n         *\n         * This is used to help the {@link XKTTile.aabb}s within split models align neatly with each other, as we\n         * build them with a k-d tree in {@link XKTModel#finalize}.  Without this, the AABBs of the different parts\n         * tend to misalign slightly, resulting in excess number of {@link XKTTile}s, which degrades memory and rendering\n         * performance when the XKT is viewer in the xeokit Viewer.\n         */\n        this.modelAABB = cfg.modelAABB;\n\n        /**\n         * Map of {@link XKTPropertySet}s within this XKTModel, each mapped to {@link XKTPropertySet#propertySetId}.\n         *\n         * Created by {@link XKTModel#createPropertySet}.\n         *\n         * @type {{String:XKTPropertySet}}\n         */\n        this.propertySets = {};\n\n        /**\n         * {@link XKTPropertySet}s within this XKTModel.\n         *\n         * Each XKTPropertySet holds its position in this list in {@link XKTPropertySet#propertySetIndex}.\n         *\n         * Created by {@link XKTModel#finalize}.\n         *\n         * @type {XKTPropertySet[]}\n         */\n        this.propertySetsList = [];\n\n        /**\n         * Map of {@link XKTMetaObject}s within this XKTModel, each mapped to {@link XKTMetaObject#metaObjectId}.\n         *\n         * Created by {@link XKTModel#createMetaObject}.\n         *\n         * @type {{String:XKTMetaObject}}\n         */\n        this.metaObjects = {};\n\n        /**\n         * {@link XKTMetaObject}s within this XKTModel.\n         *\n         * Each XKTMetaObject holds its position in this list in {@link XKTMetaObject#metaObjectIndex}.\n         *\n         * Created by {@link XKTModel#finalize}.\n         *\n         * @type {XKTMetaObject[]}\n         */\n        this.metaObjectsList = [];\n\n        /**\n         * The positions of all shared {@link XKTGeometry}s are de-quantized using this singular\n         * de-quantization matrix.\n         *\n         * This de-quantization matrix is generated from the collective Local-space boundary of the\n         * positions of all shared {@link XKTGeometry}s.\n         *\n         * @type {Float32Array}\n         */\n        this.reusedGeometriesDecodeMatrix = new Float32Array(16);\n\n        /**\n         * Map of {@link XKTGeometry}s within this XKTModel, each mapped to {@link XKTGeometry#geometryId}.\n         *\n         * Created by {@link XKTModel#createGeometry}.\n         *\n         * @type {{Number:XKTGeometry}}\n         */\n        this.geometries = {};\n\n        /**\n         * List of {@link XKTGeometry}s within this XKTModel, in the order they were created.\n         *\n         * Each XKTGeometry holds its position in this list in {@link XKTGeometry#geometryIndex}.\n         *\n         * Created by {@link XKTModel#finalize}.\n         *\n         * @type {XKTGeometry[]}\n         */\n        this.geometriesList = [];\n\n        /**\n         * Map of {@link XKTTexture}s within this XKTModel, each mapped to {@link XKTTexture#textureId}.\n         *\n         * Created by {@link XKTModel#createTexture}.\n         *\n         * @type {{Number:XKTTexture}}\n         */\n        this.textures = {};\n\n        /**\n         * List of {@link XKTTexture}s within this XKTModel, in the order they were created.\n         *\n         * Each XKTTexture holds its position in this list in {@link XKTTexture#textureIndex}.\n         *\n         * Created by {@link XKTModel#finalize}.\n         *\n         * @type {XKTTexture[]}\n         */\n        this.texturesList = [];\n\n        /**\n         * Map of {@link XKTTextureSet}s within this XKTModel, each mapped to {@link XKTTextureSet#textureSetId}.\n         *\n         * Created by {@link XKTModel#createTextureSet}.\n         *\n         * @type {{Number:XKTTextureSet}}\n         */\n        this.textureSets = {};\n\n        /**\n         * List of {@link XKTTextureSet}s within this XKTModel, in the order they were created.\n         *\n         * Each XKTTextureSet holds its position in this list in {@link XKTTextureSet#textureSetIndex}.\n         *\n         * Created by {@link XKTModel#finalize}.\n         *\n         * @type {XKTTextureSet[]}\n         */\n        this.textureSetsList = [];\n\n        /**\n         * Map of {@link XKTMesh}s within this XKTModel, each mapped to {@link XKTMesh#meshId}.\n         *\n         * Created by {@link XKTModel#createMesh}.\n         *\n         * @type {{Number:XKTMesh}}\n         */\n        this.meshes = {};\n\n        /**\n         * List of {@link XKTMesh}s within this XKTModel, in the order they were created.\n         *\n         * Each XKTMesh holds its position in this list in {@link XKTMesh#meshIndex}.\n         *\n         * Created by {@link XKTModel#finalize}.\n         *\n         * @type {XKTMesh[]}\n         */\n        this.meshesList = [];\n\n        /**\n         * Map of {@link XKTEntity}s within this XKTModel, each mapped to {@link XKTEntity#entityId}.\n         *\n         * Created by {@link XKTModel#createEntity}.\n         *\n         * @type {{String:XKTEntity}}\n         */\n        this.entities = {};\n\n        /**\n         * {@link XKTEntity}s within this XKTModel.\n         *\n         * Each XKTEntity holds its position in this list in {@link XKTEntity#entityIndex}.\n         *\n         * Created by {@link XKTModel#finalize}.\n         *\n         * @type {XKTEntity[]}\n         */\n        this.entitiesList = [];\n\n        /**\n         * {@link XKTTile}s within this XKTModel.\n         *\n         * Created by {@link XKTModel#finalize}.\n         *\n         * @type {XKTTile[]}\n         */\n        this.tilesList = [];\n\n        /**\n         * The axis-aligned 3D World-space boundary of this XKTModel.\n         *\n         * Created by {@link XKTModel#finalize}.\n         *\n         * @type {Float64Array}\n         */\n        this.aabb = math.AABB3();\n\n        /**\n         * Indicates if this XKTModel has been finalized.\n         *\n         * Set ````true```` by {@link XKTModel#finalize}.\n         *\n         * @type {boolean}\n         */\n        this.finalized = false;\n    }\n\n    /**\n     * Creates an {@link XKTPropertySet} within this XKTModel.\n     *\n     * Logs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).\n     *\n     * @param {*} params Method parameters.\n     * @param {String} params.propertySetId Unique ID for the {@link XKTPropertySet}.\n     * @param {String} [params.propertySetType=\"default\"] A meta type for the {@link XKTPropertySet}.\n     * @param {String} [params.propertySetName] Human-readable name for the {@link XKTPropertySet}. Defaults to the ````propertySetId```` parameter.\n     * @param {String[]} params.properties Properties for the {@link XKTPropertySet}.\n     * @returns {XKTPropertySet} The new {@link XKTPropertySet}.\n     */\n    createPropertySet(params) {\n\n        if (!params) {\n            throw \"[XKTModel.createPropertySet] Parameters expected: params\";\n        }\n\n        if (params.propertySetId === null || params.propertySetId === undefined) {\n            throw \"[XKTModel.createPropertySet] Parameter expected: params.propertySetId\";\n        }\n\n        if (params.properties === null || params.properties === undefined) {\n            throw \"[XKTModel.createPropertySet] Parameter expected: params.properties\";\n        }\n\n        if (this.finalized) {\n            console.error(\"XKTModel has been finalized, can't add more property sets\");\n            return;\n        }\n\n        if (this.propertySets[params.propertySetId]) {\n            //          console.error(\"XKTPropertySet already exists with this ID: \" + params.propertySetId);\n            return;\n        }\n\n        const propertySetId = params.propertySetId;\n        const propertySetType = params.propertySetType || \"Default\";\n        const propertySetName = params.propertySetName || params.propertySetId;\n        const properties = params.properties || [];\n\n        const propertySet = new XKTPropertySet(propertySetId, propertySetType, propertySetName, properties);\n\n        this.propertySets[propertySetId] = propertySet;\n        this.propertySetsList.push(propertySet);\n\n        return propertySet;\n    }\n\n    /**\n     * Creates an {@link XKTMetaObject} within this XKTModel.\n     *\n     * Logs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).\n     *\n     * @param {*} params Method parameters.\n     * @param {String} params.metaObjectId Unique ID for the {@link XKTMetaObject}.\n     * @param {String} params.propertySetIds ID of one or more property sets that contains additional metadata about\n     * this {@link XKTMetaObject}. The property sets could be stored externally (ie not managed at all by the XKT file),\n     * or could be {@link XKTPropertySet}s within {@link XKTModel#propertySets}.\n     * @param {String} [params.metaObjectType=\"default\"] A meta type for the {@link XKTMetaObject}. Can be anything,\n     * but is usually an IFC type, such as \"IfcSite\" or \"IfcWall\".\n     * @param {String} [params.metaObjectName] Human-readable name for the {@link XKTMetaObject}. Defaults to the ````metaObjectId```` parameter.\n     * @param {String} [params.parentMetaObjectId] ID of the parent {@link XKTMetaObject}, if any. Defaults to the ````metaObjectId```` parameter.\n     * @returns {XKTMetaObject} The new {@link XKTMetaObject}.\n     */\n    createMetaObject(params) {\n\n        if (!params) {\n            throw \"[XKTModel.createMetaObject] Parameters expected: params\";\n        }\n\n        if (params.metaObjectId === null || params.metaObjectId === undefined) {\n            throw \"[XKTModel.createMetaObject] Parameter expected: params.metaObjectId\";\n        }\n\n        if (this.finalized) {\n            console.error(\"XKTModel has been finalized, can't add more meta objects\");\n            return;\n        }\n\n        if (this.metaObjects[params.metaObjectId]) {\n            //          console.error(\"XKTMetaObject already exists with this ID: \" + params.metaObjectId);\n            return;\n        }\n\n        const metaObjectId = params.metaObjectId;\n        const propertySetIds = params.propertySetIds;\n        const metaObjectType = params.metaObjectType || \"Default\";\n        const metaObjectName = params.metaObjectName || params.metaObjectId;\n        const parentMetaObjectId = params.parentMetaObjectId;\n\n        const metaObject = new XKTMetaObject(metaObjectId, propertySetIds, metaObjectType, metaObjectName, parentMetaObjectId);\n\n        this.metaObjects[metaObjectId] = metaObject;\n        this.metaObjectsList.push(metaObject);\n\n        if (!parentMetaObjectId) {\n            if (!this._rootMetaObject) {\n                this._rootMetaObject = metaObject;\n            }\n        }\n\n        return metaObject;\n    }\n\n    /**\n     * Creates an {@link XKTTexture} within this XKTModel.\n     *\n     * Registers the new {@link XKTTexture} in {@link XKTModel#textures} and {@link XKTModel#texturesList}.\n     *\n     * Logs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).\n     *\n     * @param {*} params Method parameters.\n     * @param {Number} params.textureId Unique ID for the {@link XKTTexture}.\n     * @param {String} [params.src] Source of an image file for the texture.\n     * @param {Buffer} [params.imageData] Image data for the texture.\n     * @param {Number} [params.mediaType] Media type (ie. MIME type) of ````imageData````. Supported values are {@link GIFMediaType}, {@link PNGMediaType} and {@link JPEGMediaType}.\n     * @param {Number} [params.width] Texture width, used with ````imageData````. Ignored for compressed textures.\n     * @param {Number} [params.height] Texture height, used with ````imageData````. Ignored for compressed textures.\n     * @param {Boolean} [params.compressed=true] Whether to compress the texture.\n     * @param {Number} [params.minFilter=LinearMipMapNearestFilter] How the texture is sampled when a texel covers less than one pixel. Supported\n     * values are {@link LinearMipmapLinearFilter}, {@link LinearMipMapNearestFilter}, {@link NearestMipMapNearestFilter},\n     * {@link NearestMipMapLinearFilter} and {@link LinearMipMapLinearFilter}. Ignored for compressed textures.\n     * @param {Number} [params.magFilter=LinearMipMapNearestFilter] How the texture is sampled when a texel covers more than one pixel. Supported values\n     * are {@link LinearFilter} and {@link NearestFilter}. Ignored for compressed textures.\n     * @param {Number} [params.wrapS=RepeatWrapping] Wrap parameter for texture coordinate *S*. Supported values are {@link ClampToEdgeWrapping},\n     * {@link MirroredRepeatWrapping} and {@link RepeatWrapping}. Ignored for compressed textures.\n     * @param {Number} [params.wrapT=RepeatWrapping] Wrap parameter for texture coordinate *T*. Supported values are {@link ClampToEdgeWrapping},\n     * {@link MirroredRepeatWrapping} and {@link RepeatWrapping}. Ignored for compressed textures.\n     * {@param {Number} [params.wrapR=RepeatWrapping] Wrap parameter for texture coordinate *R*. Supported values are {@link ClampToEdgeWrapping},\n     * {@link MirroredRepeatWrapping} and {@link RepeatWrapping}. Ignored for compressed textures.\n     * @returns {XKTTexture} The new {@link XKTTexture}.\n     */\n    createTexture(params) {\n\n        if (!params) {\n            throw \"[XKTModel.createTexture] Parameters expected: params\";\n        }\n\n        if (params.textureId === null || params.textureId === undefined) {\n            throw \"[XKTModel.createTexture] Parameter expected: params.textureId\";\n        }\n\n        if (!params.imageData && !params.src) {\n            throw \"[XKTModel.createTexture] Parameter expected: params.imageData or params.src\";\n        }\n\n        if (this.finalized) {\n            console.error(\"XKTModel has been finalized, can't add more textures\");\n            return;\n        }\n\n        if (this.textures[params.textureId]) {\n            console.error(\"XKTTexture already exists with this ID: \" + params.textureId);\n            return;\n        }\n\n        if (params.src) {\n            const fileExt = params.src.split('.').pop();\n            if (fileExt !== \"jpg\" && fileExt !== \"jpeg\" && fileExt !== \"png\") {\n                console.error(`XKTModel does not support image files with extension '${fileExt}' - won't create texture '${params.textureId}`);\n                return;\n            }\n        }\n\n        const textureId = params.textureId;\n\n        const texture = new XKTTexture({\n            textureId,\n            imageData: params.imageData,\n            mediaType: params.mediaType,\n            minFilter: params.minFilter,\n            magFilter: params.magFilter,\n            wrapS: params.wrapS,\n            wrapT: params.wrapT,\n            wrapR: params.wrapR,\n            width: params.width,\n            height: params.height,\n            compressed: (params.compressed !== false),\n            src: params.src\n        });\n\n        this.textures[textureId] = texture;\n        this.texturesList.push(texture);\n\n        return texture;\n    }\n\n    /**\n     * Creates an {@link XKTTextureSet} within this XKTModel.\n     *\n     * Registers the new {@link XKTTextureSet} in {@link XKTModel#textureSets} and {@link XKTModel#.textureSetsList}.\n     *\n     * Logs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).\n     *\n     * @param {*} params Method parameters.\n     * @param {Number} params.textureSetId Unique ID for the {@link XKTTextureSet}.\n     * @param {*} [params.colorTextureId] ID of *RGBA* base color {@link XKTTexture}, with color in *RGB* and alpha in *A*.\n     * @param {*} [params.metallicRoughnessTextureId] ID of *RGBA* metal-roughness {@link XKTTexture}, with the metallic factor in *R*, and roughness factor in *G*.\n     * @param {*} [params.normalsTextureId] ID of *RGBA* normal {@link XKTTexture}, with normal map vectors in *RGB*.\n     * @param {*} [params.emissiveTextureId] ID of *RGBA* emissive {@link XKTTexture}, with emissive color in *RGB*.\n     * @param {*} [params.occlusionTextureId] ID of *RGBA* occlusion {@link XKTTexture}, with occlusion factor in *R*.\n     * @returns {XKTTextureSet} The new {@link XKTTextureSet}.\n     */\n    createTextureSet(params) {\n\n        if (!params) {\n            throw \"[XKTModel.createTextureSet] Parameters expected: params\";\n        }\n\n        if (params.textureSetId === null || params.textureSetId === undefined) {\n            throw \"[XKTModel.createTextureSet] Parameter expected: params.textureSetId\";\n        }\n\n        if (this.finalized) {\n            console.error(\"XKTModel has been finalized, can't add more textureSets\");\n            return;\n        }\n\n        if (this.textureSets[params.textureSetId]) {\n            console.error(\"XKTTextureSet already exists with this ID: \" + params.textureSetId);\n            return;\n        }\n\n        let colorTexture;\n        if (params.colorTextureId !== undefined && params.colorTextureId !== null) {\n            colorTexture = this.textures[params.colorTextureId];\n            if (!colorTexture) {\n                console.error(`Texture not found: ${params.colorTextureId} - ensure that you create it first with createTexture()`);\n                return;\n            }\n            colorTexture.channel = COLOR_TEXTURE;\n        }\n\n        let metallicRoughnessTexture;\n        if (params.metallicRoughnessTextureId !== undefined && params.metallicRoughnessTextureId !== null) {\n            metallicRoughnessTexture = this.textures[params.metallicRoughnessTextureId];\n            if (!metallicRoughnessTexture) {\n                console.error(`Texture not found: ${params.metallicRoughnessTextureId} - ensure that you create it first with createTexture()`);\n                return;\n            }\n            metallicRoughnessTexture.channel = METALLIC_ROUGHNESS_TEXTURE;\n        }\n\n        let normalsTexture;\n        if (params.normalsTextureId !== undefined && params.normalsTextureId !== null) {\n            normalsTexture = this.textures[params.normalsTextureId];\n            if (!normalsTexture) {\n                console.error(`Texture not found: ${params.normalsTextureId} - ensure that you create it first with createTexture()`);\n                return;\n            }\n            normalsTexture.channel = NORMALS_TEXTURE;\n        }\n\n        let emissiveTexture;\n        if (params.emissiveTextureId !== undefined && params.emissiveTextureId !== null) {\n            emissiveTexture = this.textures[params.emissiveTextureId];\n            if (!emissiveTexture) {\n                console.error(`Texture not found: ${params.emissiveTextureId} - ensure that you create it first with createTexture()`);\n                return;\n            }\n            emissiveTexture.channel = EMISSIVE_TEXTURE;\n        }\n\n        let occlusionTexture;\n        if (params.occlusionTextureId !== undefined && params.occlusionTextureId !== null) {\n            occlusionTexture = this.textures[params.occlusionTextureId];\n            if (!occlusionTexture) {\n                console.error(`Texture not found: ${params.occlusionTextureId} - ensure that you create it first with createTexture()`);\n                return;\n            }\n            occlusionTexture.channel = OCCLUSION_TEXTURE;\n        }\n\n        const textureSet = new XKTTextureSet({\n            textureSetId: params.textureSetId,\n            textureSetIndex: this.textureSetsList.length,\n            colorTexture,\n            metallicRoughnessTexture,\n            normalsTexture,\n            emissiveTexture,\n            occlusionTexture\n        });\n\n        this.textureSets[params.textureSetId] = textureSet;\n        this.textureSetsList.push(textureSet);\n\n        return textureSet;\n    }\n\n    /**\n     * Creates an {@link XKTGeometry} within this XKTModel.\n     *\n     * Registers the new {@link XKTGeometry} in {@link XKTModel#geometries} and {@link XKTModel#geometriesList}.\n     *\n     * Logs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).\n     *\n     * @param {*} params Method parameters.\n     * @param {Number} params.geometryId Unique ID for the {@link XKTGeometry}.\n     * @param {String} params.primitiveType The type of {@link XKTGeometry}: \"triangles\", \"lines\" or \"points\".\n     * @param {Float64Array} params.positions Floating-point Local-space vertex positions for the {@link XKTGeometry}. Required for all primitive types.\n     * @param {Number[]} [params.normals] Floating-point vertex normals for the {@link XKTGeometry}. Only used with triangles primitives. Ignored for points and lines.\n     * @param {Number[]} [params.colors] Floating-point RGBA vertex colors for the {@link XKTGeometry}. Required for points primitives. Ignored for lines and triangles.\n     * @param {Number[]} [params.colorsCompressed] Integer RGBA vertex colors for the {@link XKTGeometry}. Required for points primitives. Ignored for lines and triangles.\n     * @param {Number[]} [params.uvs] Floating-point vertex UV coordinates for the {@link XKTGeometry}. Alias for ````uv````.\n     * @param {Number[]} [params.uv] Floating-point vertex UV coordinates for the {@link XKTGeometry}. Alias for ````uvs````.\n     * @param {Number[]} [params.colorsCompressed] Integer RGBA vertex colors for the {@link XKTGeometry}. Required for points primitives. Ignored for lines and triangles.\n     * @param {Uint32Array} [params.indices] Indices for the {@link XKTGeometry}. Required for triangles and lines primitives. Ignored for points.\n     * @param {Number} [params.edgeThreshold=10]\n     * @returns {XKTGeometry} The new {@link XKTGeometry}.\n     */\n    createGeometry(params) {\n\n        if (!params) {\n            throw \"[XKTModel.createGeometry] Parameters expected: params\";\n        }\n\n        if (params.geometryId === null || params.geometryId === undefined) {\n            throw \"[XKTModel.createGeometry] Parameter expected: params.geometryId\";\n        }\n\n        if (!params.primitiveType) {\n            throw \"[XKTModel.createGeometry] Parameter expected: params.primitiveType\";\n        }\n\n        if (!params.positions) {\n            throw \"[XKTModel.createGeometry] Parameter expected: params.positions\";\n        }\n\n        const triangles = params.primitiveType === \"triangles\";\n        const points = params.primitiveType === \"points\";\n        const lines = params.primitiveType === \"lines\";\n        const line_strip = params.primitiveType === \"line-strip\";\n        const line_loop = params.primitiveType === \"line-loop\";\n        const triangle_strip = params.primitiveType === \"triangle-strip\";\n        const triangle_fan = params.primitiveType === \"triangle-fan\";\n\n        if (!triangles && !points && !lines && !line_strip && !line_loop) {\n            throw \"[XKTModel.createGeometry] Unsupported value for params.primitiveType: \"\n            + params.primitiveType\n            + \"' - supported values are 'triangles', 'points', 'lines', 'line-strip', 'triangle-strip' and 'triangle-fan\";\n        }\n\n        if (triangles) {\n            if (!params.indices) {\n                params.indices = this._createDefaultIndices()\n                throw \"[XKTModel.createGeometry] Parameter expected for 'triangles' primitive: params.indices\";\n            }\n        }\n\n        if (points) {\n            if (!params.colors && !params.colorsCompressed) {\n                console.error(\"[XKTModel.createGeometry] Parameter expected for 'points' primitive: params.colors or params.colorsCompressed\");\n                return;\n            }\n        }\n\n        if (lines) {\n            if (!params.indices) {\n                throw \"[XKTModel.createGeometry] Parameter expected for 'lines' primitive: params.indices\";\n            }\n        }\n\n        if (this.finalized) {\n            console.error(\"XKTModel has been finalized, can't add more geometries\");\n            return;\n        }\n\n        if (this.geometries[params.geometryId]) {\n            console.error(\"XKTGeometry already exists with this ID: \" + params.geometryId);\n            return;\n        }\n\n        const geometryId = params.geometryId;\n        const primitiveType = params.primitiveType;\n        const positions = new Float64Array(params.positions); // May modify in #finalize\n\n        const xktGeometryCfg = {\n            geometryId: geometryId,\n            geometryIndex: this.geometriesList.length,\n            primitiveType: primitiveType,\n            positions: positions,\n            uvs: params.uvs || params.uv\n        }\n\n        if (triangles) {\n            if (params.normals) {\n                xktGeometryCfg.normals = new Float32Array(params.normals);\n            }\n            if (params.indices) {\n                xktGeometryCfg.indices = params.indices;\n            } else {\n                xktGeometryCfg.indices = this._createDefaultIndices(positions.length / 3);\n            }\n        }\n\n        if (points) {\n            if (params.colorsCompressed) {\n                xktGeometryCfg.colorsCompressed = new Uint8Array(params.colorsCompressed);\n\n            } else {\n                const colors = params.colors;\n                const colorsCompressed = new Uint8Array(colors.length);\n                for (let i = 0, len = colors.length; i < len; i++) {\n                    colorsCompressed[i] = Math.floor(colors[i] * 255);\n                }\n                xktGeometryCfg.colorsCompressed = colorsCompressed;\n            }\n        }\n\n        if (lines) {\n            xktGeometryCfg.indices = params.indices;\n        }\n\n        if (triangles) {\n\n            if (!params.normals && !params.uv && !params.uvs) {\n\n                // Building models often duplicate positions to allow face-aligned vertex normals; when we're not\n                // providing normals for a geometry, it becomes possible to merge duplicate vertex positions within it.\n\n                // TODO: Make vertex merging also merge normals?\n\n                const mergedPositions = [];\n                const mergedIndices = [];\n                mergeVertices(xktGeometryCfg.positions, xktGeometryCfg.indices, mergedPositions, mergedIndices);\n                xktGeometryCfg.positions = new Float64Array(mergedPositions);\n                xktGeometryCfg.indices = mergedIndices;\n            }\n\n            xktGeometryCfg.edgeIndices = buildEdgeIndices(xktGeometryCfg.positions, xktGeometryCfg.indices, null, params.edgeThreshold || this.edgeThreshold || 10);\n        }\n\n        const geometry = new XKTGeometry(xktGeometryCfg);\n\n        this.geometries[geometryId] = geometry;\n        this.geometriesList.push(geometry);\n\n        return geometry;\n    }\n\n    _createDefaultIndices(numIndices) {\n        const indices = [];\n        for (let i = 0; i < numIndices; i++) {\n            indices.push(i);\n        }\n        return indices;\n    }\n\n    /**\n     * Creates an {@link XKTMesh} within this XKTModel.\n     *\n     * An {@link XKTMesh} can be owned by one {@link XKTEntity}, which can own multiple {@link XKTMesh}es.\n     *\n     * Registers the new {@link XKTMesh} in {@link XKTModel#meshes} and {@link XKTModel#meshesList}.\n     *\n     * @param {*} params Method parameters.\n     * @param {Number} params.meshId Unique ID for the {@link XKTMesh}.\n     * @param {Number} params.geometryId ID of an existing {@link XKTGeometry} in {@link XKTModel#geometries}.\n     * @param {Number} [params.textureSetId] Unique ID of an {@link XKTTextureSet} in {@link XKTModel#textureSets}.\n     * @param {Float32Array} params.color RGB color for the {@link XKTMesh}, with each color component in range [0..1].\n     * @param {Number} [params.metallic=0] How metallic the {@link XKTMesh} is, in range [0..1]. A value of ````0```` indicates fully dielectric material, while ````1```` indicates fully metallic.\n     * @param {Number} [params.roughness=1] How rough the {@link XKTMesh} is, in range [0..1]. A value of ````0```` indicates fully smooth, while ````1```` indicates fully rough.\n     * @param {Number} params.opacity Opacity factor for the {@link XKTMesh}, in range [0..1].\n     * @param {Float64Array} [params.matrix] Modeling matrix for the {@link XKTMesh}. Overrides ````position````, ````scale```` and ````rotation```` parameters.\n     * @param {Number[]} [params.position=[0,0,0]] Position of the {@link XKTMesh}. Overridden by the ````matrix```` parameter.\n     * @param {Number[]} [params.scale=[1,1,1]] Scale of the {@link XKTMesh}. Overridden by the ````matrix```` parameter.\n     * @param {Number[]} [params.rotation=[0,0,0]] Rotation of the {@link XKTMesh} as Euler angles given in degrees, for each of the X, Y and Z axis. Overridden by the ````matrix```` parameter.\n     * @returns {XKTMesh} The new {@link XKTMesh}.\n     */\n    createMesh(params) {\n\n        if (params.meshId === null || params.meshId === undefined) {\n            throw \"[XKTModel.createMesh] Parameter expected: params.meshId\";\n        }\n\n        if (params.geometryId === null || params.geometryId === undefined) {\n            throw \"[XKTModel.createMesh] Parameter expected: params.geometryId\";\n        }\n\n        if (this.finalized) {\n            throw \"[XKTModel.createMesh] XKTModel has been finalized, can't add more meshes\";\n        }\n\n        if (this.meshes[params.meshId]) {\n            console.error(\"XKTMesh already exists with this ID: \" + params.meshId);\n            return;\n        }\n\n        const geometry = this.geometries[params.geometryId];\n\n        if (!geometry) {\n            console.error(\"XKTGeometry not found: \" + params.geometryId);\n            return;\n        }\n\n        geometry.numInstances++;\n\n        let textureSet = null;\n        if (params.textureSetId) {\n            textureSet = this.textureSets[params.textureSetId];\n            if (!textureSet) {\n                console.error(\"XKTTextureSet not found: \" + params.textureSetId);\n                return;\n            }\n            textureSet.numInstances++;\n        }\n\n        let matrix = params.matrix;\n\n        if (!matrix) {\n\n            const position = params.position;\n            const scale = params.scale;\n            const rotation = params.rotation;\n\n            if (position || scale || rotation) {\n                matrix = math.identityMat4();\n                const quaternion = math.eulerToQuaternion(rotation || [0, 0, 0], \"XYZ\", math.identityQuaternion());\n                math.composeMat4(position || [0, 0, 0], quaternion, scale || [1, 1, 1], matrix)\n\n            } else {\n                matrix = math.identityMat4();\n            }\n        }\n\n        const meshIndex = this.meshesList.length;\n\n        const mesh = new XKTMesh({\n            meshId: params.meshId,\n            meshIndex,\n            matrix,\n            geometry,\n            color: params.color,\n            metallic: params.metallic,\n            roughness: params.roughness,\n            opacity: params.opacity,\n            textureSet\n        });\n\n        this.meshes[mesh.meshId] = mesh;\n        this.meshesList.push(mesh);\n\n        return mesh;\n    }\n\n    /**\n     * Creates an {@link XKTEntity} within this XKTModel.\n     *\n     * Registers the new {@link XKTEntity} in {@link XKTModel#entities} and {@link XKTModel#entitiesList}.\n     *\n     * Logs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).\n     *\n     * @param {*} params Method parameters.\n     * @param {String} params.entityId Unique ID for the {@link XKTEntity}.\n     * @param {String[]} params.meshIds IDs of {@link XKTMesh}es used by the {@link XKTEntity}. Note that each {@link XKTMesh} can only be used by one {@link XKTEntity}.\n     * @returns {XKTEntity} The new {@link XKTEntity}.\n     */\n    createEntity(params) {\n\n        if (!params) {\n            throw \"[XKTModel.createEntity] Parameters expected: params\";\n        }\n\n        if (params.entityId === null || params.entityId === undefined) {\n            throw \"[XKTModel.createEntity] Parameter expected: params.entityId\";\n        }\n\n        if (!params.meshIds) {\n            throw \"[XKTModel.createEntity] Parameter expected: params.meshIds\";\n        }\n\n        if (this.finalized) {\n            console.error(\"XKTModel has been finalized, can't add more entities\");\n            return;\n        }\n\n        if (params.meshIds.length === 0) {\n            console.warn(\"XKTEntity has no meshes - won't create: \" + params.entityId);\n            return;\n        }\n\n        let entityId = params.entityId;\n\n        if (this.entities[entityId]) {\n            while (this.entities[entityId]) {\n                entityId = math.createUUID();\n            }\n            console.error(\"XKTEntity already exists with this ID: \" + params.entityId + \" - substituting random ID instead: \" + entityId);\n        }\n\n        const meshIds = params.meshIds;\n        const meshes = [];\n\n        for (let meshIdIdx = 0, meshIdLen = meshIds.length; meshIdIdx < meshIdLen; meshIdIdx++) {\n\n            const meshId = meshIds[meshIdIdx];\n            const mesh = this.meshes[meshId];\n\n            if (!mesh) {\n                console.error(\"XKTMesh found: \" + meshId);\n                continue;\n            }\n\n            if (mesh.entity) {\n                console.error(\"XKTMesh \" + meshId + \" already used by XKTEntity \" + mesh.entity.entityId);\n                continue;\n            }\n\n            meshes.push(mesh);\n        }\n\n        const entity = new XKTEntity(entityId, meshes);\n\n        for (let i = 0, len = meshes.length; i < len; i++) {\n            const mesh = meshes[i];\n            mesh.entity = entity;\n        }\n\n        this.entities[entityId] = entity;\n        this.entitiesList.push(entity);\n\n        return entity;\n    }\n\n    /**\n     * Creates a default {@link XKTMetaObject} for each {@link XKTEntity} that does not already have one.\n     */\n    createDefaultMetaObjects() {\n\n        for (let i = 0, len = this.entitiesList.length; i < len; i++) {\n\n            const entity = this.entitiesList[i];\n            const metaObjectId = entity.entityId;\n            const metaObject = this.metaObjects[metaObjectId];\n\n            if (!metaObject) {\n\n                if (!this._rootMetaObject) {\n                    this._rootMetaObject = this.createMetaObject({\n                        metaObjectId: this.modelId,\n                        metaObjectType: \"Default\",\n                        metaObjectName: this.modelId\n                    });\n                }\n\n                this.createMetaObject({\n                    metaObjectId: metaObjectId,\n                    metaObjectType: \"Default\",\n                    metaObjectName: \"\" + metaObjectId,\n                    parentMetaObjectId: this._rootMetaObject.metaObjectId\n                });\n            }\n        }\n    }\n\n    /**\n     * Finalizes this XKTModel.\n     *\n     * After finalizing, we may then serialize the model to an array buffer using {@link writeXKTModelToArrayBuffer}.\n     *\n     * Logs error and does nothing if this XKTModel has already been finalized.\n     *\n     * Internally, this method:\n     *\n     * * for each {@link XKTEntity} that doesn't already have a {@link XKTMetaObject}, creates one with {@link XKTMetaObject#metaObjectType} set to \"default\"\n     * * sets each {@link XKTEntity}'s {@link XKTEntity#hasReusedGeometries} true if it shares its {@link XKTGeometry}s with other {@link XKTEntity}s,\n     * * creates each {@link XKTEntity}'s {@link XKTEntity#aabb},\n     * * creates {@link XKTTile}s in {@link XKTModel#tilesList}, and\n     * * sets {@link XKTModel#finalized} ````true````.\n     */\n    async finalize() {\n\n        if (this.finalized) {\n            console.log(\"XKTModel already finalized\");\n            return;\n        }\n\n        this._removeUnusedTextures();\n\n        await this._compressTextures();\n\n        this._bakeSingleUseGeometryPositions();\n\n        this._bakeAndOctEncodeNormals();\n\n        this._createEntityAABBs();\n\n        const rootKDNode = this._createKDTree();\n\n        this.entitiesList = [];\n\n        this._createTilesFromKDTree(rootKDNode);\n\n        this._createReusedGeometriesDecodeMatrix();\n\n        this._flagSolidGeometries();\n\n        this.aabb.set(rootKDNode.aabb);\n\n        this.finalized = true;\n    }\n\n    _removeUnusedTextures() {\n        let texturesList = [];\n        const textures = {};\n        for (let i = 0, leni = this.texturesList.length; i < leni; i++) {\n            const texture = this.texturesList[i];\n            if (texture.channel !== null) {\n                texture.textureIndex = texturesList.length;\n                texturesList.push(texture);\n                textures[texture.textureId] = texture;\n            }\n        }\n        this.texturesList = texturesList;\n        this.textures = textures;\n    }\n\n    _compressTextures() {\n        let countTextures = this.texturesList.length;\n        return new Promise((resolve) => {\n            if (countTextures === 0) {\n                resolve();\n                return;\n            }\n            for (let i = 0, leni = this.texturesList.length; i < leni; i++) {\n                const texture = this.texturesList[i];\n                const encodingOptions = TEXTURE_ENCODING_OPTIONS[texture.channel] || {};\n\n                if (texture.src) {\n\n                    // XKTTexture created with XKTModel#createTexture({ src: ... })\n\n                    const src = texture.src;\n                    const fileExt = src.split('.').pop();\n                    switch (fileExt) {\n                        case \"jpeg\":\n                        case \"jpg\":\n                        case \"png\":\n                            load(src, ImageLoader, {\n                                image: {\n                                    type: \"data\"\n                                }\n                            }).then((imageData) => {\n                                if (texture.compressed) {\n                                    encode(imageData, KTX2BasisWriter, encodingOptions).then((encodedData) => {\n                                        const encodedImageData = new Uint8Array(encodedData);\n                                        texture.imageData = encodedImageData;\n                                        if (--countTextures <= 0) {\n                                            resolve();\n                                        }\n                                    }).catch((err) => {\n                                        console.error(\"[XKTModel.finalize] Failed to encode image: \" + err);\n                                        if (--countTextures <= 0) {\n                                            resolve();\n                                        }\n                                    });\n                                } else {\n                                    texture.imageData = new Uint8Array(1);\n                                    if (--countTextures <= 0) {\n                                        resolve();\n                                    }\n                                }\n                            }).catch((err) => {\n                                console.error(\"[XKTModel.finalize] Failed to load image: \" + err);\n                                if (--countTextures <= 0) {\n                                    resolve();\n                                }\n                            });\n                            break;\n                        default:\n                            if (--countTextures <= 0) {\n                                resolve();\n                            }\n                            break;\n                    }\n                }\n\n                if (texture.imageData) {\n\n                    // XKTTexture created with XKTModel#createTexture({ imageData: ... })\n\n                    if (texture.compressed) {\n                        encode(texture.imageData, KTX2BasisWriter, encodingOptions)\n                            .then((encodedImageData) => {\n                                texture.imageData = new Uint8Array(encodedImageData);\n                                if (--countTextures <= 0) {\n                                    resolve();\n                                }\n                            }).catch((err) => {\n                            console.error(\"[XKTModel.finalize] Failed to encode image: \" + err);\n                            if (--countTextures <= 0) {\n                                resolve();\n                            }\n                        });\n                    } else {\n                        texture.imageData = new Uint8Array(1);\n                        if (--countTextures <= 0) {\n                            resolve();\n                        }\n                    }\n                }\n            }\n        });\n    }\n\n    _bakeSingleUseGeometryPositions() {\n\n        for (let j = 0, lenj = this.meshesList.length; j < lenj; j++) {\n\n            const mesh = this.meshesList[j];\n\n            const geometry = mesh.geometry;\n\n            if (geometry.numInstances === 1) {\n\n                const matrix = mesh.matrix;\n\n                if (matrix && (!math.isIdentityMat4(matrix))) {\n\n                    const positions = geometry.positions;\n\n                    for (let i = 0, len = positions.length; i < len; i += 3) {\n\n                        tempVec4a[0] = positions[i + 0];\n                        tempVec4a[1] = positions[i + 1];\n                        tempVec4a[2] = positions[i + 2];\n                        tempVec4a[3] = 1;\n\n                        math.transformPoint4(matrix, tempVec4a, tempVec4b);\n\n                        positions[i + 0] = tempVec4b[0];\n                        positions[i + 1] = tempVec4b[1];\n                        positions[i + 2] = tempVec4b[2];\n                    }\n                }\n            }\n        }\n    }\n\n    _bakeAndOctEncodeNormals() {\n\n        for (let i = 0, len = this.meshesList.length; i < len; i++) {\n\n            const mesh = this.meshesList[i];\n            const geometry = mesh.geometry;\n\n            if (geometry.normals && !geometry.normalsOctEncoded) {\n\n                geometry.normalsOctEncoded = new Int8Array(geometry.normals.length);\n\n                if (geometry.numInstances > 1) {\n                    geometryCompression.octEncodeNormals(geometry.normals, geometry.normals.length, geometry.normalsOctEncoded, 0);\n\n                } else {\n                    const modelNormalMatrix = math.inverseMat4(math.transposeMat4(mesh.matrix, tempMat4), tempMat4b);\n                    geometryCompression.transformAndOctEncodeNormals(modelNormalMatrix, geometry.normals, geometry.normals.length, geometry.normalsOctEncoded, 0);\n                }\n            }\n        }\n    }\n\n    _createEntityAABBs() {\n\n        for (let i = 0, len = this.entitiesList.length; i < len; i++) {\n\n            const entity = this.entitiesList[i];\n            const entityAABB = entity.aabb;\n            const meshes = entity.meshes;\n\n            math.collapseAABB3(entityAABB);\n\n            for (let j = 0, lenj = meshes.length; j < lenj; j++) {\n\n                const mesh = meshes[j];\n                const geometry = mesh.geometry;\n                const matrix = mesh.matrix;\n\n                if (geometry.numInstances > 1) {\n\n                    const positions = geometry.positions;\n                    for (let i = 0, len = positions.length; i < len; i += 3) {\n                        tempVec4a[0] = positions[i + 0];\n                        tempVec4a[1] = positions[i + 1];\n                        tempVec4a[2] = positions[i + 2];\n                        tempVec4a[3] = 1;\n                        math.transformPoint4(matrix, tempVec4a, tempVec4b);\n                        math.expandAABB3Point3(entityAABB, tempVec4b);\n                    }\n\n                } else {\n\n                    const positions = geometry.positions;\n                    for (let i = 0, len = positions.length; i < len; i += 3) {\n                        tempVec4a[0] = positions[i + 0];\n                        tempVec4a[1] = positions[i + 1];\n                        tempVec4a[2] = positions[i + 2];\n                        math.expandAABB3Point3(entityAABB, tempVec4a);\n                    }\n                }\n            }\n        }\n    }\n\n    _createKDTree() {\n\n        let aabb;\n        if (this.modelAABB) {\n            aabb = this.modelAABB; // Pre-known uber AABB\n        } else {\n            aabb = math.collapseAABB3();\n            for (let i = 0, len = this.entitiesList.length; i < len; i++) {\n                const entity = this.entitiesList[i];\n                math.expandAABB3(aabb, entity.aabb);\n            }\n        }\n\n        const rootKDNode = new KDNode(aabb);\n\n        for (let i = 0, len = this.entitiesList.length; i < len; i++) {\n            const entity = this.entitiesList[i];\n            this._insertEntityIntoKDTree(rootKDNode, entity);\n        }\n\n        return rootKDNode;\n    }\n\n    _insertEntityIntoKDTree(kdNode, entity) {\n\n        const nodeAABB = kdNode.aabb;\n        const entityAABB = entity.aabb;\n\n        const nodeAABBDiag = math.getAABB3Diag(nodeAABB);\n\n        if (nodeAABBDiag < this.minTileSize) {\n            kdNode.entities = kdNode.entities || [];\n            kdNode.entities.push(entity);\n            math.expandAABB3(nodeAABB, entityAABB);\n            return;\n        }\n\n        if (kdNode.left) {\n            if (math.containsAABB3(kdNode.left.aabb, entityAABB)) {\n                this._insertEntityIntoKDTree(kdNode.left, entity);\n                return;\n            }\n        }\n\n        if (kdNode.right) {\n            if (math.containsAABB3(kdNode.right.aabb, entityAABB)) {\n                this._insertEntityIntoKDTree(kdNode.right, entity);\n                return;\n            }\n        }\n\n        kdTreeDimLength[0] = nodeAABB[3] - nodeAABB[0];\n        kdTreeDimLength[1] = nodeAABB[4] - nodeAABB[1];\n        kdTreeDimLength[2] = nodeAABB[5] - nodeAABB[2];\n\n        let dim = 0;\n\n        if (kdTreeDimLength[1] > kdTreeDimLength[dim]) {\n            dim = 1;\n        }\n\n        if (kdTreeDimLength[2] > kdTreeDimLength[dim]) {\n            dim = 2;\n        }\n\n        if (!kdNode.left) {\n            const aabbLeft = nodeAABB.slice();\n            aabbLeft[dim + 3] = ((nodeAABB[dim] + nodeAABB[dim + 3]) / 2.0);\n            kdNode.left = new KDNode(aabbLeft);\n            if (math.containsAABB3(aabbLeft, entityAABB)) {\n                this._insertEntityIntoKDTree(kdNode.left, entity);\n                return;\n            }\n        }\n\n        if (!kdNode.right) {\n            const aabbRight = nodeAABB.slice();\n            aabbRight[dim] = ((nodeAABB[dim] + nodeAABB[dim + 3]) / 2.0);\n            kdNode.right = new KDNode(aabbRight);\n            if (math.containsAABB3(aabbRight, entityAABB)) {\n                this._insertEntityIntoKDTree(kdNode.right, entity);\n                return;\n            }\n        }\n\n        kdNode.entities = kdNode.entities || [];\n        kdNode.entities.push(entity);\n\n        math.expandAABB3(nodeAABB, entityAABB);\n    }\n\n    _createTilesFromKDTree(rootKDNode) {\n        this._createTilesFromKDNode(rootKDNode);\n    }\n\n    _createTilesFromKDNode(kdNode) {\n        if (kdNode.entities && kdNode.entities.length > 0) {\n            this._createTileFromEntities(kdNode);\n        }\n        if (kdNode.left) {\n            this._createTilesFromKDNode(kdNode.left);\n        }\n        if (kdNode.right) {\n            this._createTilesFromKDNode(kdNode.right);\n        }\n    }\n\n    /**\n     * Creates a tile from the given entities.\n     *\n     * For each single-use {@link XKTGeometry}, this method centers {@link XKTGeometry#positions} to make them relative to the\n     * tile's center, then quantizes the positions to unsigned 16-bit integers, relative to the tile's boundary.\n     *\n     * @param kdNode\n     */\n    _createTileFromEntities(kdNode) {\n\n        const tileAABB = kdNode.aabb;\n        const entities = kdNode.entities;\n\n        const tileCenter = math.getAABB3Center(tileAABB);\n        const tileCenterNeg = math.mulVec3Scalar(tileCenter, -1, math.vec3());\n\n        const rtcAABB = math.AABB3(); // AABB centered at the RTC origin\n\n        rtcAABB[0] = tileAABB[0] - tileCenter[0];\n        rtcAABB[1] = tileAABB[1] - tileCenter[1];\n        rtcAABB[2] = tileAABB[2] - tileCenter[2];\n        rtcAABB[3] = tileAABB[3] - tileCenter[0];\n        rtcAABB[4] = tileAABB[4] - tileCenter[1];\n        rtcAABB[5] = tileAABB[5] - tileCenter[2];\n\n        for (let i = 0; i < entities.length; i++) {\n\n            const entity = entities [i];\n\n            const meshes = entity.meshes;\n\n            for (let j = 0, lenj = meshes.length; j < lenj; j++) {\n\n                const mesh = meshes[j];\n                const geometry = mesh.geometry;\n\n                if (!geometry.reused) { // Batched geometry\n\n                    const positions = geometry.positions;\n\n                    // Center positions relative to their tile's World-space center\n\n                    for (let k = 0, lenk = positions.length; k < lenk; k += 3) {\n\n                        positions[k + 0] -= tileCenter[0];\n                        positions[k + 1] -= tileCenter[1];\n                        positions[k + 2] -= tileCenter[2];\n                    }\n\n                    // Quantize positions relative to tile's RTC-space boundary\n\n                    geometryCompression.quantizePositions(positions, positions.length, rtcAABB, geometry.positionsQuantized);\n\n                } else { // Instanced geometry\n\n                    // Post-multiply a translation to the mesh's modeling matrix\n                    // to center the entity's geometry instances to the tile RTC center\n\n                    //////////////////////////////\n                    // Why do we do this?\n                    // Seems to break various models\n                    /////////////////////////////////\n\n                    math.translateMat4v(tileCenterNeg, mesh.matrix);\n                }\n            }\n\n            entity.entityIndex = this.entitiesList.length;\n\n            this.entitiesList.push(entity);\n        }\n\n        const tile = new XKTTile(tileAABB, entities);\n\n        this.tilesList.push(tile);\n    }\n\n    _createReusedGeometriesDecodeMatrix() {\n\n        const tempVec3a = math.vec3();\n        const reusedGeometriesAABB = math.collapseAABB3(math.AABB3());\n        let countReusedGeometries = 0;\n\n        for (let geometryIndex = 0, numGeometries = this.geometriesList.length; geometryIndex < numGeometries; geometryIndex++) {\n\n            const geometry = this.geometriesList [geometryIndex];\n\n            if (geometry.reused) { // Instanced geometry\n\n                const positions = geometry.positions;\n\n                for (let i = 0, len = positions.length; i < len; i += 3) {\n\n                    tempVec3a[0] = positions[i];\n                    tempVec3a[1] = positions[i + 1];\n                    tempVec3a[2] = positions[i + 2];\n\n                    math.expandAABB3Point3(reusedGeometriesAABB, tempVec3a);\n                }\n\n                countReusedGeometries++;\n            }\n        }\n\n        if (countReusedGeometries > 0) {\n\n            geometryCompression.createPositionsDecodeMatrix(reusedGeometriesAABB, this.reusedGeometriesDecodeMatrix);\n\n            for (let geometryIndex = 0, numGeometries = this.geometriesList.length; geometryIndex < numGeometries; geometryIndex++) {\n\n                const geometry = this.geometriesList [geometryIndex];\n\n                if (geometry.reused) {\n                    geometryCompression.quantizePositions(geometry.positions, geometry.positions.length, reusedGeometriesAABB, geometry.positionsQuantized);\n                }\n            }\n\n        } else {\n            math.identityMat4(this.reusedGeometriesDecodeMatrix); // No need for this matrix, but we'll be tidy and set it to identity\n        }\n    }\n\n    _flagSolidGeometries() {\n        let maxNumPositions = 0;\n        let maxNumIndices = 0;\n        for (let i = 0, len = this.geometriesList.length; i < len; i++) {\n            const geometry = this.geometriesList[i];\n            if (geometry.primitiveType === \"triangles\") {\n                if (geometry.positionsQuantized.length > maxNumPositions) {\n                    maxNumPositions = geometry.positionsQuantized.length;\n                }\n                if (geometry.indices.length > maxNumIndices) {\n                    maxNumIndices = geometry.indices.length;\n                }\n            }\n        }\n        let vertexIndexMapping = new Array(maxNumPositions / 3);\n        let edges = new Array(maxNumIndices);\n        for (let i = 0, len = this.geometriesList.length; i < len; i++) {\n            const geometry = this.geometriesList[i];\n            if (geometry.primitiveType === \"triangles\") {\n                geometry.solid = isTriangleMeshSolid(geometry.indices, geometry.positionsQuantized, vertexIndexMapping, edges);\n            }\n        }\n    }\n}\n\nexport {\n    XKTModel\n}",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/XKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 116,
    "kind": "variable",
    "name": "tempVec4a",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~tempVec4a",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 21,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 117,
    "kind": "variable",
    "name": "tempVec4b",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~tempVec4b",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 118,
    "kind": "variable",
    "name": "tempMat4",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~tempMat4",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 119,
    "kind": "variable",
    "name": "tempMat4b",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~tempMat4b",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 25,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 120,
    "kind": "variable",
    "name": "kdTreeDimLength",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~kdTreeDimLength",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 121,
    "kind": "variable",
    "name": "COLOR_TEXTURE",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~COLOR_TEXTURE",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 122,
    "kind": "variable",
    "name": "METALLIC_ROUGHNESS_TEXTURE",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~METALLIC_ROUGHNESS_TEXTURE",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 123,
    "kind": "variable",
    "name": "NORMALS_TEXTURE",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~NORMALS_TEXTURE",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 124,
    "kind": "variable",
    "name": "EMISSIVE_TEXTURE",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~EMISSIVE_TEXTURE",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 34,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 125,
    "kind": "variable",
    "name": "OCCLUSION_TEXTURE",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~OCCLUSION_TEXTURE",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 126,
    "kind": "variable",
    "name": "TEXTURE_ENCODING_OPTIONS",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~TEXTURE_ENCODING_OPTIONS",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 39,
    "undocument": true,
    "type": {
      "types": [
        "{}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 127,
    "kind": "class",
    "name": "XKTModel",
    "memberof": "src/XKTModel/XKTModel.js",
    "static": true,
    "longname": "src/XKTModel/XKTModel.js~XKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTModel.js",
    "importStyle": "{XKTModel}",
    "description": "A document model that represents the contents of an .XKT file.\n\n* An XKTModel contains {@link XKTTile}s, which spatially subdivide the model into axis-aligned, box-shaped regions.\n* Each {@link XKTTile} contains {@link XKTEntity}s, which represent the objects within its region.\n* Each {@link XKTEntity} has {@link XKTMesh}s, which each have a {@link XKTGeometry}. Each {@link XKTGeometry} can be shared by multiple {@link XKTMesh}s.\n* Import models into an XKTModel using {@link parseGLTFJSONIntoXKTModel}, {@link parseIFCIntoXKTModel}, {@link parseCityJSONIntoXKTModel} etc.\n* Build an XKTModel programmatically using {@link XKTModel#createGeometry}, {@link XKTModel#createMesh} and {@link XKTModel#createEntity}.\n* Serialize an XKTModel to an ArrayBuffer using {@link writeXKTModelToArrayBuffer}.\n\n## Usage\n\nSee [main docs page](/docs/#javascript-api) for usage examples.",
    "lineNumber": 87,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTModel"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 128,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#constructor",
    "access": "public",
    "description": "Constructs a new XKTModel.",
    "lineNumber": 96,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configuration"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "10",
        "defaultRaw": 10,
        "name": "cfg.edgeThreshold",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "500",
        "defaultRaw": 500,
        "name": "cfg.minTileSize",
        "description": ""
      }
    ]
  },
  {
    "__docId__": 129,
    "kind": "member",
    "name": "modelId",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#modelId",
    "access": "public",
    "description": "The model's ID, if available.\n\nWill be \"default\" by default.",
    "lineNumber": 105,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 130,
    "kind": "member",
    "name": "projectId",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#projectId",
    "access": "public",
    "description": "The project ID, if available.\n\nWill be an empty string by default.",
    "lineNumber": 114,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 131,
    "kind": "member",
    "name": "revisionId",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#revisionId",
    "access": "public",
    "description": "The revision ID, if available.\n\nWill be an empty string by default.",
    "lineNumber": 123,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 132,
    "kind": "member",
    "name": "author",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#author",
    "access": "public",
    "description": "The model author, if available.\n\nWill be an empty string by default.",
    "lineNumber": 133,
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "author",
        "description": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 133,
    "kind": "member",
    "name": "createdAt",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#createdAt",
    "access": "public",
    "description": "The date the model was created, if available.\n\nWill be an empty string by default.",
    "lineNumber": 143,
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "createdAt",
        "description": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 134,
    "kind": "member",
    "name": "creatingApplication",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#creatingApplication",
    "access": "public",
    "description": "The application that created the model, if available.\n\nWill be an empty string by default.",
    "lineNumber": 153,
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "creatingApplication",
        "description": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 135,
    "kind": "member",
    "name": "schema",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#schema",
    "access": "public",
    "description": "The model schema version, if available.\n\nIn the case of IFC, this could be \"IFC2x3\" or \"IFC4\", for example.\n\nWill be an empty string by default.",
    "lineNumber": 165,
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "schema",
        "description": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 136,
    "kind": "member",
    "name": "xktVersion",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#xktVersion",
    "access": "public",
    "description": "The XKT format version.",
    "lineNumber": 173,
    "properties": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "xktVersion;",
        "description": ""
      }
    ],
    "type": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 137,
    "kind": "member",
    "name": "edgeThreshold",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#edgeThreshold",
    "access": "public",
    "description": "",
    "lineNumber": 179,
    "type": {
      "nullable": null,
      "types": [
        "Number",
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 138,
    "kind": "member",
    "name": "minTileSize",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#minTileSize",
    "access": "public",
    "description": "Minimum diagonal size of the boundary of an {@link XKTTile}.",
    "lineNumber": 186,
    "type": {
      "nullable": null,
      "types": [
        "Number",
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 139,
    "kind": "member",
    "name": "modelAABB",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#modelAABB",
    "access": "public",
    "description": "Optional overall AABB that contains all the {@link XKTEntity}s we'll create in this model, if previously known.\n\nThis is the AABB of a complete set of input files that are provided as a split-model set for conversion.\n\nThis is used to help the {@link XKTTile.aabb}s within split models align neatly with each other, as we\nbuild them with a k-d tree in {@link XKTModel#finalize}.  Without this, the AABBs of the different parts\ntend to misalign slightly, resulting in excess number of {@link XKTTile}s, which degrades memory and rendering\nperformance when the XKT is viewer in the xeokit Viewer.",
    "lineNumber": 198,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 140,
    "kind": "member",
    "name": "propertySets",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#propertySets",
    "access": "public",
    "description": "Map of {@link XKTPropertySet}s within this XKTModel, each mapped to {@link XKTPropertySet#propertySetId}.\n\nCreated by {@link XKTModel#createPropertySet}.",
    "lineNumber": 207,
    "type": {
      "nullable": null,
      "types": [
        "{String:XKTPropertySet}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 141,
    "kind": "member",
    "name": "propertySetsList",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#propertySetsList",
    "access": "public",
    "description": "{@link XKTPropertySet}s within this XKTModel.\n\nEach XKTPropertySet holds its position in this list in {@link XKTPropertySet#propertySetIndex}.\n\nCreated by {@link XKTModel#finalize}.",
    "lineNumber": 218,
    "type": {
      "nullable": null,
      "types": [
        "XKTPropertySet[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 142,
    "kind": "member",
    "name": "metaObjects",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#metaObjects",
    "access": "public",
    "description": "Map of {@link XKTMetaObject}s within this XKTModel, each mapped to {@link XKTMetaObject#metaObjectId}.\n\nCreated by {@link XKTModel#createMetaObject}.",
    "lineNumber": 227,
    "type": {
      "nullable": null,
      "types": [
        "{String:XKTMetaObject}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 143,
    "kind": "member",
    "name": "metaObjectsList",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#metaObjectsList",
    "access": "public",
    "description": "{@link XKTMetaObject}s within this XKTModel.\n\nEach XKTMetaObject holds its position in this list in {@link XKTMetaObject#metaObjectIndex}.\n\nCreated by {@link XKTModel#finalize}.",
    "lineNumber": 238,
    "type": {
      "nullable": null,
      "types": [
        "XKTMetaObject[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 144,
    "kind": "member",
    "name": "reusedGeometriesDecodeMatrix",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#reusedGeometriesDecodeMatrix",
    "access": "public",
    "description": "The positions of all shared {@link XKTGeometry}s are de-quantized using this singular\nde-quantization matrix.\n\nThis de-quantization matrix is generated from the collective Local-space boundary of the\npositions of all shared {@link XKTGeometry}s.",
    "lineNumber": 249,
    "type": {
      "nullable": null,
      "types": [
        "Float32Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 145,
    "kind": "member",
    "name": "geometries",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#geometries",
    "access": "public",
    "description": "Map of {@link XKTGeometry}s within this XKTModel, each mapped to {@link XKTGeometry#geometryId}.\n\nCreated by {@link XKTModel#createGeometry}.",
    "lineNumber": 258,
    "type": {
      "nullable": null,
      "types": [
        "{Number:XKTGeometry}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 146,
    "kind": "member",
    "name": "geometriesList",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#geometriesList",
    "access": "public",
    "description": "List of {@link XKTGeometry}s within this XKTModel, in the order they were created.\n\nEach XKTGeometry holds its position in this list in {@link XKTGeometry#geometryIndex}.\n\nCreated by {@link XKTModel#finalize}.",
    "lineNumber": 269,
    "type": {
      "nullable": null,
      "types": [
        "XKTGeometry[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 147,
    "kind": "member",
    "name": "textures",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#textures",
    "access": "public",
    "description": "Map of {@link XKTTexture}s within this XKTModel, each mapped to {@link XKTTexture#textureId}.\n\nCreated by {@link XKTModel#createTexture}.",
    "lineNumber": 278,
    "type": {
      "nullable": null,
      "types": [
        "{Number:XKTTexture}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 148,
    "kind": "member",
    "name": "texturesList",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#texturesList",
    "access": "public",
    "description": "List of {@link XKTTexture}s within this XKTModel, in the order they were created.\n\nEach XKTTexture holds its position in this list in {@link XKTTexture#textureIndex}.\n\nCreated by {@link XKTModel#finalize}.",
    "lineNumber": 289,
    "type": {
      "nullable": null,
      "types": [
        "XKTTexture[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 149,
    "kind": "member",
    "name": "textureSets",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#textureSets",
    "access": "public",
    "description": "Map of {@link XKTTextureSet}s within this XKTModel, each mapped to {@link XKTTextureSet#textureSetId}.\n\nCreated by {@link XKTModel#createTextureSet}.",
    "lineNumber": 298,
    "type": {
      "nullable": null,
      "types": [
        "{Number:XKTTextureSet}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 150,
    "kind": "member",
    "name": "textureSetsList",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#textureSetsList",
    "access": "public",
    "description": "List of {@link XKTTextureSet}s within this XKTModel, in the order they were created.\n\nEach XKTTextureSet holds its position in this list in {@link XKTTextureSet#textureSetIndex}.\n\nCreated by {@link XKTModel#finalize}.",
    "lineNumber": 309,
    "type": {
      "nullable": null,
      "types": [
        "XKTTextureSet[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 151,
    "kind": "member",
    "name": "meshes",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#meshes",
    "access": "public",
    "description": "Map of {@link XKTMesh}s within this XKTModel, each mapped to {@link XKTMesh#meshId}.\n\nCreated by {@link XKTModel#createMesh}.",
    "lineNumber": 318,
    "type": {
      "nullable": null,
      "types": [
        "{Number:XKTMesh}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 152,
    "kind": "member",
    "name": "meshesList",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#meshesList",
    "access": "public",
    "description": "List of {@link XKTMesh}s within this XKTModel, in the order they were created.\n\nEach XKTMesh holds its position in this list in {@link XKTMesh#meshIndex}.\n\nCreated by {@link XKTModel#finalize}.",
    "lineNumber": 329,
    "type": {
      "nullable": null,
      "types": [
        "XKTMesh[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 153,
    "kind": "member",
    "name": "entities",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#entities",
    "access": "public",
    "description": "Map of {@link XKTEntity}s within this XKTModel, each mapped to {@link XKTEntity#entityId}.\n\nCreated by {@link XKTModel#createEntity}.",
    "lineNumber": 338,
    "type": {
      "nullable": null,
      "types": [
        "{String:XKTEntity}"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 154,
    "kind": "member",
    "name": "entitiesList",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#entitiesList",
    "access": "public",
    "description": "{@link XKTEntity}s within this XKTModel.\n\nEach XKTEntity holds its position in this list in {@link XKTEntity#entityIndex}.\n\nCreated by {@link XKTModel#finalize}.",
    "lineNumber": 349,
    "type": {
      "nullable": null,
      "types": [
        "XKTEntity[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 155,
    "kind": "member",
    "name": "tilesList",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#tilesList",
    "access": "public",
    "description": "{@link XKTTile}s within this XKTModel.\n\nCreated by {@link XKTModel#finalize}.",
    "lineNumber": 358,
    "type": {
      "nullable": null,
      "types": [
        "XKTTile[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 156,
    "kind": "member",
    "name": "aabb",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#aabb",
    "access": "public",
    "description": "The axis-aligned 3D World-space boundary of this XKTModel.\n\nCreated by {@link XKTModel#finalize}.",
    "lineNumber": 367,
    "type": {
      "nullable": null,
      "types": [
        "Float64Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 157,
    "kind": "member",
    "name": "finalized",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#finalized",
    "access": "public",
    "description": "Indicates if this XKTModel has been finalized.\n\nSet ````true```` by {@link XKTModel#finalize}.",
    "lineNumber": 376,
    "type": {
      "nullable": null,
      "types": [
        "boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 158,
    "kind": "method",
    "name": "createPropertySet",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#createPropertySet",
    "access": "public",
    "description": "Creates an {@link XKTPropertySet} within this XKTModel.\n\nLogs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).",
    "lineNumber": 391,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{XKTPropertySet} The new {@link XKTPropertySet}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Method parameters."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "params.propertySetId",
        "description": "Unique ID for the {@link XKTPropertySet}."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "\"default\"",
        "defaultRaw": "default",
        "name": "params.propertySetType",
        "description": "A meta type for the {@link XKTPropertySet}."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "params.propertySetName",
        "description": "Human-readable name for the {@link XKTPropertySet}. Defaults to the ````propertySetId```` parameter."
      },
      {
        "nullable": null,
        "types": [
          "String[]"
        ],
        "spread": false,
        "optional": false,
        "name": "params.properties",
        "description": "Properties for the {@link XKTPropertySet}."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "XKTPropertySet"
      ],
      "spread": false,
      "description": "The new {@link XKTPropertySet}."
    }
  },
  {
    "__docId__": 159,
    "kind": "method",
    "name": "createMetaObject",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#createMetaObject",
    "access": "public",
    "description": "Creates an {@link XKTMetaObject} within this XKTModel.\n\nLogs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).",
    "lineNumber": 444,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{XKTMetaObject} The new {@link XKTMetaObject}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Method parameters."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "params.metaObjectId",
        "description": "Unique ID for the {@link XKTMetaObject}."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "params.propertySetIds",
        "description": "ID of one or more property sets that contains additional metadata about\nthis {@link XKTMetaObject}. The property sets could be stored externally (ie not managed at all by the XKT file),\nor could be {@link XKTPropertySet}s within {@link XKTModel#propertySets}."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "\"default\"",
        "defaultRaw": "default",
        "name": "params.metaObjectType",
        "description": "A meta type for the {@link XKTMetaObject}. Can be anything,\nbut is usually an IFC type, such as \"IfcSite\" or \"IfcWall\"."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "params.metaObjectName",
        "description": "Human-readable name for the {@link XKTMetaObject}. Defaults to the ````metaObjectId```` parameter."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "params.parentMetaObjectId",
        "description": "ID of the parent {@link XKTMetaObject}, if any. Defaults to the ````metaObjectId```` parameter."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "XKTMetaObject"
      ],
      "spread": false,
      "description": "The new {@link XKTMetaObject}."
    }
  },
  {
    "__docId__": 160,
    "kind": "member",
    "name": "_rootMetaObject",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_rootMetaObject",
    "access": "private",
    "description": null,
    "lineNumber": 477,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 161,
    "kind": "method",
    "name": "createTexture",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#createTexture",
    "access": "public",
    "description": "Creates an {@link XKTTexture} within this XKTModel.\n\nRegisters the new {@link XKTTexture} in {@link XKTModel#textures} and {@link XKTModel#texturesList}.\n\nLogs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).",
    "lineNumber": 512,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{XKTTexture} The new {@link XKTTexture}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Method parameters."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "params.textureId",
        "description": "Unique ID for the {@link XKTTexture}."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "params.src",
        "description": "Source of an image file for the texture."
      },
      {
        "nullable": null,
        "types": [
          "Buffer"
        ],
        "spread": false,
        "optional": true,
        "name": "params.imageData",
        "description": "Image data for the texture."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "name": "params.mediaType",
        "description": "Media type (ie. MIME type) of ````imageData````. Supported values are {@link GIFMediaType}, {@link PNGMediaType} and {@link JPEGMediaType}."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "name": "params.width",
        "description": "Texture width, used with ````imageData````. Ignored for compressed textures."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "name": "params.height",
        "description": "Texture height, used with ````imageData````. Ignored for compressed textures."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "params.compressed",
        "description": "Whether to compress the texture."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "LinearMipMapNearestFilter",
        "defaultRaw": "LinearMipMapNearestFilter",
        "name": "params.minFilter",
        "description": "How the texture is sampled when a texel covers less than one pixel. Supported\nvalues are {@link LinearMipmapLinearFilter}, {@link LinearMipMapNearestFilter}, {@link NearestMipMapNearestFilter},\n{@link NearestMipMapLinearFilter} and {@link LinearMipMapLinearFilter}. Ignored for compressed textures."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "LinearMipMapNearestFilter",
        "defaultRaw": "LinearMipMapNearestFilter",
        "name": "params.magFilter",
        "description": "How the texture is sampled when a texel covers more than one pixel. Supported values\nare {@link LinearFilter} and {@link NearestFilter}. Ignored for compressed textures."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "RepeatWrapping",
        "defaultRaw": "RepeatWrapping",
        "name": "params.wrapS",
        "description": "Wrap parameter for texture coordinate *S*. Supported values are {@link ClampToEdgeWrapping},\n{@link MirroredRepeatWrapping} and {@link RepeatWrapping}. Ignored for compressed textures."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "RepeatWrapping",
        "defaultRaw": "RepeatWrapping",
        "name": "params.wrapT",
        "description": "Wrap parameter for texture coordinate *T*. Supported values are {@link ClampToEdgeWrapping},\n{@link MirroredRepeatWrapping} and {@link RepeatWrapping}. Ignored for compressed textures.\n{@param {Number} [params.wrapR=RepeatWrapping] Wrap parameter for texture coordinate *R*. Supported values are {@link ClampToEdgeWrapping},\n{@link MirroredRepeatWrapping} and {@link RepeatWrapping}. Ignored for compressed textures."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "XKTTexture"
      ],
      "spread": false,
      "description": "The new {@link XKTTexture}."
    }
  },
  {
    "__docId__": 162,
    "kind": "method",
    "name": "createTextureSet",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#createTextureSet",
    "access": "public",
    "description": "Creates an {@link XKTTextureSet} within this XKTModel.\n\nRegisters the new {@link XKTTextureSet} in {@link XKTModel#textureSets} and {@link XKTModel#.textureSetsList}.\n\nLogs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).",
    "lineNumber": 583,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{XKTTextureSet} The new {@link XKTTextureSet}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Method parameters."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "params.textureSetId",
        "description": "Unique ID for the {@link XKTTextureSet}."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "params.colorTextureId",
        "description": "ID of *RGBA* base color {@link XKTTexture}, with color in *RGB* and alpha in *A*."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "params.metallicRoughnessTextureId",
        "description": "ID of *RGBA* metal-roughness {@link XKTTexture}, with the metallic factor in *R*, and roughness factor in *G*."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "params.normalsTextureId",
        "description": "ID of *RGBA* normal {@link XKTTexture}, with normal map vectors in *RGB*."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "params.emissiveTextureId",
        "description": "ID of *RGBA* emissive {@link XKTTexture}, with emissive color in *RGB*."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "params.occlusionTextureId",
        "description": "ID of *RGBA* occlusion {@link XKTTexture}, with occlusion factor in *R*."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "XKTTextureSet"
      ],
      "spread": false,
      "description": "The new {@link XKTTextureSet}."
    }
  },
  {
    "__docId__": 163,
    "kind": "method",
    "name": "createGeometry",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#createGeometry",
    "access": "public",
    "description": "Creates an {@link XKTGeometry} within this XKTModel.\n\nRegisters the new {@link XKTGeometry} in {@link XKTModel#geometries} and {@link XKTModel#geometriesList}.\n\nLogs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).",
    "lineNumber": 690,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{XKTGeometry} The new {@link XKTGeometry}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Method parameters."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "params.geometryId",
        "description": "Unique ID for the {@link XKTGeometry}."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "params.primitiveType",
        "description": "The type of {@link XKTGeometry}: \"triangles\", \"lines\" or \"points\"."
      },
      {
        "nullable": null,
        "types": [
          "Float64Array"
        ],
        "spread": false,
        "optional": false,
        "name": "params.positions",
        "description": "Floating-point Local-space vertex positions for the {@link XKTGeometry}. Required for all primitive types."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "params.normals",
        "description": "Floating-point vertex normals for the {@link XKTGeometry}. Only used with triangles primitives. Ignored for points and lines."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "params.colors",
        "description": "Floating-point RGBA vertex colors for the {@link XKTGeometry}. Required for points primitives. Ignored for lines and triangles."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "params.colorsCompressed",
        "description": "Integer RGBA vertex colors for the {@link XKTGeometry}. Required for points primitives. Ignored for lines and triangles."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "params.uvs",
        "description": "Floating-point vertex UV coordinates for the {@link XKTGeometry}. Alias for ````uv````."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "params.uv",
        "description": "Floating-point vertex UV coordinates for the {@link XKTGeometry}. Alias for ````uvs````."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "params.colorsCompressed",
        "description": "Integer RGBA vertex colors for the {@link XKTGeometry}. Required for points primitives. Ignored for lines and triangles."
      },
      {
        "nullable": null,
        "types": [
          "Uint32Array"
        ],
        "spread": false,
        "optional": true,
        "name": "params.indices",
        "description": "Indices for the {@link XKTGeometry}. Required for triangles and lines primitives. Ignored for points."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "10",
        "defaultRaw": 10,
        "name": "params.edgeThreshold",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "XKTGeometry"
      ],
      "spread": false,
      "description": "The new {@link XKTGeometry}."
    }
  },
  {
    "__docId__": 164,
    "kind": "method",
    "name": "_createDefaultIndices",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createDefaultIndices",
    "access": "private",
    "description": null,
    "lineNumber": 820,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "numIndices",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 165,
    "kind": "method",
    "name": "createMesh",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#createMesh",
    "access": "public",
    "description": "Creates an {@link XKTMesh} within this XKTModel.\n\nAn {@link XKTMesh} can be owned by one {@link XKTEntity}, which can own multiple {@link XKTMesh}es.\n\nRegisters the new {@link XKTMesh} in {@link XKTModel#meshes} and {@link XKTModel#meshesList}.",
    "lineNumber": 849,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{XKTMesh} The new {@link XKTMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Method parameters."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "params.meshId",
        "description": "Unique ID for the {@link XKTMesh}."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "params.geometryId",
        "description": "ID of an existing {@link XKTGeometry} in {@link XKTModel#geometries}."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "name": "params.textureSetId",
        "description": "Unique ID of an {@link XKTTextureSet} in {@link XKTModel#textureSets}."
      },
      {
        "nullable": null,
        "types": [
          "Float32Array"
        ],
        "spread": false,
        "optional": false,
        "name": "params.color",
        "description": "RGB color for the {@link XKTMesh}, with each color component in range [0..1]."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0",
        "defaultRaw": 0,
        "name": "params.metallic",
        "description": "How metallic the {@link XKTMesh} is, in range [0..1]. A value of ````0```` indicates fully dielectric material, while ````1```` indicates fully metallic."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "params.roughness",
        "description": "How rough the {@link XKTMesh} is, in range [0..1]. A value of ````0```` indicates fully smooth, while ````1```` indicates fully rough."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": false,
        "name": "params.opacity",
        "description": "Opacity factor for the {@link XKTMesh}, in range [0..1]."
      },
      {
        "nullable": null,
        "types": [
          "Float64Array"
        ],
        "spread": false,
        "optional": true,
        "name": "params.matrix",
        "description": "Modeling matrix for the {@link XKTMesh}. Overrides ````position````, ````scale```` and ````rotation```` parameters."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[0,0,0]",
        "defaultRaw": [
          0,
          0,
          0
        ],
        "name": "params.position",
        "description": "Position of the {@link XKTMesh}. Overridden by the ````matrix```` parameter."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[1,1,1]",
        "defaultRaw": [
          1,
          1,
          1
        ],
        "name": "params.scale",
        "description": "Scale of the {@link XKTMesh}. Overridden by the ````matrix```` parameter."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "[0,0,0]",
        "defaultRaw": [
          0,
          0,
          0
        ],
        "name": "params.rotation",
        "description": "Rotation of the {@link XKTMesh} as Euler angles given in degrees, for each of the X, Y and Z axis. Overridden by the ````matrix```` parameter."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "XKTMesh"
      ],
      "spread": false,
      "description": "The new {@link XKTMesh}."
    }
  },
  {
    "__docId__": 166,
    "kind": "method",
    "name": "createEntity",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#createEntity",
    "access": "public",
    "description": "Creates an {@link XKTEntity} within this XKTModel.\n\nRegisters the new {@link XKTEntity} in {@link XKTModel#entities} and {@link XKTModel#entitiesList}.\n\nLogs error and does nothing if this XKTModel has been finalized (see {@link XKTModel#finalized}).",
    "lineNumber": 937,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{XKTEntity} The new {@link XKTEntity}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Method parameters."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "params.entityId",
        "description": "Unique ID for the {@link XKTEntity}."
      },
      {
        "nullable": null,
        "types": [
          "String[]"
        ],
        "spread": false,
        "optional": false,
        "name": "params.meshIds",
        "description": "IDs of {@link XKTMesh}es used by the {@link XKTEntity}. Note that each {@link XKTMesh} can only be used by one {@link XKTEntity}."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "XKTEntity"
      ],
      "spread": false,
      "description": "The new {@link XKTEntity}."
    }
  },
  {
    "__docId__": 167,
    "kind": "method",
    "name": "createDefaultMetaObjects",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#createDefaultMetaObjects",
    "access": "public",
    "description": "Creates a default {@link XKTMetaObject} for each {@link XKTEntity} that does not already have one.",
    "lineNumber": 1007,
    "params": [],
    "return": null
  },
  {
    "__docId__": 169,
    "kind": "method",
    "name": "finalize",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#finalize",
    "access": "public",
    "description": "Finalizes this XKTModel.\n\nAfter finalizing, we may then serialize the model to an array buffer using {@link writeXKTModelToArrayBuffer}.\n\nLogs error and does nothing if this XKTModel has already been finalized.\n\nInternally, this method:\n\n* for each {@link XKTEntity} that doesn't already have a {@link XKTMetaObject}, creates one with {@link XKTMetaObject#metaObjectType} set to \"default\"\n* sets each {@link XKTEntity}'s {@link XKTEntity#hasReusedGeometries} true if it shares its {@link XKTGeometry}s with other {@link XKTEntity}s,\n* creates each {@link XKTEntity}'s {@link XKTEntity#aabb},\n* creates {@link XKTTile}s in {@link XKTModel#tilesList}, and\n* sets {@link XKTModel#finalized} ````true````.",
    "lineNumber": 1050,
    "params": [],
    "return": null
  },
  {
    "__docId__": 172,
    "kind": "method",
    "name": "_removeUnusedTextures",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_removeUnusedTextures",
    "access": "private",
    "description": null,
    "lineNumber": 1082,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 175,
    "kind": "method",
    "name": "_compressTextures",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_compressTextures",
    "access": "private",
    "description": null,
    "lineNumber": 1097,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 176,
    "kind": "method",
    "name": "_bakeSingleUseGeometryPositions",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_bakeSingleUseGeometryPositions",
    "access": "private",
    "description": null,
    "lineNumber": 1185,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 177,
    "kind": "method",
    "name": "_bakeAndOctEncodeNormals",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_bakeAndOctEncodeNormals",
    "access": "private",
    "description": null,
    "lineNumber": 1219,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 178,
    "kind": "method",
    "name": "_createEntityAABBs",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createEntityAABBs",
    "access": "private",
    "description": null,
    "lineNumber": 1241,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 179,
    "kind": "method",
    "name": "_createKDTree",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createKDTree",
    "access": "private",
    "description": null,
    "lineNumber": 1283,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 180,
    "kind": "method",
    "name": "_insertEntityIntoKDTree",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_insertEntityIntoKDTree",
    "access": "private",
    "description": null,
    "lineNumber": 1306,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "kdNode",
        "types": [
          "*"
        ]
      },
      {
        "name": "entity",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 181,
    "kind": "method",
    "name": "_createTilesFromKDTree",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createTilesFromKDTree",
    "access": "private",
    "description": null,
    "lineNumber": 1374,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "rootKDNode",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 182,
    "kind": "method",
    "name": "_createTilesFromKDNode",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createTilesFromKDNode",
    "access": "private",
    "description": null,
    "lineNumber": 1378,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "kdNode",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 183,
    "kind": "method",
    "name": "_createTileFromEntities",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createTileFromEntities",
    "access": "private",
    "description": "Creates a tile from the given entities.\n\nFor each single-use {@link XKTGeometry}, this method centers {@link XKTGeometry#positions} to make them relative to the\ntile's center, then quantizes the positions to unsigned 16-bit integers, relative to the tile's boundary.",
    "lineNumber": 1398,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "kdNode",
        "description": ""
      }
    ],
    "ignore": true,
    "return": null
  },
  {
    "__docId__": 184,
    "kind": "method",
    "name": "_createReusedGeometriesDecodeMatrix",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_createReusedGeometriesDecodeMatrix",
    "access": "private",
    "description": null,
    "lineNumber": 1467,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 185,
    "kind": "method",
    "name": "_flagSolidGeometries",
    "memberof": "src/XKTModel/XKTModel.js~XKTModel",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTModel.js~XKTModel#_flagSolidGeometries",
    "access": "private",
    "description": null,
    "lineNumber": 1512,
    "undocument": true,
    "ignore": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 186,
    "kind": "file",
    "name": "src/XKTModel/XKTPropertySet.js",
    "content": "/**\n * A property set within an {@link XKTModel}.\n *\n * These are shared among {@link XKTMetaObject}s.\n *\n * * Created by {@link XKTModel#createPropertySet}\n * * Stored in {@link XKTModel#propertySets} and {@link XKTModel#propertySetsList}\n * * Has an ID, a type, and a human-readable name\n *\n * @class XKTPropertySet\n */\nclass XKTPropertySet {\n\n    /**\n     * @private\n     */\n    constructor(propertySetId, propertySetType, propertySetName, properties) {\n\n        /**\n         * Unique ID of this ````XKTPropertySet```` in {@link XKTModel#propertySets}.\n         *\n         * @type {String}\n         */\n        this.propertySetId = propertySetId;\n\n        /**\n         * Indicates the ````XKTPropertySet````'s type.\n         *\n         * This defaults to \"default\".\n         *\n         * @type {string}\n         */\n        this.propertySetType = propertySetType;\n\n        /**\n         * Indicates the XKTPropertySet meta object name.\n         *\n         * This defaults to {@link XKTPropertySet#propertySetId}.\n         *\n         * @type {string}\n         */\n        this.propertySetName = propertySetName;\n\n        /**\n         * The properties within this ````XKTPropertySet````.\n         *\n         * @type {*[]}\n         */\n        this.properties = properties;\n    }\n}\n\nexport {XKTPropertySet};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/XKTPropertySet.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 187,
    "kind": "class",
    "name": "XKTPropertySet",
    "memberof": "src/XKTModel/XKTPropertySet.js",
    "static": true,
    "longname": "src/XKTModel/XKTPropertySet.js~XKTPropertySet",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTPropertySet.js",
    "importStyle": "{XKTPropertySet}",
    "description": "A property set within an {@link XKTModel}.\n\nThese are shared among {@link XKTMetaObject}s.\n\n* Created by {@link XKTModel#createPropertySet}\n* Stored in {@link XKTModel#propertySets} and {@link XKTModel#propertySetsList}\n* Has an ID, a type, and a human-readable name",
    "lineNumber": 12,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTPropertySet"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 188,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTPropertySet.js~XKTPropertySet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTPropertySet.js~XKTPropertySet#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 17,
    "ignore": true
  },
  {
    "__docId__": 189,
    "kind": "member",
    "name": "propertySetId",
    "memberof": "src/XKTModel/XKTPropertySet.js~XKTPropertySet",
    "static": false,
    "longname": "src/XKTModel/XKTPropertySet.js~XKTPropertySet#propertySetId",
    "access": "public",
    "description": "Unique ID of this ````XKTPropertySet```` in {@link XKTModel#propertySets}.",
    "lineNumber": 24,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 190,
    "kind": "member",
    "name": "propertySetType",
    "memberof": "src/XKTModel/XKTPropertySet.js~XKTPropertySet",
    "static": false,
    "longname": "src/XKTModel/XKTPropertySet.js~XKTPropertySet#propertySetType",
    "access": "public",
    "description": "Indicates the ````XKTPropertySet````'s type.\n\nThis defaults to \"default\".",
    "lineNumber": 33,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 191,
    "kind": "member",
    "name": "propertySetName",
    "memberof": "src/XKTModel/XKTPropertySet.js~XKTPropertySet",
    "static": false,
    "longname": "src/XKTModel/XKTPropertySet.js~XKTPropertySet#propertySetName",
    "access": "public",
    "description": "Indicates the XKTPropertySet meta object name.\n\nThis defaults to {@link XKTPropertySet#propertySetId}.",
    "lineNumber": 42,
    "type": {
      "nullable": null,
      "types": [
        "string"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 192,
    "kind": "member",
    "name": "properties",
    "memberof": "src/XKTModel/XKTPropertySet.js~XKTPropertySet",
    "static": false,
    "longname": "src/XKTModel/XKTPropertySet.js~XKTPropertySet#properties",
    "access": "public",
    "description": "The properties within this ````XKTPropertySet````.",
    "lineNumber": 49,
    "type": {
      "nullable": null,
      "types": [
        "*[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 193,
    "kind": "file",
    "name": "src/XKTModel/XKTTexture.js",
    "content": "/**\n * A texture shared by {@link XKTTextureSet}s.\n *\n * * Created by {@link XKTModel#createTexture}\n * * Stored in {@link XKTTextureSet#textures}, {@link XKTModel#textures} and {@link XKTModel#texturesList}\n *\n * @class XKTTexture\n */\nimport {RepeatWrapping, LinearMipMapNearestFilter} from \"../constants\";\n\nclass XKTTexture {\n\n    /**\n     * @private\n     */\n    constructor(cfg) {\n\n        /**\n         * Unique ID of this XKTTexture in {@link XKTModel#textures}.\n         *\n         * @type {Number}\n         */\n        this.textureId = cfg.textureId;\n\n        /**\n         * Index of this XKTTexture in {@link XKTModel#texturesList};\n         *\n         * @type {Number}\n         */\n        this.textureIndex = cfg.textureIndex;\n\n        /**\n         * Texture image data.\n         *\n         * @type {Buffer}\n         */\n        this.imageData = cfg.imageData;\n\n        /**\n         * Which material channel this texture is applied to, as determined by its {@link XKTTextureSet}s.\n         *\n         * @type {Number}\n         */\n        this.channel = null;\n\n        /**\n         * Width of this XKTTexture.\n         *\n         * @type {Number}\n         */\n        this.width = cfg.width;\n\n        /**\n         * Height of this XKTTexture.\n         *\n         * @type {Number}\n         */\n        this.height = cfg.height;\n\n        /**\n         * Texture file source.\n         *\n         * @type {String}\n         */\n        this.src = cfg.src;\n\n        /**\n         * Whether this XKTTexture is to be compressed.\n         *\n         * @type {Boolean}\n         */\n        this.compressed = (!!cfg.compressed);\n\n        /**\n         * Media type of this XKTTexture.\n         *\n         * Supported values are {@link GIFMediaType}, {@link PNGMediaType} and {@link JPEGMediaType}.\n         *\n         * Ignored for compressed textures.\n         *\n         * @type {Number}\n         */\n        this.mediaType = cfg.mediaType;\n\n        /**\n         * How the texture is sampled when a texel covers less than one pixel. Supported values\n         * are {@link LinearMipmapLinearFilter}, {@link LinearMipMapNearestFilter},\n         * {@link NearestMipMapNearestFilter}, {@link NearestMipMapLinearFilter}\n         * and {@link LinearMipMapLinearFilter}.\n         *\n         * Ignored for compressed textures.\n         *\n         * @type {Number}\n         */\n        this.minFilter = cfg.minFilter || LinearMipMapNearestFilter;\n\n        /**\n         * How the texture is sampled when a texel covers more than one pixel. Supported values\n         * are {@link LinearFilter} and {@link NearestFilter}.\n         *\n         * Ignored for compressed textures.\n         *\n         * @type {Number}\n         */\n        this.magFilter = cfg.magFilter || LinearMipMapNearestFilter;\n\n        /**\n         * S wrapping mode.\n         *\n         * Supported values are {@link ClampToEdgeWrapping},\n         * {@link MirroredRepeatWrapping} and {@link RepeatWrapping}.\n         *\n         * Ignored for compressed textures.\n         *\n         * @type {Number}\n         */\n        this.wrapS = cfg.wrapS || RepeatWrapping;\n\n        /**\n         * T wrapping mode.\n         *\n         * Supported values are {@link ClampToEdgeWrapping},\n         * {@link MirroredRepeatWrapping} and {@link RepeatWrapping}.\n         *\n         * Ignored for compressed textures.\n         *\n         * @type {Number}\n         */\n        this.wrapT = cfg.wrapT || RepeatWrapping;\n\n        /**\n         * R wrapping mode.\n         *\n         * Ignored for compressed textures.\n         *\n         * Supported values are {@link ClampToEdgeWrapping},\n         * {@link MirroredRepeatWrapping} and {@link RepeatWrapping}.\n         *\n         * @type {*|number}\n         */\n        this.wrapR = cfg.wrapR || RepeatWrapping\n    }\n}\n\nexport {XKTTexture};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/XKTTexture.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 194,
    "kind": "class",
    "name": "XKTTexture",
    "memberof": "src/XKTModel/XKTTexture.js",
    "static": true,
    "longname": "src/XKTModel/XKTTexture.js~XKTTexture",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTTexture.js",
    "importStyle": "{XKTTexture}",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "interface": false
  },
  {
    "__docId__": 195,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTTexture.js~XKTTexture",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTTexture.js~XKTTexture#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 16,
    "ignore": true
  },
  {
    "__docId__": 196,
    "kind": "member",
    "name": "textureId",
    "memberof": "src/XKTModel/XKTTexture.js~XKTTexture",
    "static": false,
    "longname": "src/XKTModel/XKTTexture.js~XKTTexture#textureId",
    "access": "public",
    "description": "Unique ID of this XKTTexture in {@link XKTModel#textures}.",
    "lineNumber": 23,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 197,
    "kind": "member",
    "name": "textureIndex",
    "memberof": "src/XKTModel/XKTTexture.js~XKTTexture",
    "static": false,
    "longname": "src/XKTModel/XKTTexture.js~XKTTexture#textureIndex",
    "access": "public",
    "description": "Index of this XKTTexture in {@link XKTModel#texturesList};",
    "lineNumber": 30,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 198,
    "kind": "member",
    "name": "imageData",
    "memberof": "src/XKTModel/XKTTexture.js~XKTTexture",
    "static": false,
    "longname": "src/XKTModel/XKTTexture.js~XKTTexture#imageData",
    "access": "public",
    "description": "Texture image data.",
    "lineNumber": 37,
    "type": {
      "nullable": null,
      "types": [
        "Buffer"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 199,
    "kind": "member",
    "name": "channel",
    "memberof": "src/XKTModel/XKTTexture.js~XKTTexture",
    "static": false,
    "longname": "src/XKTModel/XKTTexture.js~XKTTexture#channel",
    "access": "public",
    "description": "Which material channel this texture is applied to, as determined by its {@link XKTTextureSet}s.",
    "lineNumber": 44,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 200,
    "kind": "member",
    "name": "width",
    "memberof": "src/XKTModel/XKTTexture.js~XKTTexture",
    "static": false,
    "longname": "src/XKTModel/XKTTexture.js~XKTTexture#width",
    "access": "public",
    "description": "Width of this XKTTexture.",
    "lineNumber": 51,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 201,
    "kind": "member",
    "name": "height",
    "memberof": "src/XKTModel/XKTTexture.js~XKTTexture",
    "static": false,
    "longname": "src/XKTModel/XKTTexture.js~XKTTexture#height",
    "access": "public",
    "description": "Height of this XKTTexture.",
    "lineNumber": 58,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 202,
    "kind": "member",
    "name": "src",
    "memberof": "src/XKTModel/XKTTexture.js~XKTTexture",
    "static": false,
    "longname": "src/XKTModel/XKTTexture.js~XKTTexture#src",
    "access": "public",
    "description": "Texture file source.",
    "lineNumber": 65,
    "type": {
      "nullable": null,
      "types": [
        "String"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 203,
    "kind": "member",
    "name": "compressed",
    "memberof": "src/XKTModel/XKTTexture.js~XKTTexture",
    "static": false,
    "longname": "src/XKTModel/XKTTexture.js~XKTTexture#compressed",
    "access": "public",
    "description": "Whether this XKTTexture is to be compressed.",
    "lineNumber": 72,
    "type": {
      "nullable": null,
      "types": [
        "Boolean"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 204,
    "kind": "member",
    "name": "mediaType",
    "memberof": "src/XKTModel/XKTTexture.js~XKTTexture",
    "static": false,
    "longname": "src/XKTModel/XKTTexture.js~XKTTexture#mediaType",
    "access": "public",
    "description": "Media type of this XKTTexture.\n\nSupported values are {@link GIFMediaType}, {@link PNGMediaType} and {@link JPEGMediaType}.\n\nIgnored for compressed textures.",
    "lineNumber": 83,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 205,
    "kind": "member",
    "name": "minFilter",
    "memberof": "src/XKTModel/XKTTexture.js~XKTTexture",
    "static": false,
    "longname": "src/XKTModel/XKTTexture.js~XKTTexture#minFilter",
    "access": "public",
    "description": "How the texture is sampled when a texel covers less than one pixel. Supported values\nare {@link LinearMipmapLinearFilter}, {@link LinearMipMapNearestFilter},\n{@link NearestMipMapNearestFilter}, {@link NearestMipMapLinearFilter}\nand {@link LinearMipMapLinearFilter}.\n\nIgnored for compressed textures.",
    "lineNumber": 95,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 206,
    "kind": "member",
    "name": "magFilter",
    "memberof": "src/XKTModel/XKTTexture.js~XKTTexture",
    "static": false,
    "longname": "src/XKTModel/XKTTexture.js~XKTTexture#magFilter",
    "access": "public",
    "description": "How the texture is sampled when a texel covers more than one pixel. Supported values\nare {@link LinearFilter} and {@link NearestFilter}.\n\nIgnored for compressed textures.",
    "lineNumber": 105,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 207,
    "kind": "member",
    "name": "wrapS",
    "memberof": "src/XKTModel/XKTTexture.js~XKTTexture",
    "static": false,
    "longname": "src/XKTModel/XKTTexture.js~XKTTexture#wrapS",
    "access": "public",
    "description": "S wrapping mode.\n\nSupported values are {@link ClampToEdgeWrapping},\n{@link MirroredRepeatWrapping} and {@link RepeatWrapping}.\n\nIgnored for compressed textures.",
    "lineNumber": 117,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 208,
    "kind": "member",
    "name": "wrapT",
    "memberof": "src/XKTModel/XKTTexture.js~XKTTexture",
    "static": false,
    "longname": "src/XKTModel/XKTTexture.js~XKTTexture#wrapT",
    "access": "public",
    "description": "T wrapping mode.\n\nSupported values are {@link ClampToEdgeWrapping},\n{@link MirroredRepeatWrapping} and {@link RepeatWrapping}.\n\nIgnored for compressed textures.",
    "lineNumber": 129,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 209,
    "kind": "member",
    "name": "wrapR",
    "memberof": "src/XKTModel/XKTTexture.js~XKTTexture",
    "static": false,
    "longname": "src/XKTModel/XKTTexture.js~XKTTexture#wrapR",
    "access": "public",
    "description": "R wrapping mode.\n\nIgnored for compressed textures.\n\nSupported values are {@link ClampToEdgeWrapping},\n{@link MirroredRepeatWrapping} and {@link RepeatWrapping}.",
    "lineNumber": 141,
    "type": {
      "nullable": null,
      "types": [
        "*",
        "number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 210,
    "kind": "file",
    "name": "src/XKTModel/XKTTextureSet.js",
    "content": "/**\n * A set of textures shared by {@link XKTMesh}es.\n *\n * * Created by {@link XKTModel#createTextureSet}\n * * Registered in {@link XKTMesh#material}, {@link XKTModel#materials} and {@link XKTModel#.textureSetsList}\n *\n * @class XKTMetalRoughMaterial\n */\nclass XKTTextureSet {\n\n    /**\n     * @private\n     */\n    constructor(cfg) {\n\n        /**\n         * Unique ID of this XKTTextureSet in {@link XKTModel#materials}.\n         *\n         * @type {Number}\n         */\n        this.textureSetId = cfg.textureSetId;\n\n        /**\n         * Index of this XKTTexture in {@link XKTModel#texturesList};\n         *\n         * @type {Number}\n         */\n        this.textureSetIndex = cfg.textureSetIndex;\n\n        /**\n         * Identifies the material type.\n         *\n         * @type {Number}\n         */\n        this.materialType = cfg.materialType;\n\n        /**\n         * Index of this XKTTextureSet in {@link XKTModel#meshesList};\n         *\n         * @type {Number}\n         */\n        this.materialIndex = cfg.materialIndex;\n\n        /**\n         * The number of {@link XKTMesh}s that reference this XKTTextureSet.\n         *\n         * @type {Number}\n         */\n        this.numInstances = 0;\n\n        /**\n         * RGBA {@link XKTTexture} containing base color in RGB and opacity in A.\n         *\n         * @type {XKTTexture}\n         */\n        this.colorTexture = cfg.colorTexture;\n\n        /**\n         * RGBA {@link XKTTexture} containing metallic and roughness factors in R and G.\n         *\n         * @type {XKTTexture}\n         */\n        this.metallicRoughnessTexture = cfg.metallicRoughnessTexture;\n\n        /**\n         * RGBA {@link XKTTexture} with surface normals in RGB.\n         *\n         * @type {XKTTexture}\n         */\n        this.normalsTexture = cfg.normalsTexture;\n\n        /**\n         * RGBA {@link XKTTexture} with emissive color in RGB.\n         *\n         * @type {XKTTexture}\n         */\n        this.emissiveTexture = cfg.emissiveTexture;\n\n        /**\n         * RGBA {@link XKTTexture} with ambient occlusion factors in RGB.\n         *\n         * @type {XKTTexture}\n         */\n        this.occlusionTexture = cfg.occlusionTexture;\n    }\n}\n\nexport {XKTTextureSet};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/XKTTextureSet.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 211,
    "kind": "class",
    "name": "XKTTextureSet",
    "memberof": "src/XKTModel/XKTTextureSet.js",
    "static": true,
    "longname": "src/XKTModel/XKTTextureSet.js~XKTTextureSet",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTTextureSet.js",
    "importStyle": "{XKTTextureSet}",
    "description": "A set of textures shared by {@link XKTMesh}es.\n\n* Created by {@link XKTModel#createTextureSet}\n* Registered in {@link XKTMesh#material}, {@link XKTModel#materials} and {@link XKTModel#.textureSetsList}",
    "lineNumber": 9,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTMetalRoughMaterial"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 212,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTTextureSet.js~XKTTextureSet",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTTextureSet.js~XKTTextureSet#constructor",
    "access": "private",
    "description": "",
    "lineNumber": 14,
    "ignore": true
  },
  {
    "__docId__": 213,
    "kind": "member",
    "name": "textureSetId",
    "memberof": "src/XKTModel/XKTTextureSet.js~XKTTextureSet",
    "static": false,
    "longname": "src/XKTModel/XKTTextureSet.js~XKTTextureSet#textureSetId",
    "access": "public",
    "description": "Unique ID of this XKTTextureSet in {@link XKTModel#materials}.",
    "lineNumber": 21,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 214,
    "kind": "member",
    "name": "textureSetIndex",
    "memberof": "src/XKTModel/XKTTextureSet.js~XKTTextureSet",
    "static": false,
    "longname": "src/XKTModel/XKTTextureSet.js~XKTTextureSet#textureSetIndex",
    "access": "public",
    "description": "Index of this XKTTexture in {@link XKTModel#texturesList};",
    "lineNumber": 28,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 215,
    "kind": "member",
    "name": "materialType",
    "memberof": "src/XKTModel/XKTTextureSet.js~XKTTextureSet",
    "static": false,
    "longname": "src/XKTModel/XKTTextureSet.js~XKTTextureSet#materialType",
    "access": "public",
    "description": "Identifies the material type.",
    "lineNumber": 35,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 216,
    "kind": "member",
    "name": "materialIndex",
    "memberof": "src/XKTModel/XKTTextureSet.js~XKTTextureSet",
    "static": false,
    "longname": "src/XKTModel/XKTTextureSet.js~XKTTextureSet#materialIndex",
    "access": "public",
    "description": "Index of this XKTTextureSet in {@link XKTModel#meshesList};",
    "lineNumber": 42,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 217,
    "kind": "member",
    "name": "numInstances",
    "memberof": "src/XKTModel/XKTTextureSet.js~XKTTextureSet",
    "static": false,
    "longname": "src/XKTModel/XKTTextureSet.js~XKTTextureSet#numInstances",
    "access": "public",
    "description": "The number of {@link XKTMesh}s that reference this XKTTextureSet.",
    "lineNumber": 49,
    "type": {
      "nullable": null,
      "types": [
        "Number"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 218,
    "kind": "member",
    "name": "colorTexture",
    "memberof": "src/XKTModel/XKTTextureSet.js~XKTTextureSet",
    "static": false,
    "longname": "src/XKTModel/XKTTextureSet.js~XKTTextureSet#colorTexture",
    "access": "public",
    "description": "RGBA {@link XKTTexture} containing base color in RGB and opacity in A.",
    "lineNumber": 56,
    "type": {
      "nullable": null,
      "types": [
        "XKTTexture"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 219,
    "kind": "member",
    "name": "metallicRoughnessTexture",
    "memberof": "src/XKTModel/XKTTextureSet.js~XKTTextureSet",
    "static": false,
    "longname": "src/XKTModel/XKTTextureSet.js~XKTTextureSet#metallicRoughnessTexture",
    "access": "public",
    "description": "RGBA {@link XKTTexture} containing metallic and roughness factors in R and G.",
    "lineNumber": 63,
    "type": {
      "nullable": null,
      "types": [
        "XKTTexture"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 220,
    "kind": "member",
    "name": "normalsTexture",
    "memberof": "src/XKTModel/XKTTextureSet.js~XKTTextureSet",
    "static": false,
    "longname": "src/XKTModel/XKTTextureSet.js~XKTTextureSet#normalsTexture",
    "access": "public",
    "description": "RGBA {@link XKTTexture} with surface normals in RGB.",
    "lineNumber": 70,
    "type": {
      "nullable": null,
      "types": [
        "XKTTexture"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 221,
    "kind": "member",
    "name": "emissiveTexture",
    "memberof": "src/XKTModel/XKTTextureSet.js~XKTTextureSet",
    "static": false,
    "longname": "src/XKTModel/XKTTextureSet.js~XKTTextureSet#emissiveTexture",
    "access": "public",
    "description": "RGBA {@link XKTTexture} with emissive color in RGB.",
    "lineNumber": 77,
    "type": {
      "nullable": null,
      "types": [
        "XKTTexture"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 222,
    "kind": "member",
    "name": "occlusionTexture",
    "memberof": "src/XKTModel/XKTTextureSet.js~XKTTextureSet",
    "static": false,
    "longname": "src/XKTModel/XKTTextureSet.js~XKTTextureSet#occlusionTexture",
    "access": "public",
    "description": "RGBA {@link XKTTexture} with ambient occlusion factors in RGB.",
    "lineNumber": 84,
    "type": {
      "nullable": null,
      "types": [
        "XKTTexture"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 223,
    "kind": "file",
    "name": "src/XKTModel/XKTTile.js",
    "content": "/**\n * @desc A box-shaped 3D region within an {@link XKTModel} that contains {@link XKTEntity}s.\n *\n * * Created by {@link XKTModel#finalize}\n * * Stored in {@link XKTModel#tilesList}\n *\n * @class XKTTile\n */\nclass XKTTile {\n\n    /**\n     * Creates a new XKTTile.\n     *\n     * @private\n     * @param aabb\n     * @param entities\n     */\n    constructor(aabb, entities) {\n\n        /**\n         * Axis-aligned World-space bounding box that encloses the {@link XKTEntity}'s within this Tile.\n         *\n         * @type {Float64Array}\n         */\n        this.aabb = aabb;\n\n        /**\n         * The {@link XKTEntity}'s within this XKTTile.\n         *\n         * @type {XKTEntity[]}\n         */\n        this.entities = entities;\n    }\n}\n\nexport {XKTTile};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/XKTTile.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 224,
    "kind": "class",
    "name": "XKTTile",
    "memberof": "src/XKTModel/XKTTile.js",
    "static": true,
    "longname": "src/XKTModel/XKTTile.js~XKTTile",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/XKTTile.js",
    "importStyle": "{XKTTile}",
    "description": "A box-shaped 3D region within an {@link XKTModel} that contains {@link XKTEntity}s.\n\n* Created by {@link XKTModel#finalize}\n* Stored in {@link XKTModel#tilesList}",
    "lineNumber": 9,
    "unknown": [
      {
        "tagName": "@class",
        "tagValue": "XKTTile"
      }
    ],
    "interface": false
  },
  {
    "__docId__": 225,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/XKTModel/XKTTile.js~XKTTile",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/XKTModel/XKTTile.js~XKTTile#constructor",
    "access": "private",
    "description": "Creates a new XKTTile.",
    "lineNumber": 18,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "aabb",
        "description": ""
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "entities",
        "description": ""
      }
    ],
    "ignore": true
  },
  {
    "__docId__": 226,
    "kind": "member",
    "name": "aabb",
    "memberof": "src/XKTModel/XKTTile.js~XKTTile",
    "static": false,
    "longname": "src/XKTModel/XKTTile.js~XKTTile#aabb",
    "access": "public",
    "description": "Axis-aligned World-space bounding box that encloses the {@link XKTEntity}'s within this Tile.",
    "lineNumber": 25,
    "type": {
      "nullable": null,
      "types": [
        "Float64Array"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 227,
    "kind": "member",
    "name": "entities",
    "memberof": "src/XKTModel/XKTTile.js~XKTTile",
    "static": false,
    "longname": "src/XKTModel/XKTTile.js~XKTTile#entities",
    "access": "public",
    "description": "The {@link XKTEntity}'s within this XKTTile.",
    "lineNumber": 32,
    "type": {
      "nullable": null,
      "types": [
        "XKTEntity[]"
      ],
      "spread": false,
      "description": null
    }
  },
  {
    "__docId__": 228,
    "kind": "file",
    "name": "src/XKTModel/lib/buildEdgeIndices.js",
    "content": "import {math} from \"../../lib/math.js\";\n\n/**\n * @private\n */\nconst buildEdgeIndices = (function () {\n\n    const uniquePositions = [];\n    const indicesLookup = [];\n    const indicesReverseLookup = [];\n    const weldedIndices = [];\n\n// TODO: Optimize with caching, but need to cater to both compressed and uncompressed positions\n\n    const faces = [];\n    let numFaces = 0;\n    const compa = new Uint16Array(3);\n    const compb = new Uint16Array(3);\n    const compc = new Uint16Array(3);\n    const a = math.vec3();\n    const b = math.vec3();\n    const c = math.vec3();\n    const cb = math.vec3();\n    const ab = math.vec3();\n    const cross = math.vec3();\n    const normal = math.vec3();\n    const inverseNormal = math.vec3();\n\n    function weldVertices(positions, indices) {\n        const positionsMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)\n        let vx;\n        let vy;\n        let vz;\n        let key;\n        const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n        const precision = Math.pow(10, precisionPoints);\n        let i;\n        let len;\n        let lenUniquePositions = 0;\n        for (i = 0, len = positions.length; i < len; i += 3) {\n            vx = positions[i];\n            vy = positions[i + 1];\n            vz = positions[i + 2];\n            key = Math.round(vx * precision) + '_' + Math.round(vy * precision) + '_' + Math.round(vz * precision);\n            if (positionsMap[key] === undefined) {\n                positionsMap[key] = lenUniquePositions / 3;\n                uniquePositions[lenUniquePositions++] = vx;\n                uniquePositions[lenUniquePositions++] = vy;\n                uniquePositions[lenUniquePositions++] = vz;\n            }\n            indicesLookup[i / 3] = positionsMap[key];\n        }\n        for (i = 0, len = indices.length; i < len; i++) {\n            weldedIndices[i] = indicesLookup[indices[i]];\n            indicesReverseLookup[weldedIndices[i]] = indices[i];\n        }\n    }\n\n    function buildFaces(numIndices, positionsDecodeMatrix) {\n        numFaces = 0;\n        for (let i = 0, len = numIndices; i < len; i += 3) {\n            const ia = ((weldedIndices[i]) * 3);\n            const ib = ((weldedIndices[i + 1]) * 3);\n            const ic = ((weldedIndices[i + 2]) * 3);\n            if (positionsDecodeMatrix) {\n                compa[0] = uniquePositions[ia];\n                compa[1] = uniquePositions[ia + 1];\n                compa[2] = uniquePositions[ia + 2];\n                compb[0] = uniquePositions[ib];\n                compb[1] = uniquePositions[ib + 1];\n                compb[2] = uniquePositions[ib + 2];\n                compc[0] = uniquePositions[ic];\n                compc[1] = uniquePositions[ic + 1];\n                compc[2] = uniquePositions[ic + 2];\n                // Decode\n                math.decompressPosition(compa, positionsDecodeMatrix, a);\n                math.decompressPosition(compb, positionsDecodeMatrix, b);\n                math.decompressPosition(compc, positionsDecodeMatrix, c);\n            } else {\n                a[0] = uniquePositions[ia];\n                a[1] = uniquePositions[ia + 1];\n                a[2] = uniquePositions[ia + 2];\n                b[0] = uniquePositions[ib];\n                b[1] = uniquePositions[ib + 1];\n                b[2] = uniquePositions[ib + 2];\n                c[0] = uniquePositions[ic];\n                c[1] = uniquePositions[ic + 1];\n                c[2] = uniquePositions[ic + 2];\n            }\n            math.subVec3(c, b, cb);\n            math.subVec3(a, b, ab);\n            math.cross3Vec3(cb, ab, cross);\n            math.normalizeVec3(cross, normal);\n            const face = faces[numFaces] || (faces[numFaces] = {normal: math.vec3()});\n            face.normal[0] = normal[0];\n            face.normal[1] = normal[1];\n            face.normal[2] = normal[2];\n            numFaces++;\n        }\n    }\n\n    return function (positions, indices, positionsDecodeMatrix, edgeThreshold) {\n        weldVertices(positions, indices);\n        buildFaces(indices.length, positionsDecodeMatrix);\n        const edgeIndices = [];\n        const thresholdDot = Math.cos(math.DEGTORAD * edgeThreshold);\n        const edges = {};\n        let edge1;\n        let edge2;\n        let index1;\n        let index2;\n        let key;\n        let largeIndex = false;\n        let edge;\n        let normal1;\n        let normal2;\n        let dot;\n        let ia;\n        let ib;\n        for (let i = 0, len = indices.length; i < len; i += 3) {\n            const faceIndex = i / 3;\n            for (let j = 0; j < 3; j++) {\n                edge1 = weldedIndices[i + j];\n                edge2 = weldedIndices[i + ((j + 1) % 3)];\n                index1 = Math.min(edge1, edge2);\n                index2 = Math.max(edge1, edge2);\n                key = index1 + ',' + index2;\n                if (edges[key] === undefined) {\n                    edges[key] = {\n                        index1: index1,\n                        index2: index2,\n                        face1: faceIndex,\n                        face2: undefined,\n                    };\n                } else {\n                    edges[key].face2 = faceIndex;\n                }\n            }\n        }\n        for (key in edges) {\n            edge = edges[key];\n            // an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.\n            if (edge.face2 !== undefined) {\n                normal1 = faces[edge.face1].normal;\n                normal2 = faces[edge.face2].normal;\n                inverseNormal[0] = -normal2[0];\n                inverseNormal[1] = -normal2[1];\n                inverseNormal[2] = -normal2[2];\n                dot = Math.abs(math.dotVec3(normal1, normal2));\n                const dot2 = Math.abs(math.dotVec3(normal1, inverseNormal));\n                if (dot > thresholdDot && dot2 > thresholdDot) {\n                    continue;\n                }\n            }\n            ia = indicesReverseLookup[edge.index1];\n            ib = indicesReverseLookup[edge.index2];\n            if (!largeIndex && ia > 65535 || ib > 65535) {\n                largeIndex = true;\n            }\n            edgeIndices.push(ia);\n            edgeIndices.push(ib);\n        }\n        return (largeIndex) ? new Uint32Array(edgeIndices) : new Uint16Array(edgeIndices);\n    };\n})();\n\n\nexport {buildEdgeIndices};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/lib/buildEdgeIndices.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 229,
    "kind": "variable",
    "name": "buildEdgeIndices",
    "memberof": "src/XKTModel/lib/buildEdgeIndices.js",
    "static": true,
    "longname": "src/XKTModel/lib/buildEdgeIndices.js~buildEdgeIndices",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/buildEdgeIndices.js",
    "importStyle": "{buildEdgeIndices}",
    "description": "",
    "lineNumber": 6,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 230,
    "kind": "file",
    "name": "src/XKTModel/lib/buildFaceNormals.js",
    "content": "import {math} from \"./math.js\";\n\n/**\n * Builds face-aligned vertex normal vectors from positions and indices.\n *\n * @private\n */\nfunction buildFaceNormals(positions, indices, normals) {\n\n    const a = math.vec3();\n    const b = math.vec3();\n    const c = math.vec3();\n\n    const normVec = math.vec3();\n\n    for (let i = 0, len = indices.length; i < len; i += 3) {\n\n        const j0 = indices[i];\n        const j1 = indices[i + 1];\n        const j2 = indices[i + 2];\n\n        a[0] = positions[j0 * 3];\n        a[1] = positions[j0 * 3 + 1];\n        a[2] = positions[j0 * 3 + 2];\n\n        b[0] = positions[j1 * 3];\n        b[1] = positions[j1 * 3 + 1];\n        b[2] = positions[j1 * 3 + 2];\n\n        c[0] = positions[j2 * 3];\n        c[1] = positions[j2 * 3 + 1];\n        c[2] = positions[j2 * 3 + 2];\n\n        triangleNormal(a,b,c, normVec);\n\n        normals[j0 * 3 + 0] = normVec[0];\n        normals[j0 * 3 + 1] = normVec[1];\n        normals[j0 * 3 + 2] = normVec[2];\n\n        normals[j1 * 3 + 0] = normVec[0];\n        normals[j1 * 3 + 1] = normVec[1];\n        normals[j1 * 3 + 2] = normVec[2];\n\n        normals[j2 * 3 + 0] = normVec[0];\n        normals[j2 * 3 + 1] = normVec[1];\n        normals[j2 * 3 + 2] = normVec[2];\n    }\n}\n\nfunction triangleNormal(a, b, c, normal = math.vec3()) {\n    const p1x = b[0] - a[0];\n    const p1y = b[1] - a[1];\n    const p1z = b[2] - a[2];\n\n    const p2x = c[0] - a[0];\n    const p2y = c[1] - a[1];\n    const p2z = c[2] - a[2];\n\n    const p3x = p1y * p2z - p1z * p2y;\n    const p3y = p1z * p2x - p1x * p2z;\n    const p3z = p1x * p2y - p1y * p2x;\n\n    const mag = Math.sqrt(p3x * p3x + p3y * p3y + p3z * p3z);\n    if (mag === 0) {\n        normal[0] = 0;\n        normal[1] = 0;\n        normal[2] = 0;\n    } else {\n        normal[0] = p3x / mag;\n        normal[1] = p3y / mag;\n        normal[2] = p3z / mag;\n    }\n\n    return normal\n}\n\nexport {buildFaceNormals};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/lib/buildFaceNormals.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 231,
    "kind": "function",
    "name": "triangleNormal",
    "memberof": "src/XKTModel/lib/buildFaceNormals.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/buildFaceNormals.js~triangleNormal",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/buildFaceNormals.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      },
      {
        "name": "c",
        "types": [
          "*"
        ]
      },
      {
        "name": "normal",
        "optional": true,
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 232,
    "kind": "function",
    "name": "buildFaceNormals",
    "memberof": "src/XKTModel/lib/buildFaceNormals.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/buildFaceNormals.js~buildFaceNormals",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/buildFaceNormals.js",
    "importStyle": "{buildFaceNormals}",
    "description": "Builds face-aligned vertex normal vectors from positions and indices.",
    "lineNumber": 8,
    "ignore": true,
    "params": [
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "indices",
        "types": [
          "*"
        ]
      },
      {
        "name": "normals",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 233,
    "kind": "file",
    "name": "src/XKTModel/lib/buildVertexNormals.js",
    "content": "import {math} from \"./math.js\";\n\n/**\n * Builds vertex normal vectors from positions and indices.\n *\n * @private\n */\nfunction buildVertexNormals(positions, indices, normals) {\n\n    const a = math.vec3();\n    const b = math.vec3();\n    const c = math.vec3();\n    const ab = math.vec3();\n    const ac = math.vec3();\n    const crossVec = math.vec3();\n    const nvecs = new Array(positions.length / 3);\n\n    for (let i = 0, len = indices.length; i < len; i += 3) {\n\n        const j0 = indices[i];\n        const j1 = indices[i + 1];\n        const j2 = indices[i + 2];\n\n        a[0] = positions[j0 * 3];\n        a[1] = positions[j0 * 3 + 1];\n        a[2] = positions[j0 * 3 + 2];\n\n        b[0] = positions[j1 * 3];\n        b[1] = positions[j1 * 3 + 1];\n        b[2] = positions[j1 * 3 + 2];\n\n        c[0] = positions[j2 * 3];\n        c[1] = positions[j2 * 3 + 1];\n        c[2] = positions[j2 * 3 + 2];\n\n        math.subVec3(b, a, ab);\n        math.subVec3(c, a, ac);\n\n        const normVec = math.vec3();\n\n        math.normalizeVec3(math.cross3Vec3(ab, ac, crossVec), normVec);\n\n        if (!nvecs[j0]) {\n            nvecs[j0] = [];\n        }\n        if (!nvecs[j1]) {\n            nvecs[j1] = [];\n        }\n        if (!nvecs[j2]) {\n            nvecs[j2] = [];\n        }\n\n        nvecs[j0].push(normVec);\n        nvecs[j1].push(normVec);\n        nvecs[j2].push(normVec);\n    }\n\n    normals = (normals && normals.length === positions.length) ? normals : new Float32Array(positions.length);\n\n    for (let i = 0, len = nvecs.length; i < len; i++) {  // Now go through and average out everything\n\n        const count = nvecs[i].length;\n\n        let x = 0;\n        let y = 0;\n        let z = 0;\n\n        for (let j = 0; j < count; j++) {\n            x += nvecs[i][j][0];\n            y += nvecs[i][j][1];\n            z += nvecs[i][j][2];\n        }\n\n        normals[i * 3] = (x / count);\n        normals[i * 3 + 1] = (y / count);\n        normals[i * 3 + 2] = (z / count);\n    }\n\n    return normals;\n}\n\nexport {buildVertexNormals};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/lib/buildVertexNormals.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 234,
    "kind": "function",
    "name": "buildVertexNormals",
    "memberof": "src/XKTModel/lib/buildVertexNormals.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/buildVertexNormals.js~buildVertexNormals",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/buildVertexNormals.js",
    "importStyle": "{buildVertexNormals}",
    "description": "Builds vertex normal vectors from positions and indices.",
    "lineNumber": 8,
    "ignore": true,
    "params": [
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "indices",
        "types": [
          "*"
        ]
      },
      {
        "name": "normals",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 235,
    "kind": "file",
    "name": "src/XKTModel/lib/earcut.js",
    "content": "/** @private */\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 1 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim);\n            triangles.push(ear.i / dim);\n            triangles.push(next.i / dim);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n                // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n                // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var p = ear.next.next;\n\n    while (p !== ear.prev) {\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // triangle bbox; min & max are calculated like this for speed\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\n        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\n        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\n        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(minTX, minTY, minX, minY, invSize),\n        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim);\n            triangles.push(p.i / dim);\n            triangles.push(b.i / dim);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize);\n                earcutLinked(c, triangles, dim, minX, minY, invSize);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        eliminateHole(queue[i], outerNode);\n        outerNode = filterPoints(outerNode, outerNode.next);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    outerNode = findHoleBridge(hole, outerNode);\n    if (outerNode) {\n        var b = splitPolygon(outerNode, hole);\n\n        // filter collinear points around the cuts\n        filterPoints(outerNode, outerNode.next);\n        filterPoints(b, b.next);\n    }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                if (x === hx) {\n                    if (hy === p.y) return p;\n                    if (hy === p.next.y) return p.next;\n                }\n                m = p.x < p.next.x ? p : p.next;\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n            pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = 32767 * (x - minX) * invSize;\n    y = 32767 * (y - minY) * invSize;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n        (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n        (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n        (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n            intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n            (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = null;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n\nexport {earcut};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/lib/earcut.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 236,
    "kind": "function",
    "name": "linkedList",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~linkedList",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "end",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      },
      {
        "name": "clockwise",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 237,
    "kind": "function",
    "name": "filterPoints",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~filterPoints",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "end",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 238,
    "kind": "function",
    "name": "earcutLinked",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~earcutLinked",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 84,
    "undocument": true,
    "params": [
      {
        "name": "ear",
        "types": [
          "*"
        ]
      },
      {
        "name": "triangles",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      },
      {
        "name": "minX",
        "types": [
          "*"
        ]
      },
      {
        "name": "minY",
        "types": [
          "*"
        ]
      },
      {
        "name": "invSize",
        "types": [
          "*"
        ]
      },
      {
        "name": "pass",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 239,
    "kind": "function",
    "name": "isEar",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~isEar",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 137,
    "undocument": true,
    "params": [
      {
        "name": "ear",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 240,
    "kind": "function",
    "name": "isEarHashed",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~isEarHashed",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 156,
    "undocument": true,
    "params": [
      {
        "name": "ear",
        "types": [
          "*"
        ]
      },
      {
        "name": "minX",
        "types": [
          "*"
        ]
      },
      {
        "name": "minY",
        "types": [
          "*"
        ]
      },
      {
        "name": "invSize",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 241,
    "kind": "function",
    "name": "cureLocalIntersections",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~cureLocalIntersections",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 209,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "triangles",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 242,
    "kind": "function",
    "name": "splitEarcut",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~splitEarcut",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 234,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "triangles",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      },
      {
        "name": "minX",
        "types": [
          "*"
        ]
      },
      {
        "name": "minY",
        "types": [
          "*"
        ]
      },
      {
        "name": "invSize",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 243,
    "kind": "function",
    "name": "eliminateHoles",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~eliminateHoles",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 260,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "holeIndices",
        "types": [
          "*"
        ]
      },
      {
        "name": "outerNode",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 244,
    "kind": "function",
    "name": "compareX",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~compareX",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 283,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 245,
    "kind": "function",
    "name": "eliminateHole",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~eliminateHole",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 288,
    "undocument": true,
    "params": [
      {
        "name": "hole",
        "types": [
          "*"
        ]
      },
      {
        "name": "outerNode",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 246,
    "kind": "function",
    "name": "findHoleBridge",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~findHoleBridge",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 300,
    "undocument": true,
    "params": [
      {
        "name": "hole",
        "types": [
          "*"
        ]
      },
      {
        "name": "outerNode",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 247,
    "kind": "function",
    "name": "sectorContainsSector",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~sectorContainsSector",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 360,
    "undocument": true,
    "params": [
      {
        "name": "m",
        "types": [
          "*"
        ]
      },
      {
        "name": "p",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 248,
    "kind": "function",
    "name": "indexCurve",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~indexCurve",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 365,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "minX",
        "types": [
          "*"
        ]
      },
      {
        "name": "minY",
        "types": [
          "*"
        ]
      },
      {
        "name": "invSize",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 249,
    "kind": "function",
    "name": "sortLinked",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~sortLinked",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 382,
    "undocument": true,
    "params": [
      {
        "name": "list",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 250,
    "kind": "function",
    "name": "zOrder",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~zOrder",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 434,
    "undocument": true,
    "params": [
      {
        "name": "x",
        "types": [
          "*"
        ]
      },
      {
        "name": "y",
        "types": [
          "*"
        ]
      },
      {
        "name": "minX",
        "types": [
          "*"
        ]
      },
      {
        "name": "minY",
        "types": [
          "*"
        ]
      },
      {
        "name": "invSize",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 251,
    "kind": "function",
    "name": "getLeftmost",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~getLeftmost",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 453,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 252,
    "kind": "function",
    "name": "pointInTriangle",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~pointInTriangle",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 465,
    "undocument": true,
    "params": [
      {
        "name": "ax",
        "types": [
          "*"
        ]
      },
      {
        "name": "ay",
        "types": [
          "*"
        ]
      },
      {
        "name": "bx",
        "types": [
          "*"
        ]
      },
      {
        "name": "by",
        "types": [
          "*"
        ]
      },
      {
        "name": "cx",
        "types": [
          "*"
        ]
      },
      {
        "name": "cy",
        "types": [
          "*"
        ]
      },
      {
        "name": "px",
        "types": [
          "*"
        ]
      },
      {
        "name": "py",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 253,
    "kind": "function",
    "name": "isValidDiagonal",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~isValidDiagonal",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 472,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 254,
    "kind": "function",
    "name": "area",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~area",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 480,
    "undocument": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      },
      {
        "name": "q",
        "types": [
          "*"
        ]
      },
      {
        "name": "r",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 255,
    "kind": "function",
    "name": "equals",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~equals",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 485,
    "undocument": true,
    "params": [
      {
        "name": "p1",
        "types": [
          "*"
        ]
      },
      {
        "name": "p2",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 256,
    "kind": "function",
    "name": "intersects",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~intersects",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 490,
    "undocument": true,
    "params": [
      {
        "name": "p1",
        "types": [
          "*"
        ]
      },
      {
        "name": "q1",
        "types": [
          "*"
        ]
      },
      {
        "name": "p2",
        "types": [
          "*"
        ]
      },
      {
        "name": "q2",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 257,
    "kind": "function",
    "name": "onSegment",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~onSegment",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 507,
    "undocument": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      },
      {
        "name": "q",
        "types": [
          "*"
        ]
      },
      {
        "name": "r",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 258,
    "kind": "function",
    "name": "sign",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~sign",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 511,
    "undocument": true,
    "params": [
      {
        "name": "num",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 259,
    "kind": "function",
    "name": "intersectsPolygon",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~intersectsPolygon",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 516,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 260,
    "kind": "function",
    "name": "locallyInside",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~locallyInside",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 528,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 261,
    "kind": "function",
    "name": "middleInside",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~middleInside",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 535,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 262,
    "kind": "function",
    "name": "splitPolygon",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~splitPolygon",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 552,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 263,
    "kind": "function",
    "name": "insertNode",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~insertNode",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 574,
    "undocument": true,
    "params": [
      {
        "name": "i",
        "types": [
          "*"
        ]
      },
      {
        "name": "x",
        "types": [
          "*"
        ]
      },
      {
        "name": "y",
        "types": [
          "*"
        ]
      },
      {
        "name": "last",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 264,
    "kind": "function",
    "name": "removeNode",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~removeNode",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 590,
    "undocument": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 265,
    "kind": "function",
    "name": "Node",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~Node",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 598,
    "undocument": true,
    "params": [
      {
        "name": "i",
        "types": [
          "*"
        ]
      },
      {
        "name": "x",
        "types": [
          "*"
        ]
      },
      {
        "name": "y",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 266,
    "kind": "function",
    "name": "deviation",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~deviation",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 623,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "holeIndices",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      },
      {
        "name": "triangles",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 267,
    "kind": "function",
    "name": "signedArea",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~signedArea",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 650,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "end",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 268,
    "kind": "function",
    "name": "flatten",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~flatten",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 660,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 269,
    "kind": "function",
    "name": "earcut",
    "memberof": "src/XKTModel/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/earcut.js~earcut",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/earcut.js",
    "importStyle": "{earcut}",
    "description": null,
    "lineNumber": 2,
    "ignore": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "holeIndices",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 270,
    "kind": "file",
    "name": "src/XKTModel/lib/faceToVertexNormals.js",
    "content": "import {math} from \"./math.js\";\n\n/**\n * Converts surface-perpendicular face normals to vertex normals. Assumes that the mesh contains disjoint triangles\n * that don't share vertex array elements. Works by finding groups of vertices that have the same location and\n * averaging their normal vectors.\n *\n * @returns {{positions: Array, normals: *}}\n * @private\n */\nfunction faceToVertexNormals(positions, normals, options = {}) {\n    const smoothNormalsAngleThreshold = options.smoothNormalsAngleThreshold || 20;\n    const vertexMap = {};\n    const vertexNormals = [];\n    const vertexNormalAccum = {};\n    let acc;\n    let vx;\n    let vy;\n    let vz;\n    let key;\n    const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n    const precision = 10 ** precisionPoints;\n    let posi;\n    let i;\n    let j;\n    let len;\n    let a;\n    let b;\n    let c;\n\n    for (i = 0, len = positions.length; i < len; i += 3) {\n\n        posi = i / 3;\n\n        vx = positions[i];\n        vy = positions[i + 1];\n        vz = positions[i + 2];\n\n        key = `${Math.round(vx * precision)}_${Math.round(vy * precision)}_${Math.round(vz * precision)}`;\n\n        if (vertexMap[key] === undefined) {\n            vertexMap[key] = [posi];\n        } else {\n            vertexMap[key].push(posi);\n        }\n\n        const normal = math.normalizeVec3([normals[i], normals[i + 1], normals[i + 2]]);\n\n        vertexNormals[posi] = normal;\n\n        acc = math.vec4([normal[0], normal[1], normal[2], 1]);\n\n        vertexNormalAccum[posi] = acc;\n    }\n\n    for (key in vertexMap) {\n\n        if (vertexMap.hasOwnProperty(key)) {\n\n            const vertices = vertexMap[key];\n            const numVerts = vertices.length;\n\n            for (i = 0; i < numVerts; i++) {\n\n                const ii = vertices[i];\n\n                acc = vertexNormalAccum[ii];\n\n                for (j = 0; j < numVerts; j++) {\n\n                    if (i === j) {\n                        continue;\n                    }\n\n                    const jj = vertices[j];\n\n                    a = vertexNormals[ii];\n                    b = vertexNormals[jj];\n\n                    const angle = Math.abs(math.angleVec3(a, b) / math.DEGTORAD);\n\n                    if (angle < smoothNormalsAngleThreshold) {\n\n                        acc[0] += b[0];\n                        acc[1] += b[1];\n                        acc[2] += b[2];\n                        acc[3] += 1.0;\n                    }\n                }\n            }\n        }\n    }\n\n    for (i = 0, len = normals.length; i < len; i += 3) {\n\n        acc = vertexNormalAccum[i / 3];\n\n        normals[i + 0] = acc[0] / acc[3];\n        normals[i + 1] = acc[1] / acc[3];\n        normals[i + 2] = acc[2] / acc[3];\n\n    }\n}\n\nexport {faceToVertexNormals};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/lib/faceToVertexNormals.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 271,
    "kind": "function",
    "name": "faceToVertexNormals",
    "memberof": "src/XKTModel/lib/faceToVertexNormals.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/faceToVertexNormals.js~faceToVertexNormals",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/faceToVertexNormals.js",
    "importStyle": "{faceToVertexNormals}",
    "description": "Converts surface-perpendicular face normals to vertex normals. Assumes that the mesh contains disjoint triangles\nthat don't share vertex array elements. Works by finding groups of vertices that have the same location and\naveraging their normal vectors.",
    "lineNumber": 11,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{positions: Array, normals: *}}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{positions: Array, normals: *}"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true,
    "params": [
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "normals",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ]
  },
  {
    "__docId__": 272,
    "kind": "file",
    "name": "src/XKTModel/lib/geometryCompression.js",
    "content": "import {math} from \"../../lib/math.js\";\n\nfunction quantizePositions (positions, lenPositions, aabb, quantizedPositions) {\n    const xmin = aabb[0];\n    const ymin = aabb[1];\n    const zmin = aabb[2];\n    const xwid = aabb[3] - xmin;\n    const ywid = aabb[4] - ymin;\n    const zwid = aabb[5] - zmin;\n    const maxInt = 65535;\n    const xMultiplier = maxInt / xwid;\n    const yMultiplier = maxInt / ywid;\n    const zMultiplier = maxInt / zwid;\n    const verify = (num) => num >= 0 ? num : 0;\n    for (let i = 0; i < lenPositions; i += 3) {\n        quantizedPositions[i + 0] = Math.max(0, Math.min(65535,Math.floor(verify(positions[i + 0] - xmin) * xMultiplier)));\n        quantizedPositions[i + 1] = Math.max(0, Math.min(65535,Math.floor(verify(positions[i + 1] - ymin) * yMultiplier)));\n        quantizedPositions[i + 2] = Math.max(0, Math.min(65535,Math.floor(verify(positions[i + 2] - zmin) * zMultiplier)));\n    }\n}\n\nfunction compressPosition(p, aabb, q) {\n    const multiplier = new Float32Array([\n        aabb[3] !== aabb[0] ? 65535 / (aabb[3] - aabb[0]) : 0,\n        aabb[4] !== aabb[1] ? 65535 / (aabb[4] - aabb[1]) : 0,\n        aabb[5] !== aabb[2] ? 65535 / (aabb[5] - aabb[2]) : 0\n    ]);\n    q[0] = Math.max(0, Math.min(65535, Math.floor((p[0] - aabb[0]) * multiplier[0])));\n    q[1] = Math.max(0, Math.min(65535, Math.floor((p[1] - aabb[1]) * multiplier[1])));\n    q[2] = Math.max(0, Math.min(65535, Math.floor((p[2] - aabb[2]) * multiplier[2])));\n}\n\nvar createPositionsDecodeMatrix = (function () {\n    const translate = math.mat4();\n    const scale = math.mat4();\n    return function (aabb, positionsDecodeMatrix) {\n        positionsDecodeMatrix = positionsDecodeMatrix || math.mat4();\n        const xmin = aabb[0];\n        const ymin = aabb[1];\n        const zmin = aabb[2];\n        const xwid = aabb[3] - xmin;\n        const ywid = aabb[4] - ymin;\n        const zwid = aabb[5] - zmin;\n        const maxInt = 65535;\n        math.identityMat4(translate);\n        math.translationMat4v(aabb, translate);\n        math.identityMat4(scale);\n        math.scalingMat4v([xwid / maxInt, ywid / maxInt, zwid / maxInt], scale);\n        math.mulMat4(translate, scale, positionsDecodeMatrix);\n        return positionsDecodeMatrix;\n    };\n})();\n\nfunction transformAndOctEncodeNormals(modelNormalMatrix, normals, lenNormals, compressedNormals, lenCompressedNormals) {\n    // http://jcgt.org/published/0003/02/01/\n    let oct, dec, best, currentCos, bestCos;\n    let i, ei;\n    let localNormal = math.vec3();\n    let worldNormal =  math.vec3();\n    for (i = 0; i < lenNormals; i += 3) {\n        localNormal[0] = normals[i];\n        localNormal[1] = normals[i + 1];\n        localNormal[2] = normals[i + 2];\n\n        math.transformVec3(modelNormalMatrix, localNormal, worldNormal);\n        math.normalizeVec3(worldNormal, worldNormal);\n\n        // Test various combinations of ceil and floor to minimize rounding errors\n        best = oct = octEncodeVec3(worldNormal, 0, \"floor\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = bestCos = dot(worldNormal, 0, dec);\n        oct = octEncodeVec3(worldNormal, 0, \"ceil\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(worldNormal, 0, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeVec3(worldNormal, 0, \"floor\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(worldNormal, 0, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeVec3(worldNormal, 0, \"ceil\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(worldNormal, 0, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        compressedNormals[lenCompressedNormals + i + 0] = best[0];\n        compressedNormals[lenCompressedNormals + i + 1] = best[1];\n        compressedNormals[lenCompressedNormals + i + 2] = 0.0; // Unused\n    }\n    lenCompressedNormals += lenNormals;\n    return lenCompressedNormals;\n}\n\nfunction octEncodeNormals(normals, lenNormals, compressedNormals, lenCompressedNormals) { // http://jcgt.org/published/0003/02/01/\n    let oct, dec, best, currentCos, bestCos;\n    for (let i = 0; i < lenNormals; i += 3) {\n        // Test various combinations of ceil and floor to minimize rounding errors\n        best = oct = octEncodeVec3(normals, i, \"floor\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = bestCos = dot(normals, i, dec);\n        oct = octEncodeVec3(normals, i, \"ceil\", \"floor\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(normals, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeVec3(normals, i, \"floor\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(normals, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        oct = octEncodeVec3(normals, i, \"ceil\", \"ceil\");\n        dec = octDecodeVec2(oct);\n        currentCos = dot(normals, i, dec);\n        if (currentCos > bestCos) {\n            best = oct;\n            bestCos = currentCos;\n        }\n        compressedNormals[lenCompressedNormals + i + 0] = best[0];\n        compressedNormals[lenCompressedNormals + i + 1] = best[1];\n        compressedNormals[lenCompressedNormals + i + 2] = 0.0; // Unused\n    }\n    lenCompressedNormals += lenNormals;\n    return lenCompressedNormals;\n}\n\n/**\n * @private\n */\nfunction octEncodeVec3(array, i, xfunc, yfunc) { // Oct-encode single normal vector in 2 bytes\n    let x = array[i] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));\n    let y = array[i + 1] / (Math.abs(array[i]) + Math.abs(array[i + 1]) + Math.abs(array[i + 2]));\n    if (array[i + 2] < 0) {\n        let tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n        let tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n        x = tempx;\n        y = tempy;\n    }\n    return new Int8Array([\n        Math[xfunc](x * 127.5 + (x < 0 ? -1 : 0)),\n        Math[yfunc](y * 127.5 + (y < 0 ? -1 : 0))\n    ]);\n}\n\n/**\n * Decode an oct-encoded normal\n */\nfunction octDecodeVec2(oct) {\n    let x = oct[0];\n    let y = oct[1];\n    x /= x < 0 ? 127 : 128;\n    y /= y < 0 ? 127 : 128;\n    const z = 1 - Math.abs(x) - Math.abs(y);\n    if (z < 0) {\n        x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);\n        y = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);\n    }\n    const length = Math.sqrt(x * x + y * y + z * z);\n    return [\n        x / length,\n        y / length,\n        z / length\n    ];\n}\n\n/**\n * Dot product of a normal in an array against a candidate decoding\n * @private\n */\nfunction dot(array, i, vec3) {\n    return array[i] * vec3[0] + array[i + 1] * vec3[1] + array[i + 2] * vec3[2];\n}\n\n/**\n * @private\n */\nconst geometryCompression = {\n    quantizePositions,\n    compressPosition,\n    createPositionsDecodeMatrix,\n    transformAndOctEncodeNormals,\n    octEncodeNormals,\n};\n\nexport {geometryCompression}",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/lib/geometryCompression.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 273,
    "kind": "function",
    "name": "quantizePositions",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~quantizePositions",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "params": [
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "lenPositions",
        "types": [
          "*"
        ]
      },
      {
        "name": "aabb",
        "types": [
          "*"
        ]
      },
      {
        "name": "quantizedPositions",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 274,
    "kind": "function",
    "name": "compressPosition",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~compressPosition",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 22,
    "undocument": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      },
      {
        "name": "aabb",
        "types": [
          "*"
        ]
      },
      {
        "name": "q",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 275,
    "kind": "variable",
    "name": "createPositionsDecodeMatrix",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~createPositionsDecodeMatrix",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 33,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 276,
    "kind": "function",
    "name": "transformAndOctEncodeNormals",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~transformAndOctEncodeNormals",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 54,
    "undocument": true,
    "params": [
      {
        "name": "modelNormalMatrix",
        "types": [
          "*"
        ]
      },
      {
        "name": "normals",
        "types": [
          "*"
        ]
      },
      {
        "name": "lenNormals",
        "types": [
          "*"
        ]
      },
      {
        "name": "compressedNormals",
        "types": [
          "*"
        ]
      },
      {
        "name": "lenCompressedNormals",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 277,
    "kind": "function",
    "name": "octEncodeNormals",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~octEncodeNormals",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 101,
    "undocument": true,
    "params": [
      {
        "name": "normals",
        "types": [
          "*"
        ]
      },
      {
        "name": "lenNormals",
        "types": [
          "*"
        ]
      },
      {
        "name": "compressedNormals",
        "types": [
          "*"
        ]
      },
      {
        "name": "lenCompressedNormals",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 278,
    "kind": "function",
    "name": "octEncodeVec3",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~octEncodeVec3",
    "access": "private",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": "",
    "lineNumber": 140,
    "ignore": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      },
      {
        "name": "i",
        "types": [
          "*"
        ]
      },
      {
        "name": "xfunc",
        "types": [
          "*"
        ]
      },
      {
        "name": "yfunc",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 279,
    "kind": "function",
    "name": "octDecodeVec2",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~octDecodeVec2",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": "Decode an oct-encoded normal",
    "lineNumber": 158,
    "params": [
      {
        "name": "oct",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "undefined[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 280,
    "kind": "function",
    "name": "dot",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~dot",
    "access": "private",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/geometryCompression.js",
    "importStyle": null,
    "description": "Dot product of a normal in an array against a candidate decoding",
    "lineNumber": 180,
    "ignore": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      },
      {
        "name": "i",
        "types": [
          "*"
        ]
      },
      {
        "name": "vec3",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 281,
    "kind": "variable",
    "name": "geometryCompression",
    "memberof": "src/XKTModel/lib/geometryCompression.js",
    "static": true,
    "longname": "src/XKTModel/lib/geometryCompression.js~geometryCompression",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/geometryCompression.js",
    "importStyle": "{geometryCompression}",
    "description": "",
    "lineNumber": 187,
    "ignore": true,
    "type": {
      "types": [
        "{\"quantizePositions\": *, \"compressPosition\": *, \"createPositionsDecodeMatrix\": *, \"transformAndOctEncodeNormals\": *, \"octEncodeNormals\": *}"
      ]
    }
  },
  {
    "__docId__": 282,
    "kind": "file",
    "name": "src/XKTModel/lib/isTriangleMeshSolid.js",
    "content": "/**\n * Uses edge adjacency counts to identify if the given triangle mesh can be rendered with backface culling enabled.\n *\n * If all edges are connected to exactly two triangles, then the mesh will likely be a closed solid, and we can safely\n * render it with backface culling enabled.\n *\n * Otherwise, the mesh is a surface, and we must render it with backface culling disabled.\n *\n * @private\n */\nconst isTriangleMeshSolid = (indices, positions, vertexIndexMapping, edges) => {\n\n    function compareIndexPositions(a, b)\n    {\n        let posA, posB;\n\n        for (let i = 0; i < 3; i++) {\n            posA = positions [a*3+i];\n            posB = positions [b*3+i];\n\n            if (posA !== posB) {\n                return posB - posA;\n            }\n        }\n\n        return 0;\n    };\n\n    // Group together indices corresponding to same position coordinates\n    let newIndices = indices.slice ().sort (compareIndexPositions);\n\n    // Calculate the mapping:\n    // - from original index in indices array\n    // - to indices-for-unique-positions\n    let uniqueVertexIndex = null;\n\n    for (let i = 0, len = newIndices.length; i < len; i++) {\n        if (i == 0 || 0 != compareIndexPositions (\n            newIndices[i],\n            newIndices[i-1],\n        )) {\n            // different position\n            uniqueVertexIndex = newIndices [i];\n        }\n\n        vertexIndexMapping [\n            newIndices[i]\n            ] = uniqueVertexIndex;\n    }\n\n    // Generate the list of edges\n    for (let i = 0, len = indices.length; i < len; i += 3) {\n\n        const a = vertexIndexMapping[indices[i]];\n        const b = vertexIndexMapping[indices[i+1]];\n        const c = vertexIndexMapping[indices[i+2]];\n\n        let a2 = a;\n        let b2 = b;\n        let c2 = c;\n\n        if (a > b && a > c) {\n            if (b > c) {\n                a2 = a;\n                b2 = b;\n                c2 = c;\n            } else {\n                a2 = a;\n                b2 = c;\n                c2 = b;\n            }\n        } else if (b > a && b > c) {\n            if (a > c) {\n                a2 = b;\n                b2 = a;\n                c2 = c;\n            } else {\n                a2 = b;\n                b2 = c;\n                c2 = a;\n            }\n        } else if (c > a && c > b) {\n            if (a > b) {\n                a2 = c;\n                b2 = a;\n                c2 = b;\n            } else {\n                a2 = c;\n                b2 = b;\n                c2 = a;\n            }\n        }\n\n        edges[i+0] = [\n            a2, b2\n        ];\n        edges[i+1] = [\n            b2, c2\n        ];\n\n        if (a2 > c2) {\n            const temp = c2;\n            c2 = a2;\n            a2 = temp;\n        }\n\n        edges[i+2] = [\n            c2, a2\n        ];\n    }\n\n    // Group semantically equivalent edgdes together\n    function compareEdges (e1, e2) {\n        let a, b;\n\n        for (let i = 0; i < 2; i++) {\n            a = e1[i];\n            b = e2[i];\n\n            if (b !== a) {\n                return b - a;\n            }\n        }\n\n        return 0;\n    }\n\n    edges = edges.slice(0, indices.length);\n\n    edges.sort (compareEdges);\n\n    // Make sure each edge is used exactly twice\n    let sameEdgeCount = 0;\n\n    for (let i = 0; i < edges.length; i++)\n    {\n        if (i === 0 || 0 !== compareEdges (\n            edges[i], edges[i-1]\n        )) {\n            // different edge\n            if (0 !== i && sameEdgeCount !== 2)\n            {\n                return false;\n            }\n\n            sameEdgeCount = 1;\n        }\n        else\n        {\n            // same edge\n            sameEdgeCount++;\n        }\n    }\n\n    if (edges.length > 0 && sameEdgeCount !== 2)\n    {\n        return false;\n    }\n\n    // Each edge is used exactly twice, this is a\n    // watertight surface and hence a solid geometry.\n    return true;\n};\n\nexport {isTriangleMeshSolid};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/lib/isTriangleMeshSolid.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 283,
    "kind": "function",
    "name": "isTriangleMeshSolid",
    "memberof": "src/XKTModel/lib/isTriangleMeshSolid.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/isTriangleMeshSolid.js~isTriangleMeshSolid",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/isTriangleMeshSolid.js",
    "importStyle": "{isTriangleMeshSolid}",
    "description": "Uses edge adjacency counts to identify if the given triangle mesh can be rendered with backface culling enabled.\n\nIf all edges are connected to exactly two triangles, then the mesh will likely be a closed solid, and we can safely\nrender it with backface culling enabled.\n\nOtherwise, the mesh is a surface, and we must render it with backface culling disabled.",
    "lineNumber": 11,
    "ignore": true,
    "params": [
      {
        "name": "indices",
        "types": [
          "*"
        ]
      },
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "vertexIndexMapping",
        "types": [
          "*"
        ]
      },
      {
        "name": "edges",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 284,
    "kind": "file",
    "name": "src/XKTModel/lib/math.js",
    "content": "// Some temporary vars to help avoid garbage collection\n\nconst doublePrecision = true;\nconst FloatArrayType = doublePrecision ? Float64Array : Float32Array;\n\nconst tempMat1 = new FloatArrayType(16);\nconst tempMat2 = new FloatArrayType(16);\nconst tempVec4 = new FloatArrayType(4);\n\n/**\n * @private\n */\nconst math = {\n\n    MIN_DOUBLE: -Number.MAX_SAFE_INTEGER,\n    MAX_DOUBLE:  Number.MAX_SAFE_INTEGER,\n\n    /**\n     * The number of radiians in a degree (0.0174532925).\n     * @property DEGTORAD\n     * @type {Number}\n     */\n    DEGTORAD: 0.0174532925,\n\n    /**\n     * The number of degrees in a radian.\n     * @property RADTODEG\n     * @type {Number}\n     */\n    RADTODEG: 57.295779513,\n\n    /**\n     * Returns a new, uninitialized two-element vector.\n     * @method vec2\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec2(values) {\n        return new FloatArrayType(values || 2);\n    },\n\n    /**\n     * Returns a new, uninitialized three-element vector.\n     * @method vec3\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec3(values) {\n        return new FloatArrayType(values || 3);\n    },\n\n    /**\n     * Returns a new, uninitialized four-element vector.\n     * @method vec4\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec4(values) {\n        return new FloatArrayType(values || 4);\n    },\n\n    /**\n     * Returns a new, uninitialized 3x3 matrix.\n     * @method mat3\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    mat3(values) {\n        return new FloatArrayType(values || 9);\n    },\n\n    /**\n     * Converts a 3x3 matrix to 4x4\n     * @method mat3ToMat4\n     * @param mat3 3x3 matrix.\n     * @param mat4 4x4 matrix\n     * @static\n     * @returns {Number[]}\n     */\n    mat3ToMat4(mat3, mat4 = new FloatArrayType(16)) {\n        mat4[0] = mat3[0];\n        mat4[1] = mat3[1];\n        mat4[2] = mat3[2];\n        mat4[3] = 0;\n        mat4[4] = mat3[3];\n        mat4[5] = mat3[4];\n        mat4[6] = mat3[5];\n        mat4[7] = 0;\n        mat4[8] = mat3[6];\n        mat4[9] = mat3[7];\n        mat4[10] = mat3[8];\n        mat4[11] = 0;\n        mat4[12] = 0;\n        mat4[13] = 0;\n        mat4[14] = 0;\n        mat4[15] = 1;\n        return mat4;\n    },\n\n    /**\n     * Returns a new, uninitialized 4x4 matrix.\n     * @method mat4\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    mat4(values) {\n        return new FloatArrayType(values || 16);\n    },\n\n    /**\n     * Converts a 4x4 matrix to 3x3\n     * @method mat4ToMat3\n     * @param mat4 4x4 matrix.\n     * @param mat3 3x3 matrix\n     * @static\n     * @returns {Number[]}\n     */\n    mat4ToMat3(mat4, mat3) { // TODO\n        //return new FloatArrayType(values || 9);\n    },\n\n    /**\n     * Returns a new UUID.\n     * @method createUUID\n     * @static\n     * @return string The new UUID\n     */\n    createUUID: ((() => {\n        const self = {};\n        const lut = [];\n        for (let i = 0; i < 256; i++) {\n            lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\n        }\n        return () => {\n            const d0 = Math.random() * 0xffffffff | 0;\n            const d1 = Math.random() * 0xffffffff | 0;\n            const d2 = Math.random() * 0xffffffff | 0;\n            const d3 = Math.random() * 0xffffffff | 0;\n            return `${lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff]}-${lut[d1 & 0xff]}${lut[d1 >> 8 & 0xff]}-${lut[d1 >> 16 & 0x0f | 0x40]}${lut[d1 >> 24 & 0xff]}-${lut[d2 & 0x3f | 0x80]}${lut[d2 >> 8 & 0xff]}-${lut[d2 >> 16 & 0xff]}${lut[d2 >> 24 & 0xff]}${lut[d3 & 0xff]}${lut[d3 >> 8 & 0xff]}${lut[d3 >> 16 & 0xff]}${lut[d3 >> 24 & 0xff]}`;\n        };\n    }))(),\n\n    /**\n     * Clamps a value to the given range.\n     * @param {Number} value Value to clamp.\n     * @param {Number} min Lower bound.\n     * @param {Number} max Upper bound.\n     * @returns {Number} Clamped result.\n     */\n    clamp(value, min, max) {\n        return Math.max(min, Math.min(max, value));\n    },\n\n    /**\n     * Floating-point modulus\n     * @method fmod\n     * @static\n     * @param {Number} a\n     * @param {Number} b\n     * @returns {*}\n     */\n    fmod(a, b) {\n        if (a < b) {\n            console.error(\"math.fmod : Attempting to find modulus within negative range - would be infinite loop - ignoring\");\n            return a;\n        }\n        while (b <= a) {\n            a -= b;\n        }\n        return a;\n    },\n\n    /**\n     * Negates a four-element vector.\n     * @method negateVec4\n     * @static\n     * @param {Array(Number)} v Vector to negate\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    negateVec4(v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = -v[0];\n        dest[1] = -v[1];\n        dest[2] = -v[2];\n        dest[3] = -v[3];\n        return dest;\n    },\n\n    /**\n     * Adds one four-element vector to another.\n     * @method addVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    addVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] + v[0];\n        dest[1] = u[1] + v[1];\n        dest[2] = u[2] + v[2];\n        dest[3] = u[3] + v[3];\n        return dest;\n    },\n\n    /**\n     * Adds a scalar value to each element of a four-element vector.\n     * @method addVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    addVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] + s;\n        dest[1] = v[1] + s;\n        dest[2] = v[2] + s;\n        dest[3] = v[3] + s;\n        return dest;\n    },\n\n    /**\n     * Adds one three-element vector to another.\n     * @method addVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    addVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] + v[0];\n        dest[1] = u[1] + v[1];\n        dest[2] = u[2] + v[2];\n        return dest;\n    },\n\n    /**\n     * Adds a scalar value to each element of a three-element vector.\n     * @method addVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    addVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] + s;\n        dest[1] = v[1] + s;\n        dest[2] = v[2] + s;\n        return dest;\n    },\n\n    /**\n     * Subtracts one four-element vector from another.\n     * @method subVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        dest[2] = u[2] - v[2];\n        dest[3] = u[3] - v[3];\n        return dest;\n    },\n\n    /**\n     * Subtracts one three-element vector from another.\n     * @method subVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        dest[2] = u[2] - v[2];\n        return dest;\n    },\n\n    /**\n     * Subtracts one two-element vector from another.\n     * @method subVec2\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec2(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        return dest;\n    },\n\n    /**\n     * Subtracts a scalar value from each element of a four-element vector.\n     * @method subVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    subVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] - s;\n        dest[1] = v[1] - s;\n        dest[2] = v[2] - s;\n        dest[3] = v[3] - s;\n        return dest;\n    },\n\n    /**\n     * Sets each element of a 4-element vector to a scalar value minus the value of that element.\n     * @method subScalarVec4\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    subScalarVec4(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s - v[0];\n        dest[1] = s - v[1];\n        dest[2] = s - v[2];\n        dest[3] = s - v[3];\n        return dest;\n    },\n\n    /**\n     * Multiplies one three-element vector by another.\n     * @method mulVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    mulVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] * v[0];\n        dest[1] = u[1] * v[1];\n        dest[2] = u[2] * v[2];\n        dest[3] = u[3] * v[3];\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a four-element vector by a scalar.\n     * @method mulVec34calar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        dest[2] = v[2] * s;\n        dest[3] = v[3] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a three-element vector by a scalar.\n     * @method mulVec3Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        dest[2] = v[2] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a two-element vector by a scalar.\n     * @method mulVec2Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec2Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        return dest;\n    },\n\n    /**\n     * Divides one three-element vector by another.\n     * @method divVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    divVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] / v[0];\n        dest[1] = u[1] / v[1];\n        dest[2] = u[2] / v[2];\n        return dest;\n    },\n\n    /**\n     * Divides one four-element vector by another.\n     * @method divVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    divVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] / v[0];\n        dest[1] = u[1] / v[1];\n        dest[2] = u[2] / v[2];\n        dest[3] = u[3] / v[3];\n        return dest;\n    },\n\n    /**\n     * Divides a scalar by a three-element vector, returning a new vector.\n     * @method divScalarVec3\n     * @static\n     * @param v vec3\n     * @param s scalar\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divScalarVec3(s, v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s / v[0];\n        dest[1] = s / v[1];\n        dest[2] = s / v[2];\n        return dest;\n    },\n\n    /**\n     * Divides a three-element vector by a scalar.\n     * @method divVec3Scalar\n     * @static\n     * @param v vec3\n     * @param s scalar\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] / s;\n        dest[1] = v[1] / s;\n        dest[2] = v[2] / s;\n        return dest;\n    },\n\n    /**\n     * Divides a four-element vector by a scalar.\n     * @method divVec4Scalar\n     * @static\n     * @param v vec4\n     * @param s scalar\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] / s;\n        dest[1] = v[1] / s;\n        dest[2] = v[2] / s;\n        dest[3] = v[3] / s;\n        return dest;\n    },\n\n\n    /**\n     * Divides a scalar by a four-element vector, returning a new vector.\n     * @method divScalarVec4\n     * @static\n     * @param s scalar\n     * @param v vec4\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divScalarVec4(s, v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s / v[0];\n        dest[1] = s / v[1];\n        dest[2] = s / v[2];\n        dest[3] = s / v[3];\n        return dest;\n    },\n\n    /**\n     * Returns the dot product of two four-element vectors.\n     * @method dotVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec4(u, v) {\n        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2] + u[3] * v[3]);\n    },\n\n    /**\n     * Returns the cross product of two four-element vectors.\n     * @method cross3Vec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The cross product\n     */\n    cross3Vec4(u, v) {\n        const u0 = u[0];\n        const u1 = u[1];\n        const u2 = u[2];\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        return [\n            u1 * v2 - u2 * v1,\n            u2 * v0 - u0 * v2,\n            u0 * v1 - u1 * v0,\n            0.0];\n    },\n\n    /**\n     * Returns the cross product of two three-element vectors.\n     * @method cross3Vec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The cross product\n     */\n    cross3Vec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        const x = u[0];\n        const y = u[1];\n        const z = u[2];\n        const x2 = v[0];\n        const y2 = v[1];\n        const z2 = v[2];\n        dest[0] = y * z2 - z * y2;\n        dest[1] = z * x2 - x * z2;\n        dest[2] = x * y2 - y * x2;\n        return dest;\n    },\n\n\n    sqLenVec4(v) { // TODO\n        return math.dotVec4(v, v);\n    },\n\n    /**\n     * Returns the length of a four-element vector.\n     * @method lenVec4\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec4(v) {\n        return Math.sqrt(math.sqLenVec4(v));\n    },\n\n    /**\n     * Returns the dot product of two three-element vectors.\n     * @method dotVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec3(u, v) {\n        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2]);\n    },\n\n    /**\n     * Returns the dot product of two two-element vectors.\n     * @method dotVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec2(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]);\n    },\n\n\n    sqLenVec3(v) {\n        return math.dotVec3(v, v);\n    },\n\n\n    sqLenVec2(v) {\n        return math.dotVec2(v, v);\n    },\n\n    /**\n     * Returns the length of a three-element vector.\n     * @method lenVec3\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec3(v) {\n        return Math.sqrt(math.sqLenVec3(v));\n    },\n\n    distVec3: ((() => {\n        const vec = new FloatArrayType(3);\n        return (v, w) => math.lenVec3(math.subVec3(v, w, vec));\n    }))(),\n\n    /**\n     * Returns the length of a two-element vector.\n     * @method lenVec2\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec2(v) {\n        return Math.sqrt(math.sqLenVec2(v));\n    },\n\n    distVec2: ((() => {\n        const vec = new FloatArrayType(2);\n        return (v, w) => math.lenVec2(math.subVec2(v, w, vec));\n    }))(),\n\n    /**\n     * @method rcpVec3\n     * @static\n     * @param v vec3\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     *\n     */\n    rcpVec3(v, dest) {\n        return math.divScalarVec3(1.0, v, dest);\n    },\n\n    /**\n     * Normalizes a four-element vector\n     * @method normalizeVec4\n     * @static\n     * @param v vec4\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     *\n     */\n    normalizeVec4(v, dest) {\n        const f = 1.0 / math.lenVec4(v);\n        return math.mulVec4Scalar(v, f, dest);\n    },\n\n    /**\n     * Normalizes a three-element vector\n     * @method normalizeVec4\n     * @static\n     */\n    normalizeVec3(v, dest) {\n        const f = 1.0 / math.lenVec3(v);\n        return math.mulVec3Scalar(v, f, dest);\n    },\n\n    /**\n     * Normalizes a two-element vector\n     * @method normalizeVec2\n     * @static\n     */\n    normalizeVec2(v, dest) {\n        const f = 1.0 / math.lenVec2(v);\n        return math.mulVec2Scalar(v, f, dest);\n    },\n\n    /**\n     * Gets the angle between two vectors\n     * @method angleVec3\n     * @param v\n     * @param w\n     * @returns {number}\n     */\n    angleVec3(v, w) {\n        let theta = math.dotVec3(v, w) / (Math.sqrt(math.sqLenVec3(v) * math.sqLenVec3(w)));\n        theta = theta < -1 ? -1 : (theta > 1 ? 1 : theta);  // Clamp to handle numerical problems\n        return Math.acos(theta);\n    },\n\n    /**\n     * Creates a three-element vector from the rotation part of a sixteen-element matrix.\n     * @param m\n     * @param dest\n     */\n    vec3FromMat4Scale: ((() => {\n\n        const tempVec3 = new FloatArrayType(3);\n\n        return (m, dest) => {\n\n            tempVec3[0] = m[0];\n            tempVec3[1] = m[1];\n            tempVec3[2] = m[2];\n\n            dest[0] = math.lenVec3(tempVec3);\n\n            tempVec3[0] = m[4];\n            tempVec3[1] = m[5];\n            tempVec3[2] = m[6];\n\n            dest[1] = math.lenVec3(tempVec3);\n\n            tempVec3[0] = m[8];\n            tempVec3[1] = m[9];\n            tempVec3[2] = m[10];\n\n            dest[2] = math.lenVec3(tempVec3);\n\n            return dest;\n        };\n    }))(),\n\n    /**\n     * Converts an n-element vector to a JSON-serializable\n     * array with values rounded to two decimal places.\n     */\n    vecToArray: ((() => {\n        function trunc(v) {\n            return Math.round(v * 100000) / 100000\n        }\n\n        return v => {\n            v = Array.prototype.slice.call(v);\n            for (let i = 0, len = v.length; i < len; i++) {\n                v[i] = trunc(v[i]);\n            }\n            return v;\n        };\n    }))(),\n\n    /**\n     * Converts a 3-element vector from an array to an object of the form ````{x:999, y:999, z:999}````.\n     * @param arr\n     * @returns {{x: *, y: *, z: *}}\n     */\n    xyzArrayToObject(arr) {\n        return {\"x\": arr[0], \"y\": arr[1], \"z\": arr[2]};\n    },\n\n    /**\n     * Converts a 3-element vector object of the form ````{x:999, y:999, z:999}```` to an array.\n     * @param xyz\n     * @param  [arry]\n     * @returns {*[]}\n     */\n    xyzObjectToArray(xyz, arry) {\n        arry = arry || new FloatArrayType(3);\n        arry[0] = xyz.x;\n        arry[1] = xyz.y;\n        arry[2] = xyz.z;\n        return arry;\n    },\n\n    /**\n     * Duplicates a 4x4 identity matrix.\n     * @method dupMat4\n     * @static\n     */\n    dupMat4(m) {\n        return m.slice(0, 16);\n    },\n\n    /**\n     * Extracts a 3x3 matrix from a 4x4 matrix.\n     * @method mat4To3\n     * @static\n     */\n    mat4To3(m) {\n        return [\n            m[0], m[1], m[2],\n            m[4], m[5], m[6],\n            m[8], m[9], m[10]\n        ];\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to the given scalar value.\n     * @method m4s\n     * @static\n     */\n    m4s(s) {\n        return [\n            s, s, s, s,\n            s, s, s, s,\n            s, s, s, s,\n            s, s, s, s\n        ];\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to zero.\n     * @method setMat4ToZeroes\n     * @static\n     */\n    setMat4ToZeroes() {\n        return math.m4s(0.0);\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to 1.0.\n     * @method setMat4ToOnes\n     * @static\n     */\n    setMat4ToOnes() {\n        return math.m4s(1.0);\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to 1.0.\n     * @method setMat4ToOnes\n     * @static\n     */\n    diagonalMat4v(v) {\n        return new FloatArrayType([\n            v[0], 0.0, 0.0, 0.0,\n            0.0, v[1], 0.0, 0.0,\n            0.0, 0.0, v[2], 0.0,\n            0.0, 0.0, 0.0, v[3]\n        ]);\n    },\n\n    /**\n     * Returns a 4x4 matrix with diagonal elements set to the given vector.\n     * @method diagonalMat4c\n     * @static\n     */\n    diagonalMat4c(x, y, z, w) {\n        return math.diagonalMat4v([x, y, z, w]);\n    },\n\n    /**\n     * Returns a 4x4 matrix with diagonal elements set to the given scalar.\n     * @method diagonalMat4s\n     * @static\n     */\n    diagonalMat4s(s) {\n        return math.diagonalMat4c(s, s, s, s);\n    },\n\n    /**\n     * Returns a 4x4 identity matrix.\n     * @method identityMat4\n     * @static\n     */\n    identityMat4(mat = new FloatArrayType(16)) {\n        mat[0] = 1.0;\n        mat[1] = 0.0;\n        mat[2] = 0.0;\n        mat[3] = 0.0;\n\n        mat[4] = 0.0;\n        mat[5] = 1.0;\n        mat[6] = 0.0;\n        mat[7] = 0.0;\n\n        mat[8] = 0.0;\n        mat[9] = 0.0;\n        mat[10] = 1.0;\n        mat[11] = 0.0;\n\n        mat[12] = 0.0;\n        mat[13] = 0.0;\n        mat[14] = 0.0;\n        mat[15] = 1.0;\n\n        return mat;\n    },\n\n    /**\n     * Returns a 3x3 identity matrix.\n     * @method identityMat3\n     * @static\n     */\n    identityMat3(mat = new FloatArrayType(9)) {\n        mat[0] = 1.0;\n        mat[1] = 0.0;\n        mat[2] = 0.0;\n\n        mat[3] = 0.0;\n        mat[4] = 1.0;\n        mat[5] = 0.0;\n\n        mat[6] = 0.0;\n        mat[7] = 0.0;\n        mat[8] = 1.0;\n\n        return mat;\n    },\n\n    /**\n     * Tests if the given 4x4 matrix is the identity matrix.\n     * @method isIdentityMat4\n     * @static\n     */\n    isIdentityMat4(m) {\n        if (m[0] !== 1.0 || m[1] !== 0.0 || m[2] !== 0.0 || m[3] !== 0.0 ||\n            m[4] !== 0.0 || m[5] !== 1.0 || m[6] !== 0.0 || m[7] !== 0.0 ||\n            m[8] !== 0.0 || m[9] !== 0.0 || m[10] !== 1.0 || m[11] !== 0.0 ||\n            m[12] !== 0.0 || m[13] !== 0.0 || m[14] !== 0.0 || m[15] !== 1.0) {\n            return false;\n        }\n        return true;\n    },\n\n    /**\n     * Negates the given 4x4 matrix.\n     * @method negateMat4\n     * @static\n     */\n    negateMat4(m, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = -m[0];\n        dest[1] = -m[1];\n        dest[2] = -m[2];\n        dest[3] = -m[3];\n        dest[4] = -m[4];\n        dest[5] = -m[5];\n        dest[6] = -m[6];\n        dest[7] = -m[7];\n        dest[8] = -m[8];\n        dest[9] = -m[9];\n        dest[10] = -m[10];\n        dest[11] = -m[11];\n        dest[12] = -m[12];\n        dest[13] = -m[13];\n        dest[14] = -m[14];\n        dest[15] = -m[15];\n        return dest;\n    },\n\n    /**\n     * Adds the given 4x4 matrices together.\n     * @method addMat4\n     * @static\n     */\n    addMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n        dest[0] = a[0] + b[0];\n        dest[1] = a[1] + b[1];\n        dest[2] = a[2] + b[2];\n        dest[3] = a[3] + b[3];\n        dest[4] = a[4] + b[4];\n        dest[5] = a[5] + b[5];\n        dest[6] = a[6] + b[6];\n        dest[7] = a[7] + b[7];\n        dest[8] = a[8] + b[8];\n        dest[9] = a[9] + b[9];\n        dest[10] = a[10] + b[10];\n        dest[11] = a[11] + b[11];\n        dest[12] = a[12] + b[12];\n        dest[13] = a[13] + b[13];\n        dest[14] = a[14] + b[14];\n        dest[15] = a[15] + b[15];\n        return dest;\n    },\n\n    /**\n     * Adds the given scalar to each element of the given 4x4 matrix.\n     * @method addMat4Scalar\n     * @static\n     */\n    addMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] + s;\n        dest[1] = m[1] + s;\n        dest[2] = m[2] + s;\n        dest[3] = m[3] + s;\n        dest[4] = m[4] + s;\n        dest[5] = m[5] + s;\n        dest[6] = m[6] + s;\n        dest[7] = m[7] + s;\n        dest[8] = m[8] + s;\n        dest[9] = m[9] + s;\n        dest[10] = m[10] + s;\n        dest[11] = m[11] + s;\n        dest[12] = m[12] + s;\n        dest[13] = m[13] + s;\n        dest[14] = m[14] + s;\n        dest[15] = m[15] + s;\n        return dest;\n    },\n\n    /**\n     * Adds the given scalar to each element of the given 4x4 matrix.\n     * @method addScalarMat4\n     * @static\n     */\n    addScalarMat4(s, m, dest) {\n        return math.addMat4Scalar(m, s, dest);\n    },\n\n    /**\n     * Subtracts the second 4x4 matrix from the first.\n     * @method subMat4\n     * @static\n     */\n    subMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n        dest[0] = a[0] - b[0];\n        dest[1] = a[1] - b[1];\n        dest[2] = a[2] - b[2];\n        dest[3] = a[3] - b[3];\n        dest[4] = a[4] - b[4];\n        dest[5] = a[5] - b[5];\n        dest[6] = a[6] - b[6];\n        dest[7] = a[7] - b[7];\n        dest[8] = a[8] - b[8];\n        dest[9] = a[9] - b[9];\n        dest[10] = a[10] - b[10];\n        dest[11] = a[11] - b[11];\n        dest[12] = a[12] - b[12];\n        dest[13] = a[13] - b[13];\n        dest[14] = a[14] - b[14];\n        dest[15] = a[15] - b[15];\n        return dest;\n    },\n\n    /**\n     * Subtracts the given scalar from each element of the given 4x4 matrix.\n     * @method subMat4Scalar\n     * @static\n     */\n    subMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] - s;\n        dest[1] = m[1] - s;\n        dest[2] = m[2] - s;\n        dest[3] = m[3] - s;\n        dest[4] = m[4] - s;\n        dest[5] = m[5] - s;\n        dest[6] = m[6] - s;\n        dest[7] = m[7] - s;\n        dest[8] = m[8] - s;\n        dest[9] = m[9] - s;\n        dest[10] = m[10] - s;\n        dest[11] = m[11] - s;\n        dest[12] = m[12] - s;\n        dest[13] = m[13] - s;\n        dest[14] = m[14] - s;\n        dest[15] = m[15] - s;\n        return dest;\n    },\n\n    /**\n     * Subtracts the given scalar from each element of the given 4x4 matrix.\n     * @method subScalarMat4\n     * @static\n     */\n    subScalarMat4(s, m, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = s - m[0];\n        dest[1] = s - m[1];\n        dest[2] = s - m[2];\n        dest[3] = s - m[3];\n        dest[4] = s - m[4];\n        dest[5] = s - m[5];\n        dest[6] = s - m[6];\n        dest[7] = s - m[7];\n        dest[8] = s - m[8];\n        dest[9] = s - m[9];\n        dest[10] = s - m[10];\n        dest[11] = s - m[11];\n        dest[12] = s - m[12];\n        dest[13] = s - m[13];\n        dest[14] = s - m[14];\n        dest[15] = s - m[15];\n        return dest;\n    },\n\n    /**\n     * Multiplies the two given 4x4 matrix by each other.\n     * @method mulMat4\n     * @static\n     */\n    mulMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = a[0];\n\n        const a01 = a[1];\n        const a02 = a[2];\n        const a03 = a[3];\n        const a10 = a[4];\n        const a11 = a[5];\n        const a12 = a[6];\n        const a13 = a[7];\n        const a20 = a[8];\n        const a21 = a[9];\n        const a22 = a[10];\n        const a23 = a[11];\n        const a30 = a[12];\n        const a31 = a[13];\n        const a32 = a[14];\n        const a33 = a[15];\n        const b00 = b[0];\n        const b01 = b[1];\n        const b02 = b[2];\n        const b03 = b[3];\n        const b10 = b[4];\n        const b11 = b[5];\n        const b12 = b[6];\n        const b13 = b[7];\n        const b20 = b[8];\n        const b21 = b[9];\n        const b22 = b[10];\n        const b23 = b[11];\n        const b30 = b[12];\n        const b31 = b[13];\n        const b32 = b[14];\n        const b33 = b[15];\n\n        dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;\n        dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;\n        dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;\n        dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;\n        dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;\n        dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;\n        dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;\n        dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;\n        dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;\n        dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;\n        dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;\n        dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;\n        dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;\n        dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;\n        dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;\n        dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;\n\n        return dest;\n    },\n\n    /**\n     * Multiplies the two given 3x3 matrices by each other.\n     * @method mulMat4\n     * @static\n     */\n    mulMat3(a, b, dest) {\n        if (!dest) {\n            dest = new FloatArrayType(9);\n        }\n\n        const a11 = a[0];\n        const a12 = a[3];\n        const a13 = a[6];\n        const a21 = a[1];\n        const a22 = a[4];\n        const a23 = a[7];\n        const a31 = a[2];\n        const a32 = a[5];\n        const a33 = a[8];\n        const b11 = b[0];\n        const b12 = b[3];\n        const b13 = b[6];\n        const b21 = b[1];\n        const b22 = b[4];\n        const b23 = b[7];\n        const b31 = b[2];\n        const b32 = b[5];\n        const b33 = b[8];\n\n        dest[0] = a11 * b11 + a12 * b21 + a13 * b31;\n        dest[3] = a11 * b12 + a12 * b22 + a13 * b32;\n        dest[6] = a11 * b13 + a12 * b23 + a13 * b33;\n\n        dest[1] = a21 * b11 + a22 * b21 + a23 * b31;\n        dest[4] = a21 * b12 + a22 * b22 + a23 * b32;\n        dest[7] = a21 * b13 + a22 * b23 + a23 * b33;\n\n        dest[2] = a31 * b11 + a32 * b21 + a33 * b31;\n        dest[5] = a31 * b12 + a32 * b22 + a33 * b32;\n        dest[8] = a31 * b13 + a32 * b23 + a33 * b33;\n\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of the given 4x4 matrix by the given scalar.\n     * @method mulMat4Scalar\n     * @static\n     */\n    mulMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] * s;\n        dest[1] = m[1] * s;\n        dest[2] = m[2] * s;\n        dest[3] = m[3] * s;\n        dest[4] = m[4] * s;\n        dest[5] = m[5] * s;\n        dest[6] = m[6] * s;\n        dest[7] = m[7] * s;\n        dest[8] = m[8] * s;\n        dest[9] = m[9] * s;\n        dest[10] = m[10] * s;\n        dest[11] = m[11] * s;\n        dest[12] = m[12] * s;\n        dest[13] = m[13] * s;\n        dest[14] = m[14] * s;\n        dest[15] = m[15] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies the given 4x4 matrix by the given four-element vector.\n     * @method mulMat4v4\n     * @static\n     */\n    mulMat4v4(m, v, dest = math.vec4()) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;\n        dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;\n        dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;\n        dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;\n        return dest;\n    },\n\n    /**\n     * Transposes the given 4x4 matrix.\n     * @method transposeMat4\n     * @static\n     */\n    transposeMat4(mat, dest) {\n        // If we are transposing ourselves we can skip a few steps but have to cache some values\n        const m4 = mat[4];\n\n        const m14 = mat[14];\n        const m8 = mat[8];\n        const m13 = mat[13];\n        const m12 = mat[12];\n        const m9 = mat[9];\n        if (!dest || mat === dest) {\n            const a01 = mat[1];\n            const a02 = mat[2];\n            const a03 = mat[3];\n            const a12 = mat[6];\n            const a13 = mat[7];\n            const a23 = mat[11];\n            mat[1] = m4;\n            mat[2] = m8;\n            mat[3] = m12;\n            mat[4] = a01;\n            mat[6] = m9;\n            mat[7] = m13;\n            mat[8] = a02;\n            mat[9] = a12;\n            mat[11] = m14;\n            mat[12] = a03;\n            mat[13] = a13;\n            mat[14] = a23;\n            return mat;\n        }\n        dest[0] = mat[0];\n        dest[1] = m4;\n        dest[2] = m8;\n        dest[3] = m12;\n        dest[4] = mat[1];\n        dest[5] = mat[5];\n        dest[6] = m9;\n        dest[7] = m13;\n        dest[8] = mat[2];\n        dest[9] = mat[6];\n        dest[10] = mat[10];\n        dest[11] = m14;\n        dest[12] = mat[3];\n        dest[13] = mat[7];\n        dest[14] = mat[11];\n        dest[15] = mat[15];\n        return dest;\n    },\n\n    /**\n     * Transposes the given 3x3 matrix.\n     *\n     * @method transposeMat3\n     * @static\n     */\n    transposeMat3(mat, dest) {\n        if (dest === mat) {\n            const a01 = mat[1];\n            const a02 = mat[2];\n            const a12 = mat[5];\n            dest[1] = mat[3];\n            dest[2] = mat[6];\n            dest[3] = a01;\n            dest[5] = mat[7];\n            dest[6] = a02;\n            dest[7] = a12;\n        } else {\n            dest[0] = mat[0];\n            dest[1] = mat[3];\n            dest[2] = mat[6];\n            dest[3] = mat[1];\n            dest[4] = mat[4];\n            dest[5] = mat[7];\n            dest[6] = mat[2];\n            dest[7] = mat[5];\n            dest[8] = mat[8];\n        }\n        return dest;\n    },\n\n    /**\n     * Returns the determinant of the given 4x4 matrix.\n     * @method determinantMat4\n     * @static\n     */\n    determinantMat4(mat) {\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = mat[0];\n\n        const a01 = mat[1];\n        const a02 = mat[2];\n        const a03 = mat[3];\n        const a10 = mat[4];\n        const a11 = mat[5];\n        const a12 = mat[6];\n        const a13 = mat[7];\n        const a20 = mat[8];\n        const a21 = mat[9];\n        const a22 = mat[10];\n        const a23 = mat[11];\n        const a30 = mat[12];\n        const a31 = mat[13];\n        const a32 = mat[14];\n        const a33 = mat[15];\n        return a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 +\n            a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 +\n            a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 +\n            a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 +\n            a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 +\n            a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33;\n    },\n\n    /**\n     * Returns the inverse of the given 4x4 matrix.\n     * @method inverseMat4\n     * @static\n     */\n    inverseMat4(mat, dest) {\n        if (!dest) {\n            dest = mat;\n        }\n\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = mat[0];\n\n        const a01 = mat[1];\n        const a02 = mat[2];\n        const a03 = mat[3];\n        const a10 = mat[4];\n        const a11 = mat[5];\n        const a12 = mat[6];\n        const a13 = mat[7];\n        const a20 = mat[8];\n        const a21 = mat[9];\n        const a22 = mat[10];\n        const a23 = mat[11];\n        const a30 = mat[12];\n        const a31 = mat[13];\n        const a32 = mat[14];\n        const a33 = mat[15];\n        const b00 = a00 * a11 - a01 * a10;\n        const b01 = a00 * a12 - a02 * a10;\n        const b02 = a00 * a13 - a03 * a10;\n        const b03 = a01 * a12 - a02 * a11;\n        const b04 = a01 * a13 - a03 * a11;\n        const b05 = a02 * a13 - a03 * a12;\n        const b06 = a20 * a31 - a21 * a30;\n        const b07 = a20 * a32 - a22 * a30;\n        const b08 = a20 * a33 - a23 * a30;\n        const b09 = a21 * a32 - a22 * a31;\n        const b10 = a21 * a33 - a23 * a31;\n        const b11 = a22 * a33 - a23 * a32;\n\n        // Calculate the determinant (inlined to avoid double-caching)\n        const invDet = 1 / (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);\n\n        dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;\n        dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;\n        dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;\n        dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;\n        dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;\n        dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;\n        dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;\n        dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;\n        dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;\n        dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;\n        dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;\n        dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;\n        dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;\n        dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;\n        dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;\n        dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;\n\n        return dest;\n    },\n\n    /**\n     * Returns the trace of the given 4x4 matrix.\n     * @method traceMat4\n     * @static\n     */\n    traceMat4(m) {\n        return (m[0] + m[5] + m[10] + m[15]);\n    },\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4\n     * @static\n     */\n    translationMat4v(v, dest) {\n        const m = dest || math.identityMat4();\n        m[12] = v[0];\n        m[13] = v[1];\n        m[14] = v[2];\n        return m;\n    },\n\n    /**\n     * Returns 3x3 translation matrix.\n     * @method translationMat3\n     * @static\n     */\n    translationMat3v(v, dest) {\n        const m = dest || math.identityMat3();\n        m[6] = v[0];\n        m[7] = v[1];\n        return m;\n    },\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4c\n     * @static\n     */\n    translationMat4c: ((() => {\n        const xyz = new FloatArrayType(3);\n        return (x, y, z, dest) => {\n            xyz[0] = x;\n            xyz[1] = y;\n            xyz[2] = z;\n            return math.translationMat4v(xyz, dest);\n        };\n    }))(),\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4s\n     * @static\n     */\n    translationMat4s(s, dest) {\n        return math.translationMat4c(s, s, s, dest);\n    },\n\n    /**\n     * Efficiently post-concatenates a translation to the given matrix.\n     * @param v\n     * @param m\n     */\n    translateMat4v(xyz, m) {\n        return math.translateMat4c(xyz[0], xyz[1], xyz[2], m);\n    },\n\n    /**\n     * Efficiently post-concatenates a translation to the given matrix.\n     * @param x\n     * @param y\n     * @param z\n     * @param m\n     */\n    OLDtranslateMat4c(x, y, z, m) {\n\n        const m12 = m[12];\n        m[0] += m12 * x;\n        m[4] += m12 * y;\n        m[8] += m12 * z;\n\n        const m13 = m[13];\n        m[1] += m13 * x;\n        m[5] += m13 * y;\n        m[9] += m13 * z;\n\n        const m14 = m[14];\n        m[2] += m14 * x;\n        m[6] += m14 * y;\n        m[10] += m14 * z;\n\n        const m15 = m[15];\n        m[3] += m15 * x;\n        m[7] += m15 * y;\n        m[11] += m15 * z;\n\n        return m;\n    },\n\n    translateMat4c(x, y, z, m) {\n\n        const m3 = m[3];\n        m[0] += m3 * x;\n        m[1] += m3 * y;\n        m[2] += m3 * z;\n\n        const m7 = m[7];\n        m[4] += m7 * x;\n        m[5] += m7 * y;\n        m[6] += m7 * z;\n\n        const m11 = m[11];\n        m[8] += m11 * x;\n        m[9] += m11 * y;\n        m[10] += m11 * z;\n\n        const m15 = m[15];\n        m[12] += m15 * x;\n        m[13] += m15 * y;\n        m[14] += m15 * z;\n\n        return m;\n    },\n    /**\n     * Returns 4x4 rotation matrix.\n     * @method rotationMat4v\n     * @static\n     */\n    rotationMat4v(anglerad, axis, m) {\n        const ax = math.normalizeVec4([axis[0], axis[1], axis[2], 0.0], []);\n        const s = Math.sin(anglerad);\n        const c = Math.cos(anglerad);\n        const q = 1.0 - c;\n\n        const x = ax[0];\n        const y = ax[1];\n        const z = ax[2];\n\n        let xy;\n        let yz;\n        let zx;\n        let xs;\n        let ys;\n        let zs;\n\n        //xx = x * x; used once\n        //yy = y * y; used once\n        //zz = z * z; used once\n        xy = x * y;\n        yz = y * z;\n        zx = z * x;\n        xs = x * s;\n        ys = y * s;\n        zs = z * s;\n\n        m = m || math.mat4();\n\n        m[0] = (q * x * x) + c;\n        m[1] = (q * xy) + zs;\n        m[2] = (q * zx) - ys;\n        m[3] = 0.0;\n\n        m[4] = (q * xy) - zs;\n        m[5] = (q * y * y) + c;\n        m[6] = (q * yz) + xs;\n        m[7] = 0.0;\n\n        m[8] = (q * zx) + ys;\n        m[9] = (q * yz) - xs;\n        m[10] = (q * z * z) + c;\n        m[11] = 0.0;\n\n        m[12] = 0.0;\n        m[13] = 0.0;\n        m[14] = 0.0;\n        m[15] = 1.0;\n\n        return m;\n    },\n\n    /**\n     * Returns 4x4 rotation matrix.\n     * @method rotationMat4c\n     * @static\n     */\n    rotationMat4c(anglerad, x, y, z, mat) {\n        return math.rotationMat4v(anglerad, [x, y, z], mat);\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4v\n     * @static\n     */\n    scalingMat4v(v, m = math.identityMat4()) {\n        m[0] = v[0];\n        m[5] = v[1];\n        m[10] = v[2];\n        return m;\n    },\n\n    /**\n     * Returns 3x3 scale matrix.\n     * @method scalingMat3v\n     * @static\n     */\n    scalingMat3v(v, m = math.identityMat3()) {\n        m[0] = v[0];\n        m[4] = v[1];\n        return m;\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4c\n     * @static\n     */\n    scalingMat4c: ((() => {\n        const xyz = new FloatArrayType(3);\n        return (x, y, z, dest) => {\n            xyz[0] = x;\n            xyz[1] = y;\n            xyz[2] = z;\n            return math.scalingMat4v(xyz, dest);\n        };\n    }))(),\n\n    /**\n     * Efficiently post-concatenates a scaling to the given matrix.\n     * @method scaleMat4c\n     * @param x\n     * @param y\n     * @param z\n     * @param m\n     */\n    scaleMat4c(x, y, z, m) {\n\n        m[0] *= x;\n        m[4] *= y;\n        m[8] *= z;\n\n        m[1] *= x;\n        m[5] *= y;\n        m[9] *= z;\n\n        m[2] *= x;\n        m[6] *= y;\n        m[10] *= z;\n\n        m[3] *= x;\n        m[7] *= y;\n        m[11] *= z;\n        return m;\n    },\n\n    /**\n     * Efficiently post-concatenates a scaling to the given matrix.\n     * @method scaleMat4c\n     * @param xyz\n     * @param m\n     */\n    scaleMat4v(xyz, m) {\n\n        const x = xyz[0];\n        const y = xyz[1];\n        const z = xyz[2];\n\n        m[0] *= x;\n        m[4] *= y;\n        m[8] *= z;\n        m[1] *= x;\n        m[5] *= y;\n        m[9] *= z;\n        m[2] *= x;\n        m[6] *= y;\n        m[10] *= z;\n        m[3] *= x;\n        m[7] *= y;\n        m[11] *= z;\n\n        return m;\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4s\n     * @static\n     */\n    scalingMat4s(s) {\n        return math.scalingMat4c(s, s, s);\n    },\n\n    /**\n     * Creates a matrix from a quaternion rotation and vector translation\n     *\n     * @param {Number[]} q Rotation quaternion\n     * @param {Number[]} v Translation vector\n     * @param {Number[]} dest Destination matrix\n     * @returns {Number[]} dest\n     */\n    rotationTranslationMat4(q, v, dest = math.mat4()) {\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n\n        dest[0] = 1 - (yy + zz);\n        dest[1] = xy + wz;\n        dest[2] = xz - wy;\n        dest[3] = 0;\n        dest[4] = xy - wz;\n        dest[5] = 1 - (xx + zz);\n        dest[6] = yz + wx;\n        dest[7] = 0;\n        dest[8] = xz + wy;\n        dest[9] = yz - wx;\n        dest[10] = 1 - (xx + yy);\n        dest[11] = 0;\n        dest[12] = v[0];\n        dest[13] = v[1];\n        dest[14] = v[2];\n        dest[15] = 1;\n\n        return dest;\n    },\n\n    /**\n     * Gets Euler angles from a 4x4 matrix.\n     *\n     * @param {Number[]} mat The 4x4 matrix.\n     * @param {String} order Desired Euler angle order: \"XYZ\", \"YXZ\", \"ZXY\" etc.\n     * @param {Number[]} [dest] Destination Euler angles, created by default.\n     * @returns {Number[]} The Euler angles.\n     */\n    mat4ToEuler(mat, order, dest = math.vec4()) {\n        const clamp = math.clamp;\n\n        // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n        const m11 = mat[0];\n\n        const m12 = mat[4];\n        const m13 = mat[8];\n        const m21 = mat[1];\n        const m22 = mat[5];\n        const m23 = mat[9];\n        const m31 = mat[2];\n        const m32 = mat[6];\n        const m33 = mat[10];\n\n        if (order === 'XYZ') {\n\n            dest[1] = Math.asin(clamp(m13, -1, 1));\n\n            if (Math.abs(m13) < 0.99999) {\n                dest[0] = Math.atan2(-m23, m33);\n                dest[2] = Math.atan2(-m12, m11);\n            } else {\n                dest[0] = Math.atan2(m32, m22);\n                dest[2] = 0;\n\n            }\n\n        } else if (order === 'YXZ') {\n\n            dest[0] = Math.asin(-clamp(m23, -1, 1));\n\n            if (Math.abs(m23) < 0.99999) {\n                dest[1] = Math.atan2(m13, m33);\n                dest[2] = Math.atan2(m21, m22);\n            } else {\n                dest[1] = Math.atan2(-m31, m11);\n                dest[2] = 0;\n            }\n\n        } else if (order === 'ZXY') {\n\n            dest[0] = Math.asin(clamp(m32, -1, 1));\n\n            if (Math.abs(m32) < 0.99999) {\n                dest[1] = Math.atan2(-m31, m33);\n                dest[2] = Math.atan2(-m12, m22);\n            } else {\n                dest[1] = 0;\n                dest[2] = Math.atan2(m21, m11);\n            }\n\n        } else if (order === 'ZYX') {\n\n            dest[1] = Math.asin(-clamp(m31, -1, 1));\n\n            if (Math.abs(m31) < 0.99999) {\n                dest[0] = Math.atan2(m32, m33);\n                dest[2] = Math.atan2(m21, m11);\n            } else {\n                dest[0] = 0;\n                dest[2] = Math.atan2(-m12, m22);\n            }\n\n        } else if (order === 'YZX') {\n\n            dest[2] = Math.asin(clamp(m21, -1, 1));\n\n            if (Math.abs(m21) < 0.99999) {\n                dest[0] = Math.atan2(-m23, m22);\n                dest[1] = Math.atan2(-m31, m11);\n            } else {\n                dest[0] = 0;\n                dest[1] = Math.atan2(m13, m33);\n            }\n\n        } else if (order === 'XZY') {\n\n            dest[2] = Math.asin(-clamp(m12, -1, 1));\n\n            if (Math.abs(m12) < 0.99999) {\n                dest[0] = Math.atan2(m32, m22);\n                dest[1] = Math.atan2(m13, m11);\n            } else {\n                dest[0] = Math.atan2(-m23, m33);\n                dest[1] = 0;\n            }\n        }\n\n        return dest;\n    },\n\n    composeMat4(position, quaternion, scale, mat = math.mat4()) {\n        math.quaternionToRotationMat4(quaternion, mat);\n        math.scaleMat4v(scale, mat);\n        math.translateMat4v(position, mat);\n\n        return mat;\n    },\n\n    decomposeMat4: (() => {\n\n        const vec = new FloatArrayType(3);\n        const matrix = new FloatArrayType(16);\n\n        return function decompose(mat, position, quaternion, scale) {\n\n            vec[0] = mat[0];\n            vec[1] = mat[1];\n            vec[2] = mat[2];\n\n            let sx = math.lenVec3(vec);\n\n            vec[0] = mat[4];\n            vec[1] = mat[5];\n            vec[2] = mat[6];\n\n            const sy = math.lenVec3(vec);\n\n            vec[8] = mat[8];\n            vec[9] = mat[9];\n            vec[10] = mat[10];\n\n            const sz = math.lenVec3(vec);\n\n            // if determine is negative, we need to invert one scale\n            const det = math.determinantMat4(mat);\n\n            if (det < 0) {\n                sx = -sx;\n            }\n\n            position[0] = mat[12];\n            position[1] = mat[13];\n            position[2] = mat[14];\n\n            // scale the rotation part\n            matrix.set(mat);\n\n            const invSX = 1 / sx;\n            const invSY = 1 / sy;\n            const invSZ = 1 / sz;\n\n            matrix[0] *= invSX;\n            matrix[1] *= invSX;\n            matrix[2] *= invSX;\n\n            matrix[4] *= invSY;\n            matrix[5] *= invSY;\n            matrix[6] *= invSY;\n\n            matrix[8] *= invSZ;\n            matrix[9] *= invSZ;\n            matrix[10] *= invSZ;\n\n            math.mat4ToQuaternion(matrix, quaternion);\n\n            scale[0] = sx;\n            scale[1] = sy;\n            scale[2] = sz;\n\n            return this;\n\n        };\n\n    })(),\n\n    /**\n     * Returns a 4x4 'lookat' viewing transform matrix.\n     * @method lookAtMat4v\n     * @param pos vec3 position of the viewer\n     * @param target vec3 point the viewer is looking at\n     * @param up vec3 pointing \"up\"\n     * @param dest mat4 Optional, mat4 matrix will be written into\n     *\n     * @return {mat4} dest if specified, a new mat4 otherwise\n     */\n    lookAtMat4v(pos, target, up, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n\n        const posx = pos[0];\n        const posy = pos[1];\n        const posz = pos[2];\n        const upx = up[0];\n        const upy = up[1];\n        const upz = up[2];\n        const targetx = target[0];\n        const targety = target[1];\n        const targetz = target[2];\n\n        if (posx === targetx && posy === targety && posz === targetz) {\n            return math.identityMat4();\n        }\n\n        let z0;\n        let z1;\n        let z2;\n        let x0;\n        let x1;\n        let x2;\n        let y0;\n        let y1;\n        let y2;\n        let len;\n\n        //vec3.direction(eye, center, z);\n        z0 = posx - targetx;\n        z1 = posy - targety;\n        z2 = posz - targetz;\n\n        // normalize (no check needed for 0 because of early return)\n        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n        z0 *= len;\n        z1 *= len;\n        z2 *= len;\n\n        //vec3.normalize(vec3.cross(up, z, x));\n        x0 = upy * z2 - upz * z1;\n        x1 = upz * z0 - upx * z2;\n        x2 = upx * z1 - upy * z0;\n        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n        if (!len) {\n            x0 = 0;\n            x1 = 0;\n            x2 = 0;\n        } else {\n            len = 1 / len;\n            x0 *= len;\n            x1 *= len;\n            x2 *= len;\n        }\n\n        //vec3.normalize(vec3.cross(z, x, y));\n        y0 = z1 * x2 - z2 * x1;\n        y1 = z2 * x0 - z0 * x2;\n        y2 = z0 * x1 - z1 * x0;\n\n        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n        if (!len) {\n            y0 = 0;\n            y1 = 0;\n            y2 = 0;\n        } else {\n            len = 1 / len;\n            y0 *= len;\n            y1 *= len;\n            y2 *= len;\n        }\n\n        dest[0] = x0;\n        dest[1] = y0;\n        dest[2] = z0;\n        dest[3] = 0;\n        dest[4] = x1;\n        dest[5] = y1;\n        dest[6] = z1;\n        dest[7] = 0;\n        dest[8] = x2;\n        dest[9] = y2;\n        dest[10] = z2;\n        dest[11] = 0;\n        dest[12] = -(x0 * posx + x1 * posy + x2 * posz);\n        dest[13] = -(y0 * posx + y1 * posy + y2 * posz);\n        dest[14] = -(z0 * posx + z1 * posy + z2 * posz);\n        dest[15] = 1;\n\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 'lookat' viewing transform matrix.\n     * @method lookAtMat4c\n     * @static\n     */\n    lookAtMat4c(posx, posy, posz, targetx, targety, targetz, upx, upy, upz) {\n        return math.lookAtMat4v([posx, posy, posz], [targetx, targety, targetz], [upx, upy, upz], []);\n    },\n\n    /**\n     * Returns a 4x4 orthographic projection matrix.\n     * @method orthoMat4c\n     * @static\n     */\n    orthoMat4c(left, right, bottom, top, near, far, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n        const rl = (right - left);\n        const tb = (top - bottom);\n        const fn = (far - near);\n\n        dest[0] = 2.0 / rl;\n        dest[1] = 0.0;\n        dest[2] = 0.0;\n        dest[3] = 0.0;\n\n        dest[4] = 0.0;\n        dest[5] = 2.0 / tb;\n        dest[6] = 0.0;\n        dest[7] = 0.0;\n\n        dest[8] = 0.0;\n        dest[9] = 0.0;\n        dest[10] = -2.0 / fn;\n        dest[11] = 0.0;\n\n        dest[12] = -(left + right) / rl;\n        dest[13] = -(top + bottom) / tb;\n        dest[14] = -(far + near) / fn;\n        dest[15] = 1.0;\n\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method frustumMat4v\n     * @static\n     */\n    frustumMat4v(fmin, fmax, m) {\n        if (!m) {\n            m = math.mat4();\n        }\n\n        const fmin4 = [fmin[0], fmin[1], fmin[2], 0.0];\n        const fmax4 = [fmax[0], fmax[1], fmax[2], 0.0];\n\n        math.addVec4(fmax4, fmin4, tempMat1);\n        math.subVec4(fmax4, fmin4, tempMat2);\n\n        const t = 2.0 * fmin4[2];\n\n        const tempMat20 = tempMat2[0];\n        const tempMat21 = tempMat2[1];\n        const tempMat22 = tempMat2[2];\n\n        m[0] = t / tempMat20;\n        m[1] = 0.0;\n        m[2] = 0.0;\n        m[3] = 0.0;\n\n        m[4] = 0.0;\n        m[5] = t / tempMat21;\n        m[6] = 0.0;\n        m[7] = 0.0;\n\n        m[8] = tempMat1[0] / tempMat20;\n        m[9] = tempMat1[1] / tempMat21;\n        m[10] = -tempMat1[2] / tempMat22;\n        m[11] = -1.0;\n\n        m[12] = 0.0;\n        m[13] = 0.0;\n        m[14] = -t * fmax4[2] / tempMat22;\n        m[15] = 0.0;\n\n        return m;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method frustumMat4v\n     * @static\n     */\n    frustumMat4(left, right, bottom, top, near, far, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n        const rl = (right - left);\n        const tb = (top - bottom);\n        const fn = (far - near);\n        dest[0] = (near * 2) / rl;\n        dest[1] = 0;\n        dest[2] = 0;\n        dest[3] = 0;\n        dest[4] = 0;\n        dest[5] = (near * 2) / tb;\n        dest[6] = 0;\n        dest[7] = 0;\n        dest[8] = (right + left) / rl;\n        dest[9] = (top + bottom) / tb;\n        dest[10] = -(far + near) / fn;\n        dest[11] = -1;\n        dest[12] = 0;\n        dest[13] = 0;\n        dest[14] = -(far * near * 2) / fn;\n        dest[15] = 0;\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method perspectiveMat4v\n     * @static\n     */\n    perspectiveMat4(fovyrad, aspectratio, znear, zfar, m) {\n        const pmin = [];\n        const pmax = [];\n\n        pmin[2] = znear;\n        pmax[2] = zfar;\n\n        pmax[1] = pmin[2] * Math.tan(fovyrad / 2.0);\n        pmin[1] = -pmax[1];\n\n        pmax[0] = pmax[1] * aspectratio;\n        pmin[0] = -pmax[0];\n\n        return math.frustumMat4v(pmin, pmax, m);\n    },\n\n    /**\n     * Transforms a three-element position by a 4x4 matrix.\n     * @method transformPoint3\n     * @static\n     */\n    transformPoint3(m, p, dest = math.vec3()) {\n\n        const x = p[0];\n        const y = p[1];\n        const z = p[2];\n\n        dest[0] = (m[0] * x) + (m[4] * y) + (m[8] * z) + m[12];\n        dest[1] = (m[1] * x) + (m[5] * y) + (m[9] * z) + m[13];\n        dest[2] = (m[2] * x) + (m[6] * y) + (m[10] * z) + m[14];\n\n        return dest;\n    },\n\n    /**\n     * Transforms a homogeneous coordinate by a 4x4 matrix.\n     * @method transformPoint3\n     * @static\n     */\n    transformPoint4(m, v, dest = math.vec4()) {\n        dest[0] = m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3];\n        dest[1] = m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3];\n        dest[2] = m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3];\n        dest[3] = m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3];\n\n        return dest;\n    },\n\n\n    /**\n     * Transforms an array of three-element positions by a 4x4 matrix.\n     * @method transformPoints3\n     * @static\n     */\n    transformPoints3(m, points, points2) {\n        const result = points2 || [];\n        const len = points.length;\n        let p0;\n        let p1;\n        let p2;\n        let pi;\n\n        // cache values\n        const m0 = m[0];\n\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        let r;\n\n        for (let i = 0; i < len; ++i) {\n\n            // cache values\n            pi = points[i];\n\n            p0 = pi[0];\n            p1 = pi[1];\n            p2 = pi[2];\n\n            r = result[i] || (result[i] = [0, 0, 0]);\n\n            r[0] = (m0 * p0) + (m4 * p1) + (m8 * p2) + m12;\n            r[1] = (m1 * p0) + (m5 * p1) + (m9 * p2) + m13;\n            r[2] = (m2 * p0) + (m6 * p1) + (m10 * p2) + m14;\n            r[3] = (m3 * p0) + (m7 * p1) + (m11 * p2) + m15;\n        }\n\n        result.length = len;\n\n        return result;\n    },\n\n    /**\n     * Transforms an array of positions by a 4x4 matrix.\n     * @method transformPositions3\n     * @static\n     */\n    transformPositions3(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 3) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /**\n     * Transforms an array of positions by a 4x4 matrix.\n     * @method transformPositions4\n     * @static\n     */\n    transformPositions4(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 4) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /**\n     * Transforms a three-element vector by a 4x4 matrix.\n     * @method transformVec3\n     * @static\n     */\n    transformVec3(m, v, dest) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        dest = dest || this.vec3();\n        dest[0] = (m[0] * v0) + (m[4] * v1) + (m[8] * v2);\n        dest[1] = (m[1] * v0) + (m[5] * v1) + (m[9] * v2);\n        dest[2] = (m[2] * v0) + (m[6] * v1) + (m[10] * v2);\n        return dest;\n    },\n\n    /**\n     * Transforms a four-element vector by a 4x4 matrix.\n     * @method transformVec4\n     * @static\n     */\n    transformVec4(m, v, dest) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        dest = dest || math.vec4();\n        dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;\n        dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;\n        dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;\n        dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the x-axis\n     *\n     * @method rotateVec3X\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3X(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[0];\n        r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);\n        r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the y-axis\n     *\n     * @method rotateVec3Y\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3Y(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);\n        r[1] = p[1];\n        r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the z-axis\n     *\n     * @method rotateVec3Z\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3Z(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);\n        r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);\n        r[2] = p[2];\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Transforms a four-element vector by a 4x4 projection matrix.\n     *\n     * @method projectVec4\n     * @param {Number[]} p 3D View-space coordinate\n     * @param {Number[]} q 2D Projected coordinate\n     * @returns {Number[]} 2D Projected coordinate\n     * @static\n     */\n    projectVec4(p, q) {\n        const f = 1.0 / p[3];\n        q = q || math.vec2();\n        q[0] = v[0] * f;\n        q[1] = v[1] * f;\n        return q;\n    },\n\n    /**\n     * Unprojects a three-element vector.\n     *\n     * @method unprojectVec3\n     * @param {Number[]} p 3D Projected coordinate\n     * @param {Number[]} viewMat View matrix\n     * @returns {Number[]} projMat Projection matrix\n     * @static\n     */\n    unprojectVec3: ((() => {\n        const mat = new FloatArrayType(16);\n        const mat2 = new FloatArrayType(16);\n        const mat3 = new FloatArrayType(16);\n        return function (p, viewMat, projMat, q) {\n            return this.transformVec3(this.mulMat4(this.inverseMat4(viewMat, mat), this.inverseMat4(projMat, mat2), mat3), p, q)\n        };\n    }))(),\n\n    /**\n     * Linearly interpolates between two 3D vectors.\n     * @method lerpVec3\n     * @static\n     */\n    lerpVec3(t, t1, t2, p1, p2, dest) {\n        const result = dest || math.vec3();\n        const f = (t - t1) / (t2 - t1);\n        result[0] = p1[0] + (f * (p2[0] - p1[0]));\n        result[1] = p1[1] + (f * (p2[1] - p1[1]));\n        result[2] = p1[2] + (f * (p2[2] - p1[2]));\n        return result;\n    },\n\n\n    /**\n     * Flattens a two-dimensional array into a one-dimensional array.\n     *\n     * @method flatten\n     * @static\n     * @param {Array of Arrays} a A 2D array\n     * @returns Flattened 1D array\n     */\n    flatten(a) {\n\n        const result = [];\n\n        let i;\n        let leni;\n        let j;\n        let lenj;\n        let item;\n\n        for (i = 0, leni = a.length; i < leni; i++) {\n            item = a[i];\n            for (j = 0, lenj = item.length; j < lenj; j++) {\n                result.push(item[j]);\n            }\n        }\n\n        return result;\n    },\n\n\n    identityQuaternion(dest = math.vec4()) {\n        dest[0] = 0.0;\n        dest[1] = 0.0;\n        dest[2] = 0.0;\n        dest[3] = 1.0;\n        return dest;\n    },\n\n    /**\n     * Initializes a quaternion from Euler angles.\n     *\n     * @param {Number[]} euler The Euler angles.\n     * @param {String} order Euler angle order: \"XYZ\", \"YXZ\", \"ZXY\" etc.\n     * @param {Number[]} [dest] Destination quaternion, created by default.\n     * @returns {Number[]} The quaternion.\n     */\n    eulerToQuaternion(euler, order, dest = math.vec4()) {\n        // http://www.mathworks.com/matlabcentral/fileexchange/\n        // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n        //\tcontent/SpinCalc.m\n\n        const a = (euler[0] * math.DEGTORAD) / 2;\n        const b = (euler[1] * math.DEGTORAD) / 2;\n        const c = (euler[2] * math.DEGTORAD) / 2;\n\n        const c1 = Math.cos(a);\n        const c2 = Math.cos(b);\n        const c3 = Math.cos(c);\n        const s1 = Math.sin(a);\n        const s2 = Math.sin(b);\n        const s3 = Math.sin(c);\n\n        if (order === 'XYZ') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'YXZ') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n\n        } else if (order === 'ZXY') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'ZYX') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n\n        } else if (order === 'YZX') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'XZY') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n        }\n\n        return dest;\n    },\n\n    mat4ToQuaternion(m, dest = math.vec4()) {\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n        // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n        const m11 = m[0];\n        const m12 = m[4];\n        const m13 = m[8];\n        const m21 = m[1];\n        const m22 = m[5];\n        const m23 = m[9];\n        const m31 = m[2];\n        const m32 = m[6];\n        const m33 = m[10];\n        let s;\n\n        const trace = m11 + m22 + m33;\n\n        if (trace > 0) {\n\n            s = 0.5 / Math.sqrt(trace + 1.0);\n\n            dest[3] = 0.25 / s;\n            dest[0] = (m32 - m23) * s;\n            dest[1] = (m13 - m31) * s;\n            dest[2] = (m21 - m12) * s;\n\n        } else if (m11 > m22 && m11 > m33) {\n\n            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n\n            dest[3] = (m32 - m23) / s;\n            dest[0] = 0.25 * s;\n            dest[1] = (m12 + m21) / s;\n            dest[2] = (m13 + m31) / s;\n\n        } else if (m22 > m33) {\n\n            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n\n            dest[3] = (m13 - m31) / s;\n            dest[0] = (m12 + m21) / s;\n            dest[1] = 0.25 * s;\n            dest[2] = (m23 + m32) / s;\n\n        } else {\n\n            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n\n            dest[3] = (m21 - m12) / s;\n            dest[0] = (m13 + m31) / s;\n            dest[1] = (m23 + m32) / s;\n            dest[2] = 0.25 * s;\n        }\n\n        return dest;\n    },\n\n    vec3PairToQuaternion(u, v, dest = math.vec4()) {\n        const norm_u_norm_v = Math.sqrt(math.dotVec3(u, u) * math.dotVec3(v, v));\n        let real_part = norm_u_norm_v + math.dotVec3(u, v);\n\n        if (real_part < 0.00000001 * norm_u_norm_v) {\n\n            // If u and v are exactly opposite, rotate 180 degrees\n            // around an arbitrary orthogonal axis. Axis normalisation\n            // can happen later, when we normalise the quaternion.\n\n            real_part = 0.0;\n\n            if (Math.abs(u[0]) > Math.abs(u[2])) {\n\n                dest[0] = -u[1];\n                dest[1] = u[0];\n                dest[2] = 0;\n\n            } else {\n                dest[0] = 0;\n                dest[1] = -u[2];\n                dest[2] = u[1]\n            }\n\n        } else {\n\n            // Otherwise, build quaternion the standard way.\n            math.cross3Vec3(u, v, dest);\n        }\n\n        dest[3] = real_part;\n\n        return math.normalizeQuaternion(dest);\n    },\n\n    angleAxisToQuaternion(angleAxis, dest = math.vec4()) {\n        const halfAngle = angleAxis[3] / 2.0;\n        const fsin = Math.sin(halfAngle);\n        dest[0] = fsin * angleAxis[0];\n        dest[1] = fsin * angleAxis[1];\n        dest[2] = fsin * angleAxis[2];\n        dest[3] = Math.cos(halfAngle);\n        return dest;\n    },\n\n    quaternionToEuler: ((() => {\n        const mat = new FloatArrayType(16);\n        return (q, order, dest) => {\n            dest = dest || math.vec3();\n            math.quaternionToRotationMat4(q, mat);\n            math.mat4ToEuler(mat, order, dest);\n            return dest;\n        };\n    }))(),\n\n    mulQuaternions(p, q, dest = math.vec4()) {\n        const p0 = p[0];\n        const p1 = p[1];\n        const p2 = p[2];\n        const p3 = p[3];\n        const q0 = q[0];\n        const q1 = q[1];\n        const q2 = q[2];\n        const q3 = q[3];\n        dest[0] = p3 * q0 + p0 * q3 + p1 * q2 - p2 * q1;\n        dest[1] = p3 * q1 + p1 * q3 + p2 * q0 - p0 * q2;\n        dest[2] = p3 * q2 + p2 * q3 + p0 * q1 - p1 * q0;\n        dest[3] = p3 * q3 - p0 * q0 - p1 * q1 - p2 * q2;\n        return dest;\n    },\n\n    vec3ApplyQuaternion(q, vec, dest = math.vec3()) {\n        const x = vec[0];\n        const y = vec[1];\n        const z = vec[2];\n\n        const qx = q[0];\n        const qy = q[1];\n        const qz = q[2];\n        const qw = q[3];\n\n        // calculate quat * vector\n\n        const ix = qw * x + qy * z - qz * y;\n        const iy = qw * y + qz * x - qx * z;\n        const iz = qw * z + qx * y - qy * x;\n        const iw = -qx * x - qy * y - qz * z;\n\n        // calculate result * inverse quat\n\n        dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n        dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n        dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n        return dest;\n    },\n\n    quaternionToMat4(q, dest) {\n\n        dest = math.identityMat4(dest);\n\n        const q0 = q[0];  //x\n        const q1 = q[1];  //y\n        const q2 = q[2];  //z\n        const q3 = q[3];  //w\n\n        const tx = 2.0 * q0;\n        const ty = 2.0 * q1;\n        const tz = 2.0 * q2;\n\n        const twx = tx * q3;\n        const twy = ty * q3;\n        const twz = tz * q3;\n\n        const txx = tx * q0;\n        const txy = ty * q0;\n        const txz = tz * q0;\n\n        const tyy = ty * q1;\n        const tyz = tz * q1;\n        const tzz = tz * q2;\n\n        dest[0] = 1.0 - (tyy + tzz);\n        dest[1] = txy + twz;\n        dest[2] = txz - twy;\n\n        dest[4] = txy - twz;\n        dest[5] = 1.0 - (txx + tzz);\n        dest[6] = tyz + twx;\n\n        dest[8] = txz + twy;\n        dest[9] = tyz - twx;\n\n        dest[10] = 1.0 - (txx + tyy);\n\n        return dest;\n    },\n\n    quaternionToRotationMat4(q, m) {\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n\n        m[0] = 1 - (yy + zz);\n        m[4] = xy - wz;\n        m[8] = xz + wy;\n\n        m[1] = xy + wz;\n        m[5] = 1 - (xx + zz);\n        m[9] = yz - wx;\n\n        m[2] = xz - wy;\n        m[6] = yz + wx;\n        m[10] = 1 - (xx + yy);\n\n        // last column\n        m[3] = 0;\n        m[7] = 0;\n        m[11] = 0;\n\n        // bottom row\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = 0;\n        m[15] = 1;\n\n        return m;\n    },\n\n    normalizeQuaternion(q, dest = q) {\n        const len = math.lenVec4([q[0], q[1], q[2], q[3]]);\n        dest[0] = q[0] / len;\n        dest[1] = q[1] / len;\n        dest[2] = q[2] / len;\n        dest[3] = q[3] / len;\n        return dest;\n    },\n\n    conjugateQuaternion(q, dest = q) {\n        dest[0] = -q[0];\n        dest[1] = -q[1];\n        dest[2] = -q[2];\n        dest[3] = q[3];\n        return dest;\n    },\n\n    inverseQuaternion(q, dest) {\n        return math.normalizeQuaternion(math.conjugateQuaternion(q, dest));\n    },\n\n    quaternionToAngleAxis(q, angleAxis = math.vec4()) {\n        q = math.normalizeQuaternion(q, tempVec4);\n        const q3 = q[3];\n        const angle = 2 * Math.acos(q3);\n        const s = Math.sqrt(1 - q3 * q3);\n        if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt\n            angleAxis[0] = q[0];\n            angleAxis[1] = q[1];\n            angleAxis[2] = q[2];\n        } else {\n            angleAxis[0] = q[0] / s;\n            angleAxis[1] = q[1] / s;\n            angleAxis[2] = q[2] / s;\n        }\n        angleAxis[3] = angle; // * 57.295779579;\n        return angleAxis;\n    },\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Boundaries\n    //------------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Returns a new, uninitialized 3D axis-aligned bounding box.\n     *\n     * @private\n     */\n    AABB3(values) {\n        return new FloatArrayType(values || 6);\n    },\n\n    /**\n     * Returns a new, uninitialized 2D axis-aligned bounding box.\n     *\n     * @private\n     */\n    AABB2(values) {\n        return new FloatArrayType(values || 4);\n    },\n\n    /**\n     * Returns a new, uninitialized 3D oriented bounding box (OBB).\n     *\n     * @private\n     */\n    OBB3(values) {\n        return new FloatArrayType(values || 32);\n    },\n\n    /**\n     * Returns a new, uninitialized 2D oriented bounding box (OBB).\n     *\n     * @private\n     */\n    OBB2(values) {\n        return new FloatArrayType(values || 16);\n    },\n\n    /** Returns a new 3D bounding sphere */\n    Sphere3(x, y, z, r) {\n        return new FloatArrayType([x, y, z, r]);\n    },\n\n    /**\n     * Transforms an OBB3 by a 4x4 matrix.\n     *\n     * @private\n     */\n    transformOBB3(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 4) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /** Returns true if the first AABB contains the second AABB.\n     * @param aabb1\n     * @param aabb2\n     * @returns {boolean}\n     */\n    containsAABB3: function (aabb1, aabb2) {\n        const result = (\n            aabb1[0] <= aabb2[0] && aabb2[3] <= aabb1[3] &&\n            aabb1[1] <= aabb2[1] && aabb2[4] <= aabb1[4] &&\n            aabb1[2] <= aabb2[2] && aabb2[5] <= aabb1[5]);\n        return result;\n    },\n\n    /**\n     * Gets the diagonal size of an AABB3 given as minima and maxima.\n     *\n     * @private\n     */\n    getAABB3Diag: ((() => {\n\n        const min = new FloatArrayType(3);\n        const max = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return aabb => {\n\n            min[0] = aabb[0];\n            min[1] = aabb[1];\n            min[2] = aabb[2];\n\n            max[0] = aabb[3];\n            max[1] = aabb[4];\n            max[2] = aabb[5];\n\n            math.subVec3(max, min, tempVec3);\n\n            return Math.abs(math.lenVec3(tempVec3));\n        };\n    }))(),\n\n    /**\n     * Get a diagonal boundary size that is symmetrical about the given point.\n     *\n     * @private\n     */\n    getAABB3DiagPoint: ((() => {\n\n        const min = new FloatArrayType(3);\n        const max = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return (aabb, p) => {\n\n            min[0] = aabb[0];\n            min[1] = aabb[1];\n            min[2] = aabb[2];\n\n            max[0] = aabb[3];\n            max[1] = aabb[4];\n            max[2] = aabb[5];\n\n            const diagVec = math.subVec3(max, min, tempVec3);\n\n            const xneg = p[0] - aabb[0];\n            const xpos = aabb[3] - p[0];\n            const yneg = p[1] - aabb[1];\n            const ypos = aabb[4] - p[1];\n            const zneg = p[2] - aabb[2];\n            const zpos = aabb[5] - p[2];\n\n            diagVec[0] += (xneg > xpos) ? xneg : xpos;\n            diagVec[1] += (yneg > ypos) ? yneg : ypos;\n            diagVec[2] += (zneg > zpos) ? zneg : zpos;\n\n            return Math.abs(math.lenVec3(diagVec));\n        };\n    }))(),\n\n    /**\n     * Gets the center of an AABB.\n     *\n     * @private\n     */\n    getAABB3Center(aabb, dest) {\n        const r = dest || math.vec3();\n\n        r[0] = (aabb[0] + aabb[3]) / 2;\n        r[1] = (aabb[1] + aabb[4]) / 2;\n        r[2] = (aabb[2] + aabb[5]) / 2;\n\n        return r;\n    },\n\n    /**\n     * Gets the center of a 2D AABB.\n     *\n     * @private\n     */\n    getAABB2Center(aabb, dest) {\n        const r = dest || math.vec2();\n\n        r[0] = (aabb[2] + aabb[0]) / 2;\n        r[1] = (aabb[3] + aabb[1]) / 2;\n\n        return r;\n    },\n\n    /**\n     * Collapses a 3D axis-aligned boundary, ready to expand to fit 3D points.\n     * Creates new AABB if none supplied.\n     *\n     * @private\n     */\n    collapseAABB3(aabb = math.AABB3()) {\n        aabb[0] = math.MAX_DOUBLE;\n        aabb[1] = math.MAX_DOUBLE;\n        aabb[2] = math.MAX_DOUBLE;\n        aabb[3] = -math.MAX_DOUBLE;\n        aabb[4] = -math.MAX_DOUBLE;\n        aabb[5] = -math.MAX_DOUBLE;\n\n        return aabb;\n    },\n\n    /**\n     * Converts an axis-aligned 3D boundary into an oriented boundary consisting of\n     * an array of eight 3D positions, one for each corner of the boundary.\n     *\n     * @private\n     */\n    AABB3ToOBB3(aabb, obb = math.OBB3()) {\n        obb[0] = aabb[0];\n        obb[1] = aabb[1];\n        obb[2] = aabb[2];\n        obb[3] = 1;\n\n        obb[4] = aabb[3];\n        obb[5] = aabb[1];\n        obb[6] = aabb[2];\n        obb[7] = 1;\n\n        obb[8] = aabb[3];\n        obb[9] = aabb[4];\n        obb[10] = aabb[2];\n        obb[11] = 1;\n\n        obb[12] = aabb[0];\n        obb[13] = aabb[4];\n        obb[14] = aabb[2];\n        obb[15] = 1;\n\n        obb[16] = aabb[0];\n        obb[17] = aabb[1];\n        obb[18] = aabb[5];\n        obb[19] = 1;\n\n        obb[20] = aabb[3];\n        obb[21] = aabb[1];\n        obb[22] = aabb[5];\n        obb[23] = 1;\n\n        obb[24] = aabb[3];\n        obb[25] = aabb[4];\n        obb[26] = aabb[5];\n        obb[27] = 1;\n\n        obb[28] = aabb[0];\n        obb[29] = aabb[4];\n        obb[30] = aabb[5];\n        obb[31] = 1;\n\n        return obb;\n    },\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n     *\n     * @private\n     */\n    positions3ToAABB3: ((() => {\n\n        const p = new FloatArrayType(3);\n\n        return (positions, aabb, positionsDecodeMatrix) => {\n            aabb = aabb || math.AABB3();\n\n            let xmin = math.MAX_DOUBLE;\n            let ymin = math.MAX_DOUBLE;\n            let zmin = math.MAX_DOUBLE;\n            let xmax = -math.MAX_DOUBLE;\n            let ymax = -math.MAX_DOUBLE;\n            let zmax = -math.MAX_DOUBLE;\n\n            let x;\n            let y;\n            let z;\n\n            for (let i = 0, len = positions.length; i < len; i += 3) {\n\n                if (positionsDecodeMatrix) {\n\n                    p[0] = positions[i + 0];\n                    p[1] = positions[i + 1];\n                    p[2] = positions[i + 2];\n\n                    math.decompressPosition(p, positionsDecodeMatrix, p);\n\n                    x = p[0];\n                    y = p[1];\n                    z = p[2];\n\n                } else {\n                    x = positions[i + 0];\n                    y = positions[i + 1];\n                    z = positions[i + 2];\n                }\n\n                if (x < xmin) {\n                    xmin = x;\n                }\n\n                if (y < ymin) {\n                    ymin = y;\n                }\n\n                if (z < zmin) {\n                    zmin = z;\n                }\n\n                if (x > xmax) {\n                    xmax = x;\n                }\n\n                if (y > ymax) {\n                    ymax = y;\n                }\n\n                if (z > zmax) {\n                    zmax = z;\n                }\n            }\n\n            aabb[0] = xmin;\n            aabb[1] = ymin;\n            aabb[2] = zmin;\n            aabb[3] = xmax;\n            aabb[4] = ymax;\n            aabb[5] = zmax;\n\n            return aabb;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n     *\n     * @private\n     */\n    OBB3ToAABB3(obb, aabb = math.AABB3()) {\n        let xmin = math.MAX_DOUBLE;\n        let ymin = math.MAX_DOUBLE;\n        let zmin = math.MAX_DOUBLE;\n        let xmax = -math.MAX_DOUBLE;\n        let ymax = -math.MAX_DOUBLE;\n        let zmax = -math.MAX_DOUBLE;\n\n        let x;\n        let y;\n        let z;\n\n        for (let i = 0, len = obb.length; i < len; i += 4) {\n\n            x = obb[i + 0];\n            y = obb[i + 1];\n            z = obb[i + 2];\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (z < zmin) {\n                zmin = z;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n\n            if (z > zmax) {\n                zmax = z;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = zmin;\n        aabb[3] = xmax;\n        aabb[4] = ymax;\n        aabb[5] = zmax;\n\n        return aabb;\n    },\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the given 3D points.\n     *\n     * @private\n     */\n    points3ToAABB3(points, aabb = math.AABB3()) {\n        let xmin = math.MAX_DOUBLE;\n        let ymin = math.MAX_DOUBLE;\n        let zmin = math.MAX_DOUBLE;\n        let xmax = -math.MAX_DOUBLE;\n        let ymax = -math.MAX_DOUBLE;\n        let zmax = -math.MAX_DOUBLE;\n\n        let x;\n        let y;\n        let z;\n\n        for (let i = 0, len = points.length; i < len; i++) {\n\n            x = points[i][0];\n            y = points[i][1];\n            z = points[i][2];\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (z < zmin) {\n                zmin = z;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n\n            if (z > zmax) {\n                zmax = z;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = zmin;\n        aabb[3] = xmax;\n        aabb[4] = ymax;\n        aabb[5] = zmax;\n\n        return aabb;\n    },\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D points.\n     *\n     * @private\n     */\n    points3ToSphere3: ((() => {\n\n        const tempVec3 = new FloatArrayType(3);\n\n        return (points, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const numPoints = points.length;\n\n            for (i = 0; i < numPoints; i++) {\n                x += points[i][0];\n                y += points[i][1];\n                z += points[i][2];\n            }\n\n            sphere[0] = x / numPoints;\n            sphere[1] = y / numPoints;\n            sphere[2] = z / numPoints;\n\n            let radius = 0;\n            let dist;\n\n            for (i = 0; i < numPoints; i++) {\n\n                dist = Math.abs(math.lenVec3(math.subVec3(points[i], sphere, tempVec3)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D positions.\n     *\n     * @private\n     */\n    positions3ToSphere3: ((() => {\n\n        const tempVec3a = new FloatArrayType(3);\n        const tempVec3b = new FloatArrayType(3);\n\n        return (positions, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const lenPositions = positions.length;\n            let radius = 0;\n\n            for (i = 0; i < lenPositions; i += 3) {\n                x += positions[i];\n                y += positions[i + 1];\n                z += positions[i + 2];\n            }\n\n            const numPositions = lenPositions / 3;\n\n            sphere[0] = x / numPositions;\n            sphere[1] = y / numPositions;\n            sphere[2] = z / numPositions;\n\n            let dist;\n\n            for (i = 0; i < lenPositions; i += 3) {\n\n                tempVec3a[0] = positions[i];\n                tempVec3a[1] = positions[i + 1];\n                tempVec3a[2] = positions[i + 2];\n\n                dist = Math.abs(math.lenVec3(math.subVec3(tempVec3a, sphere, tempVec3b)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D points.\n     *\n     * @private\n     */\n    OBB3ToSphere3: ((() => {\n\n        const point = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return (points, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const lenPoints = points.length;\n            const numPoints = lenPoints / 4;\n\n            for (i = 0; i < lenPoints; i += 4) {\n                x += points[i + 0];\n                y += points[i + 1];\n                z += points[i + 2];\n            }\n\n            sphere[0] = x / numPoints;\n            sphere[1] = y / numPoints;\n            sphere[2] = z / numPoints;\n\n            let radius = 0;\n            let dist;\n\n            for (i = 0; i < lenPoints; i += 4) {\n\n                point[0] = points[i + 0];\n                point[1] = points[i + 1];\n                point[2] = points[i + 2];\n\n                dist = Math.abs(math.lenVec3(math.subVec3(point, sphere, tempVec3)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Gets the center of a bounding sphere.\n     *\n     * @private\n     */\n    getSphere3Center(sphere, dest = math.vec3()) {\n        dest[0] = sphere[0];\n        dest[1] = sphere[1];\n        dest[2] = sphere[2];\n\n        return dest;\n    },\n\n    /**\n     * Expands the first axis-aligned 3D boundary to enclose the second, if required.\n     *\n     * @private\n     */\n    expandAABB3(aabb1, aabb2) {\n\n        if (aabb1[0] > aabb2[0]) {\n            aabb1[0] = aabb2[0];\n        }\n\n        if (aabb1[1] > aabb2[1]) {\n            aabb1[1] = aabb2[1];\n        }\n\n        if (aabb1[2] > aabb2[2]) {\n            aabb1[2] = aabb2[2];\n        }\n\n        if (aabb1[3] < aabb2[3]) {\n            aabb1[3] = aabb2[3];\n        }\n\n        if (aabb1[4] < aabb2[4]) {\n            aabb1[4] = aabb2[4];\n        }\n\n        if (aabb1[5] < aabb2[5]) {\n            aabb1[5] = aabb2[5];\n        }\n\n        return aabb1;\n    },\n\n    /**\n     * Expands an axis-aligned 3D boundary to enclose the given point, if needed.\n     *\n     * @private\n     */\n    expandAABB3Point3(aabb, p) {\n\n        if (aabb[0] > p[0]) {\n            aabb[0] = p[0];\n        }\n\n        if (aabb[1] > p[1]) {\n            aabb[1] = p[1];\n        }\n\n        if (aabb[2] > p[2]) {\n            aabb[2] = p[2];\n        }\n\n        if (aabb[3] < p[0]) {\n            aabb[3] = p[0];\n        }\n\n        if (aabb[4] < p[1]) {\n            aabb[4] = p[1];\n        }\n\n        if (aabb[5] < p[2]) {\n            aabb[5] = p[2];\n        }\n\n        return aabb;\n    },\n\n    /**\n     * Calculates the normal vector of a triangle.\n     *\n     * @private\n     */\n    triangleNormal(a, b, c, normal = math.vec3()) {\n        const p1x = b[0] - a[0];\n        const p1y = b[1] - a[1];\n        const p1z = b[2] - a[2];\n\n        const p2x = c[0] - a[0];\n        const p2y = c[1] - a[1];\n        const p2z = c[2] - a[2];\n\n        const p3x = p1y * p2z - p1z * p2y;\n        const p3y = p1z * p2x - p1x * p2z;\n        const p3z = p1x * p2y - p1y * p2x;\n\n        const mag = Math.sqrt(p3x * p3x + p3y * p3y + p3z * p3z);\n        if (mag === 0) {\n            normal[0] = 0;\n            normal[1] = 0;\n            normal[2] = 0;\n        } else {\n            normal[0] = p3x / mag;\n            normal[1] = p3y / mag;\n            normal[2] = p3z / mag;\n        }\n\n        return normal\n    }\n};\n\nexport {math};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/lib/math.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 285,
    "kind": "variable",
    "name": "doublePrecision",
    "memberof": "src/XKTModel/lib/math.js",
    "static": true,
    "longname": "src/XKTModel/lib/math.js~doublePrecision",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 286,
    "kind": "variable",
    "name": "FloatArrayType",
    "memberof": "src/XKTModel/lib/math.js",
    "static": true,
    "longname": "src/XKTModel/lib/math.js~FloatArrayType",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 287,
    "kind": "variable",
    "name": "tempMat1",
    "memberof": "src/XKTModel/lib/math.js",
    "static": true,
    "longname": "src/XKTModel/lib/math.js~tempMat1",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 288,
    "kind": "variable",
    "name": "tempMat2",
    "memberof": "src/XKTModel/lib/math.js",
    "static": true,
    "longname": "src/XKTModel/lib/math.js~tempMat2",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 289,
    "kind": "variable",
    "name": "tempVec4",
    "memberof": "src/XKTModel/lib/math.js",
    "static": true,
    "longname": "src/XKTModel/lib/math.js~tempVec4",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 290,
    "kind": "variable",
    "name": "math",
    "memberof": "src/XKTModel/lib/math.js",
    "static": true,
    "longname": "src/XKTModel/lib/math.js~math",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/math.js",
    "importStyle": "{math}",
    "description": "",
    "lineNumber": 13,
    "ignore": true,
    "type": {
      "types": [
        "{\"MIN_DOUBLE\": *, \"MAX_DOUBLE\": *, \"DEGTORAD\": number, \"RADTODEG\": number, \"vec2\": function, \"vec3\": function, \"vec4\": function, \"mat3\": function, \"mat3ToMat4\": function, \"mat4\": function, \"mat4ToMat3\": function, \"createUUID\": *, \"clamp\": function, \"fmod\": function, \"negateVec4\": function, \"addVec4\": function, \"addVec4Scalar\": function, \"addVec3\": function, \"addVec3Scalar\": function, \"subVec4\": function, \"subVec3\": function, \"subVec2\": function, \"subVec4Scalar\": function, \"subScalarVec4\": function, \"mulVec4\": function, \"mulVec4Scalar\": function, \"mulVec3Scalar\": function, \"mulVec2Scalar\": function, \"divVec3\": function, \"divVec4\": function, \"divScalarVec3\": function, \"divVec3Scalar\": function, \"divVec4Scalar\": function, \"divScalarVec4\": function, \"dotVec4\": function, \"cross3Vec4\": function, \"cross3Vec3\": function, \"sqLenVec4\": function, \"lenVec4\": function, \"dotVec3\": function, \"dotVec2\": function, \"sqLenVec3\": function, \"sqLenVec2\": function, \"lenVec3\": function, \"distVec3\": *, \"lenVec2\": function, \"distVec2\": *, \"rcpVec3\": function, \"normalizeVec4\": function, \"normalizeVec3\": function, \"normalizeVec2\": function, \"angleVec3\": function, \"vec3FromMat4Scale\": *, \"vecToArray\": *, \"xyzArrayToObject\": function, \"xyzObjectToArray\": function, \"dupMat4\": function, \"mat4To3\": function, \"m4s\": function, \"setMat4ToZeroes\": function, \"setMat4ToOnes\": function, \"diagonalMat4v\": function, \"diagonalMat4c\": function, \"diagonalMat4s\": function, \"identityMat4\": function, \"identityMat3\": function, \"isIdentityMat4\": function, \"negateMat4\": function, \"addMat4\": function, \"addMat4Scalar\": function, \"addScalarMat4\": function, \"subMat4\": function, \"subMat4Scalar\": function, \"subScalarMat4\": function, \"mulMat4\": function, \"mulMat3\": function, \"mulMat4Scalar\": function, \"mulMat4v4\": function, \"transposeMat4\": function, \"transposeMat3\": function, \"determinantMat4\": function, \"inverseMat4\": function, \"traceMat4\": function, \"translationMat4v\": function, \"translationMat3v\": function, \"translationMat4c\": *, \"translationMat4s\": function, \"translateMat4v\": function, \"OLDtranslateMat4c\": function, \"translateMat4c\": function, \"rotationMat4v\": function, \"rotationMat4c\": function, \"scalingMat4v\": function, \"scalingMat3v\": function, \"scalingMat4c\": *, \"scaleMat4c\": function, \"scaleMat4v\": function, \"scalingMat4s\": function, \"rotationTranslationMat4\": function, \"mat4ToEuler\": function, \"composeMat4\": function, \"decomposeMat4\": *, \"lookAtMat4v\": function, \"lookAtMat4c\": function, \"orthoMat4c\": function, \"frustumMat4v\": function, \"frustumMat4\": function, \"perspectiveMat4\": function, \"transformPoint3\": function, \"transformPoint4\": function, \"transformPoints3\": function, \"transformPositions3\": function, \"transformPositions4\": function, \"transformVec3\": function, \"transformVec4\": function, \"rotateVec3X\": function, \"rotateVec3Y\": function, \"rotateVec3Z\": function, \"projectVec4\": function, \"unprojectVec3\": *, \"lerpVec3\": function, \"flatten\": function, \"identityQuaternion\": function, \"eulerToQuaternion\": function, \"mat4ToQuaternion\": function, \"vec3PairToQuaternion\": function, \"angleAxisToQuaternion\": function, \"quaternionToEuler\": *, \"mulQuaternions\": function, \"vec3ApplyQuaternion\": function, \"quaternionToMat4\": function, \"quaternionToRotationMat4\": function, \"normalizeQuaternion\": function, \"conjugateQuaternion\": function, \"inverseQuaternion\": function, \"quaternionToAngleAxis\": function, \"AABB3\": function, \"AABB2\": function, \"OBB3\": function, \"OBB2\": function, \"Sphere3\": function, \"transformOBB3\": function, \"containsAABB3\": *, \"getAABB3Diag\": *, \"getAABB3DiagPoint\": *, \"getAABB3Center\": function, \"getAABB2Center\": function, \"collapseAABB3\": function, \"AABB3ToOBB3\": function, \"positions3ToAABB3\": *, \"OBB3ToAABB3\": function, \"points3ToAABB3\": function, \"points3ToSphere3\": *, \"positions3ToSphere3\": *, \"OBB3ToSphere3\": *, \"getSphere3Center\": function, \"expandAABB3\": function, \"expandAABB3Point3\": function, \"triangleNormal\": function}"
      ]
    }
  },
  {
    "__docId__": 291,
    "kind": "file",
    "name": "src/XKTModel/lib/mergeVertices.js",
    "content": "/**\n * Given geometry defined as an array of positions, optional normals, option uv and an array of indices, returns\n * modified arrays that have duplicate vertices removed.\n *\n * @private\n */\nfunction mergeVertices(positions, indices, mergedPositions, mergedIndices) {\n    const positionsMap = {};\n    const indicesLookup = [];\n    const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n    const precision = 10 ** precisionPoints;\n    let uvi = 0;\n    for (let i = 0, len = positions.length; i < len; i += 3) {\n        const vx = positions[i];\n        const vy = positions[i + 1];\n        const vz = positions[i + 2];\n        const key = `${Math.round(vx * precision)}_${Math.round(vy * precision)}_${Math.round(vz * precision)}`;\n        if (positionsMap[key] === undefined) {\n            positionsMap[key] = mergedPositions.length / 3;\n            mergedPositions.push(vx);\n            mergedPositions.push(vy);\n            mergedPositions.push(vz);\n        }\n        indicesLookup[i / 3] = positionsMap[key];\n        uvi += 2;\n    }\n    for (let i = 0, len = indices.length; i < len; i++) {\n        mergedIndices[i] = indicesLookup[indices[i]];\n    }\n}\n\nexport {mergeVertices};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/lib/mergeVertices.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 292,
    "kind": "function",
    "name": "mergeVertices",
    "memberof": "src/XKTModel/lib/mergeVertices.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/mergeVertices.js~mergeVertices",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/mergeVertices.js",
    "importStyle": "{mergeVertices}",
    "description": "Given geometry defined as an array of positions, optional normals, option uv and an array of indices, returns\nmodified arrays that have duplicate vertices removed.",
    "lineNumber": 7,
    "ignore": true,
    "params": [
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "indices",
        "types": [
          "*"
        ]
      },
      {
        "name": "mergedPositions",
        "types": [
          "*"
        ]
      },
      {
        "name": "mergedIndices",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 293,
    "kind": "file",
    "name": "src/XKTModel/lib/toArraybuffer.js",
    "content": "/**\n * @private\n * @param buf\n * @returns {ArrayBuffer}\n */\nexport function toArrayBuffer(buf) {\n    const ab = new ArrayBuffer(buf.length);\n    const view = new Uint8Array(ab);\n    for (let i = 0; i < buf.length; ++i) {\n        view[i] = buf[i];\n    }\n    return ab;\n}",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/lib/toArraybuffer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 294,
    "kind": "function",
    "name": "toArrayBuffer",
    "memberof": "src/XKTModel/lib/toArraybuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/toArraybuffer.js~toArrayBuffer",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/toArraybuffer.js",
    "importStyle": "{toArrayBuffer}",
    "description": "",
    "lineNumber": 6,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ArrayBuffer}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "buf",
        "description": ""
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ArrayBuffer"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true
  },
  {
    "__docId__": 295,
    "kind": "file",
    "name": "src/XKTModel/lib/utils.js",
    "content": "function isString(value) {\n    return (typeof value === 'string' || value instanceof String);\n}\n\nfunction apply(o, o2) {\n    for (const name in o) {\n        if (o.hasOwnProperty(name)) {\n            o2[name] = o[name];\n        }\n    }\n    return o2;\n}\n\n/**\n * @private\n */\nconst utils = {\n    isString,\n    apply\n};\n\nexport {utils};\n",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/lib/utils.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 296,
    "kind": "function",
    "name": "isString",
    "memberof": "src/XKTModel/lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/utils.js~isString",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "params": [
      {
        "name": "value",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 297,
    "kind": "function",
    "name": "apply",
    "memberof": "src/XKTModel/lib/utils.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/lib/utils.js~apply",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/utils.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "params": [
      {
        "name": "o",
        "types": [
          "*"
        ]
      },
      {
        "name": "o2",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 298,
    "kind": "variable",
    "name": "utils",
    "memberof": "src/XKTModel/lib/utils.js",
    "static": true,
    "longname": "src/XKTModel/lib/utils.js~utils",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/lib/utils.js",
    "importStyle": "{utils}",
    "description": "",
    "lineNumber": 17,
    "ignore": true,
    "type": {
      "types": [
        "{\"isString\": *, \"apply\": *}"
      ]
    }
  },
  {
    "__docId__": 299,
    "kind": "file",
    "name": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "content": "import {XKT_INFO} from \"../XKT_INFO.js\";\nimport * as pako from 'pako';\n\nconst XKT_VERSION = XKT_INFO.xktVersion;\nconst NUM_TEXTURE_ATTRIBUTES = 9;\nconst NUM_MATERIAL_ATTRIBUTES = 6;\n\n/**\n * Writes an {@link XKTModel} to an {@link ArrayBuffer}.\n *\n * @param {XKTModel} xktModel The {@link XKTModel}.\n * @param {String} metaModelJSON The metamodel JSON in a string.\n * @param {Object} [stats] Collects statistics.\n * @param {Object} options Options for how the XKT is written.\n * @param {Boolean} [options.zip=true] ZIP the contents?\n * @returns {ArrayBuffer} The {@link ArrayBuffer}.\n */\nfunction writeXKTModelToArrayBuffer(xktModel, metaModelJSON, stats, options) {\n    if (! options.zip) {\n        return writeXKTModelToArrayBufferUncompressed(xktModel, metaModelJSON, stats);\n    }\n    const data = getModelData(xktModel, metaModelJSON, stats);\n    const deflatedData = deflateData(data, metaModelJSON, options);\n    stats.texturesSize += deflatedData.textureData.byteLength;\n    const arrayBuffer = createArrayBuffer(deflatedData);\n    return arrayBuffer;\n}\n\n// V11\nfunction writeXKTModelToArrayBufferUncompressed(xktModel, metaModelJSON, stats) {\n    const data = getModelData(xktModel, metaModelJSON, stats);\n    stats.texturesSize += data.textureData.byteLength;\n\n    const object2Array = (function() {\n        const encoder = new TextEncoder();\n        return obj => encoder.encode(JSON.stringify(obj));\n    })();\n\n    const arrays = [\n        object2Array(metaModelJSON || data.metadata),\n        data.textureData,\n        data.eachTextureDataPortion,\n        data.eachTextureAttributes,\n        data.positions,\n        data.normals,\n        data.colors,\n        data.uvs,\n        data.indices,\n        data.edgeIndices,\n        data.eachTextureSetTextures,\n        data.matrices,\n        data.reusedGeometriesDecodeMatrix,\n        data.eachGeometryPrimitiveType,\n        data.eachGeometryPositionsPortion,\n        data.eachGeometryNormalsPortion,\n        data.eachGeometryColorsPortion,\n        data.eachGeometryUVsPortion,\n        data.eachGeometryIndicesPortion,\n        data.eachGeometryEdgeIndicesPortion,\n        data.eachMeshGeometriesPortion,\n        data.eachMeshMatricesPortion,\n        data.eachMeshTextureSet,\n        data.eachMeshMaterialAttributes,\n        object2Array(data.eachEntityId),\n        data.eachEntityMeshesPortion,\n        data.eachTileAABB,\n        data.eachTileEntitiesPortion\n    ];\n\n    const arraysCnt = arrays.length;\n    const dataView = new DataView(new ArrayBuffer((1 + 2 * arraysCnt) * 4));\n\n    dataView.setUint32(0, XKT_VERSION, true);\n\n    let byteOffset = dataView.byteLength;\n    const offsets = [ ];\n\n    // Store arrays' offsets and lengths\n    for (let i = 0; i < arraysCnt; i++) {\n        const arr = arrays[i];\n        const BPE = arr.BYTES_PER_ELEMENT;\n        // align to BPE, so the arrayBuffer can be used for a typed array\n        byteOffset = Math.ceil(byteOffset / BPE) * BPE;\n        const byteLength = arr.byteLength;\n\n        const idx = 1 + 2 * i;\n        dataView.setUint32(idx       * 4, byteOffset, true);\n        dataView.setUint32((idx + 1) * 4, byteLength, true);\n\n        offsets.push(byteOffset);\n        byteOffset += byteLength;\n    }\n\n    const dataArray = new Uint8Array(byteOffset);\n    dataArray.set(new Uint8Array(dataView.buffer), 0);\n\n    const requiresSwapToLittleEndian = (function() {\n        const buffer = new ArrayBuffer(2);\n        new Uint16Array(buffer)[0] = 1;\n        return new Uint8Array(buffer)[0] !== 1;\n    })();\n\n    // Store arrays themselves\n    for (let i = 0; i < arraysCnt; i++) {\n        const arr = arrays[i];\n        const subarray = new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n\n        const BPE = arr.BYTES_PER_ELEMENT;\n        if (requiresSwapToLittleEndian && (BPE > 1)) {\n            const swaps = BPE / 2;\n            const cnt = subarray.length / BPE;\n            for (let b = 0; b < cnt; b++) {\n                const offset = b * BPE;\n                for (let j = 0; j < swaps; j++) {\n                    const i1 = offset + j;\n                    const i2 = offset - j + BPE - 1;\n                    const tmp = subarray[i1];\n                    subarray[i1] = subarray[i2];\n                    subarray[i2] = tmp;\n                }\n            }\n        }\n\n        dataArray.set(subarray, offsets[i]);\n    }\n\n    return dataArray.buffer;\n}\n\nfunction getModelData(xktModel, metaModelDataStr, stats) {\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Allocate data\n    //------------------------------------------------------------------------------------------------------------------\n\n    const propertySetsList = xktModel.propertySetsList;\n    const metaObjectsList = xktModel.metaObjectsList;\n    const geometriesList = xktModel.geometriesList;\n    const texturesList = xktModel.texturesList;\n    const textureSetsList = xktModel.textureSetsList;\n    const meshesList = xktModel.meshesList;\n    const entitiesList = xktModel.entitiesList;\n    const tilesList = xktModel.tilesList;\n\n    const numPropertySets = propertySetsList.length;\n    const numMetaObjects = metaObjectsList.length;\n    const numGeometries = geometriesList.length;\n    const numTextures = texturesList.length;\n    const numTextureSets = textureSetsList.length;\n    const numMeshes = meshesList.length;\n    const numEntities = entitiesList.length;\n    const numTiles = tilesList.length;\n\n    let lenPositions = 0;\n    let lenNormals = 0;\n    let lenColors = 0;\n    let lenUVs = 0;\n    let lenIndices = 0;\n    let lenEdgeIndices = 0;\n    let lenMatrices = 0;\n    let lenTextures = 0;\n\n    for (let geometryIndex = 0; geometryIndex < numGeometries; geometryIndex++) {\n        const geometry = geometriesList [geometryIndex];\n        if (geometry.positionsQuantized) {\n            lenPositions += geometry.positionsQuantized.length;\n        }\n        if (geometry.normalsOctEncoded) {\n            lenNormals += geometry.normalsOctEncoded.length;\n        }\n        if (geometry.colorsCompressed) {\n            lenColors += geometry.colorsCompressed.length;\n        }\n        if (geometry.uvs) {\n            lenUVs += geometry.uvs.length;\n        }\n        if (geometry.indices) {\n            lenIndices += geometry.indices.length;\n        }\n        if (geometry.edgeIndices) {\n            lenEdgeIndices += geometry.edgeIndices.length;\n        }\n    }\n\n    for (let textureIndex = 0; textureIndex < numTextures; textureIndex++) {\n        const xktTexture = texturesList[textureIndex];\n        const imageData = xktTexture.imageData;\n        lenTextures += imageData.byteLength;\n\n        if (xktTexture.compressed) {\n            stats.numCompressedTextures++;\n        }\n    }\n\n    for (let meshIndex = 0; meshIndex < numMeshes; meshIndex++) {\n        const mesh = meshesList[meshIndex];\n        if (mesh.geometry.numInstances > 1) {\n            lenMatrices += 16;\n        }\n    }\n\n    const data = {\n        metadata: {},\n        textureData: new Uint8Array(lenTextures), // All textures\n        eachTextureDataPortion: new Uint32Array(numTextures), // For each texture, an index to its first element in textureData\n        eachTextureAttributes: new Uint16Array(numTextures * NUM_TEXTURE_ATTRIBUTES),\n        positions: new Uint16Array(lenPositions), // All geometry arrays\n        normals: new Int8Array(lenNormals),\n        colors: new Uint8Array(lenColors),\n        uvs: new Float32Array(lenUVs),\n        indices: new Uint32Array(lenIndices),\n        edgeIndices: new Uint32Array(lenEdgeIndices),\n        eachTextureSetTextures: new Int32Array(numTextureSets * 5), // For each texture set, a set of five Texture indices [color, metal/roughness,normals,emissive,occlusion]; each index has value -1 if no texture\n        matrices: new Float32Array(lenMatrices), // Modeling matrices for entities that share geometries. Each entity either shares all it's geometries, or owns all its geometries exclusively. Exclusively-owned geometries are pre-transformed into World-space, and so their entities don't have modeling matrices in this array.\n        reusedGeometriesDecodeMatrix: new Float32Array(xktModel.reusedGeometriesDecodeMatrix), // A single, global vertex position de-quantization matrix for all reused geometries. Reused geometries are quantized to their collective Local-space AABB, and this matrix is derived from that AABB.\n        eachGeometryPrimitiveType: new Uint8Array(numGeometries), // Primitive type for each geometry (0=solid triangles, 1=surface triangles, 2=lines, 3=points, 4=line-strip)\n        eachGeometryPositionsPortion: new Uint32Array(numGeometries), // For each geometry, an index to its first element in data.positions. Every primitive type has positions.\n        eachGeometryNormalsPortion: new Uint32Array(numGeometries), // For each geometry, an index to its first element in data.normals. If the next geometry has the same index, then this geometry has no normals.\n        eachGeometryColorsPortion: new Uint32Array(numGeometries), // For each geometry, an index to its first element in data.colors. If the next geometry has the same index, then this geometry has no colors.\n        eachGeometryUVsPortion: new Uint32Array(numGeometries), // For each geometry, an index to its first element in data.uvs. If the next geometry has the same index, then this geometry has no UVs.\n        eachGeometryIndicesPortion: new Uint32Array(numGeometries), // For each geometry, an index to its first element in data.indices. If the next geometry has the same index, then this geometry has no indices.\n        eachGeometryEdgeIndicesPortion: new Uint32Array(numGeometries), // For each geometry, an index to its first element in data.edgeIndices. If the next geometry has the same index, then this geometry has no edge indices.\n        eachMeshGeometriesPortion: new Uint32Array(numMeshes), // For each mesh, an index into the eachGeometry* arrays\n        eachMeshMatricesPortion: new Uint32Array(numMeshes), // For each mesh that shares its geometry, an index to its first element in data.matrices, to indicate the modeling matrix that transforms the shared geometry Local-space vertex positions. This is ignored for meshes that don't share geometries, because the vertex positions of non-shared geometries are pre-transformed into World-space.\n        eachMeshTextureSet: new Int32Array(numMeshes), // For each mesh, the index of its texture set in data.eachTextureSetTextures; this array contains signed integers so that we can use -1 to indicate when a mesh has no texture set\n        eachMeshMaterialAttributes: new Uint8Array(numMeshes * NUM_MATERIAL_ATTRIBUTES), // For each mesh, an RGBA integer color of format [0..255, 0..255, 0..255, 0..255], and PBR metallic and roughness factors, of format [0..255, 0..255]\n        eachEntityId: [], // For each entity, an ID string\n        eachEntityMeshesPortion: new Uint32Array(numEntities), // For each entity, the index of the first element of meshes used by the entity\n        eachTileAABB: new Float64Array(numTiles * 6), // For each tile, an axis-aligned bounding box\n        eachTileEntitiesPortion: new Uint32Array(numTiles) // For each tile, the index of the first element of eachEntityId, eachEntityMeshesPortion and eachEntityMatricesPortion used by the tile\n    };\n\n    let countPositions = 0;\n    let countNormals = 0;\n    let countColors = 0;\n    let countUVs = 0;\n    let countIndices = 0;\n    let countEdgeIndices = 0;\n\n    // Metadata\n\n    data.metadata = {\n        id: xktModel.modelId,\n        projectId: xktModel.projectId,\n        revisionId: xktModel.revisionId,\n        author: xktModel.author,\n        createdAt: xktModel.createdAt,\n        creatingApplication: xktModel.creatingApplication,\n        schema: xktModel.schema,\n        propertySets: [],\n        metaObjects: []\n    };\n\n    // Property sets\n\n    for (let propertySetsIndex = 0; propertySetsIndex < numPropertySets; propertySetsIndex++) {\n        const propertySet = propertySetsList[propertySetsIndex];\n        const propertySetJSON = {\n            id: \"\" + propertySet.propertySetId,\n            name: propertySet.propertySetName,\n            type: propertySet.propertySetType,\n            properties: propertySet.properties\n        };\n        data.metadata.propertySets.push(propertySetJSON);\n    }\n\n    // Metaobjects\n\n    if (!metaModelDataStr) {\n        for (let metaObjectsIndex = 0; metaObjectsIndex < numMetaObjects; metaObjectsIndex++) {\n            const metaObject = metaObjectsList[metaObjectsIndex];\n            const metaObjectJSON = {\n                name: metaObject.metaObjectName,\n                type: metaObject.metaObjectType,\n                id: \"\" + metaObject.metaObjectId\n            };\n            if (metaObject.parentMetaObjectId !== undefined && metaObject.parentMetaObjectId !== null) {\n                metaObjectJSON.parent = \"\" + metaObject.parentMetaObjectId;\n            }\n            if (metaObject.propertySetIds && metaObject.propertySetIds.length > 0) {\n                metaObjectJSON.propertySetIds = metaObject.propertySetIds;\n            }\n            if (metaObject.external) {\n                metaObjectJSON.external = metaObject.external;\n            }\n            data.metadata.metaObjects.push(metaObjectJSON);\n        }\n    }\n\n    // Geometries\n\n    for (let geometryIndex = 0; geometryIndex < numGeometries; geometryIndex++) {\n        const geometry = geometriesList [geometryIndex];\n        let primitiveType = 1;\n        switch (geometry.primitiveType) {\n            case \"triangles\":\n                primitiveType = geometry.solid ? 0 : 1;\n                break;\n            case \"points\":\n                primitiveType = 2;\n                break;\n            case \"lines\":\n                primitiveType = 3;\n                break;\n            case \"line-strip\":\n            case \"line-loop\":\n                primitiveType = 4;\n                break;\n            case \"triangle-strip\":\n                primitiveType = 5;\n                break;\n            case \"triangle-fan\":\n                primitiveType = 6;\n                break;\n            default:\n                primitiveType = 1\n        }\n        data.eachGeometryPrimitiveType [geometryIndex] = primitiveType;\n        data.eachGeometryPositionsPortion [geometryIndex] = countPositions;\n        data.eachGeometryNormalsPortion [geometryIndex] = countNormals;\n        data.eachGeometryColorsPortion [geometryIndex] = countColors;\n        data.eachGeometryUVsPortion [geometryIndex] = countUVs;\n        data.eachGeometryIndicesPortion [geometryIndex] = countIndices;\n        data.eachGeometryEdgeIndicesPortion [geometryIndex] = countEdgeIndices;\n        if (geometry.positionsQuantized) {\n            data.positions.set(geometry.positionsQuantized, countPositions);\n            countPositions += geometry.positionsQuantized.length;\n        }\n        if (geometry.normalsOctEncoded) {\n            data.normals.set(geometry.normalsOctEncoded, countNormals);\n            countNormals += geometry.normalsOctEncoded.length;\n        }\n        if (geometry.colorsCompressed) {\n            data.colors.set(geometry.colorsCompressed, countColors);\n            countColors += geometry.colorsCompressed.length;\n        }\n        if (geometry.uvs) {\n            data.uvs.set(geometry.uvs, countUVs);\n            countUVs += geometry.uvs.length;\n        }\n        if (geometry.indices) {\n            data.indices.set(geometry.indices, countIndices);\n            countIndices += geometry.indices.length;\n        }\n        if (geometry.edgeIndices) {\n            data.edgeIndices.set(geometry.edgeIndices, countEdgeIndices);\n            countEdgeIndices += geometry.edgeIndices.length;\n        }\n    }\n\n    // Textures\n\n    for (let textureIndex = 0, numTextures = xktModel.texturesList.length, portionIdx = 0; textureIndex < numTextures; textureIndex++) {\n        const xktTexture = xktModel.texturesList[textureIndex];\n        const imageData = xktTexture.imageData;\n        data.textureData.set(imageData, portionIdx);\n        data.eachTextureDataPortion[textureIndex] = portionIdx;\n\n        portionIdx += imageData.byteLength;\n\n        let textureAttrIdx = textureIndex * NUM_TEXTURE_ATTRIBUTES;\n        data.eachTextureAttributes[textureAttrIdx++] = xktTexture.compressed ? 1 : 0;\n        data.eachTextureAttributes[textureAttrIdx++] = xktTexture.mediaType; // GIFMediaType | PNGMediaType | JPEGMediaType\n        data.eachTextureAttributes[textureAttrIdx++] = xktTexture.width;\n        data.eachTextureAttributes[textureAttrIdx++] = xktTexture.height;\n        data.eachTextureAttributes[textureAttrIdx++] = xktTexture.minFilter; // LinearMipmapLinearFilter | LinearMipMapNearestFilter | NearestMipMapNearestFilter | NearestMipMapLinearFilter | LinearMipMapLinearFilter\n        data.eachTextureAttributes[textureAttrIdx++] = xktTexture.magFilter; // LinearFilter | NearestFilter\n        data.eachTextureAttributes[textureAttrIdx++] = xktTexture.wrapS; // ClampToEdgeWrapping | MirroredRepeatWrapping | RepeatWrapping\n        data.eachTextureAttributes[textureAttrIdx++] = xktTexture.wrapT; // ClampToEdgeWrapping | MirroredRepeatWrapping | RepeatWrapping\n        data.eachTextureAttributes[textureAttrIdx++] = xktTexture.wrapR; // ClampToEdgeWrapping | MirroredRepeatWrapping | RepeatWrapping\n    }\n\n    // Texture sets\n\n    for (let textureSetIndex = 0, numTextureSets = xktModel.textureSetsList.length, eachTextureSetTexturesIndex = 0; textureSetIndex < numTextureSets; textureSetIndex++) {\n        const textureSet = textureSetsList[textureSetIndex];\n        data.eachTextureSetTextures[eachTextureSetTexturesIndex++] = textureSet.colorTexture ? textureSet.colorTexture.textureIndex : -1; // Color map\n        data.eachTextureSetTextures[eachTextureSetTexturesIndex++] = textureSet.metallicRoughnessTexture ? textureSet.metallicRoughnessTexture.textureIndex : -1; // Metal/rough map\n        data.eachTextureSetTextures[eachTextureSetTexturesIndex++] = textureSet.normalsTexture ? textureSet.normalsTexture.textureIndex : -1; // Normal map\n        data.eachTextureSetTextures[eachTextureSetTexturesIndex++] = textureSet.emissiveTexture ? textureSet.emissiveTexture.textureIndex : -1; // Emissive map\n        data.eachTextureSetTextures[eachTextureSetTexturesIndex++] = textureSet.occlusionTexture ? textureSet.occlusionTexture.textureIndex : -1; // Occlusion map\n    }\n\n    // Tiles -> Entities -> Meshes\n\n    let entityIndex = 0;\n    let countEntityMeshesPortion = 0;\n    let eachMeshMaterialAttributesIndex = 0;\n    let matricesIndex = 0;\n    let meshIndex = 0;\n\n    for (let tileIndex = 0; tileIndex < numTiles; tileIndex++) {\n\n        const tile = tilesList [tileIndex];\n        const tileEntities = tile.entities;\n        const numTileEntities = tileEntities.length;\n\n        if (numTileEntities === 0) {\n            continue;\n        }\n\n        data.eachTileEntitiesPortion[tileIndex] = entityIndex;\n\n        const tileAABB = tile.aabb;\n\n        for (let j = 0; j < numTileEntities; j++) {\n\n            const entity = tileEntities[j];\n            const entityMeshes = entity.meshes;\n            const numEntityMeshes = entityMeshes.length;\n\n            for (let k = 0; k < numEntityMeshes; k++) {\n\n                const mesh = entityMeshes[k];\n                const geometry = mesh.geometry;\n                const geometryIndex = geometry.geometryIndex;\n\n                data.eachMeshGeometriesPortion [countEntityMeshesPortion + k] = geometryIndex;\n\n                if (mesh.geometry.numInstances > 1) {\n                    data.matrices.set(mesh.matrix, matricesIndex);\n                    data.eachMeshMatricesPortion [meshIndex] = matricesIndex;\n                    matricesIndex += 16;\n                }\n\n                data.eachMeshTextureSet[meshIndex] = mesh.textureSet ? mesh.textureSet.textureSetIndex : -1;\n\n                data.eachMeshMaterialAttributes[eachMeshMaterialAttributesIndex++] = (mesh.color[0] * 255); // Color RGB\n                data.eachMeshMaterialAttributes[eachMeshMaterialAttributesIndex++] = (mesh.color[1] * 255);\n                data.eachMeshMaterialAttributes[eachMeshMaterialAttributesIndex++] = (mesh.color[2] * 255);\n                data.eachMeshMaterialAttributes[eachMeshMaterialAttributesIndex++] = (mesh.opacity * 255); // Opacity\n                data.eachMeshMaterialAttributes[eachMeshMaterialAttributesIndex++] = (mesh.metallic * 255); // Metallic\n                data.eachMeshMaterialAttributes[eachMeshMaterialAttributesIndex++] = (mesh.roughness * 255); // Roughness\n\n                meshIndex++;\n            }\n\n            data.eachEntityId [entityIndex] = entity.entityId;\n            data.eachEntityMeshesPortion[entityIndex] = countEntityMeshesPortion; // <<<<<<<<<<<<<<<<<<<< Error here? Order/value of countEntityMeshesPortion correct?\n\n            entityIndex++;\n            countEntityMeshesPortion += numEntityMeshes;\n        }\n\n        const tileAABBIndex = tileIndex * 6;\n\n        data.eachTileAABB.set(tileAABB, tileAABBIndex);\n    }\n\n    return data;\n}\n\nfunction deflateData(data, metaModelJSON, options) {\n\n    function deflate(buffer) {\n        return (options.zip !== false) ? pako.deflate(buffer) : buffer;\n    }\n\n    let metaModelBytes;\n    if (metaModelJSON) {\n        const deflatedJSON = deflateJSON(metaModelJSON);\n        metaModelBytes = deflate(deflatedJSON)\n    } else {\n        const deflatedJSON = deflateJSON(data.metadata);\n        metaModelBytes = deflate(deflatedJSON)\n    }\n\n    return {\n        metadata: metaModelBytes,\n        textureData: deflate(data.textureData.buffer),\n        eachTextureDataPortion: deflate(data.eachTextureDataPortion.buffer),\n        eachTextureAttributes: deflate(data.eachTextureAttributes.buffer),\n        positions: deflate(data.positions.buffer),\n        normals: deflate(data.normals.buffer),\n        colors: deflate(data.colors.buffer),\n        uvs: deflate(data.uvs.buffer),\n        indices: deflate(data.indices.buffer),\n        edgeIndices: deflate(data.edgeIndices.buffer),\n        eachTextureSetTextures: deflate(data.eachTextureSetTextures.buffer),\n        matrices: deflate(data.matrices.buffer),\n        reusedGeometriesDecodeMatrix: deflate(data.reusedGeometriesDecodeMatrix.buffer),\n        eachGeometryPrimitiveType: deflate(data.eachGeometryPrimitiveType.buffer),\n        eachGeometryPositionsPortion: deflate(data.eachGeometryPositionsPortion.buffer),\n        eachGeometryNormalsPortion: deflate(data.eachGeometryNormalsPortion.buffer),\n        eachGeometryColorsPortion: deflate(data.eachGeometryColorsPortion.buffer),\n        eachGeometryUVsPortion: deflate(data.eachGeometryUVsPortion.buffer),\n        eachGeometryIndicesPortion: deflate(data.eachGeometryIndicesPortion.buffer),\n        eachGeometryEdgeIndicesPortion: deflate(data.eachGeometryEdgeIndicesPortion.buffer),\n        eachMeshGeometriesPortion: deflate(data.eachMeshGeometriesPortion.buffer),\n        eachMeshMatricesPortion: deflate(data.eachMeshMatricesPortion.buffer),\n        eachMeshTextureSet: deflate(data.eachMeshTextureSet.buffer),\n        eachMeshMaterialAttributes: deflate(data.eachMeshMaterialAttributes.buffer),\n        eachEntityId: deflate(JSON.stringify(data.eachEntityId)\n            .replace(/[\\u007F-\\uFFFF]/g, function (chr) { // Produce only ASCII-chars, so that the data can be inflated later\n                return \"\\\\u\" + (\"0000\" + chr.charCodeAt(0).toString(16)).substr(-4)\n            })),\n        eachEntityMeshesPortion: deflate(data.eachEntityMeshesPortion.buffer),\n        eachTileAABB: deflate(data.eachTileAABB.buffer),\n        eachTileEntitiesPortion: deflate(data.eachTileEntitiesPortion.buffer)\n    };\n}\n\nfunction deflateJSON(strings) {\n    return JSON.stringify(strings)\n        .replace(/[\\u007F-\\uFFFF]/g, function (chr) { // Produce only ASCII-chars, so that the data can be inflated later\n            return \"\\\\u\" + (\"0000\" + chr.charCodeAt(0).toString(16)).substr(-4)\n        });\n}\n\nfunction createArrayBuffer(deflatedData) {\n    return toArrayBuffer([\n        deflatedData.metadata,\n        deflatedData.textureData,\n        deflatedData.eachTextureDataPortion,\n        deflatedData.eachTextureAttributes,\n        deflatedData.positions,\n        deflatedData.normals,\n        deflatedData.colors,\n        deflatedData.uvs,\n        deflatedData.indices,\n        deflatedData.edgeIndices,\n        deflatedData.eachTextureSetTextures,\n        deflatedData.matrices,\n        deflatedData.reusedGeometriesDecodeMatrix,\n        deflatedData.eachGeometryPrimitiveType,\n        deflatedData.eachGeometryPositionsPortion,\n        deflatedData.eachGeometryNormalsPortion,\n        deflatedData.eachGeometryColorsPortion,\n        deflatedData.eachGeometryUVsPortion,\n        deflatedData.eachGeometryIndicesPortion,\n        deflatedData.eachGeometryEdgeIndicesPortion,\n        deflatedData.eachMeshGeometriesPortion,\n        deflatedData.eachMeshMatricesPortion,\n        deflatedData.eachMeshTextureSet,\n        deflatedData.eachMeshMaterialAttributes,\n        deflatedData.eachEntityId,\n        deflatedData.eachEntityMeshesPortion,\n        deflatedData.eachTileAABB,\n        deflatedData.eachTileEntitiesPortion\n    ]);\n}\n\nfunction toArrayBuffer(elements) {\n    const indexData = new Uint32Array(elements.length + 2);\n    indexData[0] = 10; // XKT_VERSION for legacy v10 mode\n    indexData [1] = elements.length;  // Stored Data 1.1: number of stored elements\n    let dataLen = 0;    // Stored Data 1.2: length of stored elements\n    for (let i = 0, len = elements.length; i < len; i++) {\n        const element = elements[i];\n        const elementsize = element.length;\n        indexData[i + 2] = elementsize;\n        dataLen += elementsize;\n    }\n    const indexBuf = new Uint8Array(indexData.buffer);\n    const dataArray = new Uint8Array(indexBuf.length + dataLen);\n    dataArray.set(indexBuf);\n    let offset = indexBuf.length;\n    for (let i = 0, len = elements.length; i < len; i++) {     // Stored Data 2: the elements themselves\n        const element = elements[i];\n        dataArray.set(element, offset);\n        offset += element.length;\n    }\n    return dataArray.buffer;\n}\n\nexport {writeXKTModelToArrayBuffer};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 300,
    "kind": "variable",
    "name": "XKT_VERSION",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~XKT_VERSION",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 301,
    "kind": "variable",
    "name": "NUM_TEXTURE_ATTRIBUTES",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~NUM_TEXTURE_ATTRIBUTES",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 302,
    "kind": "variable",
    "name": "NUM_MATERIAL_ATTRIBUTES",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~NUM_MATERIAL_ATTRIBUTES",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 303,
    "kind": "function",
    "name": "writeXKTModelToArrayBufferUncompressed",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~writeXKTModelToArrayBufferUncompressed",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 30,
    "undocument": true,
    "params": [
      {
        "name": "xktModel",
        "types": [
          "*"
        ]
      },
      {
        "name": "metaModelJSON",
        "types": [
          "*"
        ]
      },
      {
        "name": "stats",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 304,
    "kind": "function",
    "name": "getModelData",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~getModelData",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 130,
    "undocument": true,
    "params": [
      {
        "name": "xktModel",
        "types": [
          "*"
        ]
      },
      {
        "name": "metaModelDataStr",
        "types": [
          "*"
        ]
      },
      {
        "name": "stats",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 305,
    "kind": "function",
    "name": "deflateData",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~deflateData",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 453,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "metaModelJSON",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "{\"metadata\": *, \"textureData\": *, \"eachTextureDataPortion\": *, \"eachTextureAttributes\": *, \"positions\": *, \"normals\": *, \"colors\": *, \"uvs\": *, \"indices\": *, \"edgeIndices\": *, \"eachTextureSetTextures\": *, \"matrices\": *, \"reusedGeometriesDecodeMatrix\": *, \"eachGeometryPrimitiveType\": *, \"eachGeometryPositionsPortion\": *, \"eachGeometryNormalsPortion\": *, \"eachGeometryColorsPortion\": *, \"eachGeometryUVsPortion\": *, \"eachGeometryIndicesPortion\": *, \"eachGeometryEdgeIndicesPortion\": *, \"eachMeshGeometriesPortion\": *, \"eachMeshMatricesPortion\": *, \"eachMeshTextureSet\": *, \"eachMeshMaterialAttributes\": *, \"eachEntityId\": *, \"eachEntityMeshesPortion\": *, \"eachTileAABB\": *, \"eachTileEntitiesPortion\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 306,
    "kind": "function",
    "name": "deflateJSON",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~deflateJSON",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 503,
    "undocument": true,
    "params": [
      {
        "name": "strings",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 307,
    "kind": "function",
    "name": "createArrayBuffer",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~createArrayBuffer",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 510,
    "undocument": true,
    "params": [
      {
        "name": "deflatedData",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 308,
    "kind": "function",
    "name": "toArrayBuffer",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~toArrayBuffer",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 543,
    "undocument": true,
    "params": [
      {
        "name": "elements",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 309,
    "kind": "function",
    "name": "writeXKTModelToArrayBuffer",
    "memberof": "src/XKTModel/writeXKTModelToArrayBuffer.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/XKTModel/writeXKTModelToArrayBuffer.js~writeXKTModelToArrayBuffer",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKTModel/writeXKTModelToArrayBuffer.js",
    "importStyle": "{writeXKTModelToArrayBuffer}",
    "description": "Writes an {@link XKTModel} to an {@link ArrayBuffer}.",
    "lineNumber": 18,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{ArrayBuffer} The {@link ArrayBuffer}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "xktModel",
        "description": "The {@link XKTModel}."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "metaModelJSON",
        "description": "The metamodel JSON in a string."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "stats",
        "description": "Collects statistics."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "options",
        "description": "Options for how the XKT is written."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "options.zip",
        "description": "ZIP the contents?"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "ArrayBuffer"
      ],
      "spread": false,
      "description": "The {@link ArrayBuffer}."
    }
  },
  {
    "__docId__": 310,
    "kind": "file",
    "name": "src/XKT_INFO.js",
    "content": "/**\n * @desc Provides info on the XKT generated by xeokit-convert.\n */\nconst XKT_INFO = {\n\n    /**\n     * The XKT version generated by xeokit-convert.\n     *\n     * This is the XKT version that's modeled by {@link XKTModel}, serialized\n     * by {@link writeXKTModelToArrayBuffer}, and written by {@link convert2xkt}.\n     *\n     * * Current XKT version: **10**\n     * * [XKT format specs](https://github.com/xeokit/xeokit-convert/blob/main/specs/index.md)\n     *\n     * @property xktVersion\n     * @type {number}\n     */\n    xktVersion: 11\n};\n\nexport {XKT_INFO};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/XKT_INFO.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 311,
    "kind": "variable",
    "name": "XKT_INFO",
    "memberof": "src/XKT_INFO.js",
    "static": true,
    "longname": "src/XKT_INFO.js~XKT_INFO",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/XKT_INFO.js",
    "importStyle": "{XKT_INFO}",
    "description": "Provides info on the XKT generated by xeokit-convert.",
    "lineNumber": 4,
    "type": {
      "types": [
        "{\"xktVersion\": number}"
      ]
    }
  },
  {
    "__docId__": 312,
    "kind": "file",
    "name": "src/constants.js",
    "content": "/*----------------------------------------------------------------------------------------------------------------------\n * NOTE: The values of these constants must match those within xeokit-sdk\n *--------------------------------------------------------------------------------------------------------------------*/\n\n/**\n * Texture wrapping mode in which the texture repeats to infinity.\n */\nexport const RepeatWrapping = 1000;\n\n/**\n * Texture wrapping mode in which the last pixel of the texture stretches to the edge of the mesh.\n */\nexport const ClampToEdgeWrapping = 1001;\n\n/**\n * Texture wrapping mode in which the texture repeats to infinity, mirroring on each repeat.\n */\nexport const MirroredRepeatWrapping = 1002;\n\n/**\n * Texture magnification and minification filter that returns the nearest texel to the given sample coordinates.\n */\nexport const NearestFilter = 1003;\n\n/**\n * Texture minification filter that chooses the mipmap that most closely matches the size of the pixel being textured and returns the nearest texel to the given sample coordinates.\n */\nexport const NearestMipMapNearestFilter = 1004;\n\n/**\n * Texture minification filter that chooses the mipmap that most closely matches the size of the pixel being textured\n * and returns the nearest texel to the given sample coordinates.\n */\nexport const NearestMipmapNearestFilter = 1004;\n\n/**\n * Texture minification filter that chooses two mipmaps that most closely match the size of the pixel being textured\n * and returns the nearest texel to the center of the pixel at the given sample coordinates.\n */\nexport const NearestMipmapLinearFilter = 1005;\n\n/**\n * Texture minification filter that chooses two mipmaps that most closely match the size of the pixel being textured\n * and returns the nearest texel to the center of the pixel at the given sample coordinates.\n */\nexport const NearestMipMapLinearFilter = 1005;\n\n/**\n * Texture magnification and minification filter that returns the weighted average of the four nearest texels to the given sample coordinates.\n */\nexport const LinearFilter = 1006;\n\n/**\n * Texture minification filter that chooses the mipmap that most closely matches the size of the pixel being textured and\n * returns the weighted average of the four nearest texels to the given sample coordinates.\n */\nexport const LinearMipmapNearestFilter = 1007;\n\n/**\n * Texture minification filter that chooses the mipmap that most closely matches the size of the pixel being textured and\n * returns the weighted average of the four nearest texels to the given sample coordinates.\n */\nexport const LinearMipMapNearestFilter = 1007;\n\n/**\n * Texture minification filter that chooses two mipmaps that most closely match the size of the pixel being textured,\n * finds within each mipmap the weighted average of the nearest texel to the center of the pixel, then returns the\n * weighted average of those two values.\n */\nexport const LinearMipmapLinearFilter = 1008;\n\n/**\n * Texture minification filter that chooses two mipmaps that most closely match the size of the pixel being textured,\n * finds within each mipmap the weighted average of the nearest texel to the center of the pixel, then returns the\n * weighted average of those two values.\n */\nexport const LinearMipMapLinearFilter = 1008;\n\n/**\n * Media type for GIF images.\n */\nexport const GIFMediaType = 10000;\n\n/**\n * Media type for JPEG images.\n */\nexport const JPEGMediaType = 10001;\n\n/**\n * Media type for PNG images.\n */\nexport const PNGMediaType = 10002;",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/constants.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 313,
    "kind": "variable",
    "name": "RepeatWrapping",
    "memberof": "src/constants.js",
    "static": true,
    "longname": "src/constants.js~RepeatWrapping",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/constants.js",
    "importStyle": "{RepeatWrapping}",
    "description": "Texture wrapping mode in which the texture repeats to infinity.",
    "lineNumber": 8,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 314,
    "kind": "variable",
    "name": "ClampToEdgeWrapping",
    "memberof": "src/constants.js",
    "static": true,
    "longname": "src/constants.js~ClampToEdgeWrapping",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/constants.js",
    "importStyle": "{ClampToEdgeWrapping}",
    "description": "Texture wrapping mode in which the last pixel of the texture stretches to the edge of the mesh.",
    "lineNumber": 13,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 315,
    "kind": "variable",
    "name": "MirroredRepeatWrapping",
    "memberof": "src/constants.js",
    "static": true,
    "longname": "src/constants.js~MirroredRepeatWrapping",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/constants.js",
    "importStyle": "{MirroredRepeatWrapping}",
    "description": "Texture wrapping mode in which the texture repeats to infinity, mirroring on each repeat.",
    "lineNumber": 18,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 316,
    "kind": "variable",
    "name": "NearestFilter",
    "memberof": "src/constants.js",
    "static": true,
    "longname": "src/constants.js~NearestFilter",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/constants.js",
    "importStyle": "{NearestFilter}",
    "description": "Texture magnification and minification filter that returns the nearest texel to the given sample coordinates.",
    "lineNumber": 23,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 317,
    "kind": "variable",
    "name": "NearestMipMapNearestFilter",
    "memberof": "src/constants.js",
    "static": true,
    "longname": "src/constants.js~NearestMipMapNearestFilter",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/constants.js",
    "importStyle": "{NearestMipMapNearestFilter}",
    "description": "Texture minification filter that chooses the mipmap that most closely matches the size of the pixel being textured and returns the nearest texel to the given sample coordinates.",
    "lineNumber": 28,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 318,
    "kind": "variable",
    "name": "NearestMipmapNearestFilter",
    "memberof": "src/constants.js",
    "static": true,
    "longname": "src/constants.js~NearestMipmapNearestFilter",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/constants.js",
    "importStyle": "{NearestMipmapNearestFilter}",
    "description": "Texture minification filter that chooses the mipmap that most closely matches the size of the pixel being textured\nand returns the nearest texel to the given sample coordinates.",
    "lineNumber": 34,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 319,
    "kind": "variable",
    "name": "NearestMipmapLinearFilter",
    "memberof": "src/constants.js",
    "static": true,
    "longname": "src/constants.js~NearestMipmapLinearFilter",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/constants.js",
    "importStyle": "{NearestMipmapLinearFilter}",
    "description": "Texture minification filter that chooses two mipmaps that most closely match the size of the pixel being textured\nand returns the nearest texel to the center of the pixel at the given sample coordinates.",
    "lineNumber": 40,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 320,
    "kind": "variable",
    "name": "NearestMipMapLinearFilter",
    "memberof": "src/constants.js",
    "static": true,
    "longname": "src/constants.js~NearestMipMapLinearFilter",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/constants.js",
    "importStyle": "{NearestMipMapLinearFilter}",
    "description": "Texture minification filter that chooses two mipmaps that most closely match the size of the pixel being textured\nand returns the nearest texel to the center of the pixel at the given sample coordinates.",
    "lineNumber": 46,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 321,
    "kind": "variable",
    "name": "LinearFilter",
    "memberof": "src/constants.js",
    "static": true,
    "longname": "src/constants.js~LinearFilter",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/constants.js",
    "importStyle": "{LinearFilter}",
    "description": "Texture magnification and minification filter that returns the weighted average of the four nearest texels to the given sample coordinates.",
    "lineNumber": 51,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 322,
    "kind": "variable",
    "name": "LinearMipmapNearestFilter",
    "memberof": "src/constants.js",
    "static": true,
    "longname": "src/constants.js~LinearMipmapNearestFilter",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/constants.js",
    "importStyle": "{LinearMipmapNearestFilter}",
    "description": "Texture minification filter that chooses the mipmap that most closely matches the size of the pixel being textured and\nreturns the weighted average of the four nearest texels to the given sample coordinates.",
    "lineNumber": 57,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 323,
    "kind": "variable",
    "name": "LinearMipMapNearestFilter",
    "memberof": "src/constants.js",
    "static": true,
    "longname": "src/constants.js~LinearMipMapNearestFilter",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/constants.js",
    "importStyle": "{LinearMipMapNearestFilter}",
    "description": "Texture minification filter that chooses the mipmap that most closely matches the size of the pixel being textured and\nreturns the weighted average of the four nearest texels to the given sample coordinates.",
    "lineNumber": 63,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 324,
    "kind": "variable",
    "name": "LinearMipmapLinearFilter",
    "memberof": "src/constants.js",
    "static": true,
    "longname": "src/constants.js~LinearMipmapLinearFilter",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/constants.js",
    "importStyle": "{LinearMipmapLinearFilter}",
    "description": "Texture minification filter that chooses two mipmaps that most closely match the size of the pixel being textured,\nfinds within each mipmap the weighted average of the nearest texel to the center of the pixel, then returns the\nweighted average of those two values.",
    "lineNumber": 70,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 325,
    "kind": "variable",
    "name": "LinearMipMapLinearFilter",
    "memberof": "src/constants.js",
    "static": true,
    "longname": "src/constants.js~LinearMipMapLinearFilter",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/constants.js",
    "importStyle": "{LinearMipMapLinearFilter}",
    "description": "Texture minification filter that chooses two mipmaps that most closely match the size of the pixel being textured,\nfinds within each mipmap the weighted average of the nearest texel to the center of the pixel, then returns the\nweighted average of those two values.",
    "lineNumber": 77,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 326,
    "kind": "variable",
    "name": "GIFMediaType",
    "memberof": "src/constants.js",
    "static": true,
    "longname": "src/constants.js~GIFMediaType",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/constants.js",
    "importStyle": "{GIFMediaType}",
    "description": "Media type for GIF images.",
    "lineNumber": 82,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 327,
    "kind": "variable",
    "name": "JPEGMediaType",
    "memberof": "src/constants.js",
    "static": true,
    "longname": "src/constants.js~JPEGMediaType",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/constants.js",
    "importStyle": "{JPEGMediaType}",
    "description": "Media type for JPEG images.",
    "lineNumber": 87,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 328,
    "kind": "variable",
    "name": "PNGMediaType",
    "memberof": "src/constants.js",
    "static": true,
    "longname": "src/constants.js~PNGMediaType",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/constants.js",
    "importStyle": "{PNGMediaType}",
    "description": "Media type for PNG images.",
    "lineNumber": 92,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 329,
    "kind": "file",
    "name": "src/convert2xkt.js",
    "content": "import {XKT_INFO} from \"./XKT_INFO.js\";\nimport {XKTModel} from \"./XKTModel/XKTModel.js\";\nimport {parseCityJSONIntoXKTModel} from \"./parsers/parseCityJSONIntoXKTModel.js\";\nimport {parseGLTFIntoXKTModel} from \"./parsers/parseGLTFIntoXKTModel.js\";\nimport {parseIFCIntoXKTModel} from \"./parsers/parseIFCIntoXKTModel.js\";\nimport {parseLASIntoXKTModel} from \"./parsers/parseLASIntoXKTModel.js\";\nimport {parsePCDIntoXKTModel} from \"./parsers/parsePCDIntoXKTModel.js\";\nimport {parsePLYIntoXKTModel} from \"./parsers/parsePLYIntoXKTModel.js\";\nimport {parseSTLIntoXKTModel} from \"./parsers/parseSTLIntoXKTModel.js\";\nimport {writeXKTModelToArrayBuffer} from \"./XKTModel/writeXKTModelToArrayBuffer.js\";\n\nimport {toArrayBuffer} from \"./XKTModel/lib/toArraybuffer\";\n\nconst fs = require('fs');\nconst path = require(\"path\");\n\n/**\n * Converts model files into xeokit's native XKT format.\n *\n * Supported source formats are: IFC, CityJSON, glTF, LAZ and LAS.\n *\n * **Only bundled in xeokit-convert.cjs.js.**\n *\n * ## Usage\n *\n * ````javascript\n * const convert2xkt = require(\"@xeokit/xeokit-convert/dist/convert2xkt.cjs.js\");\n * const fs = require('fs');\n *\n * convert2xkt({\n *      sourceData: fs.readFileSync(\"rme_advanced_sample_project.ifc\"),\n *      outputXKT: (xtkArrayBuffer) => {\n *          fs.writeFileSync(\"rme_advanced_sample_project.ifc.xkt\", xtkArrayBuffer);\n *      }\n *  }).then(() => {\n *      console.log(\"Converted.\");\n *  }, (errMsg) => {\n *      console.error(\"Conversion failed: \" + errMsg)\n *  });\n ````\n * @param {Object} params Conversion parameters.\n * @param {Object} params.WebIFC The WebIFC library. We pass this in as an external dependency, in order to give the\n * caller the choice of whether to use the Browser or NodeJS version.\n * @param {*} [params.configs] Configurations.\n * @param {String} [params.source] Path to source file. Alternative to ````sourceData````.\n * @param {ArrayBuffer|JSON} [params.sourceData] Source file data. Alternative to ````source````.\n * @param {String} [params.sourceFormat] Format of source file/data. Always needed with ````sourceData````, but not normally needed with ````source````, because convert2xkt will determine the format automatically from the file extension of ````source````.\n * @param {String} [params.metaModelDataStr] Source file data. Overrides metadata from ````metaModelSource````, ````sourceData```` and ````source````.\n * @param {String} [params.metaModelSource] Path to source metaModel file. Overrides metadata from ````sourceData```` and ````source````. Overridden by ````metaModelData````.\n * @param {String} [params.output] Path to destination XKT file. Directories on this path are automatically created if not existing.\n * @param {Function} [params.outputXKTModel] Callback to collect the ````XKTModel```` that is internally build by this method.\n * @param {Function} [params.outputXKT] Callback to collect XKT file data.\n * @param {String[]} [params.includeTypes] Option to only convert objects of these types.\n * @param {String[]} [params.excludeTypes] Option to never convert objects of these types.\n * @param {Object} [stats] Collects conversion statistics. Statistics are attached to this object if provided.\n * @param {Function} [params.outputStats] Callback to collect statistics.\n * @param {Boolean} [params.rotateX=false] Whether to rotate the model 90 degrees about the X axis to make the Y axis \"up\", if necessary. Applies to CityJSON and LAS/LAZ models.\n * @param {Boolean} [params.reuseGeometries=true] When true, will enable geometry reuse within the XKT. When false,\n * will automatically \"expand\" all reused geometries into duplicate copies. This has the drawback of increasing the XKT\n * file size (~10-30% for typical models), but can make the model more responsive in the xeokit Viewer, especially if the model\n * has excessive geometry reuse. An example of excessive geometry reuse would be when a model (eg. glTF) has 4000 geometries that are\n * shared amongst 2000 objects, ie. a large number of geometries with a low amount of reuse, which can present a\n * pathological performance case for xeokit's underlying graphics APIs (WebGL, WebGPU etc).\n * @param {Boolean} [params.includeTextures=true] Whether to convert textures. Only works for ````glTF```` models.\n * @param {Boolean} [params.includeNormals=true] Whether to convert normals. When false, the parser will ignore\n * geometry normals, and the modelwill rely on the xeokit ````Viewer```` to automatically generate them. This has\n * the limitation that the normals will be face-aligned, and therefore the ````Viewer```` will only be able to render\n * a flat-shaded non-PBR representation of the model.\n * @param {Number} [params.minTileSize=200] Minimum RTC coordinate tile size. Set this to a value between 100 and 10000,\n * depending on how far from the coordinate origin the model's vertex positions are; specify larger tile sizes when close\n * to the origin, and smaller sizes when distant.  This compensates for decreasing precision as floats get bigger.\n * @param {Function} [params.log] Logging callback.\n * @return {Promise<number>}\n */\nfunction convert2xkt({\n                         WebIFC,\n                         configs = {},\n                         source,\n                         sourceData,\n                         sourceFormat,\n                         metaModelSource,\n                         metaModelDataStr,\n                         modelAABB,\n                         output,\n                         outputXKTModel,\n                         outputXKT,\n                         includeTypes,\n                         excludeTypes,\n                         reuseGeometries = true,\n                         minTileSize = 200,\n                         stats = {},\n                         outputStats,\n                         rotateX = false,\n                         includeTextures = true,\n                         includeNormals = true,\n                         zip = true,\n                         log = function (msg) {\n                         }\n                     }) {\n\n    stats.sourceFormat = \"\";\n    stats.schemaVersion = \"\";\n    stats.title = \"\";\n    stats.author = \"\";\n    stats.created = \"\";\n    stats.numMetaObjects = 0;\n    stats.numPropertySets = 0;\n    stats.numTriangles = 0;\n    stats.numVertices = 0;\n    stats.numNormals = 0;\n    stats.numUVs = 0;\n    stats.numTextures = 0;\n    stats.numTextureSets = 0;\n    stats.numObjects = 0;\n    stats.numGeometries = 0;\n    stats.sourceSize = 0;\n    stats.xktSize = 0;\n    stats.texturesSize = 0;\n    stats.xktVersion = \"\";\n    stats.compressionRatio = 0;\n    stats.conversionTime = 0;\n    stats.aabb = null;\n\n    function getFileExtension(fileName) {\n        let ext = path.extname(fileName);\n        if (ext.charAt(0) === \".\") {\n            ext = ext.substring(1);\n        }\n        return ext;\n    }\n\n    return new Promise(function (resolve, reject) {\n        const _log = log;\n        log = (msg) => {\n            _log(`[convert2xkt] ${msg}`)\n        }\n\n        if (!source && !sourceData) {\n            reject(\"Argument expected: source or sourceData\");\n            return;\n        }\n\n        if (!sourceFormat && sourceData) {\n            reject(\"Argument expected: sourceFormat is required with sourceData\");\n            return;\n        }\n\n        if (!output && !outputXKTModel && !outputXKT) {\n            reject(\"Argument expected: output, outputXKTModel or outputXKT\");\n            return;\n        }\n\n        if (source) {\n            log('Reading input file: ' + source);\n        }\n\n        const startTime = new Date();\n\n        const sourceConfigs = configs.sourceConfigs || {};\n        const ext = sourceFormat || getFileExtension(source);\n\n        log(`Input file extension: \"${ext}\"`);\n\n        let fileTypeConfigs = sourceConfigs[ext];\n\n        if (!fileTypeConfigs) {\n            log(`[WARNING] Could not find configs sourceConfigs entry for source format \"${ext}\". This is derived from the source file name extension. Will use internal default configs.`);\n            fileTypeConfigs = {};\n        }\n\n        function overrideOption(option1, option2) {\n            if (option1 !== undefined) {\n                return option1;\n            }\n            return option2;\n        }\n\n        if (!sourceData) {\n            try {\n                sourceData = fs.readFileSync(source);\n            } catch (err) {\n                reject(err);\n                return;\n            }\n        }\n\n        const sourceFileSizeBytes = sourceData.byteLength;\n\n        log(\"Input file size: \" + (sourceFileSizeBytes / 1000).toFixed(2) + \" kB\");\n\n        if (!metaModelDataStr && metaModelSource) {\n            log('Reading input metadata file: ' + metaModelSource);\n            try {\n                metaModelDataStr = fs.readFileSync(metaModelSource);\n            } catch (err) {\n                reject(err);\n                return;\n            }\n        } else {\n            log(`Not embedding metadata in XKT`);\n        }\n\n        let metaModelJSON;\n\n        if (metaModelDataStr) {\n            try {\n                metaModelJSON = JSON.parse(metaModelDataStr);\n            } catch (e) {\n                metaModelJSON = {};\n                log(`Error parsing metadata JSON: ${e}`);\n            }\n        }\n\n        minTileSize = overrideOption(fileTypeConfigs.minTileSize, minTileSize);\n        rotateX = overrideOption(fileTypeConfigs.rotateX, rotateX);\n        reuseGeometries = overrideOption(fileTypeConfigs.reuseGeometries, reuseGeometries);\n        includeTextures = overrideOption(fileTypeConfigs.includeTextures, includeTextures);\n        includeNormals = overrideOption(fileTypeConfigs.includeNormals, includeNormals);\n        includeTypes = overrideOption(fileTypeConfigs.includeTypes, includeTypes);\n        excludeTypes = overrideOption(fileTypeConfigs.excludeTypes, excludeTypes);\n\n        if (reuseGeometries === false) {\n            log(\"Geometry reuse is disabled\");\n        }\n\n        const xktModel = new XKTModel({\n            minTileSize,\n            modelAABB\n        });\n\n        switch (ext) {\n            case \"json\":\n                convert(parseCityJSONIntoXKTModel, {\n                    data: JSON.parse(sourceData),\n                    xktModel,\n                    stats,\n                    rotateX,\n                    center: fileTypeConfigs.center,\n                    transform: fileTypeConfigs.transform,\n                    log\n                });\n                break;\n\n            case \"glb\":\n                sourceData = toArrayBuffer(sourceData);\n                convert(parseGLTFIntoXKTModel, {\n                    data: sourceData,\n                    reuseGeometries,\n                    includeTextures: true,\n                    includeNormals,\n                    metaModelData: metaModelJSON,\n                    xktModel,\n                    stats,\n                    log\n                });\n                break;\n\n            case \"gltf\":\n                sourceData = toArrayBuffer(sourceData);\n                const gltfBasePath = source ? path.dirname(source) : \"\";\n                convert(parseGLTFIntoXKTModel, {\n                    baseUri: gltfBasePath,\n                    data: sourceData,\n                    reuseGeometries,\n                    includeTextures: true,\n                    includeNormals,\n                    metaModelData: metaModelJSON,\n                    xktModel,\n                    stats,\n                    log\n                });\n                break;\n\n            // case \"gltf\":\n            //     const gltfJSON = JSON.parse(sourceData);\n            //     const gltfBasePath = source ? getBasePath(source) : \"\";\n            //     convert(parseGLTFIntoXKTModel, {\n            //         baseUri: gltfBasePath,\n            //         data: gltfJSON,\n            //         reuseGeometries,\n            //         includeTextures,\n            //         includeNormals,\n            //         metaModelData: metaModelJSON,\n            //         xktModel,\n            //         getAttachment: async (name) => {\n            //             const filePath = gltfBasePath + name;\n            //             log(`Reading attachment file: ${filePath}`);\n            //             const buffer = fs.readFileSync(filePath);\n            //             const arrayBuf = toArrayBuffer(buffer);\n            //             return arrayBuf;\n            //         },\n            //         stats,\n            //         log\n            //     });\n            //     break;\n\n            case \"ifc\":\n                convert(parseIFCIntoXKTModel, {\n                    WebIFC,\n                    data: sourceData,\n                    xktModel,\n                    wasmPath: \"./\",\n                    includeTypes,\n                    excludeTypes,\n                    stats,\n                    log\n                });\n                break;\n\n            case \"laz\":\n                convert(parseLASIntoXKTModel, {\n                    data: sourceData,\n                    xktModel,\n                    stats,\n                    fp64: fileTypeConfigs.fp64,\n                    colorDepth: fileTypeConfigs.colorDepth,\n                    center: fileTypeConfigs.center,\n                    transform: fileTypeConfigs.transform,\n                    skip: overrideOption(fileTypeConfigs.skip, 1),\n                    log\n                });\n                break;\n\n            case \"las\":\n                convert(parseLASIntoXKTModel, {\n                    data: sourceData,\n                    xktModel,\n                    stats,\n                    fp64: fileTypeConfigs.fp64,\n                    colorDepth: fileTypeConfigs.colorDepth,\n                    center: fileTypeConfigs.center,\n                    transform: fileTypeConfigs.transform,\n                    skip: overrideOption(fileTypeConfigs.skip, 1),\n                    log\n                });\n                break;\n\n            case \"pcd\":\n                convert(parsePCDIntoXKTModel, {\n                    data: sourceData,\n                    xktModel,\n                    stats,\n                    log\n                });\n                break;\n\n            case \"ply\":\n                convert(parsePLYIntoXKTModel, {\n                    data: sourceData,\n                    xktModel,\n                    stats,\n                    log\n                });\n                break;\n\n            case \"stl\":\n                convert(parseSTLIntoXKTModel, {\n                    data: sourceData,\n                    xktModel,\n                    stats,\n                    log\n                });\n                break;\n\n            default:\n                reject(`Error: unsupported source format: \"${ext}\".`);\n                return;\n        }\n\n        function convert(parser, converterParams) {\n\n            parser(converterParams).then(() => {\n\n                if (!metaModelJSON) {\n                    log(\"Creating default metamodel in XKT\");\n                    xktModel.createDefaultMetaObjects();\n                }\n\n                log(\"Input file parsed OK. Building XKT document...\");\n\n                xktModel.finalize().then(() => {\n\n                    log(\"XKT document built OK. Writing to XKT file...\");\n\n                    const xktArrayBuffer = writeXKTModelToArrayBuffer(xktModel, metaModelJSON, stats, {zip: zip});\n\n                    const xktContent = Buffer.from(xktArrayBuffer);\n\n                    const targetFileSizeBytes = xktArrayBuffer.byteLength;\n\n                    stats.minTileSize = minTileSize || 200;\n                    stats.sourceSize = (sourceFileSizeBytes / 1000).toFixed(2);\n                    stats.xktSize = (targetFileSizeBytes / 1000).toFixed(2);\n                    stats.xktVersion = zip ? 10 : XKT_INFO.xktVersion;\n                    stats.compressionRatio = (sourceFileSizeBytes / targetFileSizeBytes).toFixed(2);\n                    stats.conversionTime = ((new Date() - startTime) / 1000.0).toFixed(2);\n                    stats.aabb = xktModel.aabb;\n                    log(`Converted to: XKT v${stats.xktVersion}`);\n                    if (includeTypes) {\n                        log(\"Include types: \" + (includeTypes ? includeTypes : \"(include all)\"));\n                    }\n                    if (excludeTypes) {\n                        log(\"Exclude types: \" + (excludeTypes ? excludeTypes : \"(exclude none)\"));\n                    }\n                    log(\"XKT size: \" + stats.xktSize + \" kB\");\n                    log(\"XKT textures size: \" + (stats.texturesSize / 1000).toFixed(2) + \"kB\");\n                    log(\"Compression ratio: \" + stats.compressionRatio);\n                    log(\"Conversion time: \" + stats.conversionTime + \" s\");\n                    log(\"Converted metaobjects: \" + stats.numMetaObjects);\n                    log(\"Converted property sets: \" + stats.numPropertySets);\n                    log(\"Converted drawable objects: \" + stats.numObjects);\n                    log(\"Converted geometries: \" + stats.numGeometries);\n                    log(\"Converted textures: \" + stats.numTextures);\n                    log(\"Converted textureSets: \" + stats.numTextureSets);\n                    log(\"Converted triangles: \" + stats.numTriangles);\n                    log(\"Converted vertices: \" + stats.numVertices);\n                    log(\"Converted UVs: \" + stats.numUVs);\n                    log(\"Converted normals: \" + stats.numNormals);\n                    log(\"Converted tiles: \" + xktModel.tilesList.length);\n                    log(\"minTileSize: \" + stats.minTileSize);\n\n                    if (output) {\n                        const outputDir = path.dirname(output);\n                        if (outputDir !== \"\" && !fs.existsSync(outputDir)) {\n                            fs.mkdirSync(outputDir, {recursive: true});\n                        }\n                        log('Writing XKT file: ' + output);\n                        fs.writeFileSync(output, xktContent);\n                    }\n\n                    if (outputXKTModel) {\n                        outputXKTModel(xktModel);\n                    }\n\n                    if (outputXKT) {\n                        outputXKT(xktContent);\n                    }\n\n                    if (outputStats) {\n                        outputStats(stats);\n                    }\n\n                    resolve();\n                });\n            }, (err) => {\n                reject(err);\n            });\n        }\n    });\n}\n\nexport {convert2xkt};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/convert2xkt.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 330,
    "kind": "function",
    "name": "convert2xkt",
    "memberof": "src/convert2xkt.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/convert2xkt.js~convert2xkt",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/convert2xkt.js",
    "importStyle": "{convert2xkt}",
    "description": "Converts model files into xeokit's native XKT format.\n\nSupported source formats are: IFC, CityJSON, glTF, LAZ and LAS.\n\n**Only bundled in xeokit-convert.cjs.js.**\n\n## Usage\n\n````javascript\nconst convert2xkt = require(\"@xeokit/xeokit-convert/dist/convert2xkt.cjs.js\");\nconst fs = require('fs');\n\nconvert2xkt({\n     sourceData: fs.readFileSync(\"rme_advanced_sample_project.ifc\"),\n     outputXKT: (xtkArrayBuffer) => {\n         fs.writeFileSync(\"rme_advanced_sample_project.ifc.xkt\", xtkArrayBuffer);\n     }\n }).then(() => {\n     console.log(\"Converted.\");\n }, (errMsg) => {\n     console.error(\"Conversion failed: \" + errMsg)\n });\n````",
    "lineNumber": 75,
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Conversion parameters."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.WebIFC",
        "description": "The WebIFC library. We pass this in as an external dependency, in order to give the\ncaller the choice of whether to use the Browser or NodeJS version."
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "params.configs",
        "description": "Configurations."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "params.source",
        "description": "Path to source file. Alternative to ````sourceData````."
      },
      {
        "nullable": null,
        "types": [
          "ArrayBuffer",
          "JSON"
        ],
        "spread": false,
        "optional": true,
        "name": "params.sourceData",
        "description": "Source file data. Alternative to ````source````."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "params.sourceFormat",
        "description": "Format of source file/data. Always needed with ````sourceData````, but not normally needed with ````source````, because convert2xkt will determine the format automatically from the file extension of ````source````."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "params.metaModelDataStr",
        "description": "Source file data. Overrides metadata from ````metaModelSource````, ````sourceData```` and ````source````."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "params.metaModelSource",
        "description": "Path to source metaModel file. Overrides metadata from ````sourceData```` and ````source````. Overridden by ````metaModelData````."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "params.output",
        "description": "Path to destination XKT file. Directories on this path are automatically created if not existing."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.outputXKTModel",
        "description": "Callback to collect the ````XKTModel```` that is internally build by this method."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.outputXKT",
        "description": "Callback to collect XKT file data."
      },
      {
        "nullable": null,
        "types": [
          "String[]"
        ],
        "spread": false,
        "optional": true,
        "name": "params.includeTypes",
        "description": "Option to only convert objects of these types."
      },
      {
        "nullable": null,
        "types": [
          "String[]"
        ],
        "spread": false,
        "optional": true,
        "name": "params.excludeTypes",
        "description": "Option to never convert objects of these types."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "stats",
        "description": "Collects conversion statistics. Statistics are attached to this object if provided."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.outputStats",
        "description": "Callback to collect statistics."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "params.rotateX",
        "description": "Whether to rotate the model 90 degrees about the X axis to make the Y axis \"up\", if necessary. Applies to CityJSON and LAS/LAZ models."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "params.reuseGeometries",
        "description": "When true, will enable geometry reuse within the XKT. When false,\nwill automatically \"expand\" all reused geometries into duplicate copies. This has the drawback of increasing the XKT\nfile size (~10-30% for typical models), but can make the model more responsive in the xeokit Viewer, especially if the model\nhas excessive geometry reuse. An example of excessive geometry reuse would be when a model (eg. glTF) has 4000 geometries that are\nshared amongst 2000 objects, ie. a large number of geometries with a low amount of reuse, which can present a\npathological performance case for xeokit's underlying graphics APIs (WebGL, WebGPU etc)."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "params.includeTextures",
        "description": "Whether to convert textures. Only works for ````glTF```` models."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "params.includeNormals",
        "description": "Whether to convert normals. When false, the parser will ignore\ngeometry normals, and the modelwill rely on the xeokit ````Viewer```` to automatically generate them. This has\nthe limitation that the normals will be face-aligned, and therefore the ````Viewer```` will only be able to render\na flat-shaded non-PBR representation of the model."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "200",
        "defaultRaw": 200,
        "name": "params.minTileSize",
        "description": "Minimum RTC coordinate tile size. Set this to a value between 100 and 10000,\ndepending on how far from the coordinate origin the model's vertex positions are; specify larger tile sizes when close\nto the origin, and smaller sizes when distant.  This compensates for decreasing precision as floats get bigger."
      },
      {
        "nullable": null,
        "types": [
          "Function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.log",
        "description": "Logging callback."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise<number>"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 331,
    "kind": "file",
    "name": "src/geometryBuilders/buildBoxGeometry.js",
    "content": "/**\n * @desc Creates box-shaped triangle mesh geometry arrays.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a box-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildBoxGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const box = buildBoxGeometry({\n *     primitiveType: \"triangles\" // or \"lines\"\n *     center: [0,0,0],\n *     xSize: 1,  // Half-size on each axis\n *     ySize: 1,\n *     zSize: 1\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"boxGeometry\",\n *      primitiveType: box.primitiveType,\n *      positions: box.positions,\n *      normals: box.normals,\n *      indices: box.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redBoxMesh\",\n *      geometryId: \"boxGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n * const xktEntity = xktModel.createEntity({\n *      entityId: \"redBox\",\n *      meshIds: [\"redBoxMesh\"]\n *  });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildBoxGeometry\n * @param {*} [cfg] Configs\n * @param {Number[]} [cfg.center]  3D point indicating the center position.\n * @param {Number} [cfg.xSize=1.0]  Half-size on the X-axis.\n * @param {Number} [cfg.ySize=1.0]  Half-size on the Y-axis.\n * @param {Number} [cfg.zSize=1.0]  Half-size on the Z-axis.\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildBoxGeometry(cfg = {}) {\n\n    let xSize = cfg.xSize || 1;\n    if (xSize < 0) {\n        console.error(\"negative xSize not allowed - will invert\");\n        xSize *= -1;\n    }\n\n    let ySize = cfg.ySize || 1;\n    if (ySize < 0) {\n        console.error(\"negative ySize not allowed - will invert\");\n        ySize *= -1;\n    }\n\n    let zSize = cfg.zSize || 1;\n    if (zSize < 0) {\n        console.error(\"negative zSize not allowed - will invert\");\n        zSize *= -1;\n    }\n\n    const center = cfg.center;\n    const centerX = center ? center[0] : 0;\n    const centerY = center ? center[1] : 0;\n    const centerZ = center ? center[2] : 0;\n\n    const xmin = -xSize + centerX;\n    const ymin = -ySize + centerY;\n    const zmin = -zSize + centerZ;\n    const xmax = xSize + centerX;\n    const ymax = ySize + centerY;\n    const zmax = zSize + centerZ;\n\n    return {\n\n        primitiveType: \"triangles\",\n\n        // The vertices - eight for our cube, each\n        // one spanning three array elements for X,Y and Z\n\n        positions: [\n\n            // v0-v1-v2-v3 front\n            xmax, ymax, zmax,\n            xmin, ymax, zmax,\n            xmin, ymin, zmax,\n            xmax, ymin, zmax,\n\n            // v0-v3-v4-v1 right\n            xmax, ymax, zmax,\n            xmax, ymin, zmax,\n            xmax, ymin, zmin,\n            xmax, ymax, zmin,\n\n            // v0-v1-v6-v1 top\n            xmax, ymax, zmax,\n            xmax, ymax, zmin,\n            xmin, ymax, zmin,\n            xmin, ymax, zmax,\n\n            // v1-v6-v7-v2 left\n            xmin, ymax, zmax,\n            xmin, ymax, zmin,\n            xmin, ymin, zmin,\n            xmin, ymin, zmax,\n\n            // v7-v4-v3-v2 bottom\n            xmin, ymin, zmin,\n            xmax, ymin, zmin,\n            xmax, ymin, zmax,\n            xmin, ymin, zmax,\n\n            // v4-v7-v6-v1 back\n            xmax, ymin, zmin,\n            xmin, ymin, zmin,\n            xmin, ymax, zmin,\n            xmax, ymax, zmin\n        ],\n\n        // Normal vectors, one for each vertex\n        normals: [\n\n            // v0-v1-v2-v3 front\n            0, 0, 1,\n            0, 0, 1,\n            0, 0, 1,\n            0, 0, 1,\n\n            // v0-v3-v4-v5 right\n            1, 0, 0,\n            1, 0, 0,\n            1, 0, 0,\n            1, 0, 0,\n\n            // v0-v5-v6-v1 top\n            0, 1, 0,\n            0, 1, 0,\n            0, 1, 0,\n            0, 1, 0,\n\n            // v1-v6-v7-v2 left\n            -1, 0, 0,\n            -1, 0, 0,\n            -1, 0, 0,\n            -1, 0, 0,\n\n            // v7-v4-v3-v2 bottom\n            0, -1, 0,\n            0, -1, 0,\n            0, -1, 0,\n            0, -1, 0,\n\n            // v4-v7-v6-v5 back\n            0, 0, -1,\n            0, 0, -1,\n            0, 0, -1,\n            0, 0, -1\n        ],\n\n        // UV coords\n        uv: [\n\n            // v0-v1-v2-v3 front\n            1, 0,\n            0, 0,\n            0, 1,\n            1, 1,\n\n            // v0-v3-v4-v1 right\n            0, 0,\n            0, 1,\n            1, 1,\n            1, 0,\n\n            // v0-v1-v6-v1 top\n            1, 1,\n            1, 0,\n            0, 0,\n            0, 1,\n\n            // v1-v6-v7-v2 left\n            1, 0,\n            0, 0,\n            0, 1,\n            1, 1,\n\n            // v7-v4-v3-v2 bottom\n            0, 1,\n            1, 1,\n            1, 0,\n            0, 0,\n\n            // v4-v7-v6-v1 back\n            0, 1,\n            1, 1,\n            1, 0,\n            0, 0\n        ],\n\n        // Indices - these organise the\n        // positions and uv texture coordinates\n        // into geometric primitives in accordance\n        // with the \"primitive\" parameter,\n        // in this case a set of three indices\n        // for each triangle.\n        //\n        // Note that each triangle is specified\n        // in counter-clockwise winding order.\n        //\n        // You can specify them in clockwise\n        // order if you configure the Modes\n        // node's frontFace flag as \"cw\", instead of\n        // the default \"ccw\".\n        indices: [\n            0, 1, 2,\n            0, 2, 3,\n            // front\n            4, 5, 6,\n            4, 6, 7,\n            // right\n            8, 9, 10,\n            8, 10, 11,\n            // top\n            12, 13, 14,\n            12, 14, 15,\n            // left\n            16, 17, 18,\n            16, 18, 19,\n            // bottom\n            20, 21, 22,\n            20, 22, 23\n        ]\n    };\n}\n\nexport {buildBoxGeometry};\n",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/geometryBuilders/buildBoxGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 332,
    "kind": "function",
    "name": "buildBoxGeometry",
    "memberof": "src/geometryBuilders/buildBoxGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildBoxGeometry.js~buildBoxGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/geometryBuilders/buildBoxGeometry.js",
    "importStyle": "{buildBoxGeometry}",
    "description": "Creates box-shaped triangle mesh geometry arrays.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a box-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildBoxGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst box = buildBoxGeometry({\n    primitiveType: \"triangles\" // or \"lines\"\n    center: [0,0,0],\n    xSize: 1,  // Half-size on each axis\n    ySize: 1,\n    zSize: 1\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"boxGeometry\",\n     primitiveType: box.primitiveType,\n     positions: box.positions,\n     normals: box.normals,\n     indices: box.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redBoxMesh\",\n     geometryId: \"boxGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redBox\",\n     meshIds: [\"redBoxMesh\"]\n });\n\nxktModel.finalize();\n````",
    "lineNumber": 55,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildBoxGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.center",
        "description": "3D point indicating the center position."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1.0",
        "defaultRaw": 1,
        "name": "cfg.xSize",
        "description": "Half-size on the X-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1.0",
        "defaultRaw": 1,
        "name": "cfg.ySize",
        "description": "Half-size on the Y-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1.0",
        "defaultRaw": 1,
        "name": "cfg.zSize",
        "description": "Half-size on the Z-axis."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 333,
    "kind": "file",
    "name": "src/geometryBuilders/buildBoxLinesGeometry.js",
    "content": "/**\n * @desc Creates box-shaped line segment geometry arrays.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a box-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildBoxLinesGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const box = buildBoxLinesGeometry({\n *     center: [0,0,0],\n *     xSize: 1,  // Half-size on each axis\n *     ySize: 1,\n *     zSize: 1\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"boxGeometry\",\n *      primitiveType: box.primitiveType, // \"lines\"\n *      positions: box.positions,\n *      normals: box.normals,\n *      indices: box.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redBoxMesh\",\n *      geometryId: \"boxGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n * const xktEntity = xktModel.createEntity({\n *      entityId: \"redBox\",\n *      meshIds: [\"redBoxMesh\"]\n *  });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildBoxLinesGeometry\n * @param {*} [cfg] Configs\n * @param {Number[]} [cfg.center]  3D point indicating the center position.\n * @param {Number} [cfg.xSize=1.0]  Half-size on the X-axis.\n * @param {Number} [cfg.ySize=1.0]  Half-size on the Y-axis.\n * @param {Number} [cfg.zSize=1.0]  Half-size on the Z-axis.\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildBoxLinesGeometry(cfg = {}) {\n\n    let xSize = cfg.xSize || 1;\n    if (xSize < 0) {\n        console.error(\"negative xSize not allowed - will invert\");\n        xSize *= -1;\n    }\n\n    let ySize = cfg.ySize || 1;\n    if (ySize < 0) {\n        console.error(\"negative ySize not allowed - will invert\");\n        ySize *= -1;\n    }\n\n    let zSize = cfg.zSize || 1;\n    if (zSize < 0) {\n        console.error(\"negative zSize not allowed - will invert\");\n        zSize *= -1;\n    }\n\n    const center = cfg.center;\n    const centerX = center ? center[0] : 0;\n    const centerY = center ? center[1] : 0;\n    const centerZ = center ? center[2] : 0;\n\n    const xmin = -xSize + centerX;\n    const ymin = -ySize + centerY;\n    const zmin = -zSize + centerZ;\n    const xmax = xSize + centerX;\n    const ymax = ySize + centerY;\n    const zmax = zSize + centerZ;\n\n    return {\n        primitiveType: \"lines\",\n        positions: [\n            xmin, ymin, zmin,\n            xmin, ymin, zmax,\n            xmin, ymax, zmin,\n            xmin, ymax, zmax,\n            xmax, ymin, zmin,\n            xmax, ymin, zmax,\n            xmax, ymax, zmin,\n            xmax, ymax, zmax\n        ],\n        indices: [\n            0, 1,\n            1, 3,\n            3, 2,\n            2, 0,\n            4, 5,\n            5, 7,\n            7, 6,\n            6, 4,\n            0, 4,\n            1, 5,\n            2, 6,\n            3, 7\n        ]\n    }\n}\n\nexport {buildBoxLinesGeometry};\n",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/geometryBuilders/buildBoxLinesGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 334,
    "kind": "function",
    "name": "buildBoxLinesGeometry",
    "memberof": "src/geometryBuilders/buildBoxLinesGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildBoxLinesGeometry.js~buildBoxLinesGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/geometryBuilders/buildBoxLinesGeometry.js",
    "importStyle": "{buildBoxLinesGeometry}",
    "description": "Creates box-shaped line segment geometry arrays.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a box-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildBoxLinesGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst box = buildBoxLinesGeometry({\n    center: [0,0,0],\n    xSize: 1,  // Half-size on each axis\n    ySize: 1,\n    zSize: 1\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"boxGeometry\",\n     primitiveType: box.primitiveType, // \"lines\"\n     positions: box.positions,\n     normals: box.normals,\n     indices: box.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redBoxMesh\",\n     geometryId: \"boxGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redBox\",\n     meshIds: [\"redBoxMesh\"]\n });\n\nxktModel.finalize();\n````",
    "lineNumber": 54,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildBoxLinesGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.center",
        "description": "3D point indicating the center position."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1.0",
        "defaultRaw": 1,
        "name": "cfg.xSize",
        "description": "Half-size on the X-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1.0",
        "defaultRaw": 1,
        "name": "cfg.ySize",
        "description": "Half-size on the Y-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1.0",
        "defaultRaw": 1,
        "name": "cfg.zSize",
        "description": "Half-size on the Z-axis."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 335,
    "kind": "file",
    "name": "src/geometryBuilders/buildCylinderGeometry.js",
    "content": "/**\n * @desc Creates cylinder-shaped geometry arrays.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a cylinder-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildCylinderGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const cylinder = buildCylinderGeometry({\n *      center: [0,0,0],\n *      radiusTop: 2.0,\n *      radiusBottom: 2.0,\n *      height: 5.0,\n *      radialSegments: 20,\n *      heightSegments: 1,\n *      openEnded: false\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"cylinderGeometry\",\n *      primitiveType: cylinder.primitiveType,\n *      positions: cylinder.positions,\n *      normals: cylinder.normals,\n *      indices: cylinder.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redCylinderMesh\",\n *      geometryId: \"cylinderGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n * const xktEntity = xktModel.createEntity({\n *      entityId: \"redCylinder\",\n *      meshIds: [\"redCylinderMesh\"]\n *  });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildCylinderGeometry\n * @param {*} [cfg] Configs\n * @param {Number[]} [cfg.center] 3D point indicating the center position.\n * @param {Number} [cfg.radiusTop=1]  Radius of top.\n * @param {Number} [cfg.radiusBottom=1]  Radius of bottom.\n * @param {Number} [cfg.height=1] Height.\n * @param {Number} [cfg.radialSegments=60]  Number of horizontal segments.\n * @param {Number} [cfg.heightSegments=1]  Number of vertical segments.\n * @param {Boolean} [cfg.openEnded=false]  Whether or not the cylinder has solid caps on the ends.\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildCylinderGeometry(cfg = {}) {\n\n    let radiusTop = cfg.radiusTop || 1;\n    if (radiusTop < 0) {\n        console.error(\"negative radiusTop not allowed - will invert\");\n        radiusTop *= -1;\n    }\n\n    let radiusBottom = cfg.radiusBottom || 1;\n    if (radiusBottom < 0) {\n        console.error(\"negative radiusBottom not allowed - will invert\");\n        radiusBottom *= -1;\n    }\n\n    let height = cfg.height || 1;\n    if (height < 0) {\n        console.error(\"negative height not allowed - will invert\");\n        height *= -1;\n    }\n\n    let radialSegments = cfg.radialSegments || 32;\n    if (radialSegments < 0) {\n        console.error(\"negative radialSegments not allowed - will invert\");\n        radialSegments *= -1;\n    }\n    if (radialSegments < 3) {\n        radialSegments = 3;\n    }\n\n    let heightSegments = cfg.heightSegments || 1;\n    if (heightSegments < 0) {\n        console.error(\"negative heightSegments not allowed - will invert\");\n        heightSegments *= -1;\n    }\n    if (heightSegments < 1) {\n        heightSegments = 1;\n    }\n\n    const openEnded = !!cfg.openEnded;\n\n    let center = cfg.center;\n    const centerX = center ? center[0] : 0;\n    const centerY = center ? center[1] : 0;\n    const centerZ = center ? center[2] : 0;\n\n    const heightHalf = height / 2;\n    const heightLength = height / heightSegments;\n    const radialAngle = (2.0 * Math.PI / radialSegments);\n    const radialLength = 1.0 / radialSegments;\n    //var nextRadius = this._radiusBottom;\n    const radiusChange = (radiusTop - radiusBottom) / heightSegments;\n\n    const positions = [];\n    const normals = [];\n    const uvs = [];\n    const indices = [];\n\n    let h;\n    let i;\n\n    let x;\n    let z;\n\n    let currentRadius;\n    let currentHeight;\n\n    let first;\n    let second;\n\n    let startIndex;\n    let tu;\n    let tv;\n\n    // create vertices\n    const normalY = (90.0 - (Math.atan(height / (radiusBottom - radiusTop))) * 180 / Math.PI) / 90.0;\n\n    for (h = 0; h <= heightSegments; h++) {\n        currentRadius = radiusTop - h * radiusChange;\n        currentHeight = heightHalf - h * heightLength;\n\n        for (i = 0; i <= radialSegments; i++) {\n            x = Math.sin(i * radialAngle);\n            z = Math.cos(i * radialAngle);\n\n            normals.push(currentRadius * x);\n            normals.push(normalY); //todo\n            normals.push(currentRadius * z);\n\n            uvs.push((i * radialLength));\n            uvs.push(h * 1 / heightSegments);\n\n            positions.push((currentRadius * x) + centerX);\n            positions.push((currentHeight) + centerY);\n            positions.push((currentRadius * z) + centerZ);\n        }\n    }\n\n    // create faces\n    for (h = 0; h < heightSegments; h++) {\n        for (i = 0; i <= radialSegments; i++) {\n\n            first = h * (radialSegments + 1) + i;\n            second = first + radialSegments;\n\n            indices.push(first);\n            indices.push(second);\n            indices.push(second + 1);\n\n            indices.push(first);\n            indices.push(second + 1);\n            indices.push(first + 1);\n        }\n    }\n\n    // create top cap\n    if (!openEnded && radiusTop > 0) {\n        startIndex = (positions.length / 3);\n\n        // top center\n        normals.push(0.0);\n        normals.push(1.0);\n        normals.push(0.0);\n\n        uvs.push(0.5);\n        uvs.push(0.5);\n\n        positions.push(0 + centerX);\n        positions.push(heightHalf + centerY);\n        positions.push(0 + centerZ);\n\n        // top triangle fan\n        for (i = 0; i <= radialSegments; i++) {\n            x = Math.sin(i * radialAngle);\n            z = Math.cos(i * radialAngle);\n            tu = (0.5 * Math.sin(i * radialAngle)) + 0.5;\n            tv = (0.5 * Math.cos(i * radialAngle)) + 0.5;\n\n            normals.push(radiusTop * x);\n            normals.push(1.0);\n            normals.push(radiusTop * z);\n\n            uvs.push(tu);\n            uvs.push(tv);\n\n            positions.push((radiusTop * x) + centerX);\n            positions.push((heightHalf) + centerY);\n            positions.push((radiusTop * z) + centerZ);\n        }\n\n        for (i = 0; i < radialSegments; i++) {\n            center = startIndex;\n            first = startIndex + 1 + i;\n\n            indices.push(first);\n            indices.push(first + 1);\n            indices.push(center);\n        }\n    }\n\n    // create bottom cap\n    if (!openEnded && radiusBottom > 0) {\n\n        startIndex = (positions.length / 3);\n\n        // top center\n        normals.push(0.0);\n        normals.push(-1.0);\n        normals.push(0.0);\n\n        uvs.push(0.5);\n        uvs.push(0.5);\n\n        positions.push(0 + centerX);\n        positions.push(0 - heightHalf + centerY);\n        positions.push(0 + centerZ);\n\n        // top triangle fan\n        for (i = 0; i <= radialSegments; i++) {\n\n            x = Math.sin(i * radialAngle);\n            z = Math.cos(i * radialAngle);\n\n            tu = (0.5 * Math.sin(i * radialAngle)) + 0.5;\n            tv = (0.5 * Math.cos(i * radialAngle)) + 0.5;\n\n            normals.push(radiusBottom * x);\n            normals.push(-1.0);\n            normals.push(radiusBottom * z);\n\n            uvs.push(tu);\n            uvs.push(tv);\n\n            positions.push((radiusBottom * x) + centerX);\n            positions.push((0 - heightHalf) + centerY);\n            positions.push((radiusBottom * z) + centerZ);\n        }\n\n        for (i = 0; i < radialSegments; i++) {\n\n            center = startIndex;\n            first = startIndex + 1 + i;\n\n            indices.push(center);\n            indices.push(first + 1);\n            indices.push(first);\n        }\n    }\n\n    return  {\n        primitiveType: \"triangles\",\n        positions: positions,\n        normals: normals,\n        uv: uvs,\n        uvs: uvs,\n        indices: indices\n    };\n}\n\n\nexport {buildCylinderGeometry};\n",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/geometryBuilders/buildCylinderGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 336,
    "kind": "function",
    "name": "buildCylinderGeometry",
    "memberof": "src/geometryBuilders/buildCylinderGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildCylinderGeometry.js~buildCylinderGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/geometryBuilders/buildCylinderGeometry.js",
    "importStyle": "{buildCylinderGeometry}",
    "description": "Creates cylinder-shaped geometry arrays.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a cylinder-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildCylinderGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst cylinder = buildCylinderGeometry({\n     center: [0,0,0],\n     radiusTop: 2.0,\n     radiusBottom: 2.0,\n     height: 5.0,\n     radialSegments: 20,\n     heightSegments: 1,\n     openEnded: false\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"cylinderGeometry\",\n     primitiveType: cylinder.primitiveType,\n     positions: cylinder.positions,\n     normals: cylinder.normals,\n     indices: cylinder.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redCylinderMesh\",\n     geometryId: \"cylinderGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redCylinder\",\n     meshIds: [\"redCylinderMesh\"]\n });\n\nxktModel.finalize();\n````",
    "lineNumber": 60,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildCylinderGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.center",
        "description": "3D point indicating the center position."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.radiusTop",
        "description": "Radius of top."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.radiusBottom",
        "description": "Radius of bottom."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.height",
        "description": "Height."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "60",
        "defaultRaw": 60,
        "name": "cfg.radialSegments",
        "description": "Number of horizontal segments."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.heightSegments",
        "description": "Number of vertical segments."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "cfg.openEnded",
        "description": "Whether or not the cylinder has solid caps on the ends."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 337,
    "kind": "file",
    "name": "src/geometryBuilders/buildGridGeometry.js",
    "content": "/**\n * @desc Creates grid-shaped geometry arrays..\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a grid-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildGridGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const grid = buildGridGeometry({\n *      size: 1000,\n *      divisions: 500\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"gridGeometry\",\n *      primitiveType: grid.primitiveType, // Will be \"lines\"\n *      positions: grid.positions,\n *      indices: grid.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redGridMesh\",\n *      geometryId: \"gridGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n * const xktEntity = xktModel.createEntity({\n *      entityId: \"redGrid\",\n *      meshIds: [\"redGridMesh\"]\n * });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildGridGeometry\n * @param {*} [cfg] Configs\n * @param {Number} [cfg.size=1] Dimension on the X and Z-axis.\n * @param {Number} [cfg.divisions=1] Number of divisions on X and Z axis..\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildGridGeometry(cfg = {}) {\n\n    let size = cfg.size || 1;\n    if (size < 0) {\n        console.error(\"negative size not allowed - will invert\");\n        size *= -1;\n    }\n\n    let divisions = cfg.divisions || 1;\n    if (divisions < 0) {\n        console.error(\"negative divisions not allowed - will invert\");\n        divisions *= -1;\n    }\n    if (divisions < 1) {\n        divisions = 1;\n    }\n\n    size = size || 10;\n    divisions = divisions || 10;\n\n    const step = size / divisions;\n    const halfSize = size / 2;\n\n    const positions = [];\n    const indices = [];\n    let l = 0;\n\n    for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {\n\n        positions.push(-halfSize);\n        positions.push(0);\n        positions.push(k);\n\n        positions.push(halfSize);\n        positions.push(0);\n        positions.push(k);\n\n        positions.push(k);\n        positions.push(0);\n        positions.push(-halfSize);\n\n        positions.push(k);\n        positions.push(0);\n        positions.push(halfSize);\n\n        indices.push(l++);\n        indices.push(l++);\n        indices.push(l++);\n        indices.push(l++);\n    }\n\n    return {\n        primitiveType: \"lines\",\n        positions: positions,\n        indices: indices\n    };\n}\n\n\nexport {buildGridGeometry};\n",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/geometryBuilders/buildGridGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 338,
    "kind": "function",
    "name": "buildGridGeometry",
    "memberof": "src/geometryBuilders/buildGridGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildGridGeometry.js~buildGridGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/geometryBuilders/buildGridGeometry.js",
    "importStyle": "{buildGridGeometry}",
    "description": "Creates grid-shaped geometry arrays..\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a grid-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildGridGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst grid = buildGridGeometry({\n     size: 1000,\n     divisions: 500\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"gridGeometry\",\n     primitiveType: grid.primitiveType, // Will be \"lines\"\n     positions: grid.positions,\n     indices: grid.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redGridMesh\",\n     geometryId: \"gridGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redGrid\",\n     meshIds: [\"redGridMesh\"]\n});\n\nxktModel.finalize();\n````",
    "lineNumber": 49,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildGridGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.size",
        "description": "Dimension on the X and Z-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.divisions",
        "description": "Number of divisions on X and Z axis.."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 339,
    "kind": "file",
    "name": "src/geometryBuilders/buildPlaneGeometry.js",
    "content": "/**\n * @desc Creates plane-shaped geometry arrays.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a plane-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildPlaneGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const plane = buildPlaneGeometry({\n *      center: [0,0,0],\n *      xSize: 2,\n *      zSize: 2,\n *      xSegments: 10,\n *      zSegments: 10\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"planeGeometry\",\n *      primitiveType: plane.primitiveType, // Will be \"triangles\"\n *      positions: plane.positions,\n *      normals: plane.normals,\n *      indices: plane.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redPlaneMesh\",\n *      geometryId: \"planeGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n * const xktEntity = xktModel.createEntity({\n *      entityId: \"redPlane\",\n *      meshIds: [\"redPlaneMesh\"]\n *  });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildPlaneGeometry\n * @param {*} [cfg] Configs\n * @param {Number[]} [cfg.center]  3D point indicating the center position.\n * @param {Number} [cfg.xSize=1] Dimension on the X-axis.\n * @param {Number} [cfg.zSize=1] Dimension on the Z-axis.\n * @param {Number} [cfg.xSegments=1] Number of segments on the X-axis.\n * @param {Number} [cfg.zSegments=1] Number of segments on the Z-axis.\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildPlaneGeometry(cfg = {}) {\n\n    let xSize = cfg.xSize || 1;\n    if (xSize < 0) {\n        console.error(\"negative xSize not allowed - will invert\");\n        xSize *= -1;\n    }\n\n    let zSize = cfg.zSize || 1;\n    if (zSize < 0) {\n        console.error(\"negative zSize not allowed - will invert\");\n        zSize *= -1;\n    }\n\n    let xSegments = cfg.xSegments || 1;\n    if (xSegments < 0) {\n        console.error(\"negative xSegments not allowed - will invert\");\n        xSegments *= -1;\n    }\n    if (xSegments < 1) {\n        xSegments = 1;\n    }\n\n    let zSegments = cfg.xSegments || 1;\n    if (zSegments < 0) {\n        console.error(\"negative zSegments not allowed - will invert\");\n        zSegments *= -1;\n    }\n    if (zSegments < 1) {\n        zSegments = 1;\n    }\n\n    const center = cfg.center;\n    const centerX = center ? center[0] : 0;\n    const centerY = center ? center[1] : 0;\n    const centerZ = center ? center[2] : 0;\n\n    const halfWidth = xSize / 2;\n    const halfHeight = zSize / 2;\n\n    const planeX = Math.floor(xSegments) || 1;\n    const planeZ = Math.floor(zSegments) || 1;\n\n    const planeX1 = planeX + 1;\n    const planeZ1 = planeZ + 1;\n\n    const segmentWidth = xSize / planeX;\n    const segmentHeight = zSize / planeZ;\n\n    const positions = new Float32Array(planeX1 * planeZ1 * 3);\n    const normals = new Float32Array(planeX1 * planeZ1 * 3);\n    const uvs = new Float32Array(planeX1 * planeZ1 * 2);\n\n    let offset = 0;\n    let offset2 = 0;\n\n    let iz;\n    let ix;\n    let x;\n    let a;\n    let b;\n    let c;\n    let d;\n\n    for (iz = 0; iz < planeZ1; iz++) {\n\n        const z = iz * segmentHeight - halfHeight;\n\n        for (ix = 0; ix < planeX1; ix++) {\n\n            x = ix * segmentWidth - halfWidth;\n\n            positions[offset] = x + centerX;\n            positions[offset + 1] = centerY;\n            positions[offset + 2] = -z + centerZ;\n\n            normals[offset + 2] = -1;\n\n            uvs[offset2] = (ix) / planeX;\n            uvs[offset2 + 1] = ((planeZ - iz) / planeZ);\n\n            offset += 3;\n            offset2 += 2;\n        }\n    }\n\n    offset = 0;\n\n    const indices = new ((positions.length / 3) > 65535 ? Uint32Array : Uint16Array)(planeX * planeZ * 6);\n\n    for (iz = 0; iz < planeZ; iz++) {\n\n        for (ix = 0; ix < planeX; ix++) {\n\n            a = ix + planeX1 * iz;\n            b = ix + planeX1 * (iz + 1);\n            c = (ix + 1) + planeX1 * (iz + 1);\n            d = (ix + 1) + planeX1 * iz;\n\n            indices[offset] = d;\n            indices[offset + 1] = b;\n            indices[offset + 2] = a;\n\n            indices[offset + 3] = d;\n            indices[offset + 4] = c;\n            indices[offset + 5] = b;\n\n            offset += 6;\n        }\n    }\n\n    return {\n        primitiveType: \"triangles\",\n        positions: positions,\n        normals: normals,\n        uv: uvs,\n        uvs: uvs,\n        indices: indices\n    };\n}\n\nexport {buildPlaneGeometry};\n",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/geometryBuilders/buildPlaneGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 340,
    "kind": "function",
    "name": "buildPlaneGeometry",
    "memberof": "src/geometryBuilders/buildPlaneGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildPlaneGeometry.js~buildPlaneGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/geometryBuilders/buildPlaneGeometry.js",
    "importStyle": "{buildPlaneGeometry}",
    "description": "Creates plane-shaped geometry arrays.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a plane-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildPlaneGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst plane = buildPlaneGeometry({\n     center: [0,0,0],\n     xSize: 2,\n     zSize: 2,\n     xSegments: 10,\n     zSegments: 10\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"planeGeometry\",\n     primitiveType: plane.primitiveType, // Will be \"triangles\"\n     positions: plane.positions,\n     normals: plane.normals,\n     indices: plane.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redPlaneMesh\",\n     geometryId: \"planeGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redPlane\",\n     meshIds: [\"redPlaneMesh\"]\n });\n\nxktModel.finalize();\n````",
    "lineNumber": 56,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildPlaneGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.center",
        "description": "3D point indicating the center position."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.xSize",
        "description": "Dimension on the X-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.zSize",
        "description": "Dimension on the Z-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.xSegments",
        "description": "Number of segments on the X-axis."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.zSegments",
        "description": "Number of segments on the Z-axis."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 341,
    "kind": "file",
    "name": "src/geometryBuilders/buildSphereGeometry.js",
    "content": "/**\n * @desc Creates sphere-shaped geometry arrays.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a sphere-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildSphereGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const sphere = buildSphereGeometry({\n *      center: [0,0,0],\n *      radius: 1.5,\n *      heightSegments: 60,\n *      widthSegments: 60\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"sphereGeometry\",\n *      primitiveType: sphere.primitiveType, // Will be \"triangles\"\n *      positions: sphere.positions,\n *      normals: sphere.normals,\n *      indices: sphere.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redSphereMesh\",\n *      geometryId: \"sphereGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n *const xktEntity = xktModel.createEntity({\n *      entityId: \"redSphere\",\n *      meshIds: [\"redSphereMesh\"]\n *  });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildSphereGeometry\n * @param {*} [cfg] Configs\n * @param {Number[]} [cfg.center]  3D point indicating the center position.\n * @param {Number} [cfg.radius=1]  Radius.\n * @param {Number} [cfg.heightSegments=24] Number of latitudinal bands.\n * @param  {Number} [cfg.widthSegments=18] Number of longitudinal bands.\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildSphereGeometry(cfg = {}) {\n\n    const lod = cfg.lod || 1;\n\n    const centerX = cfg.center ? cfg.center[0] : 0;\n    const centerY = cfg.center ? cfg.center[1] : 0;\n    const centerZ = cfg.center ? cfg.center[2] : 0;\n\n    let radius = cfg.radius || 1;\n    if (radius < 0) {\n        console.error(\"negative radius not allowed - will invert\");\n        radius *= -1;\n    }\n\n    let heightSegments = cfg.heightSegments || 18;\n    if (heightSegments < 0) {\n        console.error(\"negative heightSegments not allowed - will invert\");\n        heightSegments *= -1;\n    }\n    heightSegments = Math.floor(lod * heightSegments);\n    if (heightSegments < 18) {\n        heightSegments = 18;\n    }\n\n    let widthSegments = cfg.widthSegments || 18;\n    if (widthSegments < 0) {\n        console.error(\"negative widthSegments not allowed - will invert\");\n        widthSegments *= -1;\n    }\n    widthSegments = Math.floor(lod * widthSegments);\n    if (widthSegments < 18) {\n        widthSegments = 18;\n    }\n\n    const positions = [];\n    const normals = [];\n    const uvs = [];\n    const indices = [];\n\n    let i;\n    let j;\n\n    let theta;\n    let sinTheta;\n    let cosTheta;\n\n    let phi;\n    let sinPhi;\n    let cosPhi;\n\n    let x;\n    let y;\n    let z;\n\n    let u;\n    let v;\n\n    let first;\n    let second;\n\n    for (i = 0; i <= heightSegments; i++) {\n\n        theta = i * Math.PI / heightSegments;\n        sinTheta = Math.sin(theta);\n        cosTheta = Math.cos(theta);\n\n        for (j = 0; j <= widthSegments; j++) {\n\n            phi = j * 2 * Math.PI / widthSegments;\n            sinPhi = Math.sin(phi);\n            cosPhi = Math.cos(phi);\n\n            x = cosPhi * sinTheta;\n            y = cosTheta;\n            z = sinPhi * sinTheta;\n            u = 1.0 - j / widthSegments;\n            v = i / heightSegments;\n\n            normals.push(x);\n            normals.push(y);\n            normals.push(z);\n\n            uvs.push(u);\n            uvs.push(v);\n\n            positions.push(centerX + radius * x);\n            positions.push(centerY + radius * y);\n            positions.push(centerZ + radius * z);\n        }\n    }\n\n    for (i = 0; i < heightSegments; i++) {\n        for (j = 0; j < widthSegments; j++) {\n\n            first = (i * (widthSegments + 1)) + j;\n            second = first + widthSegments + 1;\n\n            indices.push(first + 1);\n            indices.push(second + 1);\n            indices.push(second);\n            indices.push(first + 1);\n            indices.push(second);\n            indices.push(first);\n        }\n    }\n\n    return {\n        primitiveType: \"triangles\",\n        positions: positions,\n        normals: normals,\n        uv: uvs,\n        uvs: uvs,\n        indices: indices\n    };\n}\n\nexport {buildSphereGeometry};\n",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/geometryBuilders/buildSphereGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 342,
    "kind": "function",
    "name": "buildSphereGeometry",
    "memberof": "src/geometryBuilders/buildSphereGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildSphereGeometry.js~buildSphereGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/geometryBuilders/buildSphereGeometry.js",
    "importStyle": "{buildSphereGeometry}",
    "description": "Creates sphere-shaped geometry arrays.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a sphere-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildSphereGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst sphere = buildSphereGeometry({\n     center: [0,0,0],\n     radius: 1.5,\n     heightSegments: 60,\n     widthSegments: 60\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"sphereGeometry\",\n     primitiveType: sphere.primitiveType, // Will be \"triangles\"\n     positions: sphere.positions,\n     normals: sphere.normals,\n     indices: sphere.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redSphereMesh\",\n     geometryId: \"sphereGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redSphere\",\n     meshIds: [\"redSphereMesh\"]\n });\n\nxktModel.finalize();\n````",
    "lineNumber": 54,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildSphereGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.center",
        "description": "3D point indicating the center position."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.radius",
        "description": "Radius."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "24",
        "defaultRaw": 24,
        "name": "cfg.heightSegments",
        "description": "Number of latitudinal bands."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "18",
        "defaultRaw": 18,
        "name": "cfg.widthSegments",
        "description": "Number of longitudinal bands."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 343,
    "kind": "file",
    "name": "src/geometryBuilders/buildTorusGeometry.js",
    "content": "import {math} from '../lib/math.js';\n\n/**\n * @desc Creates torus-shaped geometry arrays.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a torus-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildTorusGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const torus = buildTorusGeometry({\n *      center: [0,0,0],\n *      radius: 1.0,\n *      tube: 0.5,\n *      radialSegments: 32,\n *      tubeSegments: 24,\n *      arc: Math.PI * 2.0\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"torusGeometry\",\n *      primitiveType: torus.primitiveType, // Will be \"triangles\"\n *      positions: torus.positions,\n *      normals: torus.normals,\n *      indices: torus.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redTorusMesh\",\n *      geometryId: \"torusGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n * const xktEntity = xktModel.createEntity({\n *      entityId: \"redTorus\",\n *      meshIds: [\"redTorusMesh\"]\n * });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildTorusGeometry\n * @param {*} [cfg] Configs\n * @param {Number[]} [cfg.center] 3D point indicating the center position.\n * @param {Number} [cfg.radius=1] The overall radius.\n * @param {Number} [cfg.tube=0.3] The tube radius.\n * @param {Number} [cfg.radialSegments=32] The number of radial segments.\n * @param {Number} [cfg.tubeSegments=24] The number of tubular segments.\n * @param {Number} [cfg.arc=Math.PI*0.5] The length of the arc in radians, where Math.PI*2 is a closed torus.\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildTorusGeometry(cfg = {}) {\n\n    let radius = cfg.radius || 1;\n    if (radius < 0) {\n        console.error(\"negative radius not allowed - will invert\");\n        radius *= -1;\n    }\n    radius *= 0.5;\n\n    let tube = cfg.tube || 0.3;\n    if (tube < 0) {\n        console.error(\"negative tube not allowed - will invert\");\n        tube *= -1;\n    }\n\n    let radialSegments = cfg.radialSegments || 32;\n    if (radialSegments < 0) {\n        console.error(\"negative radialSegments not allowed - will invert\");\n        radialSegments *= -1;\n    }\n    if (radialSegments < 4) {\n        radialSegments = 4;\n    }\n\n    let tubeSegments = cfg.tubeSegments || 24;\n    if (tubeSegments < 0) {\n        console.error(\"negative tubeSegments not allowed - will invert\");\n        tubeSegments *= -1;\n    }\n    if (tubeSegments < 4) {\n        tubeSegments = 4;\n    }\n\n    let arc = cfg.arc || Math.PI * 2;\n    if (arc < 0) {\n        console.warn(\"negative arc not allowed - will invert\");\n        arc *= -1;\n    }\n    if (arc > 360) {\n        arc = 360;\n    }\n\n    const center = cfg.center;\n    let centerX = center ? center[0] : 0;\n    let centerY = center ? center[1] : 0;\n    const centerZ = center ? center[2] : 0;\n\n    const positions = [];\n    const normals = [];\n    const uvs = [];\n    const indices = [];\n\n    let u;\n    let v;\n    let x;\n    let y;\n    let z;\n    let vec;\n\n    let i;\n    let j;\n\n    for (j = 0; j <= tubeSegments; j++) {\n        for (i = 0; i <= radialSegments; i++) {\n\n            u = i / radialSegments * arc;\n            v = 0.785398 + (j / tubeSegments * Math.PI * 2);\n\n            centerX = radius * Math.cos(u);\n            centerY = radius * Math.sin(u);\n\n            x = (radius + tube * Math.cos(v)) * Math.cos(u);\n            y = (radius + tube * Math.cos(v)) * Math.sin(u);\n            z = tube * Math.sin(v);\n\n            positions.push(x + centerX);\n            positions.push(y + centerY);\n            positions.push(z + centerZ);\n\n            uvs.push(1 - (i / radialSegments));\n            uvs.push((j / tubeSegments));\n\n            vec = math.normalizeVec3(math.subVec3([x, y, z], [centerX, centerY, centerZ], []), []);\n\n            normals.push(vec[0]);\n            normals.push(vec[1]);\n            normals.push(vec[2]);\n        }\n    }\n\n    let a;\n    let b;\n    let c;\n    let d;\n\n    for (j = 1; j <= tubeSegments; j++) {\n        for (i = 1; i <= radialSegments; i++) {\n\n            a = (radialSegments + 1) * j + i - 1;\n            b = (radialSegments + 1) * (j - 1) + i - 1;\n            c = (radialSegments + 1) * (j - 1) + i;\n            d = (radialSegments + 1) * j + i;\n\n            indices.push(a);\n            indices.push(b);\n            indices.push(c);\n\n            indices.push(c);\n            indices.push(d);\n            indices.push(a);\n        }\n    }\n\n    return {\n        primitiveType: \"triangles\",\n        positions: positions,\n        normals: normals,\n        uv: uvs,\n        uvs: uvs,\n        indices: indices\n    };\n}\n\nexport {buildTorusGeometry};\n",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/geometryBuilders/buildTorusGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 344,
    "kind": "function",
    "name": "buildTorusGeometry",
    "memberof": "src/geometryBuilders/buildTorusGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildTorusGeometry.js~buildTorusGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/geometryBuilders/buildTorusGeometry.js",
    "importStyle": "{buildTorusGeometry}",
    "description": "Creates torus-shaped geometry arrays.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a torus-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildTorusGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst torus = buildTorusGeometry({\n     center: [0,0,0],\n     radius: 1.0,\n     tube: 0.5,\n     radialSegments: 32,\n     tubeSegments: 24,\n     arc: Math.PI * 2.0\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"torusGeometry\",\n     primitiveType: torus.primitiveType, // Will be \"triangles\"\n     positions: torus.positions,\n     normals: torus.normals,\n     indices: torus.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redTorusMesh\",\n     geometryId: \"torusGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redTorus\",\n     meshIds: [\"redTorusMesh\"]\n});\n\nxktModel.finalize();\n````",
    "lineNumber": 60,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildTorusGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.center",
        "description": "3D point indicating the center position."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.radius",
        "description": "The overall radius."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "0.3",
        "defaultRaw": 0.3,
        "name": "cfg.tube",
        "description": "The tube radius."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "32",
        "defaultRaw": 32,
        "name": "cfg.radialSegments",
        "description": "The number of radial segments."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "24",
        "defaultRaw": 24,
        "name": "cfg.tubeSegments",
        "description": "The number of tubular segments."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "Math.PI*0.5",
        "defaultRaw": "Math.PI*0.5",
        "name": "cfg.arc",
        "description": "The length of the arc in radians, where Math.PI*2 is a closed torus."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 345,
    "kind": "file",
    "name": "src/geometryBuilders/buildVectorTextGeometry.js",
    "content": "const letters = {\n    ' ': {width: 16, points: []},\n    '!': {\n        width: 10, points: [\n            [5, 21],\n            [5, 7],\n            [-1, -1],\n            [5, 2],\n            [4, 1],\n            [5, 0],\n            [6, 1],\n            [5, 2]\n        ]\n    },\n    '\"': {\n        width: 16, points: [\n            [4, 21],\n            [4, 14],\n            [-1, -1],\n            [12, 21],\n            [12, 14]\n        ]\n    },\n    '#': {\n        width: 21, points: [\n            [11, 25],\n            [4, -7],\n            [-1, -1],\n            [17, 25],\n            [10, -7],\n            [-1, -1],\n            [4, 12],\n            [18, 12],\n            [-1, -1],\n            [3, 6],\n            [17, 6]\n        ]\n    },\n    '$': {\n        width: 20, points: [\n            [8, 25],\n            [8, -4],\n            [-1, -1],\n            [12, 25],\n            [12, -4],\n            [-1, -1],\n            [17, 18],\n            [15, 20],\n            [12, 21],\n            [8, 21],\n            [5, 20],\n            [3, 18],\n            [3, 16],\n            [4, 14],\n            [5, 13],\n            [7, 12],\n            [13, 10],\n            [15, 9],\n            [16, 8],\n            [17, 6],\n            [17, 3],\n            [15, 1],\n            [12, 0],\n            [8, 0],\n            [5, 1],\n            [3, 3]\n        ]\n    },\n    '%': {\n        width: 24, points: [\n            [21, 21],\n            [3, 0],\n            [-1, -1],\n            [8, 21],\n            [10, 19],\n            [10, 17],\n            [9, 15],\n            [7, 14],\n            [5, 14],\n            [3, 16],\n            [3, 18],\n            [4, 20],\n            [6, 21],\n            [8, 21],\n            [10, 20],\n            [13, 19],\n            [16, 19],\n            [19, 20],\n            [21, 21],\n            [-1, -1],\n            [17, 7],\n            [15, 6],\n            [14, 4],\n            [14, 2],\n            [16, 0],\n            [18, 0],\n            [20, 1],\n            [21, 3],\n            [21, 5],\n            [19, 7],\n            [17, 7]\n        ]\n    },\n    '&': {\n        width: 26, points: [\n            [23, 12],\n            [23, 13],\n            [22, 14],\n            [21, 14],\n            [20, 13],\n            [19, 11],\n            [17, 6],\n            [15, 3],\n            [13, 1],\n            [11, 0],\n            [7, 0],\n            [5, 1],\n            [4, 2],\n            [3, 4],\n            [3, 6],\n            [4, 8],\n            [5, 9],\n            [12, 13],\n            [13, 14],\n            [14, 16],\n            [14, 18],\n            [13, 20],\n            [11, 21],\n            [9, 20],\n            [8, 18],\n            [8, 16],\n            [9, 13],\n            [11, 10],\n            [16, 3],\n            [18, 1],\n            [20, 0],\n            [22, 0],\n            [23, 1],\n            [23, 2]\n        ]\n    },\n    '\\'': {\n        width: 10, points: [\n            [5, 19],\n            [4, 20],\n            [5, 21],\n            [6, 20],\n            [6, 18],\n            [5, 16],\n            [4, 15]\n        ]\n    },\n    '(': {\n        width: 14, points: [\n            [11, 25],\n            [9, 23],\n            [7, 20],\n            [5, 16],\n            [4, 11],\n            [4, 7],\n            [5, 2],\n            [7, -2],\n            [9, -5],\n            [11, -7]\n        ]\n    },\n    ')': {\n        width: 14, points: [\n            [3, 25],\n            [5, 23],\n            [7, 20],\n            [9, 16],\n            [10, 11],\n            [10, 7],\n            [9, 2],\n            [7, -2],\n            [5, -5],\n            [3, -7]\n        ]\n    },\n    '*': {\n        width: 16, points: [\n            [8, 21],\n            [8, 9],\n            [-1, -1],\n            [3, 18],\n            [13, 12],\n            [-1, -1],\n            [13, 18],\n            [3, 12]\n        ]\n    },\n    '+': {\n        width: 26, points: [\n            [13, 18],\n            [13, 0],\n            [-1, -1],\n            [4, 9],\n            [22, 9]\n        ]\n    },\n    ',': {\n        width: 10, points: [\n            [6, 1],\n            [5, 0],\n            [4, 1],\n            [5, 2],\n            [6, 1],\n            [6, -1],\n            [5, -3],\n            [4, -4]\n        ]\n    },\n    '-': {\n        width: 26, points: [\n            [4, 9],\n            [22, 9]\n        ]\n    },\n    '.': {\n        width: 10, points: [\n            [5, 2],\n            [4, 1],\n            [5, 0],\n            [6, 1],\n            [5, 2]\n        ]\n    },\n    '/': {\n        width: 22, points: [\n            [20, 25],\n            [2, -7]\n        ]\n    },\n    '0': {\n        width: 20, points: [\n            [9, 21],\n            [6, 20],\n            [4, 17],\n            [3, 12],\n            [3, 9],\n            [4, 4],\n            [6, 1],\n            [9, 0],\n            [11, 0],\n            [14, 1],\n            [16, 4],\n            [17, 9],\n            [17, 12],\n            [16, 17],\n            [14, 20],\n            [11, 21],\n            [9, 21]\n        ]\n    },\n    '1': {\n        width: 20, points: [\n            [6, 17],\n            [8, 18],\n            [11, 21],\n            [11, 0]\n        ]\n    },\n    '2': {\n        width: 20, points: [\n            [4, 16],\n            [4, 17],\n            [5, 19],\n            [6, 20],\n            [8, 21],\n            [12, 21],\n            [14, 20],\n            [15, 19],\n            [16, 17],\n            [16, 15],\n            [15, 13],\n            [13, 10],\n            [3, 0],\n            [17, 0]\n        ]\n    },\n    '3': {\n        width: 20, points: [\n            [5, 21],\n            [16, 21],\n            [10, 13],\n            [13, 13],\n            [15, 12],\n            [16, 11],\n            [17, 8],\n            [17, 6],\n            [16, 3],\n            [14, 1],\n            [11, 0],\n            [8, 0],\n            [5, 1],\n            [4, 2],\n            [3, 4]\n        ]\n    },\n    '4': {\n        width: 20, points: [\n            [13, 21],\n            [3, 7],\n            [18, 7],\n            [-1, -1],\n            [13, 21],\n            [13, 0]\n        ]\n    },\n    '5': {\n        width: 20, points: [\n            [15, 21],\n            [5, 21],\n            [4, 12],\n            [5, 13],\n            [8, 14],\n            [11, 14],\n            [14, 13],\n            [16, 11],\n            [17, 8],\n            [17, 6],\n            [16, 3],\n            [14, 1],\n            [11, 0],\n            [8, 0],\n            [5, 1],\n            [4, 2],\n            [3, 4]\n        ]\n    },\n    '6': {\n        width: 20, points: [\n            [16, 18],\n            [15, 20],\n            [12, 21],\n            [10, 21],\n            [7, 20],\n            [5, 17],\n            [4, 12],\n            [4, 7],\n            [5, 3],\n            [7, 1],\n            [10, 0],\n            [11, 0],\n            [14, 1],\n            [16, 3],\n            [17, 6],\n            [17, 7],\n            [16, 10],\n            [14, 12],\n            [11, 13],\n            [10, 13],\n            [7, 12],\n            [5, 10],\n            [4, 7]\n        ]\n    },\n    '7': {\n        width: 20, points: [\n            [17, 21],\n            [7, 0],\n            [-1, -1],\n            [3, 21],\n            [17, 21]\n        ]\n    },\n    '8': {\n        width: 20, points: [\n            [8, 21],\n            [5, 20],\n            [4, 18],\n            [4, 16],\n            [5, 14],\n            [7, 13],\n            [11, 12],\n            [14, 11],\n            [16, 9],\n            [17, 7],\n            [17, 4],\n            [16, 2],\n            [15, 1],\n            [12, 0],\n            [8, 0],\n            [5, 1],\n            [4, 2],\n            [3, 4],\n            [3, 7],\n            [4, 9],\n            [6, 11],\n            [9, 12],\n            [13, 13],\n            [15, 14],\n            [16, 16],\n            [16, 18],\n            [15, 20],\n            [12, 21],\n            [8, 21]\n        ]\n    },\n    '9': {\n        width: 20, points: [\n            [16, 14],\n            [15, 11],\n            [13, 9],\n            [10, 8],\n            [9, 8],\n            [6, 9],\n            [4, 11],\n            [3, 14],\n            [3, 15],\n            [4, 18],\n            [6, 20],\n            [9, 21],\n            [10, 21],\n            [13, 20],\n            [15, 18],\n            [16, 14],\n            [16, 9],\n            [15, 4],\n            [13, 1],\n            [10, 0],\n            [8, 0],\n            [5, 1],\n            [4, 3]\n        ]\n    },\n    ':': {\n        width: 10, points: [\n            [5, 14],\n            [4, 13],\n            [5, 12],\n            [6, 13],\n            [5, 14],\n            [-1, -1],\n            [5, 2],\n            [4, 1],\n            [5, 0],\n            [6, 1],\n            [5, 2]\n        ]\n    },\n    ';': {\n        width: 10, points: [\n            [5, 14],\n            [4, 13],\n            [5, 12],\n            [6, 13],\n            [5, 14],\n            [-1, -1],\n            [6, 1],\n            [5, 0],\n            [4, 1],\n            [5, 2],\n            [6, 1],\n            [6, -1],\n            [5, -3],\n            [4, -4]\n        ]\n    },\n    '<': {\n        width: 24, points: [\n            [20, 18],\n            [4, 9],\n            [20, 0]\n        ]\n    },\n    '=': {\n        width: 26, points: [\n            [4, 12],\n            [22, 12],\n            [-1, -1],\n            [4, 6],\n            [22, 6]\n        ]\n    },\n    '>': {\n        width: 24, points: [\n            [4, 18],\n            [20, 9],\n            [4, 0]\n        ]\n    },\n    '?': {\n        width: 18, points: [\n            [3, 16],\n            [3, 17],\n            [4, 19],\n            [5, 20],\n            [7, 21],\n            [11, 21],\n            [13, 20],\n            [14, 19],\n            [15, 17],\n            [15, 15],\n            [14, 13],\n            [13, 12],\n            [9, 10],\n            [9, 7],\n            [-1, -1],\n            [9, 2],\n            [8, 1],\n            [9, 0],\n            [10, 1],\n            [9, 2]\n        ]\n    },\n    '@': {\n        width: 27, points: [\n            [18, 13],\n            [17, 15],\n            [15, 16],\n            [12, 16],\n            [10, 15],\n            [9, 14],\n            [8, 11],\n            [8, 8],\n            [9, 6],\n            [11, 5],\n            [14, 5],\n            [16, 6],\n            [17, 8],\n            [-1, -1],\n            [12, 16],\n            [10, 14],\n            [9, 11],\n            [9, 8],\n            [10, 6],\n            [11, 5],\n            [-1, -1],\n            [18, 16],\n            [17, 8],\n            [17, 6],\n            [19, 5],\n            [21, 5],\n            [23, 7],\n            [24, 10],\n            [24, 12],\n            [23, 15],\n            [22, 17],\n            [20, 19],\n            [18, 20],\n            [15, 21],\n            [12, 21],\n            [9, 20],\n            [7, 19],\n            [5, 17],\n            [4, 15],\n            [3, 12],\n            [3, 9],\n            [4, 6],\n            [5, 4],\n            [7, 2],\n            [9, 1],\n            [12, 0],\n            [15, 0],\n            [18, 1],\n            [20, 2],\n            [21, 3],\n            [-1, -1],\n            [19, 16],\n            [18, 8],\n            [18, 6],\n            [19, 5]\n        ]\n    },\n    'A': {\n        width: 18, points: [\n            [9, 21],\n            [1, 0],\n            [-1, -1],\n            [9, 21],\n            [17, 0],\n            [-1, -1],\n            [4, 7],\n            [14, 7]\n        ]\n    },\n    'B': {\n        width: 21, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [13, 21],\n            [16, 20],\n            [17, 19],\n            [18, 17],\n            [18, 15],\n            [17, 13],\n            [16, 12],\n            [13, 11],\n            [-1, -1],\n            [4, 11],\n            [13, 11],\n            [16, 10],\n            [17, 9],\n            [18, 7],\n            [18, 4],\n            [17, 2],\n            [16, 1],\n            [13, 0],\n            [4, 0]\n        ]\n    },\n    'C': {\n        width: 21, points: [\n            [18, 16],\n            [17, 18],\n            [15, 20],\n            [13, 21],\n            [9, 21],\n            [7, 20],\n            [5, 18],\n            [4, 16],\n            [3, 13],\n            [3, 8],\n            [4, 5],\n            [5, 3],\n            [7, 1],\n            [9, 0],\n            [13, 0],\n            [15, 1],\n            [17, 3],\n            [18, 5]\n        ]\n    },\n    'D': {\n        width: 21, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [11, 21],\n            [14, 20],\n            [16, 18],\n            [17, 16],\n            [18, 13],\n            [18, 8],\n            [17, 5],\n            [16, 3],\n            [14, 1],\n            [11, 0],\n            [4, 0]\n        ]\n    },\n    'E': {\n        width: 19, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [17, 21],\n            [-1, -1],\n            [4, 11],\n            [12, 11],\n            [-1, -1],\n            [4, 0],\n            [17, 0]\n        ]\n    },\n    'F': {\n        width: 18, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [17, 21],\n            [-1, -1],\n            [4, 11],\n            [12, 11]\n        ]\n    },\n    'G': {\n        width: 21, points: [\n            [18, 16],\n            [17, 18],\n            [15, 20],\n            [13, 21],\n            [9, 21],\n            [7, 20],\n            [5, 18],\n            [4, 16],\n            [3, 13],\n            [3, 8],\n            [4, 5],\n            [5, 3],\n            [7, 1],\n            [9, 0],\n            [13, 0],\n            [15, 1],\n            [17, 3],\n            [18, 5],\n            [18, 8],\n            [-1, -1],\n            [13, 8],\n            [18, 8]\n        ]\n    },\n    'H': {\n        width: 22, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [18, 21],\n            [18, 0],\n            [-1, -1],\n            [4, 11],\n            [18, 11]\n        ]\n    },\n    'I': {\n        width: 8, points: [\n            [4, 21],\n            [4, 0]\n        ]\n    },\n    'J': {\n        width: 16, points: [\n            [12, 21],\n            [12, 5],\n            [11, 2],\n            [10, 1],\n            [8, 0],\n            [6, 0],\n            [4, 1],\n            [3, 2],\n            [2, 5],\n            [2, 7]\n        ]\n    },\n    'K': {\n        width: 21, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [18, 21],\n            [4, 7],\n            [-1, -1],\n            [9, 12],\n            [18, 0]\n        ]\n    },\n    'L': {\n        width: 17, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 0],\n            [16, 0]\n        ]\n    },\n    'M': {\n        width: 24, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [12, 0],\n            [-1, -1],\n            [20, 21],\n            [12, 0],\n            [-1, -1],\n            [20, 21],\n            [20, 0]\n        ]\n    },\n    'N': {\n        width: 22, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [18, 0],\n            [-1, -1],\n            [18, 21],\n            [18, 0]\n        ]\n    },\n    'O': {\n        width: 22, points: [\n            [9, 21],\n            [7, 20],\n            [5, 18],\n            [4, 16],\n            [3, 13],\n            [3, 8],\n            [4, 5],\n            [5, 3],\n            [7, 1],\n            [9, 0],\n            [13, 0],\n            [15, 1],\n            [17, 3],\n            [18, 5],\n            [19, 8],\n            [19, 13],\n            [18, 16],\n            [17, 18],\n            [15, 20],\n            [13, 21],\n            [9, 21]\n        ]\n    },\n    'P': {\n        width: 21, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [13, 21],\n            [16, 20],\n            [17, 19],\n            [18, 17],\n            [18, 14],\n            [17, 12],\n            [16, 11],\n            [13, 10],\n            [4, 10]\n        ]\n    },\n    'Q': {\n        width: 22, points: [\n            [9, 21],\n            [7, 20],\n            [5, 18],\n            [4, 16],\n            [3, 13],\n            [3, 8],\n            [4, 5],\n            [5, 3],\n            [7, 1],\n            [9, 0],\n            [13, 0],\n            [15, 1],\n            [17, 3],\n            [18, 5],\n            [19, 8],\n            [19, 13],\n            [18, 16],\n            [17, 18],\n            [15, 20],\n            [13, 21],\n            [9, 21],\n            [-1, -1],\n            [12, 4],\n            [18, -2]\n        ]\n    },\n    'R': {\n        width: 21, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 21],\n            [13, 21],\n            [16, 20],\n            [17, 19],\n            [18, 17],\n            [18, 15],\n            [17, 13],\n            [16, 12],\n            [13, 11],\n            [4, 11],\n            [-1, -1],\n            [11, 11],\n            [18, 0]\n        ]\n    },\n    'S': {\n        width: 20, points: [\n            [17, 18],\n            [15, 20],\n            [12, 21],\n            [8, 21],\n            [5, 20],\n            [3, 18],\n            [3, 16],\n            [4, 14],\n            [5, 13],\n            [7, 12],\n            [13, 10],\n            [15, 9],\n            [16, 8],\n            [17, 6],\n            [17, 3],\n            [15, 1],\n            [12, 0],\n            [8, 0],\n            [5, 1],\n            [3, 3]\n        ]\n    },\n    'T': {\n        width: 16, points: [\n            [8, 21],\n            [8, 0],\n            [-1, -1],\n            [1, 21],\n            [15, 21]\n        ]\n    },\n    'U': {\n        width: 22, points: [\n            [4, 21],\n            [4, 6],\n            [5, 3],\n            [7, 1],\n            [10, 0],\n            [12, 0],\n            [15, 1],\n            [17, 3],\n            [18, 6],\n            [18, 21]\n        ]\n    },\n    'V': {\n        width: 18, points: [\n            [1, 21],\n            [9, 0],\n            [-1, -1],\n            [17, 21],\n            [9, 0]\n        ]\n    },\n    'W': {\n        width: 24, points: [\n            [2, 21],\n            [7, 0],\n            [-1, -1],\n            [12, 21],\n            [7, 0],\n            [-1, -1],\n            [12, 21],\n            [17, 0],\n            [-1, -1],\n            [22, 21],\n            [17, 0]\n        ]\n    },\n    'X': {\n        width: 20, points: [\n            [3, 21],\n            [17, 0],\n            [-1, -1],\n            [17, 21],\n            [3, 0]\n        ]\n    },\n    'Y': {\n        width: 18, points: [\n            [1, 21],\n            [9, 11],\n            [9, 0],\n            [-1, -1],\n            [17, 21],\n            [9, 11]\n        ]\n    },\n    'Z': {\n        width: 20, points: [\n            [17, 21],\n            [3, 0],\n            [-1, -1],\n            [3, 21],\n            [17, 21],\n            [-1, -1],\n            [3, 0],\n            [17, 0]\n        ]\n    },\n    '[': {\n        width: 14, points: [\n            [4, 25],\n            [4, -7],\n            [-1, -1],\n            [5, 25],\n            [5, -7],\n            [-1, -1],\n            [4, 25],\n            [11, 25],\n            [-1, -1],\n            [4, -7],\n            [11, -7]\n        ]\n    },\n    '\\\\': {\n        width: 14, points: [\n            [0, 21],\n            [14, -3]\n        ]\n    },\n    ']': {\n        width: 14, points: [\n            [9, 25],\n            [9, -7],\n            [-1, -1],\n            [10, 25],\n            [10, -7],\n            [-1, -1],\n            [3, 25],\n            [10, 25],\n            [-1, -1],\n            [3, -7],\n            [10, -7]\n        ]\n    },\n    '^': {\n        width: 16, points: [\n            [6, 15],\n            [8, 18],\n            [10, 15],\n            [-1, -1],\n            [3, 12],\n            [8, 17],\n            [13, 12],\n            [-1, -1],\n            [8, 17],\n            [8, 0]\n        ]\n    },\n    '_': {\n        width: 16, points: [\n            [0, -2],\n            [16, -2]\n        ]\n    },\n    '`': {\n        width: 10, points: [\n            [6, 21],\n            [5, 20],\n            [4, 18],\n            [4, 16],\n            [5, 15],\n            [6, 16],\n            [5, 17]\n        ]\n    },\n    'a': {\n        width: 19, points: [\n            [15, 14],\n            [15, 0],\n            [-1, -1],\n            [15, 11],\n            [13, 13],\n            [11, 14],\n            [8, 14],\n            [6, 13],\n            [4, 11],\n            [3, 8],\n            [3, 6],\n            [4, 3],\n            [6, 1],\n            [8, 0],\n            [11, 0],\n            [13, 1],\n            [15, 3]\n        ]\n    },\n    'b': {\n        width: 19, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 11],\n            [6, 13],\n            [8, 14],\n            [11, 14],\n            [13, 13],\n            [15, 11],\n            [16, 8],\n            [16, 6],\n            [15, 3],\n            [13, 1],\n            [11, 0],\n            [8, 0],\n            [6, 1],\n            [4, 3]\n        ]\n    },\n    'c': {\n        width: 18, points: [\n            [15, 11],\n            [13, 13],\n            [11, 14],\n            [8, 14],\n            [6, 13],\n            [4, 11],\n            [3, 8],\n            [3, 6],\n            [4, 3],\n            [6, 1],\n            [8, 0],\n            [11, 0],\n            [13, 1],\n            [15, 3]\n        ]\n    },\n    'd': {\n        width: 19, points: [\n            [15, 21],\n            [15, 0],\n            [-1, -1],\n            [15, 11],\n            [13, 13],\n            [11, 14],\n            [8, 14],\n            [6, 13],\n            [4, 11],\n            [3, 8],\n            [3, 6],\n            [4, 3],\n            [6, 1],\n            [8, 0],\n            [11, 0],\n            [13, 1],\n            [15, 3]\n        ]\n    },\n    'e': {\n        width: 18, points: [\n            [3, 8],\n            [15, 8],\n            [15, 10],\n            [14, 12],\n            [13, 13],\n            [11, 14],\n            [8, 14],\n            [6, 13],\n            [4, 11],\n            [3, 8],\n            [3, 6],\n            [4, 3],\n            [6, 1],\n            [8, 0],\n            [11, 0],\n            [13, 1],\n            [15, 3]\n        ]\n    },\n    'f': {\n        width: 12, points: [\n            [10, 21],\n            [8, 21],\n            [6, 20],\n            [5, 17],\n            [5, 0],\n            [-1, -1],\n            [2, 14],\n            [9, 14]\n        ]\n    },\n    'g': {\n        width: 19, points: [\n            [15, 14],\n            [15, -2],\n            [14, -5],\n            [13, -6],\n            [11, -7],\n            [8, -7],\n            [6, -6],\n            [-1, -1],\n            [15, 11],\n            [13, 13],\n            [11, 14],\n            [8, 14],\n            [6, 13],\n            [4, 11],\n            [3, 8],\n            [3, 6],\n            [4, 3],\n            [6, 1],\n            [8, 0],\n            [11, 0],\n            [13, 1],\n            [15, 3]\n        ]\n    },\n    'h': {\n        width: 19, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [4, 10],\n            [7, 13],\n            [9, 14],\n            [12, 14],\n            [14, 13],\n            [15, 10],\n            [15, 0]\n        ]\n    },\n    'i': {\n        width: 8, points: [\n            [3, 21],\n            [4, 20],\n            [5, 21],\n            [4, 22],\n            [3, 21],\n            [-1, -1],\n            [4, 14],\n            [4, 0]\n        ]\n    },\n    'j': {\n        width: 10, points: [\n            [5, 21],\n            [6, 20],\n            [7, 21],\n            [6, 22],\n            [5, 21],\n            [-1, -1],\n            [6, 14],\n            [6, -3],\n            [5, -6],\n            [3, -7],\n            [1, -7]\n        ]\n    },\n    'k': {\n        width: 17, points: [\n            [4, 21],\n            [4, 0],\n            [-1, -1],\n            [14, 14],\n            [4, 4],\n            [-1, -1],\n            [8, 8],\n            [15, 0]\n        ]\n    },\n    'l': {\n        width: 8, points: [\n            [4, 21],\n            [4, 0]\n        ]\n    },\n    'm': {\n        width: 30, points: [\n            [4, 14],\n            [4, 0],\n            [-1, -1],\n            [4, 10],\n            [7, 13],\n            [9, 14],\n            [12, 14],\n            [14, 13],\n            [15, 10],\n            [15, 0],\n            [-1, -1],\n            [15, 10],\n            [18, 13],\n            [20, 14],\n            [23, 14],\n            [25, 13],\n            [26, 10],\n            [26, 0]\n        ]\n    },\n    'n': {\n        width: 19, points: [\n            [4, 14],\n            [4, 0],\n            [-1, -1],\n            [4, 10],\n            [7, 13],\n            [9, 14],\n            [12, 14],\n            [14, 13],\n            [15, 10],\n            [15, 0]\n        ]\n    },\n    'o': {\n        width: 19, points: [\n            [8, 14],\n            [6, 13],\n            [4, 11],\n            [3, 8],\n            [3, 6],\n            [4, 3],\n            [6, 1],\n            [8, 0],\n            [11, 0],\n            [13, 1],\n            [15, 3],\n            [16, 6],\n            [16, 8],\n            [15, 11],\n            [13, 13],\n            [11, 14],\n            [8, 14]\n        ]\n    },\n    'p': {\n        width: 19, points: [\n            [4, 14],\n            [4, -7],\n            [-1, -1],\n            [4, 11],\n            [6, 13],\n            [8, 14],\n            [11, 14],\n            [13, 13],\n            [15, 11],\n            [16, 8],\n            [16, 6],\n            [15, 3],\n            [13, 1],\n            [11, 0],\n            [8, 0],\n            [6, 1],\n            [4, 3]\n        ]\n    },\n    'q': {\n        width: 19, points: [\n            [15, 14],\n            [15, -7],\n            [-1, -1],\n            [15, 11],\n            [13, 13],\n            [11, 14],\n            [8, 14],\n            [6, 13],\n            [4, 11],\n            [3, 8],\n            [3, 6],\n            [4, 3],\n            [6, 1],\n            [8, 0],\n            [11, 0],\n            [13, 1],\n            [15, 3]\n        ]\n    },\n    'r': {\n        width: 13, points: [\n            [4, 14],\n            [4, 0],\n            [-1, -1],\n            [4, 8],\n            [5, 11],\n            [7, 13],\n            [9, 14],\n            [12, 14]\n        ]\n    },\n    's': {\n        width: 17, points: [\n            [14, 11],\n            [13, 13],\n            [10, 14],\n            [7, 14],\n            [4, 13],\n            [3, 11],\n            [4, 9],\n            [6, 8],\n            [11, 7],\n            [13, 6],\n            [14, 4],\n            [14, 3],\n            [13, 1],\n            [10, 0],\n            [7, 0],\n            [4, 1],\n            [3, 3]\n        ]\n    },\n    't': {\n        width: 12, points: [\n            [5, 21],\n            [5, 4],\n            [6, 1],\n            [8, 0],\n            [10, 0],\n            [-1, -1],\n            [2, 14],\n            [9, 14]\n        ]\n    },\n    'u': {\n        width: 19, points: [\n            [4, 14],\n            [4, 4],\n            [5, 1],\n            [7, 0],\n            [10, 0],\n            [12, 1],\n            [15, 4],\n            [-1, -1],\n            [15, 14],\n            [15, 0]\n        ]\n    },\n    'v': {\n        width: 16, points: [\n            [2, 14],\n            [8, 0],\n            [-1, -1],\n            [14, 14],\n            [8, 0]\n        ]\n    },\n    'w': {\n        width: 22, points: [\n            [3, 14],\n            [7, 0],\n            [-1, -1],\n            [11, 14],\n            [7, 0],\n            [-1, -1],\n            [11, 14],\n            [15, 0],\n            [-1, -1],\n            [19, 14],\n            [15, 0]\n        ]\n    },\n    'x': {\n        width: 17, points: [\n            [3, 14],\n            [14, 0],\n            [-1, -1],\n            [14, 14],\n            [3, 0]\n        ]\n    },\n    'y': {\n        width: 16, points: [\n            [2, 14],\n            [8, 0],\n            [-1, -1],\n            [14, 14],\n            [8, 0],\n            [6, -4],\n            [4, -6],\n            [2, -7],\n            [1, -7]\n        ]\n    },\n    'z': {\n        width: 17, points: [\n            [14, 14],\n            [3, 0],\n            [-1, -1],\n            [3, 14],\n            [14, 14],\n            [-1, -1],\n            [3, 0],\n            [14, 0]\n        ]\n    },\n    '{': {\n        width: 14, points: [\n            [9, 25],\n            [7, 24],\n            [6, 23],\n            [5, 21],\n            [5, 19],\n            [6, 17],\n            [7, 16],\n            [8, 14],\n            [8, 12],\n            [6, 10],\n            [-1, -1],\n            [7, 24],\n            [6, 22],\n            [6, 20],\n            [7, 18],\n            [8, 17],\n            [9, 15],\n            [9, 13],\n            [8, 11],\n            [4, 9],\n            [8, 7],\n            [9, 5],\n            [9, 3],\n            [8, 1],\n            [7, 0],\n            [6, -2],\n            [6, -4],\n            [7, -6],\n            [-1, -1],\n            [6, 8],\n            [8, 6],\n            [8, 4],\n            [7, 2],\n            [6, 1],\n            [5, -1],\n            [5, -3],\n            [6, -5],\n            [7, -6],\n            [9, -7]\n        ]\n    },\n    '|': {\n        width: 8, points: [\n            [4, 25],\n            [4, -7]\n        ]\n    },\n    '}': {\n        width: 14, points: [\n            [5, 25],\n            [7, 24],\n            [8, 23],\n            [9, 21],\n            [9, 19],\n            [8, 17],\n            [7, 16],\n            [6, 14],\n            [6, 12],\n            [8, 10],\n            [-1, -1],\n            [7, 24],\n            [8, 22],\n            [8, 20],\n            [7, 18],\n            [6, 17],\n            [5, 15],\n            [5, 13],\n            [6, 11],\n            [10, 9],\n            [6, 7],\n            [5, 5],\n            [5, 3],\n            [6, 1],\n            [7, 0],\n            [8, -2],\n            [8, -4],\n            [7, -6],\n            [-1, -1],\n            [8, 8],\n            [6, 6],\n            [6, 4],\n            [7, 2],\n            [8, 1],\n            [9, -1],\n            [9, -3],\n            [8, -5],\n            [7, -6],\n            [5, -7]\n        ]\n    },\n    '~': {\n        width: 24, points: [\n            [3, 6],\n            [3, 8],\n            [4, 11],\n            [6, 12],\n            [8, 12],\n            [10, 11],\n            [14, 8],\n            [16, 7],\n            [18, 7],\n            [20, 8],\n            [21, 10],\n            [-1, -1],\n            [3, 8],\n            [4, 10],\n            [6, 11],\n            [8, 11],\n            [10, 10],\n            [14, 7],\n            [16, 6],\n            [18, 6],\n            [20, 7],\n            [21, 10],\n            [21, 12]\n        ]\n    }\n};\n\n/**\n * @desc Creates wireframe text-shaped geometry arrays.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a text-shaped {@link XKTGeometry}.\n *\n * [[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildVectorTextGeometry)]\n *\n * ````javascript\n * const xktModel = new XKTModel();\n *\n * const text = buildVectorTextGeometry({\n *      origin: [0,0,0],\n *      text: \"On the other side of the screen, it all looked so easy\"\n * });\n *\n * const xktGeometry = xktModel.createGeometry({\n *      geometryId: \"textGeometry\",\n *      primitiveType: text.primitiveType, // Will be \"lines\"\n *      positions: text.positions,\n *      indices: text.indices\n * });\n *\n * const xktMesh = xktModel.createMesh({\n *      meshId: \"redTextMesh\",\n *      geometryId: \"textGeometry\",\n *      position: [-4, -6, -4],\n *      scale: [1, 3, 1],\n *      rotation: [0, 0, 0],\n *      color: [1, 0, 0],\n *      opacity: 1\n * });\n *\n * const xktEntity = xktModel.createEntity({\n *      entityId: \"redText\",\n *      meshIds: [\"redTextMesh\"]\n *  });\n *\n * xktModel.finalize();\n * ````\n *\n * @function buildVectorTextGeometry\n * @param {*} [cfg] Configs\n * @param {Number[]} [cfg.center]  3D point indicating the center position.\n * @param {Number[]} [cfg.origin] 3D point indicating the top left corner.\n * @param {Number} [cfg.size=1] Size of each character.\n * @param {String} [cfg.text=\"\"] The text.\n * @returns {Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}.\n */\nfunction buildVectorTextGeometry(cfg = {}) {\n\n    var origin = cfg.origin || [0, 0, 0];\n    var xOrigin = origin[0];\n    var yOrigin = origin[1];\n    var zOrigin = origin[2];\n    var size = cfg.size || 1;\n\n    var positions = [];\n    var indices = [];\n    var text = (\"\" + cfg.text).trim();\n    var lines = (text || \"\").split(\"\\n\");\n    var countVerts = 0;\n    var y = 0;\n    var x;\n    var str;\n    var len;\n    var c;\n    var mag = 1.0 / 25.0;\n    var penUp;\n    var p1;\n    var p2;\n    var needLine;\n    var pointsLen;\n    var a;\n\n    for (var iLine = 0; iLine < lines.length; iLine++) {\n\n        x = 0;\n        str = lines[iLine];\n        len = str.length;\n\n        for (var i = 0; i < len; i++) {\n\n            c = letters[str.charAt(i)];\n\n            if (c === '\\n') {\n                //alert(\"newline\");\n            }\n\n            if (!c) {\n                continue;\n            }\n\n            penUp = 1;\n            p1 = -1;\n            p2 = -1;\n            needLine = false;\n\n            pointsLen = c.points.length;\n\n            for (var j = 0; j < pointsLen; j++) {\n                a = c.points[j];\n\n                if (a[0] === -1 && a[1] === -1) {\n                    penUp = 1;\n                    needLine = false;\n                    continue;\n                }\n\n                positions.push((x + (a[0] * size) * mag) + xOrigin);\n                positions.push((y + (a[1] * size) * mag) + yOrigin);\n                positions.push(0 + zOrigin);\n\n                if (p1 === -1) {\n                    p1 = countVerts;\n                } else if (p2 === -1) {\n                    p2 = countVerts;\n                } else {\n                    p1 = p2;\n                    p2 = countVerts;\n                }\n                countVerts++;\n\n                if (penUp) {\n                    penUp = false;\n\n                } else {\n                    indices.push(p1);\n                    indices.push(p2);\n                }\n\n                needLine = true;\n            }\n            x += c.width * mag * size;\n\n        }\n        y -= 35 * mag * size;\n    }\n\n    return {\n        primitiveType: \"lines\",\n        positions: positions,\n        indices: indices\n    };\n}\n\n\nexport {buildVectorTextGeometry}\n",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/geometryBuilders/buildVectorTextGeometry.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 346,
    "kind": "variable",
    "name": "letters",
    "memberof": "src/geometryBuilders/buildVectorTextGeometry.js",
    "static": true,
    "longname": "src/geometryBuilders/buildVectorTextGeometry.js~letters",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/geometryBuilders/buildVectorTextGeometry.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 1,
    "undocument": true,
    "type": {
      "types": [
        "{\" \": *, \"!\": *, \"\"\": *, \"#\": *, \"$\": *, \"%\": *, \"&\": *, \"'\": *, \"(\": *, \")\": *, \"*\": *, \"+\": *, \",\": *, \"-\": *, \".\": *, \"/\": *, \"0\": *, \"1\": *, \"2\": *, \"3\": *, \"4\": *, \"5\": *, \"6\": *, \"7\": *, \"8\": *, \"9\": *, \":\": *, \";\": *, \"<\": *, \"=\": *, \">\": *, \"?\": *, \"@\": *, \"A\": *, \"B\": *, \"C\": *, \"D\": *, \"E\": *, \"F\": *, \"G\": *, \"H\": *, \"I\": *, \"J\": *, \"K\": *, \"L\": *, \"M\": *, \"N\": *, \"O\": *, \"P\": *, \"Q\": *, \"R\": *, \"S\": *, \"T\": *, \"U\": *, \"V\": *, \"W\": *, \"X\": *, \"Y\": *, \"Z\": *, \"[\": *, \"\\\": *, \"]\": *, \"^\": *, \"_\": *, \"`\": *, \"a\": *, \"b\": *, \"c\": *, \"d\": *, \"e\": *, \"f\": *, \"g\": *, \"h\": *, \"i\": *, \"j\": *, \"k\": *, \"l\": *, \"m\": *, \"n\": *, \"o\": *, \"p\": *, \"q\": *, \"r\": *, \"s\": *, \"t\": *, \"u\": *, \"v\": *, \"w\": *, \"x\": *, \"y\": *, \"z\": *, \"{\": *, \"|\": *, \"}\": *, \"~\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 347,
    "kind": "function",
    "name": "buildVectorTextGeometry",
    "memberof": "src/geometryBuilders/buildVectorTextGeometry.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/geometryBuilders/buildVectorTextGeometry.js~buildVectorTextGeometry",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/geometryBuilders/buildVectorTextGeometry.js",
    "importStyle": "{buildVectorTextGeometry}",
    "description": "Creates wireframe text-shaped geometry arrays.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then create an {@link XKTMesh} with a text-shaped {@link XKTGeometry}.\n\n[[Run this example](http://xeokit.github.io/xeokit-sdk/examples/#geometry_builders_buildVectorTextGeometry)]\n\n````javascript\nconst xktModel = new XKTModel();\n\nconst text = buildVectorTextGeometry({\n     origin: [0,0,0],\n     text: \"On the other side of the screen, it all looked so easy\"\n});\n\nconst xktGeometry = xktModel.createGeometry({\n     geometryId: \"textGeometry\",\n     primitiveType: text.primitiveType, // Will be \"lines\"\n     positions: text.positions,\n     indices: text.indices\n});\n\nconst xktMesh = xktModel.createMesh({\n     meshId: \"redTextMesh\",\n     geometryId: \"textGeometry\",\n     position: [-4, -6, -4],\n     scale: [1, 3, 1],\n     rotation: [0, 0, 0],\n     color: [1, 0, 0],\n     opacity: 1\n});\n\nconst xktEntity = xktModel.createEntity({\n     entityId: \"redText\",\n     meshIds: [\"redTextMesh\"]\n });\n\nxktModel.finalize();\n````",
    "lineNumber": 1625,
    "unknown": [
      {
        "tagName": "@function",
        "tagValue": "buildVectorTextGeometry"
      },
      {
        "tagName": "@returns",
        "tagValue": "{Object} Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg",
        "description": "Configs"
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.center",
        "description": "3D point indicating the center position."
      },
      {
        "nullable": null,
        "types": [
          "Number[]"
        ],
        "spread": false,
        "optional": true,
        "name": "cfg.origin",
        "description": "3D point indicating the top left corner."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "cfg.size",
        "description": "Size of each character."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "\"\"",
        "defaultRaw": "",
        "name": "cfg.text",
        "description": "The text."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Object"
      ],
      "spread": false,
      "description": "Geometry arrays for {@link XKTModel#createGeometry} or {@link XKTModel#createMesh}."
    }
  },
  {
    "__docId__": 348,
    "kind": "file",
    "name": "src/index.js",
    "content": "export {XKT_INFO} from \"./XKT_INFO.js\";\nexport * from \"./constants.js\";\nexport {XKTModel} from \"./XKTModel/XKTModel.js\";\nexport {writeXKTModelToArrayBuffer} from \"./XKTModel/writeXKTModelToArrayBuffer.js\";\n\nexport {parseCityJSONIntoXKTModel} from \"./parsers/parseCityJSONIntoXKTModel.js\";\nexport {parseGLTFIntoXKTModel} from \"./parsers/parseGLTFIntoXKTModel.js\";\nexport {parseGLTFJSONIntoXKTModel} from \"./parsers/parseGLTFJSONIntoXKTModel.js\";\nexport {parseIFCIntoXKTModel} from \"./parsers/parseIFCIntoXKTModel.js\";\nexport {parseLASIntoXKTModel} from \"./parsers/parseLASIntoXKTModel.js\";\nexport {parseMetaModelIntoXKTModel} from \"./parsers/parseMetaModelIntoXKTModel.js\";\nexport {parsePCDIntoXKTModel} from \"./parsers/parsePCDIntoXKTModel.js\";\nexport {parsePLYIntoXKTModel} from \"./parsers/parsePLYIntoXKTModel.js\";\nexport {parseSTLIntoXKTModel} from \"./parsers/parseSTLIntoXKTModel.js\";\n\nexport {buildBoxGeometry} from \"./geometryBuilders/buildBoxGeometry.js\";\nexport {buildBoxLinesGeometry} from \"./geometryBuilders/buildBoxLinesGeometry.js\";\nexport {buildCylinderGeometry} from \"./geometryBuilders/buildCylinderGeometry.js\";\nexport {buildGridGeometry} from \"./geometryBuilders/buildGridGeometry.js\";\nexport {buildPlaneGeometry} from \"./geometryBuilders/buildPlaneGeometry.js\";\nexport {buildSphereGeometry} from \"./geometryBuilders/buildSphereGeometry.js\";\nexport {buildTorusGeometry} from \"./geometryBuilders/buildTorusGeometry.js\";\nexport {buildVectorTextGeometry} from \"./geometryBuilders/buildVectorTextGeometry.js\";\n\n",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/index.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 349,
    "kind": "file",
    "name": "src/lib/buildFaceNormals.js",
    "content": "import {math} from \"./math.js\";\n\n/**\n * Builds face-aligned vertex normal vectors from positions and indices.\n *\n * @private\n */\nfunction buildFaceNormals(positions, indices, normals) {\n\n    const a = math.vec3();\n    const b = math.vec3();\n    const c = math.vec3();\n\n    const normVec = math.vec3();\n\n    for (let i = 0, len = indices.length; i < len; i += 3) {\n\n        const j0 = indices[i];\n        const j1 = indices[i + 1];\n        const j2 = indices[i + 2];\n\n        a[0] = positions[j0 * 3];\n        a[1] = positions[j0 * 3 + 1];\n        a[2] = positions[j0 * 3 + 2];\n\n        b[0] = positions[j1 * 3];\n        b[1] = positions[j1 * 3 + 1];\n        b[2] = positions[j1 * 3 + 2];\n\n        c[0] = positions[j2 * 3];\n        c[1] = positions[j2 * 3 + 1];\n        c[2] = positions[j2 * 3 + 2];\n\n        triangleNormal(a,b,c, normVec);\n\n        normals[j0 * 3 + 0] = normVec[0];\n        normals[j0 * 3 + 1] = normVec[1];\n        normals[j0 * 3 + 2] = normVec[2];\n\n        normals[j1 * 3 + 0] = normVec[0];\n        normals[j1 * 3 + 1] = normVec[1];\n        normals[j1 * 3 + 2] = normVec[2];\n\n        normals[j2 * 3 + 0] = normVec[0];\n        normals[j2 * 3 + 1] = normVec[1];\n        normals[j2 * 3 + 2] = normVec[2];\n    }\n}\n\nfunction triangleNormal(a, b, c, normal = math.vec3()) {\n    const p1x = b[0] - a[0];\n    const p1y = b[1] - a[1];\n    const p1z = b[2] - a[2];\n\n    const p2x = c[0] - a[0];\n    const p2y = c[1] - a[1];\n    const p2z = c[2] - a[2];\n\n    const p3x = p1y * p2z - p1z * p2y;\n    const p3y = p1z * p2x - p1x * p2z;\n    const p3z = p1x * p2y - p1y * p2x;\n\n    const mag = Math.sqrt(p3x * p3x + p3y * p3y + p3z * p3z);\n    if (mag === 0) {\n        normal[0] = 0;\n        normal[1] = 0;\n        normal[2] = 0;\n    } else {\n        normal[0] = p3x / mag;\n        normal[1] = p3y / mag;\n        normal[2] = p3z / mag;\n    }\n\n    return normal\n}\n\nexport {buildFaceNormals};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/lib/buildFaceNormals.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 350,
    "kind": "function",
    "name": "triangleNormal",
    "memberof": "src/lib/buildFaceNormals.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/buildFaceNormals.js~triangleNormal",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/buildFaceNormals.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 50,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      },
      {
        "name": "c",
        "types": [
          "*"
        ]
      },
      {
        "name": "normal",
        "optional": true,
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 351,
    "kind": "function",
    "name": "buildFaceNormals",
    "memberof": "src/lib/buildFaceNormals.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/buildFaceNormals.js~buildFaceNormals",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/lib/buildFaceNormals.js",
    "importStyle": "{buildFaceNormals}",
    "description": "Builds face-aligned vertex normal vectors from positions and indices.",
    "lineNumber": 8,
    "ignore": true,
    "params": [
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "indices",
        "types": [
          "*"
        ]
      },
      {
        "name": "normals",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 352,
    "kind": "file",
    "name": "src/lib/buildVertexNormals.js",
    "content": "import {math} from \"./math.js\";\n\n/**\n * Builds vertex normal vectors from positions and indices.\n *\n * @private\n */\nfunction buildVertexNormals(positions, indices, normals) {\n\n    const a = math.vec3();\n    const b = math.vec3();\n    const c = math.vec3();\n    const ab = math.vec3();\n    const ac = math.vec3();\n    const crossVec = math.vec3();\n    const nvecs = new Array(positions.length / 3);\n\n    for (let i = 0, len = indices.length; i < len; i += 3) {\n\n        const j0 = indices[i];\n        const j1 = indices[i + 1];\n        const j2 = indices[i + 2];\n\n        a[0] = positions[j0 * 3];\n        a[1] = positions[j0 * 3 + 1];\n        a[2] = positions[j0 * 3 + 2];\n\n        b[0] = positions[j1 * 3];\n        b[1] = positions[j1 * 3 + 1];\n        b[2] = positions[j1 * 3 + 2];\n\n        c[0] = positions[j2 * 3];\n        c[1] = positions[j2 * 3 + 1];\n        c[2] = positions[j2 * 3 + 2];\n\n        math.subVec3(b, a, ab);\n        math.subVec3(c, a, ac);\n\n        const normVec = math.vec3();\n\n        math.normalizeVec3(math.cross3Vec3(ab, ac, crossVec), normVec);\n\n        if (!nvecs[j0]) {\n            nvecs[j0] = [];\n        }\n        if (!nvecs[j1]) {\n            nvecs[j1] = [];\n        }\n        if (!nvecs[j2]) {\n            nvecs[j2] = [];\n        }\n\n        nvecs[j0].push(normVec);\n        nvecs[j1].push(normVec);\n        nvecs[j2].push(normVec);\n    }\n\n    normals = (normals && normals.length === positions.length) ? normals : new Float32Array(positions.length);\n\n    for (let i = 0, len = nvecs.length; i < len; i++) {  // Now go through and average out everything\n\n        const count = nvecs[i].length;\n\n        let x = 0;\n        let y = 0;\n        let z = 0;\n\n        for (let j = 0; j < count; j++) {\n            x += nvecs[i][j][0];\n            y += nvecs[i][j][1];\n            z += nvecs[i][j][2];\n        }\n\n        normals[i * 3] = (x / count);\n        normals[i * 3 + 1] = (y / count);\n        normals[i * 3 + 2] = (z / count);\n    }\n\n    return normals;\n}\n\nexport {buildVertexNormals};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/lib/buildVertexNormals.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 353,
    "kind": "function",
    "name": "buildVertexNormals",
    "memberof": "src/lib/buildVertexNormals.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/buildVertexNormals.js~buildVertexNormals",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/lib/buildVertexNormals.js",
    "importStyle": "{buildVertexNormals}",
    "description": "Builds vertex normal vectors from positions and indices.",
    "lineNumber": 8,
    "ignore": true,
    "params": [
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "indices",
        "types": [
          "*"
        ]
      },
      {
        "name": "normals",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 354,
    "kind": "file",
    "name": "src/lib/earcut.js",
    "content": "/** @private */\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode || outerNode.next === outerNode.prev) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, invSize;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and invSize are later used to transform coords into integers for z-order calculation\n        invSize = Math.max(maxX - minX, maxY - minY);\n        invSize = invSize !== 0 ? 1 / invSize : 0;\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);\n\n    return triangles;\n}\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) break;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim);\n            triangles.push(ear.i / dim);\n            triangles.push(next.i / dim);\n\n            removeNode(ear);\n\n            // skipping the next vertex leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);\n\n                // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(filterPoints(ear), triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);\n\n                // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, invSize);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var p = ear.next.next;\n\n    while (p !== ear.prev) {\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, invSize) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // triangle bbox; min & max are calculated like this for speed\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\n        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\n        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\n        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(minTX, minTY, minX, minY, invSize),\n        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);\n\n    var p = ear.prevZ,\n        n = ear.nextZ;\n\n    // look for points inside the triangle in both directions\n    while (p && p.z >= minZ && n && n.z <= maxZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    // look for remaining points in decreasing z-order\n    while (p && p.z >= minZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    // look for remaining points in increasing z-order\n    while (n && n.z <= maxZ) {\n        if (n !== ear.prev && n !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&\n            area(n.prev, n, n.next) >= 0) return false;\n        n = n.nextZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim);\n            triangles.push(p.i / dim);\n            triangles.push(b.i / dim);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return filterPoints(p);\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, invSize) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, invSize);\n                earcutLinked(c, triangles, dim, minX, minY, invSize);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        eliminateHole(queue[i], outerNode);\n        outerNode = filterPoints(outerNode, outerNode.next);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    outerNode = findHoleBridge(hole, outerNode);\n    if (outerNode) {\n        var b = splitPolygon(outerNode, hole);\n\n        // filter collinear points around the cuts\n        filterPoints(outerNode, outerNode.next);\n        filterPoints(b, b.next);\n    }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                if (x === hx) {\n                    if (hy === p.y) return p;\n                    if (hy === p.next.y) return p.next;\n                }\n                m = p.x < p.next.x ? p : p.next;\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    if (hx === qx) return m; // hole touches outer segment; pick leftmost endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m;\n\n    do {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n            pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if (locallyInside(p, hole) &&\n                (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && sectorContainsSector(m, p)))))) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    } while (p !== stop);\n\n    return m;\n}\n\n// whether sector in vertex m contains sector in vertex p in the same coordinates\nfunction sectorContainsSector(m, p) {\n    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, invSize) {\n    var p = start;\n    do {\n        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and inverse of the longer side of data bbox\nfunction zOrder(x, y, minX, minY, invSize) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = 32767 * (x - minX) * invSize;\n    y = 32767 * (y - minY) * invSize;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n        (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n        (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && // dones't intersect other edges\n        (locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && // locally visible\n            (area(a.prev, a, b.prev) || area(a, b.prev, b)) || // does not create opposite-facing sectors\n            equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    var o1 = sign(area(p1, q1, p2));\n    var o2 = sign(area(p1, q1, q2));\n    var o3 = sign(area(p2, q2, p1));\n    var o4 = sign(area(p2, q2, q1));\n\n    if (o1 !== o2 && o3 !== o4) return true; // general case\n\n    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1\n    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1\n    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2\n    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2\n\n    return false;\n}\n\n// for collinear points p, q, r, check if point q lies on segment pr\nfunction onSegment(p, q, r) {\n    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);\n}\n\nfunction sign(num) {\n    return num > 0 ? 1 : num < 0 ? -1 : 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n            intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n            (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertex index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertex nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = null;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n\nexport {earcut};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/lib/earcut.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 355,
    "kind": "function",
    "name": "linkedList",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~linkedList",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 42,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "end",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      },
      {
        "name": "clockwise",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 356,
    "kind": "function",
    "name": "filterPoints",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~filterPoints",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "end",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 357,
    "kind": "function",
    "name": "earcutLinked",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~earcutLinked",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 84,
    "undocument": true,
    "params": [
      {
        "name": "ear",
        "types": [
          "*"
        ]
      },
      {
        "name": "triangles",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      },
      {
        "name": "minX",
        "types": [
          "*"
        ]
      },
      {
        "name": "minY",
        "types": [
          "*"
        ]
      },
      {
        "name": "invSize",
        "types": [
          "*"
        ]
      },
      {
        "name": "pass",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 358,
    "kind": "function",
    "name": "isEar",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~isEar",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 137,
    "undocument": true,
    "params": [
      {
        "name": "ear",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 359,
    "kind": "function",
    "name": "isEarHashed",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~isEarHashed",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 156,
    "undocument": true,
    "params": [
      {
        "name": "ear",
        "types": [
          "*"
        ]
      },
      {
        "name": "minX",
        "types": [
          "*"
        ]
      },
      {
        "name": "minY",
        "types": [
          "*"
        ]
      },
      {
        "name": "invSize",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 360,
    "kind": "function",
    "name": "cureLocalIntersections",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~cureLocalIntersections",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 209,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "triangles",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 361,
    "kind": "function",
    "name": "splitEarcut",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~splitEarcut",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 234,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "triangles",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      },
      {
        "name": "minX",
        "types": [
          "*"
        ]
      },
      {
        "name": "minY",
        "types": [
          "*"
        ]
      },
      {
        "name": "invSize",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 362,
    "kind": "function",
    "name": "eliminateHoles",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~eliminateHoles",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 260,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "holeIndices",
        "types": [
          "*"
        ]
      },
      {
        "name": "outerNode",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 363,
    "kind": "function",
    "name": "compareX",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~compareX",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 283,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 364,
    "kind": "function",
    "name": "eliminateHole",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~eliminateHole",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 288,
    "undocument": true,
    "params": [
      {
        "name": "hole",
        "types": [
          "*"
        ]
      },
      {
        "name": "outerNode",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 365,
    "kind": "function",
    "name": "findHoleBridge",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~findHoleBridge",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 300,
    "undocument": true,
    "params": [
      {
        "name": "hole",
        "types": [
          "*"
        ]
      },
      {
        "name": "outerNode",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 366,
    "kind": "function",
    "name": "sectorContainsSector",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~sectorContainsSector",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 360,
    "undocument": true,
    "params": [
      {
        "name": "m",
        "types": [
          "*"
        ]
      },
      {
        "name": "p",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 367,
    "kind": "function",
    "name": "indexCurve",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~indexCurve",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 365,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "minX",
        "types": [
          "*"
        ]
      },
      {
        "name": "minY",
        "types": [
          "*"
        ]
      },
      {
        "name": "invSize",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 368,
    "kind": "function",
    "name": "sortLinked",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~sortLinked",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 382,
    "undocument": true,
    "params": [
      {
        "name": "list",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 369,
    "kind": "function",
    "name": "zOrder",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~zOrder",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 434,
    "undocument": true,
    "params": [
      {
        "name": "x",
        "types": [
          "*"
        ]
      },
      {
        "name": "y",
        "types": [
          "*"
        ]
      },
      {
        "name": "minX",
        "types": [
          "*"
        ]
      },
      {
        "name": "minY",
        "types": [
          "*"
        ]
      },
      {
        "name": "invSize",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 370,
    "kind": "function",
    "name": "getLeftmost",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~getLeftmost",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 453,
    "undocument": true,
    "params": [
      {
        "name": "start",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 371,
    "kind": "function",
    "name": "pointInTriangle",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~pointInTriangle",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 465,
    "undocument": true,
    "params": [
      {
        "name": "ax",
        "types": [
          "*"
        ]
      },
      {
        "name": "ay",
        "types": [
          "*"
        ]
      },
      {
        "name": "bx",
        "types": [
          "*"
        ]
      },
      {
        "name": "by",
        "types": [
          "*"
        ]
      },
      {
        "name": "cx",
        "types": [
          "*"
        ]
      },
      {
        "name": "cy",
        "types": [
          "*"
        ]
      },
      {
        "name": "px",
        "types": [
          "*"
        ]
      },
      {
        "name": "py",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 372,
    "kind": "function",
    "name": "isValidDiagonal",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~isValidDiagonal",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 472,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 373,
    "kind": "function",
    "name": "area",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~area",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 480,
    "undocument": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      },
      {
        "name": "q",
        "types": [
          "*"
        ]
      },
      {
        "name": "r",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 374,
    "kind": "function",
    "name": "equals",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~equals",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 485,
    "undocument": true,
    "params": [
      {
        "name": "p1",
        "types": [
          "*"
        ]
      },
      {
        "name": "p2",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 375,
    "kind": "function",
    "name": "intersects",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~intersects",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 490,
    "undocument": true,
    "params": [
      {
        "name": "p1",
        "types": [
          "*"
        ]
      },
      {
        "name": "q1",
        "types": [
          "*"
        ]
      },
      {
        "name": "p2",
        "types": [
          "*"
        ]
      },
      {
        "name": "q2",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 376,
    "kind": "function",
    "name": "onSegment",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~onSegment",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 507,
    "undocument": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      },
      {
        "name": "q",
        "types": [
          "*"
        ]
      },
      {
        "name": "r",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 377,
    "kind": "function",
    "name": "sign",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~sign",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 511,
    "undocument": true,
    "params": [
      {
        "name": "num",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 378,
    "kind": "function",
    "name": "intersectsPolygon",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~intersectsPolygon",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 516,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 379,
    "kind": "function",
    "name": "locallyInside",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~locallyInside",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 528,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 380,
    "kind": "function",
    "name": "middleInside",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~middleInside",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 535,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 381,
    "kind": "function",
    "name": "splitPolygon",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~splitPolygon",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 552,
    "undocument": true,
    "params": [
      {
        "name": "a",
        "types": [
          "*"
        ]
      },
      {
        "name": "b",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 382,
    "kind": "function",
    "name": "insertNode",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~insertNode",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 574,
    "undocument": true,
    "params": [
      {
        "name": "i",
        "types": [
          "*"
        ]
      },
      {
        "name": "x",
        "types": [
          "*"
        ]
      },
      {
        "name": "y",
        "types": [
          "*"
        ]
      },
      {
        "name": "last",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 383,
    "kind": "function",
    "name": "removeNode",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~removeNode",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 590,
    "undocument": true,
    "params": [
      {
        "name": "p",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 384,
    "kind": "function",
    "name": "Node",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~Node",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 598,
    "undocument": true,
    "params": [
      {
        "name": "i",
        "types": [
          "*"
        ]
      },
      {
        "name": "x",
        "types": [
          "*"
        ]
      },
      {
        "name": "y",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 385,
    "kind": "function",
    "name": "deviation",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~deviation",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 623,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "holeIndices",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      },
      {
        "name": "triangles",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 386,
    "kind": "function",
    "name": "signedArea",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~signedArea",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 650,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "start",
        "types": [
          "*"
        ]
      },
      {
        "name": "end",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 387,
    "kind": "function",
    "name": "flatten",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~flatten",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 660,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 388,
    "kind": "function",
    "name": "earcut",
    "memberof": "src/lib/earcut.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/earcut.js~earcut",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/lib/earcut.js",
    "importStyle": "{earcut}",
    "description": null,
    "lineNumber": 2,
    "ignore": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      },
      {
        "name": "holeIndices",
        "types": [
          "*"
        ]
      },
      {
        "name": "dim",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 389,
    "kind": "file",
    "name": "src/lib/faceToVertexNormals.js",
    "content": "import {math} from \"./math.js\";\n\n/**\n * Converts surface-perpendicular face normals to vertex normals. Assumes that the mesh contains disjoint triangles\n * that don't share vertex array elements. Works by finding groups of vertices that have the same location and\n * averaging their normal vectors.\n *\n * @returns {{positions: Array, normals: *}}\n * @private\n */\nfunction faceToVertexNormals(positions, normals, options = {}) {\n    const smoothNormalsAngleThreshold = options.smoothNormalsAngleThreshold || 20;\n    const vertexMap = {};\n    const vertexNormals = [];\n    const vertexNormalAccum = {};\n    let acc;\n    let vx;\n    let vy;\n    let vz;\n    let key;\n    const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n    const precision = 10 ** precisionPoints;\n    let posi;\n    let i;\n    let j;\n    let len;\n    let a;\n    let b;\n    let c;\n\n    for (i = 0, len = positions.length; i < len; i += 3) {\n\n        posi = i / 3;\n\n        vx = positions[i];\n        vy = positions[i + 1];\n        vz = positions[i + 2];\n\n        key = `${Math.round(vx * precision)}_${Math.round(vy * precision)}_${Math.round(vz * precision)}`;\n\n        if (vertexMap[key] === undefined) {\n            vertexMap[key] = [posi];\n        } else {\n            vertexMap[key].push(posi);\n        }\n\n        const normal = math.normalizeVec3([normals[i], normals[i + 1], normals[i + 2]]);\n\n        vertexNormals[posi] = normal;\n\n        acc = math.vec4([normal[0], normal[1], normal[2], 1]);\n\n        vertexNormalAccum[posi] = acc;\n    }\n\n    for (key in vertexMap) {\n\n        if (vertexMap.hasOwnProperty(key)) {\n\n            const vertices = vertexMap[key];\n            const numVerts = vertices.length;\n\n            for (i = 0; i < numVerts; i++) {\n\n                const ii = vertices[i];\n\n                acc = vertexNormalAccum[ii];\n\n                for (j = 0; j < numVerts; j++) {\n\n                    if (i === j) {\n                        continue;\n                    }\n\n                    const jj = vertices[j];\n\n                    a = vertexNormals[ii];\n                    b = vertexNormals[jj];\n\n                    const angle = Math.abs(math.angleVec3(a, b) / math.DEGTORAD);\n\n                    if (angle < smoothNormalsAngleThreshold) {\n\n                        acc[0] += b[0];\n                        acc[1] += b[1];\n                        acc[2] += b[2];\n                        acc[3] += 1.0;\n                    }\n                }\n            }\n        }\n    }\n\n    for (i = 0, len = normals.length; i < len; i += 3) {\n\n        acc = vertexNormalAccum[i / 3];\n\n        normals[i + 0] = acc[0] / acc[3];\n        normals[i + 1] = acc[1] / acc[3];\n        normals[i + 2] = acc[2] / acc[3];\n\n    }\n}\n\nexport {faceToVertexNormals};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/lib/faceToVertexNormals.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 390,
    "kind": "function",
    "name": "faceToVertexNormals",
    "memberof": "src/lib/faceToVertexNormals.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/faceToVertexNormals.js~faceToVertexNormals",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/lib/faceToVertexNormals.js",
    "importStyle": "{faceToVertexNormals}",
    "description": "Converts surface-perpendicular face normals to vertex normals. Assumes that the mesh contains disjoint triangles\nthat don't share vertex array elements. Works by finding groups of vertices that have the same location and\naveraging their normal vectors.",
    "lineNumber": 11,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{positions: Array, normals: *}}"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{positions: Array, normals: *}"
      ],
      "spread": false,
      "description": ""
    },
    "ignore": true,
    "params": [
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "normals",
        "types": [
          "*"
        ]
      },
      {
        "name": "options",
        "optional": true,
        "types": [
          "{}"
        ],
        "defaultRaw": {},
        "defaultValue": "{}"
      }
    ]
  },
  {
    "__docId__": 391,
    "kind": "file",
    "name": "src/lib/math.js",
    "content": "// Some temporary vars to help avoid garbage collection\n\nconst doublePrecision = true;\nconst FloatArrayType = doublePrecision ? Float64Array : Float32Array;\n\nconst tempMat1 = new FloatArrayType(16);\nconst tempMat2 = new FloatArrayType(16);\nconst tempVec4 = new FloatArrayType(4);\n\n/**\n * @private\n */\nconst math = {\n\n    MIN_DOUBLE: -Number.MAX_SAFE_INTEGER,\n    MAX_DOUBLE:  Number.MAX_SAFE_INTEGER,\n\n    /**\n     * The number of radiians in a degree (0.0174532925).\n     * @property DEGTORAD\n     * @type {Number}\n     */\n    DEGTORAD: 0.0174532925,\n\n    /**\n     * The number of degrees in a radian.\n     * @property RADTODEG\n     * @type {Number}\n     */\n    RADTODEG: 57.295779513,\n\n    /**\n     * Returns a new, uninitialized two-element vector.\n     * @method vec2\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec2(values) {\n        return new FloatArrayType(values || 2);\n    },\n\n    /**\n     * Returns a new, uninitialized three-element vector.\n     * @method vec3\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec3(values) {\n        return new FloatArrayType(values || 3);\n    },\n\n    /**\n     * Returns a new, uninitialized four-element vector.\n     * @method vec4\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    vec4(values) {\n        return new FloatArrayType(values || 4);\n    },\n\n    /**\n     * Returns a new, uninitialized 3x3 matrix.\n     * @method mat3\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    mat3(values) {\n        return new FloatArrayType(values || 9);\n    },\n\n    /**\n     * Converts a 3x3 matrix to 4x4\n     * @method mat3ToMat4\n     * @param mat3 3x3 matrix.\n     * @param mat4 4x4 matrix\n     * @static\n     * @returns {Number[]}\n     */\n    mat3ToMat4(mat3, mat4 = new FloatArrayType(16)) {\n        mat4[0] = mat3[0];\n        mat4[1] = mat3[1];\n        mat4[2] = mat3[2];\n        mat4[3] = 0;\n        mat4[4] = mat3[3];\n        mat4[5] = mat3[4];\n        mat4[6] = mat3[5];\n        mat4[7] = 0;\n        mat4[8] = mat3[6];\n        mat4[9] = mat3[7];\n        mat4[10] = mat3[8];\n        mat4[11] = 0;\n        mat4[12] = 0;\n        mat4[13] = 0;\n        mat4[14] = 0;\n        mat4[15] = 1;\n        return mat4;\n    },\n\n    /**\n     * Returns a new, uninitialized 4x4 matrix.\n     * @method mat4\n     * @param [values] Initial values.\n     * @static\n     * @returns {Number[]}\n     */\n    mat4(values) {\n        return new FloatArrayType(values || 16);\n    },\n\n    /**\n     * Converts a 4x4 matrix to 3x3\n     * @method mat4ToMat3\n     * @param mat4 4x4 matrix.\n     * @param mat3 3x3 matrix\n     * @static\n     * @returns {Number[]}\n     */\n    mat4ToMat3(mat4, mat3) { // TODO\n        //return new FloatArrayType(values || 9);\n    },\n\n    /**\n     * Returns a new UUID.\n     * @method createUUID\n     * @static\n     * @return string The new UUID\n     */\n    createUUID: ((() => {\n        const self = {};\n        const lut = [];\n        for (let i = 0; i < 256; i++) {\n            lut[i] = (i < 16 ? '0' : '') + (i).toString(16);\n        }\n        return () => {\n            const d0 = Math.random() * 0xffffffff | 0;\n            const d1 = Math.random() * 0xffffffff | 0;\n            const d2 = Math.random() * 0xffffffff | 0;\n            const d3 = Math.random() * 0xffffffff | 0;\n            return `${lut[d0 & 0xff] + lut[d0 >> 8 & 0xff] + lut[d0 >> 16 & 0xff] + lut[d0 >> 24 & 0xff]}-${lut[d1 & 0xff]}${lut[d1 >> 8 & 0xff]}-${lut[d1 >> 16 & 0x0f | 0x40]}${lut[d1 >> 24 & 0xff]}-${lut[d2 & 0x3f | 0x80]}${lut[d2 >> 8 & 0xff]}-${lut[d2 >> 16 & 0xff]}${lut[d2 >> 24 & 0xff]}${lut[d3 & 0xff]}${lut[d3 >> 8 & 0xff]}${lut[d3 >> 16 & 0xff]}${lut[d3 >> 24 & 0xff]}`;\n        };\n    }))(),\n\n    /**\n     * Clamps a value to the given range.\n     * @param {Number} value Value to clamp.\n     * @param {Number} min Lower bound.\n     * @param {Number} max Upper bound.\n     * @returns {Number} Clamped result.\n     */\n    clamp(value, min, max) {\n        return Math.max(min, Math.min(max, value));\n    },\n\n    /**\n     * Floating-point modulus\n     * @method fmod\n     * @static\n     * @param {Number} a\n     * @param {Number} b\n     * @returns {*}\n     */\n    fmod(a, b) {\n        if (a < b) {\n            console.error(\"math.fmod : Attempting to find modulus within negative range - would be infinite loop - ignoring\");\n            return a;\n        }\n        while (b <= a) {\n            a -= b;\n        }\n        return a;\n    },\n\n    /**\n     * Negates a four-element vector.\n     * @method negateVec4\n     * @static\n     * @param {Array(Number)} v Vector to negate\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    negateVec4(v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = -v[0];\n        dest[1] = -v[1];\n        dest[2] = -v[2];\n        dest[3] = -v[3];\n        return dest;\n    },\n\n    /**\n     * Adds one four-element vector to another.\n     * @method addVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    addVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] + v[0];\n        dest[1] = u[1] + v[1];\n        dest[2] = u[2] + v[2];\n        dest[3] = u[3] + v[3];\n        return dest;\n    },\n\n    /**\n     * Adds a scalar value to each element of a four-element vector.\n     * @method addVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    addVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] + s;\n        dest[1] = v[1] + s;\n        dest[2] = v[2] + s;\n        dest[3] = v[3] + s;\n        return dest;\n    },\n\n    /**\n     * Adds one three-element vector to another.\n     * @method addVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    addVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] + v[0];\n        dest[1] = u[1] + v[1];\n        dest[2] = u[2] + v[2];\n        return dest;\n    },\n\n    /**\n     * Adds a scalar value to each element of a three-element vector.\n     * @method addVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    addVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] + s;\n        dest[1] = v[1] + s;\n        dest[2] = v[2] + s;\n        return dest;\n    },\n\n    /**\n     * Subtracts one four-element vector from another.\n     * @method subVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        dest[2] = u[2] - v[2];\n        dest[3] = u[3] - v[3];\n        return dest;\n    },\n\n    /**\n     * Subtracts one three-element vector from another.\n     * @method subVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        dest[2] = u[2] - v[2];\n        return dest;\n    },\n\n    /**\n     * Subtracts one two-element vector from another.\n     * @method subVec2\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Vector to subtract\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    subVec2(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] - v[0];\n        dest[1] = u[1] - v[1];\n        return dest;\n    },\n\n    /**\n     * Subtracts a scalar value from each element of a four-element vector.\n     * @method subVec4Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    subVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] - s;\n        dest[1] = v[1] - s;\n        dest[2] = v[2] - s;\n        dest[3] = v[3] - s;\n        return dest;\n    },\n\n    /**\n     * Sets each element of a 4-element vector to a scalar value minus the value of that element.\n     * @method subScalarVec4\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    subScalarVec4(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s - v[0];\n        dest[1] = s - v[1];\n        dest[2] = s - v[2];\n        dest[3] = s - v[3];\n        return dest;\n    },\n\n    /**\n     * Multiplies one three-element vector by another.\n     * @method mulVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    mulVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] * v[0];\n        dest[1] = u[1] * v[1];\n        dest[2] = u[2] * v[2];\n        dest[3] = u[3] * v[3];\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a four-element vector by a scalar.\n     * @method mulVec34calar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        dest[2] = v[2] * s;\n        dest[3] = v[3] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a three-element vector by a scalar.\n     * @method mulVec3Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        dest[2] = v[2] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of a two-element vector by a scalar.\n     * @method mulVec2Scalar\n     * @static\n     * @param {Array(Number)} v The vector\n     * @param {Number} s The scalar\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, v otherwise\n     */\n    mulVec2Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] * s;\n        dest[1] = v[1] * s;\n        return dest;\n    },\n\n    /**\n     * Divides one three-element vector by another.\n     * @method divVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    divVec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] / v[0];\n        dest[1] = u[1] / v[1];\n        dest[2] = u[2] / v[2];\n        return dest;\n    },\n\n    /**\n     * Divides one four-element vector by another.\n     * @method divVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @param  {Array(Number)} [dest] Destination vector\n     * @return {Array(Number)} dest if specified, u otherwise\n     */\n    divVec4(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        dest[0] = u[0] / v[0];\n        dest[1] = u[1] / v[1];\n        dest[2] = u[2] / v[2];\n        dest[3] = u[3] / v[3];\n        return dest;\n    },\n\n    /**\n     * Divides a scalar by a three-element vector, returning a new vector.\n     * @method divScalarVec3\n     * @static\n     * @param v vec3\n     * @param s scalar\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divScalarVec3(s, v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s / v[0];\n        dest[1] = s / v[1];\n        dest[2] = s / v[2];\n        return dest;\n    },\n\n    /**\n     * Divides a three-element vector by a scalar.\n     * @method divVec3Scalar\n     * @static\n     * @param v vec3\n     * @param s scalar\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divVec3Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] / s;\n        dest[1] = v[1] / s;\n        dest[2] = v[2] / s;\n        return dest;\n    },\n\n    /**\n     * Divides a four-element vector by a scalar.\n     * @method divVec4Scalar\n     * @static\n     * @param v vec4\n     * @param s scalar\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divVec4Scalar(v, s, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = v[0] / s;\n        dest[1] = v[1] / s;\n        dest[2] = v[2] / s;\n        dest[3] = v[3] / s;\n        return dest;\n    },\n\n\n    /**\n     * Divides a scalar by a four-element vector, returning a new vector.\n     * @method divScalarVec4\n     * @static\n     * @param s scalar\n     * @param v vec4\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     */\n    divScalarVec4(s, v, dest) {\n        if (!dest) {\n            dest = v;\n        }\n        dest[0] = s / v[0];\n        dest[1] = s / v[1];\n        dest[2] = s / v[2];\n        dest[3] = s / v[3];\n        return dest;\n    },\n\n    /**\n     * Returns the dot product of two four-element vectors.\n     * @method dotVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec4(u, v) {\n        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2] + u[3] * v[3]);\n    },\n\n    /**\n     * Returns the cross product of two four-element vectors.\n     * @method cross3Vec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The cross product\n     */\n    cross3Vec4(u, v) {\n        const u0 = u[0];\n        const u1 = u[1];\n        const u2 = u[2];\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        return [\n            u1 * v2 - u2 * v1,\n            u2 * v0 - u0 * v2,\n            u0 * v1 - u1 * v0,\n            0.0];\n    },\n\n    /**\n     * Returns the cross product of two three-element vectors.\n     * @method cross3Vec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The cross product\n     */\n    cross3Vec3(u, v, dest) {\n        if (!dest) {\n            dest = u;\n        }\n        const x = u[0];\n        const y = u[1];\n        const z = u[2];\n        const x2 = v[0];\n        const y2 = v[1];\n        const z2 = v[2];\n        dest[0] = y * z2 - z * y2;\n        dest[1] = z * x2 - x * z2;\n        dest[2] = x * y2 - y * x2;\n        return dest;\n    },\n\n\n    sqLenVec4(v) { // TODO\n        return math.dotVec4(v, v);\n    },\n\n    /**\n     * Returns the length of a four-element vector.\n     * @method lenVec4\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec4(v) {\n        return Math.sqrt(math.sqLenVec4(v));\n    },\n\n    /**\n     * Returns the dot product of two three-element vectors.\n     * @method dotVec3\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec3(u, v) {\n        return (u[0] * v[0] + u[1] * v[1] + u[2] * v[2]);\n    },\n\n    /**\n     * Returns the dot product of two two-element vectors.\n     * @method dotVec4\n     * @static\n     * @param {Array(Number)} u First vector\n     * @param {Array(Number)} v Second vector\n     * @return The dot product\n     */\n    dotVec2(u, v) {\n        return (u[0] * v[0] + u[1] * v[1]);\n    },\n\n\n    sqLenVec3(v) {\n        return math.dotVec3(v, v);\n    },\n\n\n    sqLenVec2(v) {\n        return math.dotVec2(v, v);\n    },\n\n    /**\n     * Returns the length of a three-element vector.\n     * @method lenVec3\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec3(v) {\n        return Math.sqrt(math.sqLenVec3(v));\n    },\n\n    distVec3: ((() => {\n        const vec = new FloatArrayType(3);\n        return (v, w) => math.lenVec3(math.subVec3(v, w, vec));\n    }))(),\n\n    /**\n     * Returns the length of a two-element vector.\n     * @method lenVec2\n     * @static\n     * @param {Array(Number)} v The vector\n     * @return The length\n     */\n    lenVec2(v) {\n        return Math.sqrt(math.sqLenVec2(v));\n    },\n\n    distVec2: ((() => {\n        const vec = new FloatArrayType(2);\n        return (v, w) => math.lenVec2(math.subVec2(v, w, vec));\n    }))(),\n\n    /**\n     * @method rcpVec3\n     * @static\n     * @param v vec3\n     * @param dest vec3 - optional destination\n     * @return [] dest if specified, v otherwise\n     *\n     */\n    rcpVec3(v, dest) {\n        return math.divScalarVec3(1.0, v, dest);\n    },\n\n    /**\n     * Normalizes a four-element vector\n     * @method normalizeVec4\n     * @static\n     * @param v vec4\n     * @param dest vec4 - optional destination\n     * @return [] dest if specified, v otherwise\n     *\n     */\n    normalizeVec4(v, dest) {\n        const f = 1.0 / math.lenVec4(v);\n        return math.mulVec4Scalar(v, f, dest);\n    },\n\n    /**\n     * Normalizes a three-element vector\n     * @method normalizeVec4\n     * @static\n     */\n    normalizeVec3(v, dest) {\n        const f = 1.0 / math.lenVec3(v);\n        return math.mulVec3Scalar(v, f, dest);\n    },\n\n    /**\n     * Normalizes a two-element vector\n     * @method normalizeVec2\n     * @static\n     */\n    normalizeVec2(v, dest) {\n        const f = 1.0 / math.lenVec2(v);\n        return math.mulVec2Scalar(v, f, dest);\n    },\n\n    /**\n     * Gets the angle between two vectors\n     * @method angleVec3\n     * @param v\n     * @param w\n     * @returns {number}\n     */\n    angleVec3(v, w) {\n        let theta = math.dotVec3(v, w) / (Math.sqrt(math.sqLenVec3(v) * math.sqLenVec3(w)));\n        theta = theta < -1 ? -1 : (theta > 1 ? 1 : theta);  // Clamp to handle numerical problems\n        return Math.acos(theta);\n    },\n\n    /**\n     * Creates a three-element vector from the rotation part of a sixteen-element matrix.\n     * @param m\n     * @param dest\n     */\n    vec3FromMat4Scale: ((() => {\n\n        const tempVec3 = new FloatArrayType(3);\n\n        return (m, dest) => {\n\n            tempVec3[0] = m[0];\n            tempVec3[1] = m[1];\n            tempVec3[2] = m[2];\n\n            dest[0] = math.lenVec3(tempVec3);\n\n            tempVec3[0] = m[4];\n            tempVec3[1] = m[5];\n            tempVec3[2] = m[6];\n\n            dest[1] = math.lenVec3(tempVec3);\n\n            tempVec3[0] = m[8];\n            tempVec3[1] = m[9];\n            tempVec3[2] = m[10];\n\n            dest[2] = math.lenVec3(tempVec3);\n\n            return dest;\n        };\n    }))(),\n\n    /**\n     * Converts an n-element vector to a JSON-serializable\n     * array with values rounded to two decimal places.\n     */\n    vecToArray: ((() => {\n        function trunc(v) {\n            return Math.round(v * 100000) / 100000\n        }\n\n        return v => {\n            v = Array.prototype.slice.call(v);\n            for (let i = 0, len = v.length; i < len; i++) {\n                v[i] = trunc(v[i]);\n            }\n            return v;\n        };\n    }))(),\n\n    /**\n     * Converts a 3-element vector from an array to an object of the form ````{x:999, y:999, z:999}````.\n     * @param arr\n     * @returns {{x: *, y: *, z: *}}\n     */\n    xyzArrayToObject(arr) {\n        return {\"x\": arr[0], \"y\": arr[1], \"z\": arr[2]};\n    },\n\n    /**\n     * Converts a 3-element vector object of the form ````{x:999, y:999, z:999}```` to an array.\n     * @param xyz\n     * @param  [arry]\n     * @returns {*[]}\n     */\n    xyzObjectToArray(xyz, arry) {\n        arry = arry || new FloatArrayType(3);\n        arry[0] = xyz.x;\n        arry[1] = xyz.y;\n        arry[2] = xyz.z;\n        return arry;\n    },\n\n    /**\n     * Duplicates a 4x4 identity matrix.\n     * @method dupMat4\n     * @static\n     */\n    dupMat4(m) {\n        return m.slice(0, 16);\n    },\n\n    /**\n     * Extracts a 3x3 matrix from a 4x4 matrix.\n     * @method mat4To3\n     * @static\n     */\n    mat4To3(m) {\n        return [\n            m[0], m[1], m[2],\n            m[4], m[5], m[6],\n            m[8], m[9], m[10]\n        ];\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to the given scalar value.\n     * @method m4s\n     * @static\n     */\n    m4s(s) {\n        return [\n            s, s, s, s,\n            s, s, s, s,\n            s, s, s, s,\n            s, s, s, s\n        ];\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to zero.\n     * @method setMat4ToZeroes\n     * @static\n     */\n    setMat4ToZeroes() {\n        return math.m4s(0.0);\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to 1.0.\n     * @method setMat4ToOnes\n     * @static\n     */\n    setMat4ToOnes() {\n        return math.m4s(1.0);\n    },\n\n    /**\n     * Returns a 4x4 matrix with each element set to 1.0.\n     * @method setMat4ToOnes\n     * @static\n     */\n    diagonalMat4v(v) {\n        return new FloatArrayType([\n            v[0], 0.0, 0.0, 0.0,\n            0.0, v[1], 0.0, 0.0,\n            0.0, 0.0, v[2], 0.0,\n            0.0, 0.0, 0.0, v[3]\n        ]);\n    },\n\n    /**\n     * Returns a 4x4 matrix with diagonal elements set to the given vector.\n     * @method diagonalMat4c\n     * @static\n     */\n    diagonalMat4c(x, y, z, w) {\n        return math.diagonalMat4v([x, y, z, w]);\n    },\n\n    /**\n     * Returns a 4x4 matrix with diagonal elements set to the given scalar.\n     * @method diagonalMat4s\n     * @static\n     */\n    diagonalMat4s(s) {\n        return math.diagonalMat4c(s, s, s, s);\n    },\n\n    /**\n     * Returns a 4x4 identity matrix.\n     * @method identityMat4\n     * @static\n     */\n    identityMat4(mat = new FloatArrayType(16)) {\n        mat[0] = 1.0;\n        mat[1] = 0.0;\n        mat[2] = 0.0;\n        mat[3] = 0.0;\n\n        mat[4] = 0.0;\n        mat[5] = 1.0;\n        mat[6] = 0.0;\n        mat[7] = 0.0;\n\n        mat[8] = 0.0;\n        mat[9] = 0.0;\n        mat[10] = 1.0;\n        mat[11] = 0.0;\n\n        mat[12] = 0.0;\n        mat[13] = 0.0;\n        mat[14] = 0.0;\n        mat[15] = 1.0;\n\n        return mat;\n    },\n\n    /**\n     * Returns a 3x3 identity matrix.\n     * @method identityMat3\n     * @static\n     */\n    identityMat3(mat = new FloatArrayType(9)) {\n        mat[0] = 1.0;\n        mat[1] = 0.0;\n        mat[2] = 0.0;\n\n        mat[3] = 0.0;\n        mat[4] = 1.0;\n        mat[5] = 0.0;\n\n        mat[6] = 0.0;\n        mat[7] = 0.0;\n        mat[8] = 1.0;\n\n        return mat;\n    },\n\n    /**\n     * Tests if the given 4x4 matrix is the identity matrix.\n     * @method isIdentityMat4\n     * @static\n     */\n    isIdentityMat4(m) {\n        if (m[0] !== 1.0 || m[1] !== 0.0 || m[2] !== 0.0 || m[3] !== 0.0 ||\n            m[4] !== 0.0 || m[5] !== 1.0 || m[6] !== 0.0 || m[7] !== 0.0 ||\n            m[8] !== 0.0 || m[9] !== 0.0 || m[10] !== 1.0 || m[11] !== 0.0 ||\n            m[12] !== 0.0 || m[13] !== 0.0 || m[14] !== 0.0 || m[15] !== 1.0) {\n            return false;\n        }\n        return true;\n    },\n\n    /**\n     * Negates the given 4x4 matrix.\n     * @method negateMat4\n     * @static\n     */\n    negateMat4(m, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = -m[0];\n        dest[1] = -m[1];\n        dest[2] = -m[2];\n        dest[3] = -m[3];\n        dest[4] = -m[4];\n        dest[5] = -m[5];\n        dest[6] = -m[6];\n        dest[7] = -m[7];\n        dest[8] = -m[8];\n        dest[9] = -m[9];\n        dest[10] = -m[10];\n        dest[11] = -m[11];\n        dest[12] = -m[12];\n        dest[13] = -m[13];\n        dest[14] = -m[14];\n        dest[15] = -m[15];\n        return dest;\n    },\n\n    /**\n     * Adds the given 4x4 matrices together.\n     * @method addMat4\n     * @static\n     */\n    addMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n        dest[0] = a[0] + b[0];\n        dest[1] = a[1] + b[1];\n        dest[2] = a[2] + b[2];\n        dest[3] = a[3] + b[3];\n        dest[4] = a[4] + b[4];\n        dest[5] = a[5] + b[5];\n        dest[6] = a[6] + b[6];\n        dest[7] = a[7] + b[7];\n        dest[8] = a[8] + b[8];\n        dest[9] = a[9] + b[9];\n        dest[10] = a[10] + b[10];\n        dest[11] = a[11] + b[11];\n        dest[12] = a[12] + b[12];\n        dest[13] = a[13] + b[13];\n        dest[14] = a[14] + b[14];\n        dest[15] = a[15] + b[15];\n        return dest;\n    },\n\n    /**\n     * Adds the given scalar to each element of the given 4x4 matrix.\n     * @method addMat4Scalar\n     * @static\n     */\n    addMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] + s;\n        dest[1] = m[1] + s;\n        dest[2] = m[2] + s;\n        dest[3] = m[3] + s;\n        dest[4] = m[4] + s;\n        dest[5] = m[5] + s;\n        dest[6] = m[6] + s;\n        dest[7] = m[7] + s;\n        dest[8] = m[8] + s;\n        dest[9] = m[9] + s;\n        dest[10] = m[10] + s;\n        dest[11] = m[11] + s;\n        dest[12] = m[12] + s;\n        dest[13] = m[13] + s;\n        dest[14] = m[14] + s;\n        dest[15] = m[15] + s;\n        return dest;\n    },\n\n    /**\n     * Adds the given scalar to each element of the given 4x4 matrix.\n     * @method addScalarMat4\n     * @static\n     */\n    addScalarMat4(s, m, dest) {\n        return math.addMat4Scalar(m, s, dest);\n    },\n\n    /**\n     * Subtracts the second 4x4 matrix from the first.\n     * @method subMat4\n     * @static\n     */\n    subMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n        dest[0] = a[0] - b[0];\n        dest[1] = a[1] - b[1];\n        dest[2] = a[2] - b[2];\n        dest[3] = a[3] - b[3];\n        dest[4] = a[4] - b[4];\n        dest[5] = a[5] - b[5];\n        dest[6] = a[6] - b[6];\n        dest[7] = a[7] - b[7];\n        dest[8] = a[8] - b[8];\n        dest[9] = a[9] - b[9];\n        dest[10] = a[10] - b[10];\n        dest[11] = a[11] - b[11];\n        dest[12] = a[12] - b[12];\n        dest[13] = a[13] - b[13];\n        dest[14] = a[14] - b[14];\n        dest[15] = a[15] - b[15];\n        return dest;\n    },\n\n    /**\n     * Subtracts the given scalar from each element of the given 4x4 matrix.\n     * @method subMat4Scalar\n     * @static\n     */\n    subMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] - s;\n        dest[1] = m[1] - s;\n        dest[2] = m[2] - s;\n        dest[3] = m[3] - s;\n        dest[4] = m[4] - s;\n        dest[5] = m[5] - s;\n        dest[6] = m[6] - s;\n        dest[7] = m[7] - s;\n        dest[8] = m[8] - s;\n        dest[9] = m[9] - s;\n        dest[10] = m[10] - s;\n        dest[11] = m[11] - s;\n        dest[12] = m[12] - s;\n        dest[13] = m[13] - s;\n        dest[14] = m[14] - s;\n        dest[15] = m[15] - s;\n        return dest;\n    },\n\n    /**\n     * Subtracts the given scalar from each element of the given 4x4 matrix.\n     * @method subScalarMat4\n     * @static\n     */\n    subScalarMat4(s, m, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = s - m[0];\n        dest[1] = s - m[1];\n        dest[2] = s - m[2];\n        dest[3] = s - m[3];\n        dest[4] = s - m[4];\n        dest[5] = s - m[5];\n        dest[6] = s - m[6];\n        dest[7] = s - m[7];\n        dest[8] = s - m[8];\n        dest[9] = s - m[9];\n        dest[10] = s - m[10];\n        dest[11] = s - m[11];\n        dest[12] = s - m[12];\n        dest[13] = s - m[13];\n        dest[14] = s - m[14];\n        dest[15] = s - m[15];\n        return dest;\n    },\n\n    /**\n     * Multiplies the two given 4x4 matrix by each other.\n     * @method mulMat4\n     * @static\n     */\n    mulMat4(a, b, dest) {\n        if (!dest) {\n            dest = a;\n        }\n\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = a[0];\n\n        const a01 = a[1];\n        const a02 = a[2];\n        const a03 = a[3];\n        const a10 = a[4];\n        const a11 = a[5];\n        const a12 = a[6];\n        const a13 = a[7];\n        const a20 = a[8];\n        const a21 = a[9];\n        const a22 = a[10];\n        const a23 = a[11];\n        const a30 = a[12];\n        const a31 = a[13];\n        const a32 = a[14];\n        const a33 = a[15];\n        const b00 = b[0];\n        const b01 = b[1];\n        const b02 = b[2];\n        const b03 = b[3];\n        const b10 = b[4];\n        const b11 = b[5];\n        const b12 = b[6];\n        const b13 = b[7];\n        const b20 = b[8];\n        const b21 = b[9];\n        const b22 = b[10];\n        const b23 = b[11];\n        const b30 = b[12];\n        const b31 = b[13];\n        const b32 = b[14];\n        const b33 = b[15];\n\n        dest[0] = b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30;\n        dest[1] = b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31;\n        dest[2] = b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32;\n        dest[3] = b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33;\n        dest[4] = b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30;\n        dest[5] = b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31;\n        dest[6] = b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32;\n        dest[7] = b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33;\n        dest[8] = b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30;\n        dest[9] = b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31;\n        dest[10] = b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32;\n        dest[11] = b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33;\n        dest[12] = b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30;\n        dest[13] = b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31;\n        dest[14] = b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32;\n        dest[15] = b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33;\n\n        return dest;\n    },\n\n    /**\n     * Multiplies the two given 3x3 matrices by each other.\n     * @method mulMat4\n     * @static\n     */\n    mulMat3(a, b, dest) {\n        if (!dest) {\n            dest = new FloatArrayType(9);\n        }\n\n        const a11 = a[0];\n        const a12 = a[3];\n        const a13 = a[6];\n        const a21 = a[1];\n        const a22 = a[4];\n        const a23 = a[7];\n        const a31 = a[2];\n        const a32 = a[5];\n        const a33 = a[8];\n        const b11 = b[0];\n        const b12 = b[3];\n        const b13 = b[6];\n        const b21 = b[1];\n        const b22 = b[4];\n        const b23 = b[7];\n        const b31 = b[2];\n        const b32 = b[5];\n        const b33 = b[8];\n\n        dest[0] = a11 * b11 + a12 * b21 + a13 * b31;\n        dest[3] = a11 * b12 + a12 * b22 + a13 * b32;\n        dest[6] = a11 * b13 + a12 * b23 + a13 * b33;\n\n        dest[1] = a21 * b11 + a22 * b21 + a23 * b31;\n        dest[4] = a21 * b12 + a22 * b22 + a23 * b32;\n        dest[7] = a21 * b13 + a22 * b23 + a23 * b33;\n\n        dest[2] = a31 * b11 + a32 * b21 + a33 * b31;\n        dest[5] = a31 * b12 + a32 * b22 + a33 * b32;\n        dest[8] = a31 * b13 + a32 * b23 + a33 * b33;\n\n        return dest;\n    },\n\n    /**\n     * Multiplies each element of the given 4x4 matrix by the given scalar.\n     * @method mulMat4Scalar\n     * @static\n     */\n    mulMat4Scalar(m, s, dest) {\n        if (!dest) {\n            dest = m;\n        }\n        dest[0] = m[0] * s;\n        dest[1] = m[1] * s;\n        dest[2] = m[2] * s;\n        dest[3] = m[3] * s;\n        dest[4] = m[4] * s;\n        dest[5] = m[5] * s;\n        dest[6] = m[6] * s;\n        dest[7] = m[7] * s;\n        dest[8] = m[8] * s;\n        dest[9] = m[9] * s;\n        dest[10] = m[10] * s;\n        dest[11] = m[11] * s;\n        dest[12] = m[12] * s;\n        dest[13] = m[13] * s;\n        dest[14] = m[14] * s;\n        dest[15] = m[15] * s;\n        return dest;\n    },\n\n    /**\n     * Multiplies the given 4x4 matrix by the given four-element vector.\n     * @method mulMat4v4\n     * @static\n     */\n    mulMat4v4(m, v, dest = math.vec4()) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;\n        dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;\n        dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;\n        dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;\n        return dest;\n    },\n\n    /**\n     * Transposes the given 4x4 matrix.\n     * @method transposeMat4\n     * @static\n     */\n    transposeMat4(mat, dest) {\n        // If we are transposing ourselves we can skip a few steps but have to cache some values\n        const m4 = mat[4];\n\n        const m14 = mat[14];\n        const m8 = mat[8];\n        const m13 = mat[13];\n        const m12 = mat[12];\n        const m9 = mat[9];\n        if (!dest || mat === dest) {\n            const a01 = mat[1];\n            const a02 = mat[2];\n            const a03 = mat[3];\n            const a12 = mat[6];\n            const a13 = mat[7];\n            const a23 = mat[11];\n            mat[1] = m4;\n            mat[2] = m8;\n            mat[3] = m12;\n            mat[4] = a01;\n            mat[6] = m9;\n            mat[7] = m13;\n            mat[8] = a02;\n            mat[9] = a12;\n            mat[11] = m14;\n            mat[12] = a03;\n            mat[13] = a13;\n            mat[14] = a23;\n            return mat;\n        }\n        dest[0] = mat[0];\n        dest[1] = m4;\n        dest[2] = m8;\n        dest[3] = m12;\n        dest[4] = mat[1];\n        dest[5] = mat[5];\n        dest[6] = m9;\n        dest[7] = m13;\n        dest[8] = mat[2];\n        dest[9] = mat[6];\n        dest[10] = mat[10];\n        dest[11] = m14;\n        dest[12] = mat[3];\n        dest[13] = mat[7];\n        dest[14] = mat[11];\n        dest[15] = mat[15];\n        return dest;\n    },\n\n    /**\n     * Transposes the given 3x3 matrix.\n     *\n     * @method transposeMat3\n     * @static\n     */\n    transposeMat3(mat, dest) {\n        if (dest === mat) {\n            const a01 = mat[1];\n            const a02 = mat[2];\n            const a12 = mat[5];\n            dest[1] = mat[3];\n            dest[2] = mat[6];\n            dest[3] = a01;\n            dest[5] = mat[7];\n            dest[6] = a02;\n            dest[7] = a12;\n        } else {\n            dest[0] = mat[0];\n            dest[1] = mat[3];\n            dest[2] = mat[6];\n            dest[3] = mat[1];\n            dest[4] = mat[4];\n            dest[5] = mat[7];\n            dest[6] = mat[2];\n            dest[7] = mat[5];\n            dest[8] = mat[8];\n        }\n        return dest;\n    },\n\n    /**\n     * Returns the determinant of the given 4x4 matrix.\n     * @method determinantMat4\n     * @static\n     */\n    determinantMat4(mat) {\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = mat[0];\n\n        const a01 = mat[1];\n        const a02 = mat[2];\n        const a03 = mat[3];\n        const a10 = mat[4];\n        const a11 = mat[5];\n        const a12 = mat[6];\n        const a13 = mat[7];\n        const a20 = mat[8];\n        const a21 = mat[9];\n        const a22 = mat[10];\n        const a23 = mat[11];\n        const a30 = mat[12];\n        const a31 = mat[13];\n        const a32 = mat[14];\n        const a33 = mat[15];\n        return a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 +\n            a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 +\n            a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 +\n            a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 +\n            a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 +\n            a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33;\n    },\n\n    /**\n     * Returns the inverse of the given 4x4 matrix.\n     * @method inverseMat4\n     * @static\n     */\n    inverseMat4(mat, dest) {\n        if (!dest) {\n            dest = mat;\n        }\n\n        // Cache the matrix values (makes for huge speed increases!)\n        const a00 = mat[0];\n\n        const a01 = mat[1];\n        const a02 = mat[2];\n        const a03 = mat[3];\n        const a10 = mat[4];\n        const a11 = mat[5];\n        const a12 = mat[6];\n        const a13 = mat[7];\n        const a20 = mat[8];\n        const a21 = mat[9];\n        const a22 = mat[10];\n        const a23 = mat[11];\n        const a30 = mat[12];\n        const a31 = mat[13];\n        const a32 = mat[14];\n        const a33 = mat[15];\n        const b00 = a00 * a11 - a01 * a10;\n        const b01 = a00 * a12 - a02 * a10;\n        const b02 = a00 * a13 - a03 * a10;\n        const b03 = a01 * a12 - a02 * a11;\n        const b04 = a01 * a13 - a03 * a11;\n        const b05 = a02 * a13 - a03 * a12;\n        const b06 = a20 * a31 - a21 * a30;\n        const b07 = a20 * a32 - a22 * a30;\n        const b08 = a20 * a33 - a23 * a30;\n        const b09 = a21 * a32 - a22 * a31;\n        const b10 = a21 * a33 - a23 * a31;\n        const b11 = a22 * a33 - a23 * a32;\n\n        // Calculate the determinant (inlined to avoid double-caching)\n        const invDet = 1 / (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);\n\n        dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;\n        dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;\n        dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;\n        dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;\n        dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;\n        dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;\n        dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;\n        dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;\n        dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;\n        dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;\n        dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;\n        dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;\n        dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;\n        dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;\n        dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;\n        dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;\n\n        return dest;\n    },\n\n    /**\n     * Returns the trace of the given 4x4 matrix.\n     * @method traceMat4\n     * @static\n     */\n    traceMat4(m) {\n        return (m[0] + m[5] + m[10] + m[15]);\n    },\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4\n     * @static\n     */\n    translationMat4v(v, dest) {\n        const m = dest || math.identityMat4();\n        m[12] = v[0];\n        m[13] = v[1];\n        m[14] = v[2];\n        return m;\n    },\n\n    /**\n     * Returns 3x3 translation matrix.\n     * @method translationMat3\n     * @static\n     */\n    translationMat3v(v, dest) {\n        const m = dest || math.identityMat3();\n        m[6] = v[0];\n        m[7] = v[1];\n        return m;\n    },\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4c\n     * @static\n     */\n    translationMat4c: ((() => {\n        const xyz = new FloatArrayType(3);\n        return (x, y, z, dest) => {\n            xyz[0] = x;\n            xyz[1] = y;\n            xyz[2] = z;\n            return math.translationMat4v(xyz, dest);\n        };\n    }))(),\n\n    /**\n     * Returns 4x4 translation matrix.\n     * @method translationMat4s\n     * @static\n     */\n    translationMat4s(s, dest) {\n        return math.translationMat4c(s, s, s, dest);\n    },\n\n    /**\n     * Efficiently post-concatenates a translation to the given matrix.\n     * @param v\n     * @param m\n     */\n    translateMat4v(xyz, m) {\n        return math.translateMat4c(xyz[0], xyz[1], xyz[2], m);\n    },\n\n    /**\n     * Efficiently post-concatenates a translation to the given matrix.\n     * @param x\n     * @param y\n     * @param z\n     * @param m\n     */\n    OLDtranslateMat4c(x, y, z, m) {\n\n        const m12 = m[12];\n        m[0] += m12 * x;\n        m[4] += m12 * y;\n        m[8] += m12 * z;\n\n        const m13 = m[13];\n        m[1] += m13 * x;\n        m[5] += m13 * y;\n        m[9] += m13 * z;\n\n        const m14 = m[14];\n        m[2] += m14 * x;\n        m[6] += m14 * y;\n        m[10] += m14 * z;\n\n        const m15 = m[15];\n        m[3] += m15 * x;\n        m[7] += m15 * y;\n        m[11] += m15 * z;\n\n        return m;\n    },\n\n    translateMat4c(x, y, z, m) {\n\n        const m3 = m[3];\n        m[0] += m3 * x;\n        m[1] += m3 * y;\n        m[2] += m3 * z;\n\n        const m7 = m[7];\n        m[4] += m7 * x;\n        m[5] += m7 * y;\n        m[6] += m7 * z;\n\n        const m11 = m[11];\n        m[8] += m11 * x;\n        m[9] += m11 * y;\n        m[10] += m11 * z;\n\n        const m15 = m[15];\n        m[12] += m15 * x;\n        m[13] += m15 * y;\n        m[14] += m15 * z;\n\n        return m;\n    },\n    /**\n     * Returns 4x4 rotation matrix.\n     * @method rotationMat4v\n     * @static\n     */\n    rotationMat4v(anglerad, axis, m) {\n        const ax = math.normalizeVec4([axis[0], axis[1], axis[2], 0.0], []);\n        const s = Math.sin(anglerad);\n        const c = Math.cos(anglerad);\n        const q = 1.0 - c;\n\n        const x = ax[0];\n        const y = ax[1];\n        const z = ax[2];\n\n        let xy;\n        let yz;\n        let zx;\n        let xs;\n        let ys;\n        let zs;\n\n        //xx = x * x; used once\n        //yy = y * y; used once\n        //zz = z * z; used once\n        xy = x * y;\n        yz = y * z;\n        zx = z * x;\n        xs = x * s;\n        ys = y * s;\n        zs = z * s;\n\n        m = m || math.mat4();\n\n        m[0] = (q * x * x) + c;\n        m[1] = (q * xy) + zs;\n        m[2] = (q * zx) - ys;\n        m[3] = 0.0;\n\n        m[4] = (q * xy) - zs;\n        m[5] = (q * y * y) + c;\n        m[6] = (q * yz) + xs;\n        m[7] = 0.0;\n\n        m[8] = (q * zx) + ys;\n        m[9] = (q * yz) - xs;\n        m[10] = (q * z * z) + c;\n        m[11] = 0.0;\n\n        m[12] = 0.0;\n        m[13] = 0.0;\n        m[14] = 0.0;\n        m[15] = 1.0;\n\n        return m;\n    },\n\n    /**\n     * Returns 4x4 rotation matrix.\n     * @method rotationMat4c\n     * @static\n     */\n    rotationMat4c(anglerad, x, y, z, mat) {\n        return math.rotationMat4v(anglerad, [x, y, z], mat);\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4v\n     * @static\n     */\n    scalingMat4v(v, m = math.identityMat4()) {\n        m[0] = v[0];\n        m[5] = v[1];\n        m[10] = v[2];\n        return m;\n    },\n\n    /**\n     * Returns 3x3 scale matrix.\n     * @method scalingMat3v\n     * @static\n     */\n    scalingMat3v(v, m = math.identityMat3()) {\n        m[0] = v[0];\n        m[4] = v[1];\n        return m;\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4c\n     * @static\n     */\n    scalingMat4c: ((() => {\n        const xyz = new FloatArrayType(3);\n        return (x, y, z, dest) => {\n            xyz[0] = x;\n            xyz[1] = y;\n            xyz[2] = z;\n            return math.scalingMat4v(xyz, dest);\n        };\n    }))(),\n\n    /**\n     * Efficiently post-concatenates a scaling to the given matrix.\n     * @method scaleMat4c\n     * @param x\n     * @param y\n     * @param z\n     * @param m\n     */\n    scaleMat4c(x, y, z, m) {\n\n        m[0] *= x;\n        m[4] *= y;\n        m[8] *= z;\n\n        m[1] *= x;\n        m[5] *= y;\n        m[9] *= z;\n\n        m[2] *= x;\n        m[6] *= y;\n        m[10] *= z;\n\n        m[3] *= x;\n        m[7] *= y;\n        m[11] *= z;\n        return m;\n    },\n\n    /**\n     * Efficiently post-concatenates a scaling to the given matrix.\n     * @method scaleMat4c\n     * @param xyz\n     * @param m\n     */\n    scaleMat4v(xyz, m) {\n\n        const x = xyz[0];\n        const y = xyz[1];\n        const z = xyz[2];\n\n        m[0] *= x;\n        m[4] *= y;\n        m[8] *= z;\n        m[1] *= x;\n        m[5] *= y;\n        m[9] *= z;\n        m[2] *= x;\n        m[6] *= y;\n        m[10] *= z;\n        m[3] *= x;\n        m[7] *= y;\n        m[11] *= z;\n\n        return m;\n    },\n\n    /**\n     * Returns 4x4 scale matrix.\n     * @method scalingMat4s\n     * @static\n     */\n    scalingMat4s(s) {\n        return math.scalingMat4c(s, s, s);\n    },\n\n    /**\n     * Creates a matrix from a quaternion rotation and vector translation\n     *\n     * @param {Number[]} q Rotation quaternion\n     * @param {Number[]} v Translation vector\n     * @param {Number[]} dest Destination matrix\n     * @returns {Number[]} dest\n     */\n    rotationTranslationMat4(q, v, dest = math.mat4()) {\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n\n        dest[0] = 1 - (yy + zz);\n        dest[1] = xy + wz;\n        dest[2] = xz - wy;\n        dest[3] = 0;\n        dest[4] = xy - wz;\n        dest[5] = 1 - (xx + zz);\n        dest[6] = yz + wx;\n        dest[7] = 0;\n        dest[8] = xz + wy;\n        dest[9] = yz - wx;\n        dest[10] = 1 - (xx + yy);\n        dest[11] = 0;\n        dest[12] = v[0];\n        dest[13] = v[1];\n        dest[14] = v[2];\n        dest[15] = 1;\n\n        return dest;\n    },\n\n    /**\n     * Gets Euler angles from a 4x4 matrix.\n     *\n     * @param {Number[]} mat The 4x4 matrix.\n     * @param {String} order Desired Euler angle order: \"XYZ\", \"YXZ\", \"ZXY\" etc.\n     * @param {Number[]} [dest] Destination Euler angles, created by default.\n     * @returns {Number[]} The Euler angles.\n     */\n    mat4ToEuler(mat, order, dest = math.vec4()) {\n        const clamp = math.clamp;\n\n        // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n        const m11 = mat[0];\n\n        const m12 = mat[4];\n        const m13 = mat[8];\n        const m21 = mat[1];\n        const m22 = mat[5];\n        const m23 = mat[9];\n        const m31 = mat[2];\n        const m32 = mat[6];\n        const m33 = mat[10];\n\n        if (order === 'XYZ') {\n\n            dest[1] = Math.asin(clamp(m13, -1, 1));\n\n            if (Math.abs(m13) < 0.99999) {\n                dest[0] = Math.atan2(-m23, m33);\n                dest[2] = Math.atan2(-m12, m11);\n            } else {\n                dest[0] = Math.atan2(m32, m22);\n                dest[2] = 0;\n\n            }\n\n        } else if (order === 'YXZ') {\n\n            dest[0] = Math.asin(-clamp(m23, -1, 1));\n\n            if (Math.abs(m23) < 0.99999) {\n                dest[1] = Math.atan2(m13, m33);\n                dest[2] = Math.atan2(m21, m22);\n            } else {\n                dest[1] = Math.atan2(-m31, m11);\n                dest[2] = 0;\n            }\n\n        } else if (order === 'ZXY') {\n\n            dest[0] = Math.asin(clamp(m32, -1, 1));\n\n            if (Math.abs(m32) < 0.99999) {\n                dest[1] = Math.atan2(-m31, m33);\n                dest[2] = Math.atan2(-m12, m22);\n            } else {\n                dest[1] = 0;\n                dest[2] = Math.atan2(m21, m11);\n            }\n\n        } else if (order === 'ZYX') {\n\n            dest[1] = Math.asin(-clamp(m31, -1, 1));\n\n            if (Math.abs(m31) < 0.99999) {\n                dest[0] = Math.atan2(m32, m33);\n                dest[2] = Math.atan2(m21, m11);\n            } else {\n                dest[0] = 0;\n                dest[2] = Math.atan2(-m12, m22);\n            }\n\n        } else if (order === 'YZX') {\n\n            dest[2] = Math.asin(clamp(m21, -1, 1));\n\n            if (Math.abs(m21) < 0.99999) {\n                dest[0] = Math.atan2(-m23, m22);\n                dest[1] = Math.atan2(-m31, m11);\n            } else {\n                dest[0] = 0;\n                dest[1] = Math.atan2(m13, m33);\n            }\n\n        } else if (order === 'XZY') {\n\n            dest[2] = Math.asin(-clamp(m12, -1, 1));\n\n            if (Math.abs(m12) < 0.99999) {\n                dest[0] = Math.atan2(m32, m22);\n                dest[1] = Math.atan2(m13, m11);\n            } else {\n                dest[0] = Math.atan2(-m23, m33);\n                dest[1] = 0;\n            }\n        }\n\n        return dest;\n    },\n\n    composeMat4(position, quaternion, scale, mat = math.mat4()) {\n        math.quaternionToRotationMat4(quaternion, mat);\n        math.scaleMat4v(scale, mat);\n        math.translateMat4v(position, mat);\n\n        return mat;\n    },\n\n    decomposeMat4: (() => {\n\n        const vec = new FloatArrayType(3);\n        const matrix = new FloatArrayType(16);\n\n        return function decompose(mat, position, quaternion, scale) {\n\n            vec[0] = mat[0];\n            vec[1] = mat[1];\n            vec[2] = mat[2];\n\n            let sx = math.lenVec3(vec);\n\n            vec[0] = mat[4];\n            vec[1] = mat[5];\n            vec[2] = mat[6];\n\n            const sy = math.lenVec3(vec);\n\n            vec[8] = mat[8];\n            vec[9] = mat[9];\n            vec[10] = mat[10];\n\n            const sz = math.lenVec3(vec);\n\n            // if determine is negative, we need to invert one scale\n            const det = math.determinantMat4(mat);\n\n            if (det < 0) {\n                sx = -sx;\n            }\n\n            position[0] = mat[12];\n            position[1] = mat[13];\n            position[2] = mat[14];\n\n            // scale the rotation part\n            matrix.set(mat);\n\n            const invSX = 1 / sx;\n            const invSY = 1 / sy;\n            const invSZ = 1 / sz;\n\n            matrix[0] *= invSX;\n            matrix[1] *= invSX;\n            matrix[2] *= invSX;\n\n            matrix[4] *= invSY;\n            matrix[5] *= invSY;\n            matrix[6] *= invSY;\n\n            matrix[8] *= invSZ;\n            matrix[9] *= invSZ;\n            matrix[10] *= invSZ;\n\n            math.mat4ToQuaternion(matrix, quaternion);\n\n            scale[0] = sx;\n            scale[1] = sy;\n            scale[2] = sz;\n\n            return this;\n\n        };\n\n    })(),\n\n    /**\n     * Returns a 4x4 'lookat' viewing transform matrix.\n     * @method lookAtMat4v\n     * @param pos vec3 position of the viewer\n     * @param target vec3 point the viewer is looking at\n     * @param up vec3 pointing \"up\"\n     * @param dest mat4 Optional, mat4 matrix will be written into\n     *\n     * @return {mat4} dest if specified, a new mat4 otherwise\n     */\n    lookAtMat4v(pos, target, up, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n\n        const posx = pos[0];\n        const posy = pos[1];\n        const posz = pos[2];\n        const upx = up[0];\n        const upy = up[1];\n        const upz = up[2];\n        const targetx = target[0];\n        const targety = target[1];\n        const targetz = target[2];\n\n        if (posx === targetx && posy === targety && posz === targetz) {\n            return math.identityMat4();\n        }\n\n        let z0;\n        let z1;\n        let z2;\n        let x0;\n        let x1;\n        let x2;\n        let y0;\n        let y1;\n        let y2;\n        let len;\n\n        //vec3.direction(eye, center, z);\n        z0 = posx - targetx;\n        z1 = posy - targety;\n        z2 = posz - targetz;\n\n        // normalize (no check needed for 0 because of early return)\n        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);\n        z0 *= len;\n        z1 *= len;\n        z2 *= len;\n\n        //vec3.normalize(vec3.cross(up, z, x));\n        x0 = upy * z2 - upz * z1;\n        x1 = upz * z0 - upx * z2;\n        x2 = upx * z1 - upy * z0;\n        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);\n        if (!len) {\n            x0 = 0;\n            x1 = 0;\n            x2 = 0;\n        } else {\n            len = 1 / len;\n            x0 *= len;\n            x1 *= len;\n            x2 *= len;\n        }\n\n        //vec3.normalize(vec3.cross(z, x, y));\n        y0 = z1 * x2 - z2 * x1;\n        y1 = z2 * x0 - z0 * x2;\n        y2 = z0 * x1 - z1 * x0;\n\n        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);\n        if (!len) {\n            y0 = 0;\n            y1 = 0;\n            y2 = 0;\n        } else {\n            len = 1 / len;\n            y0 *= len;\n            y1 *= len;\n            y2 *= len;\n        }\n\n        dest[0] = x0;\n        dest[1] = y0;\n        dest[2] = z0;\n        dest[3] = 0;\n        dest[4] = x1;\n        dest[5] = y1;\n        dest[6] = z1;\n        dest[7] = 0;\n        dest[8] = x2;\n        dest[9] = y2;\n        dest[10] = z2;\n        dest[11] = 0;\n        dest[12] = -(x0 * posx + x1 * posy + x2 * posz);\n        dest[13] = -(y0 * posx + y1 * posy + y2 * posz);\n        dest[14] = -(z0 * posx + z1 * posy + z2 * posz);\n        dest[15] = 1;\n\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 'lookat' viewing transform matrix.\n     * @method lookAtMat4c\n     * @static\n     */\n    lookAtMat4c(posx, posy, posz, targetx, targety, targetz, upx, upy, upz) {\n        return math.lookAtMat4v([posx, posy, posz], [targetx, targety, targetz], [upx, upy, upz], []);\n    },\n\n    /**\n     * Returns a 4x4 orthographic projection matrix.\n     * @method orthoMat4c\n     * @static\n     */\n    orthoMat4c(left, right, bottom, top, near, far, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n        const rl = (right - left);\n        const tb = (top - bottom);\n        const fn = (far - near);\n\n        dest[0] = 2.0 / rl;\n        dest[1] = 0.0;\n        dest[2] = 0.0;\n        dest[3] = 0.0;\n\n        dest[4] = 0.0;\n        dest[5] = 2.0 / tb;\n        dest[6] = 0.0;\n        dest[7] = 0.0;\n\n        dest[8] = 0.0;\n        dest[9] = 0.0;\n        dest[10] = -2.0 / fn;\n        dest[11] = 0.0;\n\n        dest[12] = -(left + right) / rl;\n        dest[13] = -(top + bottom) / tb;\n        dest[14] = -(far + near) / fn;\n        dest[15] = 1.0;\n\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method frustumMat4v\n     * @static\n     */\n    frustumMat4v(fmin, fmax, m) {\n        if (!m) {\n            m = math.mat4();\n        }\n\n        const fmin4 = [fmin[0], fmin[1], fmin[2], 0.0];\n        const fmax4 = [fmax[0], fmax[1], fmax[2], 0.0];\n\n        math.addVec4(fmax4, fmin4, tempMat1);\n        math.subVec4(fmax4, fmin4, tempMat2);\n\n        const t = 2.0 * fmin4[2];\n\n        const tempMat20 = tempMat2[0];\n        const tempMat21 = tempMat2[1];\n        const tempMat22 = tempMat2[2];\n\n        m[0] = t / tempMat20;\n        m[1] = 0.0;\n        m[2] = 0.0;\n        m[3] = 0.0;\n\n        m[4] = 0.0;\n        m[5] = t / tempMat21;\n        m[6] = 0.0;\n        m[7] = 0.0;\n\n        m[8] = tempMat1[0] / tempMat20;\n        m[9] = tempMat1[1] / tempMat21;\n        m[10] = -tempMat1[2] / tempMat22;\n        m[11] = -1.0;\n\n        m[12] = 0.0;\n        m[13] = 0.0;\n        m[14] = -t * fmax4[2] / tempMat22;\n        m[15] = 0.0;\n\n        return m;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method frustumMat4v\n     * @static\n     */\n    frustumMat4(left, right, bottom, top, near, far, dest) {\n        if (!dest) {\n            dest = math.mat4();\n        }\n        const rl = (right - left);\n        const tb = (top - bottom);\n        const fn = (far - near);\n        dest[0] = (near * 2) / rl;\n        dest[1] = 0;\n        dest[2] = 0;\n        dest[3] = 0;\n        dest[4] = 0;\n        dest[5] = (near * 2) / tb;\n        dest[6] = 0;\n        dest[7] = 0;\n        dest[8] = (right + left) / rl;\n        dest[9] = (top + bottom) / tb;\n        dest[10] = -(far + near) / fn;\n        dest[11] = -1;\n        dest[12] = 0;\n        dest[13] = 0;\n        dest[14] = -(far * near * 2) / fn;\n        dest[15] = 0;\n        return dest;\n    },\n\n    /**\n     * Returns a 4x4 perspective projection matrix.\n     * @method perspectiveMat4v\n     * @static\n     */\n    perspectiveMat4(fovyrad, aspectratio, znear, zfar, m) {\n        const pmin = [];\n        const pmax = [];\n\n        pmin[2] = znear;\n        pmax[2] = zfar;\n\n        pmax[1] = pmin[2] * Math.tan(fovyrad / 2.0);\n        pmin[1] = -pmax[1];\n\n        pmax[0] = pmax[1] * aspectratio;\n        pmin[0] = -pmax[0];\n\n        return math.frustumMat4v(pmin, pmax, m);\n    },\n\n    /**\n     * Transforms a three-element position by a 4x4 matrix.\n     * @method transformPoint3\n     * @static\n     */\n    transformPoint3(m, p, dest = math.vec3()) {\n\n        const x = p[0];\n        const y = p[1];\n        const z = p[2];\n\n        dest[0] = (m[0] * x) + (m[4] * y) + (m[8] * z) + m[12];\n        dest[1] = (m[1] * x) + (m[5] * y) + (m[9] * z) + m[13];\n        dest[2] = (m[2] * x) + (m[6] * y) + (m[10] * z) + m[14];\n\n        return dest;\n    },\n\n    /**\n     * Transforms a homogeneous coordinate by a 4x4 matrix.\n     * @method transformPoint3\n     * @static\n     */\n    transformPoint4(m, v, dest = math.vec4()) {\n        dest[0] = m[0] * v[0] + m[4] * v[1] + m[8] * v[2] + m[12] * v[3];\n        dest[1] = m[1] * v[0] + m[5] * v[1] + m[9] * v[2] + m[13] * v[3];\n        dest[2] = m[2] * v[0] + m[6] * v[1] + m[10] * v[2] + m[14] * v[3];\n        dest[3] = m[3] * v[0] + m[7] * v[1] + m[11] * v[2] + m[15] * v[3];\n\n        return dest;\n    },\n\n\n    /**\n     * Transforms an array of three-element positions by a 4x4 matrix.\n     * @method transformPoints3\n     * @static\n     */\n    transformPoints3(m, points, points2) {\n        const result = points2 || [];\n        const len = points.length;\n        let p0;\n        let p1;\n        let p2;\n        let pi;\n\n        // cache values\n        const m0 = m[0];\n\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        let r;\n\n        for (let i = 0; i < len; ++i) {\n\n            // cache values\n            pi = points[i];\n\n            p0 = pi[0];\n            p1 = pi[1];\n            p2 = pi[2];\n\n            r = result[i] || (result[i] = [0, 0, 0]);\n\n            r[0] = (m0 * p0) + (m4 * p1) + (m8 * p2) + m12;\n            r[1] = (m1 * p0) + (m5 * p1) + (m9 * p2) + m13;\n            r[2] = (m2 * p0) + (m6 * p1) + (m10 * p2) + m14;\n            r[3] = (m3 * p0) + (m7 * p1) + (m11 * p2) + m15;\n        }\n\n        result.length = len;\n\n        return result;\n    },\n\n    /**\n     * Transforms an array of positions by a 4x4 matrix.\n     * @method transformPositions3\n     * @static\n     */\n    transformPositions3(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 3) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /**\n     * Transforms an array of positions by a 4x4 matrix.\n     * @method transformPositions4\n     * @static\n     */\n    transformPositions4(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 4) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /**\n     * Transforms a three-element vector by a 4x4 matrix.\n     * @method transformVec3\n     * @static\n     */\n    transformVec3(m, v, dest) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        dest = dest || this.vec3();\n        dest[0] = (m[0] * v0) + (m[4] * v1) + (m[8] * v2);\n        dest[1] = (m[1] * v0) + (m[5] * v1) + (m[9] * v2);\n        dest[2] = (m[2] * v0) + (m[6] * v1) + (m[10] * v2);\n        return dest;\n    },\n\n    /**\n     * Transforms a four-element vector by a 4x4 matrix.\n     * @method transformVec4\n     * @static\n     */\n    transformVec4(m, v, dest) {\n        const v0 = v[0];\n        const v1 = v[1];\n        const v2 = v[2];\n        const v3 = v[3];\n        dest = dest || math.vec4();\n        dest[0] = m[0] * v0 + m[4] * v1 + m[8] * v2 + m[12] * v3;\n        dest[1] = m[1] * v0 + m[5] * v1 + m[9] * v2 + m[13] * v3;\n        dest[2] = m[2] * v0 + m[6] * v1 + m[10] * v2 + m[14] * v3;\n        dest[3] = m[3] * v0 + m[7] * v1 + m[11] * v2 + m[15] * v3;\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the x-axis\n     *\n     * @method rotateVec3X\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3X(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[0];\n        r[1] = p[1] * Math.cos(c) - p[2] * Math.sin(c);\n        r[2] = p[1] * Math.sin(c) + p[2] * Math.cos(c);\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the y-axis\n     *\n     * @method rotateVec3Y\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3Y(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[2] * Math.sin(c) + p[0] * Math.cos(c);\n        r[1] = p[1];\n        r[2] = p[2] * Math.cos(c) - p[0] * Math.sin(c);\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Rotate a 3D vector around the z-axis\n     *\n     * @method rotateVec3Z\n     * @param {Number[]} a The vec3 point to rotate\n     * @param {Number[]} b The origin of the rotation\n     * @param {Number} c The angle of rotation\n     * @param {Number[]} dest The receiving vec3\n     * @returns {Number[]} dest\n     * @static\n     */\n    rotateVec3Z(a, b, c, dest) {\n        const p = [];\n        const r = [];\n\n        //Translate point to the origin\n        p[0] = a[0] - b[0];\n        p[1] = a[1] - b[1];\n        p[2] = a[2] - b[2];\n\n        //perform rotation\n        r[0] = p[0] * Math.cos(c) - p[1] * Math.sin(c);\n        r[1] = p[0] * Math.sin(c) + p[1] * Math.cos(c);\n        r[2] = p[2];\n\n        //translate to correct position\n        dest[0] = r[0] + b[0];\n        dest[1] = r[1] + b[1];\n        dest[2] = r[2] + b[2];\n\n        return dest;\n    },\n\n    /**\n     * Transforms a four-element vector by a 4x4 projection matrix.\n     *\n     * @method projectVec4\n     * @param {Number[]} p 3D View-space coordinate\n     * @param {Number[]} q 2D Projected coordinate\n     * @returns {Number[]} 2D Projected coordinate\n     * @static\n     */\n    projectVec4(p, q) {\n        const f = 1.0 / p[3];\n        q = q || math.vec2();\n        q[0] = v[0] * f;\n        q[1] = v[1] * f;\n        return q;\n    },\n\n    /**\n     * Unprojects a three-element vector.\n     *\n     * @method unprojectVec3\n     * @param {Number[]} p 3D Projected coordinate\n     * @param {Number[]} viewMat View matrix\n     * @returns {Number[]} projMat Projection matrix\n     * @static\n     */\n    unprojectVec3: ((() => {\n        const mat = new FloatArrayType(16);\n        const mat2 = new FloatArrayType(16);\n        const mat3 = new FloatArrayType(16);\n        return function (p, viewMat, projMat, q) {\n            return this.transformVec3(this.mulMat4(this.inverseMat4(viewMat, mat), this.inverseMat4(projMat, mat2), mat3), p, q)\n        };\n    }))(),\n\n    /**\n     * Linearly interpolates between two 3D vectors.\n     * @method lerpVec3\n     * @static\n     */\n    lerpVec3(t, t1, t2, p1, p2, dest) {\n        const result = dest || math.vec3();\n        const f = (t - t1) / (t2 - t1);\n        result[0] = p1[0] + (f * (p2[0] - p1[0]));\n        result[1] = p1[1] + (f * (p2[1] - p1[1]));\n        result[2] = p1[2] + (f * (p2[2] - p1[2]));\n        return result;\n    },\n\n\n    /**\n     * Flattens a two-dimensional array into a one-dimensional array.\n     *\n     * @method flatten\n     * @static\n     * @param {Array of Arrays} a A 2D array\n     * @returns Flattened 1D array\n     */\n    flatten(a) {\n\n        const result = [];\n\n        let i;\n        let leni;\n        let j;\n        let lenj;\n        let item;\n\n        for (i = 0, leni = a.length; i < leni; i++) {\n            item = a[i];\n            for (j = 0, lenj = item.length; j < lenj; j++) {\n                result.push(item[j]);\n            }\n        }\n\n        return result;\n    },\n\n\n    identityQuaternion(dest = math.vec4()) {\n        dest[0] = 0.0;\n        dest[1] = 0.0;\n        dest[2] = 0.0;\n        dest[3] = 1.0;\n        return dest;\n    },\n\n    /**\n     * Initializes a quaternion from Euler angles.\n     *\n     * @param {Number[]} euler The Euler angles.\n     * @param {String} order Euler angle order: \"XYZ\", \"YXZ\", \"ZXY\" etc.\n     * @param {Number[]} [dest] Destination quaternion, created by default.\n     * @returns {Number[]} The quaternion.\n     */\n    eulerToQuaternion(euler, order, dest = math.vec4()) {\n        // http://www.mathworks.com/matlabcentral/fileexchange/\n        // \t20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/\n        //\tcontent/SpinCalc.m\n\n        const a = (euler[0] * math.DEGTORAD) / 2;\n        const b = (euler[1] * math.DEGTORAD) / 2;\n        const c = (euler[2] * math.DEGTORAD) / 2;\n\n        const c1 = Math.cos(a);\n        const c2 = Math.cos(b);\n        const c3 = Math.cos(c);\n        const s1 = Math.sin(a);\n        const s2 = Math.sin(b);\n        const s3 = Math.sin(c);\n\n        if (order === 'XYZ') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'YXZ') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n\n        } else if (order === 'ZXY') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'ZYX') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n\n        } else if (order === 'YZX') {\n\n            dest[0] = s1 * c2 * c3 + c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 + s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 - s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 - s1 * s2 * s3;\n\n        } else if (order === 'XZY') {\n\n            dest[0] = s1 * c2 * c3 - c1 * s2 * s3;\n            dest[1] = c1 * s2 * c3 - s1 * c2 * s3;\n            dest[2] = c1 * c2 * s3 + s1 * s2 * c3;\n            dest[3] = c1 * c2 * c3 + s1 * s2 * s3;\n        }\n\n        return dest;\n    },\n\n    mat4ToQuaternion(m, dest = math.vec4()) {\n        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm\n\n        // Assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\n\n        const m11 = m[0];\n        const m12 = m[4];\n        const m13 = m[8];\n        const m21 = m[1];\n        const m22 = m[5];\n        const m23 = m[9];\n        const m31 = m[2];\n        const m32 = m[6];\n        const m33 = m[10];\n        let s;\n\n        const trace = m11 + m22 + m33;\n\n        if (trace > 0) {\n\n            s = 0.5 / Math.sqrt(trace + 1.0);\n\n            dest[3] = 0.25 / s;\n            dest[0] = (m32 - m23) * s;\n            dest[1] = (m13 - m31) * s;\n            dest[2] = (m21 - m12) * s;\n\n        } else if (m11 > m22 && m11 > m33) {\n\n            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n\n            dest[3] = (m32 - m23) / s;\n            dest[0] = 0.25 * s;\n            dest[1] = (m12 + m21) / s;\n            dest[2] = (m13 + m31) / s;\n\n        } else if (m22 > m33) {\n\n            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n\n            dest[3] = (m13 - m31) / s;\n            dest[0] = (m12 + m21) / s;\n            dest[1] = 0.25 * s;\n            dest[2] = (m23 + m32) / s;\n\n        } else {\n\n            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n\n            dest[3] = (m21 - m12) / s;\n            dest[0] = (m13 + m31) / s;\n            dest[1] = (m23 + m32) / s;\n            dest[2] = 0.25 * s;\n        }\n\n        return dest;\n    },\n\n    vec3PairToQuaternion(u, v, dest = math.vec4()) {\n        const norm_u_norm_v = Math.sqrt(math.dotVec3(u, u) * math.dotVec3(v, v));\n        let real_part = norm_u_norm_v + math.dotVec3(u, v);\n\n        if (real_part < 0.00000001 * norm_u_norm_v) {\n\n            // If u and v are exactly opposite, rotate 180 degrees\n            // around an arbitrary orthogonal axis. Axis normalisation\n            // can happen later, when we normalise the quaternion.\n\n            real_part = 0.0;\n\n            if (Math.abs(u[0]) > Math.abs(u[2])) {\n\n                dest[0] = -u[1];\n                dest[1] = u[0];\n                dest[2] = 0;\n\n            } else {\n                dest[0] = 0;\n                dest[1] = -u[2];\n                dest[2] = u[1]\n            }\n\n        } else {\n\n            // Otherwise, build quaternion the standard way.\n            math.cross3Vec3(u, v, dest);\n        }\n\n        dest[3] = real_part;\n\n        return math.normalizeQuaternion(dest);\n    },\n\n    angleAxisToQuaternion(angleAxis, dest = math.vec4()) {\n        const halfAngle = angleAxis[3] / 2.0;\n        const fsin = Math.sin(halfAngle);\n        dest[0] = fsin * angleAxis[0];\n        dest[1] = fsin * angleAxis[1];\n        dest[2] = fsin * angleAxis[2];\n        dest[3] = Math.cos(halfAngle);\n        return dest;\n    },\n\n    quaternionToEuler: ((() => {\n        const mat = new FloatArrayType(16);\n        return (q, order, dest) => {\n            dest = dest || math.vec3();\n            math.quaternionToRotationMat4(q, mat);\n            math.mat4ToEuler(mat, order, dest);\n            return dest;\n        };\n    }))(),\n\n    mulQuaternions(p, q, dest = math.vec4()) {\n        const p0 = p[0];\n        const p1 = p[1];\n        const p2 = p[2];\n        const p3 = p[3];\n        const q0 = q[0];\n        const q1 = q[1];\n        const q2 = q[2];\n        const q3 = q[3];\n        dest[0] = p3 * q0 + p0 * q3 + p1 * q2 - p2 * q1;\n        dest[1] = p3 * q1 + p1 * q3 + p2 * q0 - p0 * q2;\n        dest[2] = p3 * q2 + p2 * q3 + p0 * q1 - p1 * q0;\n        dest[3] = p3 * q3 - p0 * q0 - p1 * q1 - p2 * q2;\n        return dest;\n    },\n\n    vec3ApplyQuaternion(q, vec, dest = math.vec3()) {\n        const x = vec[0];\n        const y = vec[1];\n        const z = vec[2];\n\n        const qx = q[0];\n        const qy = q[1];\n        const qz = q[2];\n        const qw = q[3];\n\n        // calculate quat * vector\n\n        const ix = qw * x + qy * z - qz * y;\n        const iy = qw * y + qz * x - qx * z;\n        const iz = qw * z + qx * y - qy * x;\n        const iw = -qx * x - qy * y - qz * z;\n\n        // calculate result * inverse quat\n\n        dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n        dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n        dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n\n        return dest;\n    },\n\n    quaternionToMat4(q, dest) {\n\n        dest = math.identityMat4(dest);\n\n        const q0 = q[0];  //x\n        const q1 = q[1];  //y\n        const q2 = q[2];  //z\n        const q3 = q[3];  //w\n\n        const tx = 2.0 * q0;\n        const ty = 2.0 * q1;\n        const tz = 2.0 * q2;\n\n        const twx = tx * q3;\n        const twy = ty * q3;\n        const twz = tz * q3;\n\n        const txx = tx * q0;\n        const txy = ty * q0;\n        const txz = tz * q0;\n\n        const tyy = ty * q1;\n        const tyz = tz * q1;\n        const tzz = tz * q2;\n\n        dest[0] = 1.0 - (tyy + tzz);\n        dest[1] = txy + twz;\n        dest[2] = txz - twy;\n\n        dest[4] = txy - twz;\n        dest[5] = 1.0 - (txx + tzz);\n        dest[6] = tyz + twx;\n\n        dest[8] = txz + twy;\n        dest[9] = tyz - twx;\n\n        dest[10] = 1.0 - (txx + tyy);\n\n        return dest;\n    },\n\n    quaternionToRotationMat4(q, m) {\n        const x = q[0];\n        const y = q[1];\n        const z = q[2];\n        const w = q[3];\n\n        const x2 = x + x;\n        const y2 = y + y;\n        const z2 = z + z;\n        const xx = x * x2;\n        const xy = x * y2;\n        const xz = x * z2;\n        const yy = y * y2;\n        const yz = y * z2;\n        const zz = z * z2;\n        const wx = w * x2;\n        const wy = w * y2;\n        const wz = w * z2;\n\n        m[0] = 1 - (yy + zz);\n        m[4] = xy - wz;\n        m[8] = xz + wy;\n\n        m[1] = xy + wz;\n        m[5] = 1 - (xx + zz);\n        m[9] = yz - wx;\n\n        m[2] = xz - wy;\n        m[6] = yz + wx;\n        m[10] = 1 - (xx + yy);\n\n        // last column\n        m[3] = 0;\n        m[7] = 0;\n        m[11] = 0;\n\n        // bottom row\n        m[12] = 0;\n        m[13] = 0;\n        m[14] = 0;\n        m[15] = 1;\n\n        return m;\n    },\n\n    normalizeQuaternion(q, dest = q) {\n        const len = math.lenVec4([q[0], q[1], q[2], q[3]]);\n        dest[0] = q[0] / len;\n        dest[1] = q[1] / len;\n        dest[2] = q[2] / len;\n        dest[3] = q[3] / len;\n        return dest;\n    },\n\n    conjugateQuaternion(q, dest = q) {\n        dest[0] = -q[0];\n        dest[1] = -q[1];\n        dest[2] = -q[2];\n        dest[3] = q[3];\n        return dest;\n    },\n\n    inverseQuaternion(q, dest) {\n        return math.normalizeQuaternion(math.conjugateQuaternion(q, dest));\n    },\n\n    quaternionToAngleAxis(q, angleAxis = math.vec4()) {\n        q = math.normalizeQuaternion(q, tempVec4);\n        const q3 = q[3];\n        const angle = 2 * Math.acos(q3);\n        const s = Math.sqrt(1 - q3 * q3);\n        if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt\n            angleAxis[0] = q[0];\n            angleAxis[1] = q[1];\n            angleAxis[2] = q[2];\n        } else {\n            angleAxis[0] = q[0] / s;\n            angleAxis[1] = q[1] / s;\n            angleAxis[2] = q[2] / s;\n        }\n        angleAxis[3] = angle; // * 57.295779579;\n        return angleAxis;\n    },\n\n    //------------------------------------------------------------------------------------------------------------------\n    // Boundaries\n    //------------------------------------------------------------------------------------------------------------------\n\n    /**\n     * Returns a new, uninitialized 3D axis-aligned bounding box.\n     *\n     * @private\n     */\n    AABB3(values) {\n        return new FloatArrayType(values || 6);\n    },\n\n    /**\n     * Returns a new, uninitialized 2D axis-aligned bounding box.\n     *\n     * @private\n     */\n    AABB2(values) {\n        return new FloatArrayType(values || 4);\n    },\n\n    /**\n     * Returns a new, uninitialized 3D oriented bounding box (OBB).\n     *\n     * @private\n     */\n    OBB3(values) {\n        return new FloatArrayType(values || 32);\n    },\n\n    /**\n     * Returns a new, uninitialized 2D oriented bounding box (OBB).\n     *\n     * @private\n     */\n    OBB2(values) {\n        return new FloatArrayType(values || 16);\n    },\n\n    /** Returns a new 3D bounding sphere */\n    Sphere3(x, y, z, r) {\n        return new FloatArrayType([x, y, z, r]);\n    },\n\n    /**\n     * Transforms an OBB3 by a 4x4 matrix.\n     *\n     * @private\n     */\n    transformOBB3(m, p, p2 = p) {\n        let i;\n        const len = p.length;\n\n        let x;\n        let y;\n        let z;\n\n        const m0 = m[0];\n        const m1 = m[1];\n        const m2 = m[2];\n        const m3 = m[3];\n        const m4 = m[4];\n        const m5 = m[5];\n        const m6 = m[6];\n        const m7 = m[7];\n        const m8 = m[8];\n        const m9 = m[9];\n        const m10 = m[10];\n        const m11 = m[11];\n        const m12 = m[12];\n        const m13 = m[13];\n        const m14 = m[14];\n        const m15 = m[15];\n\n        for (i = 0; i < len; i += 4) {\n\n            x = p[i + 0];\n            y = p[i + 1];\n            z = p[i + 2];\n\n            p2[i + 0] = (m0 * x) + (m4 * y) + (m8 * z) + m12;\n            p2[i + 1] = (m1 * x) + (m5 * y) + (m9 * z) + m13;\n            p2[i + 2] = (m2 * x) + (m6 * y) + (m10 * z) + m14;\n            p2[i + 3] = (m3 * x) + (m7 * y) + (m11 * z) + m15;\n        }\n\n        return p2;\n    },\n\n    /** Returns true if the first AABB contains the second AABB.\n     * @param aabb1\n     * @param aabb2\n     * @returns {boolean}\n     */\n    containsAABB3: function (aabb1, aabb2) {\n        const result = (\n            aabb1[0] <= aabb2[0] && aabb2[3] <= aabb1[3] &&\n            aabb1[1] <= aabb2[1] && aabb2[4] <= aabb1[4] &&\n            aabb1[2] <= aabb2[2] && aabb2[5] <= aabb1[5]);\n        return result;\n    },\n\n    /**\n     * Gets the diagonal size of an AABB3 given as minima and maxima.\n     *\n     * @private\n     */\n    getAABB3Diag: ((() => {\n\n        const min = new FloatArrayType(3);\n        const max = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return aabb => {\n\n            min[0] = aabb[0];\n            min[1] = aabb[1];\n            min[2] = aabb[2];\n\n            max[0] = aabb[3];\n            max[1] = aabb[4];\n            max[2] = aabb[5];\n\n            math.subVec3(max, min, tempVec3);\n\n            return Math.abs(math.lenVec3(tempVec3));\n        };\n    }))(),\n\n    /**\n     * Get a diagonal boundary size that is symmetrical about the given point.\n     *\n     * @private\n     */\n    getAABB3DiagPoint: ((() => {\n\n        const min = new FloatArrayType(3);\n        const max = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return (aabb, p) => {\n\n            min[0] = aabb[0];\n            min[1] = aabb[1];\n            min[2] = aabb[2];\n\n            max[0] = aabb[3];\n            max[1] = aabb[4];\n            max[2] = aabb[5];\n\n            const diagVec = math.subVec3(max, min, tempVec3);\n\n            const xneg = p[0] - aabb[0];\n            const xpos = aabb[3] - p[0];\n            const yneg = p[1] - aabb[1];\n            const ypos = aabb[4] - p[1];\n            const zneg = p[2] - aabb[2];\n            const zpos = aabb[5] - p[2];\n\n            diagVec[0] += (xneg > xpos) ? xneg : xpos;\n            diagVec[1] += (yneg > ypos) ? yneg : ypos;\n            diagVec[2] += (zneg > zpos) ? zneg : zpos;\n\n            return Math.abs(math.lenVec3(diagVec));\n        };\n    }))(),\n\n    /**\n     * Gets the center of an AABB.\n     *\n     * @private\n     */\n    getAABB3Center(aabb, dest) {\n        const r = dest || math.vec3();\n\n        r[0] = (aabb[0] + aabb[3]) / 2;\n        r[1] = (aabb[1] + aabb[4]) / 2;\n        r[2] = (aabb[2] + aabb[5]) / 2;\n\n        return r;\n    },\n\n    /**\n     * Gets the center of a 2D AABB.\n     *\n     * @private\n     */\n    getAABB2Center(aabb, dest) {\n        const r = dest || math.vec2();\n\n        r[0] = (aabb[2] + aabb[0]) / 2;\n        r[1] = (aabb[3] + aabb[1]) / 2;\n\n        return r;\n    },\n\n    /**\n     * Collapses a 3D axis-aligned boundary, ready to expand to fit 3D points.\n     * Creates new AABB if none supplied.\n     *\n     * @private\n     */\n    collapseAABB3(aabb = math.AABB3()) {\n        aabb[0] = math.MAX_DOUBLE;\n        aabb[1] = math.MAX_DOUBLE;\n        aabb[2] = math.MAX_DOUBLE;\n        aabb[3] = -math.MAX_DOUBLE;\n        aabb[4] = -math.MAX_DOUBLE;\n        aabb[5] = -math.MAX_DOUBLE;\n\n        return aabb;\n    },\n\n    /**\n     * Converts an axis-aligned 3D boundary into an oriented boundary consisting of\n     * an array of eight 3D positions, one for each corner of the boundary.\n     *\n     * @private\n     */\n    AABB3ToOBB3(aabb, obb = math.OBB3()) {\n        obb[0] = aabb[0];\n        obb[1] = aabb[1];\n        obb[2] = aabb[2];\n        obb[3] = 1;\n\n        obb[4] = aabb[3];\n        obb[5] = aabb[1];\n        obb[6] = aabb[2];\n        obb[7] = 1;\n\n        obb[8] = aabb[3];\n        obb[9] = aabb[4];\n        obb[10] = aabb[2];\n        obb[11] = 1;\n\n        obb[12] = aabb[0];\n        obb[13] = aabb[4];\n        obb[14] = aabb[2];\n        obb[15] = 1;\n\n        obb[16] = aabb[0];\n        obb[17] = aabb[1];\n        obb[18] = aabb[5];\n        obb[19] = 1;\n\n        obb[20] = aabb[3];\n        obb[21] = aabb[1];\n        obb[22] = aabb[5];\n        obb[23] = 1;\n\n        obb[24] = aabb[3];\n        obb[25] = aabb[4];\n        obb[26] = aabb[5];\n        obb[27] = 1;\n\n        obb[28] = aabb[0];\n        obb[29] = aabb[4];\n        obb[30] = aabb[5];\n        obb[31] = 1;\n\n        return obb;\n    },\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n     *\n     * @private\n     */\n    positions3ToAABB3: ((() => {\n\n        const p = new FloatArrayType(3);\n\n        return (positions, aabb, positionsDecodeMatrix) => {\n            aabb = aabb || math.AABB3();\n\n            let xmin = math.MAX_DOUBLE;\n            let ymin = math.MAX_DOUBLE;\n            let zmin = math.MAX_DOUBLE;\n            let xmax = -math.MAX_DOUBLE;\n            let ymax = -math.MAX_DOUBLE;\n            let zmax = -math.MAX_DOUBLE;\n\n            let x;\n            let y;\n            let z;\n\n            for (let i = 0, len = positions.length; i < len; i += 3) {\n\n                if (positionsDecodeMatrix) {\n\n                    p[0] = positions[i + 0];\n                    p[1] = positions[i + 1];\n                    p[2] = positions[i + 2];\n\n                    math.decompressPosition(p, positionsDecodeMatrix, p);\n\n                    x = p[0];\n                    y = p[1];\n                    z = p[2];\n\n                } else {\n                    x = positions[i + 0];\n                    y = positions[i + 1];\n                    z = positions[i + 2];\n                }\n\n                if (x < xmin) {\n                    xmin = x;\n                }\n\n                if (y < ymin) {\n                    ymin = y;\n                }\n\n                if (z < zmin) {\n                    zmin = z;\n                }\n\n                if (x > xmax) {\n                    xmax = x;\n                }\n\n                if (y > ymax) {\n                    ymax = y;\n                }\n\n                if (z > zmax) {\n                    zmax = z;\n                }\n            }\n\n            aabb[0] = xmin;\n            aabb[1] = ymin;\n            aabb[2] = zmin;\n            aabb[3] = xmax;\n            aabb[4] = ymax;\n            aabb[5] = zmax;\n\n            return aabb;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the homogeneous 3D points (x,y,z,w) given in a flattened array.\n     *\n     * @private\n     */\n    OBB3ToAABB3(obb, aabb = math.AABB3()) {\n        let xmin = math.MAX_DOUBLE;\n        let ymin = math.MAX_DOUBLE;\n        let zmin = math.MAX_DOUBLE;\n        let xmax = -math.MAX_DOUBLE;\n        let ymax = -math.MAX_DOUBLE;\n        let zmax = -math.MAX_DOUBLE;\n\n        let x;\n        let y;\n        let z;\n\n        for (let i = 0, len = obb.length; i < len; i += 4) {\n\n            x = obb[i + 0];\n            y = obb[i + 1];\n            z = obb[i + 2];\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (z < zmin) {\n                zmin = z;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n\n            if (z > zmax) {\n                zmax = z;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = zmin;\n        aabb[3] = xmax;\n        aabb[4] = ymax;\n        aabb[5] = zmax;\n\n        return aabb;\n    },\n\n    /**\n     * Finds the minimum axis-aligned 3D boundary enclosing the given 3D points.\n     *\n     * @private\n     */\n    points3ToAABB3(points, aabb = math.AABB3()) {\n        let xmin = math.MAX_DOUBLE;\n        let ymin = math.MAX_DOUBLE;\n        let zmin = math.MAX_DOUBLE;\n        let xmax = -math.MAX_DOUBLE;\n        let ymax = -math.MAX_DOUBLE;\n        let zmax = -math.MAX_DOUBLE;\n\n        let x;\n        let y;\n        let z;\n\n        for (let i = 0, len = points.length; i < len; i++) {\n\n            x = points[i][0];\n            y = points[i][1];\n            z = points[i][2];\n\n            if (x < xmin) {\n                xmin = x;\n            }\n\n            if (y < ymin) {\n                ymin = y;\n            }\n\n            if (z < zmin) {\n                zmin = z;\n            }\n\n            if (x > xmax) {\n                xmax = x;\n            }\n\n            if (y > ymax) {\n                ymax = y;\n            }\n\n            if (z > zmax) {\n                zmax = z;\n            }\n        }\n\n        aabb[0] = xmin;\n        aabb[1] = ymin;\n        aabb[2] = zmin;\n        aabb[3] = xmax;\n        aabb[4] = ymax;\n        aabb[5] = zmax;\n\n        return aabb;\n    },\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D points.\n     *\n     * @private\n     */\n    points3ToSphere3: ((() => {\n\n        const tempVec3 = new FloatArrayType(3);\n\n        return (points, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const numPoints = points.length;\n\n            for (i = 0; i < numPoints; i++) {\n                x += points[i][0];\n                y += points[i][1];\n                z += points[i][2];\n            }\n\n            sphere[0] = x / numPoints;\n            sphere[1] = y / numPoints;\n            sphere[2] = z / numPoints;\n\n            let radius = 0;\n            let dist;\n\n            for (i = 0; i < numPoints; i++) {\n\n                dist = Math.abs(math.lenVec3(math.subVec3(points[i], sphere, tempVec3)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D positions.\n     *\n     * @private\n     */\n    positions3ToSphere3: ((() => {\n\n        const tempVec3a = new FloatArrayType(3);\n        const tempVec3b = new FloatArrayType(3);\n\n        return (positions, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const lenPositions = positions.length;\n            let radius = 0;\n\n            for (i = 0; i < lenPositions; i += 3) {\n                x += positions[i];\n                y += positions[i + 1];\n                z += positions[i + 2];\n            }\n\n            const numPositions = lenPositions / 3;\n\n            sphere[0] = x / numPositions;\n            sphere[1] = y / numPositions;\n            sphere[2] = z / numPositions;\n\n            let dist;\n\n            for (i = 0; i < lenPositions; i += 3) {\n\n                tempVec3a[0] = positions[i];\n                tempVec3a[1] = positions[i + 1];\n                tempVec3a[2] = positions[i + 2];\n\n                dist = Math.abs(math.lenVec3(math.subVec3(tempVec3a, sphere, tempVec3b)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Finds the minimum boundary sphere enclosing the given 3D points.\n     *\n     * @private\n     */\n    OBB3ToSphere3: ((() => {\n\n        const point = new FloatArrayType(3);\n        const tempVec3 = new FloatArrayType(3);\n\n        return (points, sphere) => {\n\n            sphere = sphere || math.vec4();\n\n            let x = 0;\n            let y = 0;\n            let z = 0;\n\n            let i;\n            const lenPoints = points.length;\n            const numPoints = lenPoints / 4;\n\n            for (i = 0; i < lenPoints; i += 4) {\n                x += points[i + 0];\n                y += points[i + 1];\n                z += points[i + 2];\n            }\n\n            sphere[0] = x / numPoints;\n            sphere[1] = y / numPoints;\n            sphere[2] = z / numPoints;\n\n            let radius = 0;\n            let dist;\n\n            for (i = 0; i < lenPoints; i += 4) {\n\n                point[0] = points[i + 0];\n                point[1] = points[i + 1];\n                point[2] = points[i + 2];\n\n                dist = Math.abs(math.lenVec3(math.subVec3(point, sphere, tempVec3)));\n\n                if (dist > radius) {\n                    radius = dist;\n                }\n            }\n\n            sphere[3] = radius;\n\n            return sphere;\n        };\n    }))(),\n\n    /**\n     * Gets the center of a bounding sphere.\n     *\n     * @private\n     */\n    getSphere3Center(sphere, dest = math.vec3()) {\n        dest[0] = sphere[0];\n        dest[1] = sphere[1];\n        dest[2] = sphere[2];\n\n        return dest;\n    },\n\n    /**\n     * Expands the first axis-aligned 3D boundary to enclose the second, if required.\n     *\n     * @private\n     */\n    expandAABB3(aabb1, aabb2) {\n\n        if (aabb1[0] > aabb2[0]) {\n            aabb1[0] = aabb2[0];\n        }\n\n        if (aabb1[1] > aabb2[1]) {\n            aabb1[1] = aabb2[1];\n        }\n\n        if (aabb1[2] > aabb2[2]) {\n            aabb1[2] = aabb2[2];\n        }\n\n        if (aabb1[3] < aabb2[3]) {\n            aabb1[3] = aabb2[3];\n        }\n\n        if (aabb1[4] < aabb2[4]) {\n            aabb1[4] = aabb2[4];\n        }\n\n        if (aabb1[5] < aabb2[5]) {\n            aabb1[5] = aabb2[5];\n        }\n\n        return aabb1;\n    },\n\n    /**\n     * Expands an axis-aligned 3D boundary to enclose the given point, if needed.\n     *\n     * @private\n     */\n    expandAABB3Point3(aabb, p) {\n\n        if (aabb[0] > p[0]) {\n            aabb[0] = p[0];\n        }\n\n        if (aabb[1] > p[1]) {\n            aabb[1] = p[1];\n        }\n\n        if (aabb[2] > p[2]) {\n            aabb[2] = p[2];\n        }\n\n        if (aabb[3] < p[0]) {\n            aabb[3] = p[0];\n        }\n\n        if (aabb[4] < p[1]) {\n            aabb[4] = p[1];\n        }\n\n        if (aabb[5] < p[2]) {\n            aabb[5] = p[2];\n        }\n\n        return aabb;\n    },\n\n    /**\n     * Calculates the normal vector of a triangle.\n     *\n     * @private\n     */\n    triangleNormal(a, b, c, normal = math.vec3()) {\n        const p1x = b[0] - a[0];\n        const p1y = b[1] - a[1];\n        const p1z = b[2] - a[2];\n\n        const p2x = c[0] - a[0];\n        const p2y = c[1] - a[1];\n        const p2z = c[2] - a[2];\n\n        const p3x = p1y * p2z - p1z * p2y;\n        const p3y = p1z * p2x - p1x * p2z;\n        const p3z = p1x * p2y - p1y * p2x;\n\n        const mag = Math.sqrt(p3x * p3x + p3y * p3y + p3z * p3z);\n        if (mag === 0) {\n            normal[0] = 0;\n            normal[1] = 0;\n            normal[2] = 0;\n        } else {\n            normal[0] = p3x / mag;\n            normal[1] = p3y / mag;\n            normal[2] = p3z / mag;\n        }\n\n        return normal\n    }\n};\n\nexport {math};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/lib/math.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 392,
    "kind": "variable",
    "name": "doublePrecision",
    "memberof": "src/lib/math.js",
    "static": true,
    "longname": "src/lib/math.js~doublePrecision",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 393,
    "kind": "variable",
    "name": "FloatArrayType",
    "memberof": "src/lib/math.js",
    "static": true,
    "longname": "src/lib/math.js~FloatArrayType",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 394,
    "kind": "variable",
    "name": "tempMat1",
    "memberof": "src/lib/math.js",
    "static": true,
    "longname": "src/lib/math.js~tempMat1",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 395,
    "kind": "variable",
    "name": "tempMat2",
    "memberof": "src/lib/math.js",
    "static": true,
    "longname": "src/lib/math.js~tempMat2",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 396,
    "kind": "variable",
    "name": "tempVec4",
    "memberof": "src/lib/math.js",
    "static": true,
    "longname": "src/lib/math.js~tempVec4",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/lib/math.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 8,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 397,
    "kind": "variable",
    "name": "math",
    "memberof": "src/lib/math.js",
    "static": true,
    "longname": "src/lib/math.js~math",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/lib/math.js",
    "importStyle": "{math}",
    "description": "",
    "lineNumber": 13,
    "ignore": true,
    "type": {
      "types": [
        "{\"MIN_DOUBLE\": *, \"MAX_DOUBLE\": *, \"DEGTORAD\": number, \"RADTODEG\": number, \"vec2\": function, \"vec3\": function, \"vec4\": function, \"mat3\": function, \"mat3ToMat4\": function, \"mat4\": function, \"mat4ToMat3\": function, \"createUUID\": *, \"clamp\": function, \"fmod\": function, \"negateVec4\": function, \"addVec4\": function, \"addVec4Scalar\": function, \"addVec3\": function, \"addVec3Scalar\": function, \"subVec4\": function, \"subVec3\": function, \"subVec2\": function, \"subVec4Scalar\": function, \"subScalarVec4\": function, \"mulVec4\": function, \"mulVec4Scalar\": function, \"mulVec3Scalar\": function, \"mulVec2Scalar\": function, \"divVec3\": function, \"divVec4\": function, \"divScalarVec3\": function, \"divVec3Scalar\": function, \"divVec4Scalar\": function, \"divScalarVec4\": function, \"dotVec4\": function, \"cross3Vec4\": function, \"cross3Vec3\": function, \"sqLenVec4\": function, \"lenVec4\": function, \"dotVec3\": function, \"dotVec2\": function, \"sqLenVec3\": function, \"sqLenVec2\": function, \"lenVec3\": function, \"distVec3\": *, \"lenVec2\": function, \"distVec2\": *, \"rcpVec3\": function, \"normalizeVec4\": function, \"normalizeVec3\": function, \"normalizeVec2\": function, \"angleVec3\": function, \"vec3FromMat4Scale\": *, \"vecToArray\": *, \"xyzArrayToObject\": function, \"xyzObjectToArray\": function, \"dupMat4\": function, \"mat4To3\": function, \"m4s\": function, \"setMat4ToZeroes\": function, \"setMat4ToOnes\": function, \"diagonalMat4v\": function, \"diagonalMat4c\": function, \"diagonalMat4s\": function, \"identityMat4\": function, \"identityMat3\": function, \"isIdentityMat4\": function, \"negateMat4\": function, \"addMat4\": function, \"addMat4Scalar\": function, \"addScalarMat4\": function, \"subMat4\": function, \"subMat4Scalar\": function, \"subScalarMat4\": function, \"mulMat4\": function, \"mulMat3\": function, \"mulMat4Scalar\": function, \"mulMat4v4\": function, \"transposeMat4\": function, \"transposeMat3\": function, \"determinantMat4\": function, \"inverseMat4\": function, \"traceMat4\": function, \"translationMat4v\": function, \"translationMat3v\": function, \"translationMat4c\": *, \"translationMat4s\": function, \"translateMat4v\": function, \"OLDtranslateMat4c\": function, \"translateMat4c\": function, \"rotationMat4v\": function, \"rotationMat4c\": function, \"scalingMat4v\": function, \"scalingMat3v\": function, \"scalingMat4c\": *, \"scaleMat4c\": function, \"scaleMat4v\": function, \"scalingMat4s\": function, \"rotationTranslationMat4\": function, \"mat4ToEuler\": function, \"composeMat4\": function, \"decomposeMat4\": *, \"lookAtMat4v\": function, \"lookAtMat4c\": function, \"orthoMat4c\": function, \"frustumMat4v\": function, \"frustumMat4\": function, \"perspectiveMat4\": function, \"transformPoint3\": function, \"transformPoint4\": function, \"transformPoints3\": function, \"transformPositions3\": function, \"transformPositions4\": function, \"transformVec3\": function, \"transformVec4\": function, \"rotateVec3X\": function, \"rotateVec3Y\": function, \"rotateVec3Z\": function, \"projectVec4\": function, \"unprojectVec3\": *, \"lerpVec3\": function, \"flatten\": function, \"identityQuaternion\": function, \"eulerToQuaternion\": function, \"mat4ToQuaternion\": function, \"vec3PairToQuaternion\": function, \"angleAxisToQuaternion\": function, \"quaternionToEuler\": *, \"mulQuaternions\": function, \"vec3ApplyQuaternion\": function, \"quaternionToMat4\": function, \"quaternionToRotationMat4\": function, \"normalizeQuaternion\": function, \"conjugateQuaternion\": function, \"inverseQuaternion\": function, \"quaternionToAngleAxis\": function, \"AABB3\": function, \"AABB2\": function, \"OBB3\": function, \"OBB2\": function, \"Sphere3\": function, \"transformOBB3\": function, \"containsAABB3\": *, \"getAABB3Diag\": *, \"getAABB3DiagPoint\": *, \"getAABB3Center\": function, \"getAABB2Center\": function, \"collapseAABB3\": function, \"AABB3ToOBB3\": function, \"positions3ToAABB3\": *, \"OBB3ToAABB3\": function, \"points3ToAABB3\": function, \"points3ToSphere3\": *, \"positions3ToSphere3\": *, \"OBB3ToSphere3\": *, \"getSphere3Center\": function, \"expandAABB3\": function, \"expandAABB3Point3\": function, \"triangleNormal\": function}"
      ]
    }
  },
  {
    "__docId__": 398,
    "kind": "file",
    "name": "src/lib/mergeVertices.js",
    "content": "/**\n * Given geometry defined as an array of positions, optional normals, option uv and an array of indices, returns\n * modified arrays that have duplicate vertices removed.\n *\n * @private\n */\nfunction mergeVertices(positions, indices, mergedPositions, mergedIndices) {\n    const positionsMap = {};\n    const indicesLookup = [];\n    const precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001\n    const precision = 10 ** precisionPoints;\n    let uvi = 0;\n    for (let i = 0, len = positions.length; i < len; i += 3) {\n        const vx = positions[i];\n        const vy = positions[i + 1];\n        const vz = positions[i + 2];\n        const key = `${Math.round(vx * precision)}_${Math.round(vy * precision)}_${Math.round(vz * precision)}`;\n        if (positionsMap[key] === undefined) {\n            positionsMap[key] = mergedPositions.length / 3;\n            mergedPositions.push(vx);\n            mergedPositions.push(vy);\n            mergedPositions.push(vz);\n        }\n        indicesLookup[i / 3] = positionsMap[key];\n        uvi += 2;\n    }\n    for (let i = 0, len = indices.length; i < len; i++) {\n        mergedIndices[i] = indicesLookup[indices[i]];\n    }\n}\n\nexport {mergeVertices};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/lib/mergeVertices.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 399,
    "kind": "function",
    "name": "mergeVertices",
    "memberof": "src/lib/mergeVertices.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/lib/mergeVertices.js~mergeVertices",
    "access": "private",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/lib/mergeVertices.js",
    "importStyle": "{mergeVertices}",
    "description": "Given geometry defined as an array of positions, optional normals, option uv and an array of indices, returns\nmodified arrays that have duplicate vertices removed.",
    "lineNumber": 7,
    "ignore": true,
    "params": [
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "indices",
        "types": [
          "*"
        ]
      },
      {
        "name": "mergedPositions",
        "types": [
          "*"
        ]
      },
      {
        "name": "mergedIndices",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 400,
    "kind": "file",
    "name": "src/parsers/parseCityJSONIntoXKTModel.js",
    "content": "import {earcut} from './../lib/earcut';\nimport {math} from \"./../lib/math.js\";\n\nconst tempVec2a = math.vec2();\nconst tempVec3a = math.vec3();\nconst tempVec3b = math.vec3();\nconst tempVec3c = math.vec3();\n\n/**\n * @desc Parses a CityJSON model into an {@link XKTModel}.\n *\n * [CityJSON](https://www.cityjson.org) is a JSON-based encoding for a subset of the CityGML data model (version 2.0.0),\n * which is an open standardised data model and exchange format to store digital 3D models of cities and\n * landscapes. CityGML is an official standard of the [Open Geospatial Consortium](https://www.ogc.org/).\n *\n * This converter function supports most of the [CityJSON 1.0.2 Specification](https://www.cityjson.org/specs/1.0.2),\n * with the following limitations:\n *\n * * Does not (yet) support CityJSON semantics for geometry primitives.\n * * Does not (yet) support textured geometries.\n * * Does not (yet) support geometry templates.\n * * When the CityJSON file provides multiple *themes* for a geometry, then we parse only the first of the provided themes for that geometry.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then load a CityJSON model into it.\n *\n * ````javascript\n * utils.loadJSON(\"./models/cityjson/DenHaag.json\", async (data) => {\n *\n *     const xktModel = new XKTModel();\n *\n *     parseCityJSONIntoXKTModel({\n *          data,\n *          xktModel,\n *          log: (msg) => { console.log(msg); }\n *     }).then(()=>{\n *        xktModel.finalize();\n *     },\n *     (msg) => {\n *         console.error(msg);\n *     });\n * });\n * ````\n *\n * @param {Object} params Parsing params.\n * @param {Object} params.data CityJSON data.\n * @param {XKTModel} params.xktModel XKTModel to parse into.\n * @param {boolean} [params.center=false] Set true to center the CityJSON vertex positions to [0,0,0]. This is applied before the transformation matrix, if specified.\n * @param {Boolean} [params.transform] 4x4 transformation matrix to transform CityJSON vertex positions. Use this to rotate, translate and scale them if neccessary.\n * @param {Object} [params.stats] Collects statistics.\n * @param {function} [params.log] Logging callback.\n @returns {Promise} Resolves when CityJSON has been parsed.\n */\nfunction parseCityJSONIntoXKTModel({\n                                       data,\n                                       xktModel,\n                                       center = false,\n                                       transform = null,\n                                       stats = {}, log\n                                   }) {\n\n    return new Promise(function (resolve, reject) {\n\n        if (!data) {\n            reject(\"Argument expected: data\");\n            return;\n        }\n\n        if (data.type !== \"CityJSON\") {\n            reject(\"Invalid argument: data is not a CityJSON file\");\n            return;\n        }\n\n        if (!xktModel) {\n            reject(\"Argument expected: xktModel\");\n            return;\n        }\n\n        let vertices;\n\n        log(\"Using parser: parseCityJSONIntoXKTModel\");\n\n        log(`center: ${center}`);\n        if (transform) {\n            log(`transform: [${transform}]`);\n        }\n\n        if (data.transform || center || transform) {\n            vertices = copyVertices(data.vertices);\n            if (data.transform) {\n                transformVertices(vertices, data.transform)\n            }\n            if (center) {\n                centerVertices(vertices);\n            }\n            if (transform) {\n                customTransformVertices(vertices, transform);\n            }\n        } else {\n            vertices = data.vertices;\n        }\n\n        stats.sourceFormat = data.type || \"\";\n        stats.schemaVersion = data.version || \"\";\n        stats.title = \"\";\n        stats.author = \"\";\n        stats.created = \"\";\n        stats.numMetaObjects = 0;\n        stats.numPropertySets = 0;\n        stats.numTriangles = 0;\n        stats.numVertices = 0;\n        stats.numObjects = 0;\n        stats.numGeometries = 0;\n\n        const rootMetaObjectId = math.createUUID();\n\n        xktModel.createMetaObject({\n            metaObjectId: rootMetaObjectId,\n            metaObjectType: \"Model\",\n            metaObjectName: \"Model\"\n        });\n\n        stats.numMetaObjects++;\n\n        const modelMetaObjectId = math.createUUID();\n\n        xktModel.createMetaObject({\n            metaObjectId: modelMetaObjectId,\n            metaObjectType: \"CityJSON\",\n            metaObjectName: \"CityJSON\",\n            parentMetaObjectId: rootMetaObjectId\n        });\n\n        stats.numMetaObjects++;\n\n        const ctx = {\n            data,\n            vertices,\n            xktModel,\n            rootMetaObjectId: modelMetaObjectId,\n            log: (log || function (msg) {\n            }),\n            nextId: 0,\n            stats\n        };\n\n        ctx.xktModel.schema = data.type + \" \" + data.version;\n\n        ctx.log(\"Converting \" + ctx.xktModel.schema);\n\n        parseCityJSON(ctx);\n\n        resolve();\n    });\n}\n\nfunction copyVertices(vertices) {\n    const vertices2 = [];\n    for (let i = 0, j = 0; i < vertices.length; i++, j += 3) {\n        const x = vertices[i][0];\n        const y = vertices[i][1];\n        const z = vertices[i][2];\n        vertices2.push([x, y, z]);\n    }\n    return vertices2;\n}\n\nfunction transformVertices(vertices, cityJSONTransform) {\n    const scale = cityJSONTransform.scale || math.vec3([1, 1, 1]);\n    const translate = cityJSONTransform.translate || math.vec3([0, 0, 0]);\n    for (let i = 0; i < vertices.length; i++) {\n        const vertex = vertices[i];\n        vertex[0] = (vertex[0] * scale[0]) + translate[0];\n        vertex[1] = (vertex[1] * scale[1]) + translate[1];\n        vertex[2] = (vertex[2] * scale[2]) + translate[2];\n    }\n}\n\nfunction centerVertices(vertices) {\n    if (center) {\n        const centerPos = math.vec3();\n        const numPoints = vertices.length;\n        for (let i = 0, len = vertices.length; i < len; i++) {\n            const vertex = vertices[i];\n            centerPos[0] += vertex[0];\n            centerPos[1] += vertex[1];\n            centerPos[2] += vertex[2];\n        }\n        centerPos[0] /= numPoints;\n        centerPos[1] /= numPoints;\n        centerPos[2] /= numPoints;\n        for (let i = 0, len = vertices.length; i < len; i++) {\n            const vertex = vertices[i];\n            vertex[0] -= centerPos[0];\n            vertex[1] -= centerPos[1];\n            vertex[2] -= centerPos[2];\n        }\n    }\n}\n\nfunction customTransformVertices(vertices, transform) {\n    if (transform) {\n        const mat = math.mat4(transform);\n        for (let i = 0, len = vertices.length; i < len; i++) {\n            const vertex = vertices[i];\n            math.transformPoint3(mat, vertex, vertex);\n        }\n    }\n}\n\nfunction parseCityJSON(ctx) {\n\n    const data = ctx.data;\n    const cityObjects = data.CityObjects;\n\n    for (const objectId in cityObjects) {\n        if (cityObjects.hasOwnProperty(objectId)) {\n            const cityObject = cityObjects[objectId];\n            parseCityObject(ctx, cityObject, objectId);\n        }\n    }\n}\n\nfunction parseCityObject(ctx, cityObject, objectId) {\n\n    const xktModel = ctx.xktModel;\n    const data = ctx.data;\n    const metaObjectId = objectId;\n    const metaObjectType = cityObject.type;\n    const metaObjectName = metaObjectType + \" : \" + objectId;\n\n    const parentMetaObjectId = cityObject.parents ? cityObject.parents[0] : ctx.rootMetaObjectId;\n\n    xktModel.createMetaObject({\n        metaObjectId,\n        metaObjectName,\n        metaObjectType,\n        parentMetaObjectId\n    });\n\n    ctx.stats.numMetaObjects++;\n\n    if (!(cityObject.geometry && cityObject.geometry.length > 0)) {\n        return;\n    }\n\n    const meshIds = [];\n\n    for (let i = 0, len = cityObject.geometry.length; i < len; i++) {\n\n        const geometry = cityObject.geometry[i];\n\n        let objectMaterial;\n        let surfaceMaterials;\n\n        const appearance = data.appearance;\n        if (appearance) {\n            const materials = appearance.materials;\n            if (materials) {\n                const geometryMaterial = geometry.material;\n                if (geometryMaterial) {\n                    const themeIds = Object.keys(geometryMaterial);\n                    if (themeIds.length > 0) {\n                        const themeId = themeIds[0];\n                        const theme = geometryMaterial[themeId];\n                        if (theme.value !== undefined) {\n                            objectMaterial = materials[theme.value];\n                        } else {\n                            const values = theme.values;\n                            if (values) {\n                                surfaceMaterials = [];\n                                for (let j = 0, lenj = values.length; j < lenj; j++) {\n                                    const value = values[i];\n                                    const surfaceMaterial = materials[value];\n                                    surfaceMaterials.push(surfaceMaterial);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        if (surfaceMaterials) {\n            parseGeometrySurfacesWithOwnMaterials(ctx, geometry, surfaceMaterials, meshIds);\n\n        } else {\n            parseGeometrySurfacesWithSharedMaterial(ctx, geometry, objectMaterial, meshIds);\n        }\n    }\n\n    if (meshIds.length > 0) {\n        xktModel.createEntity({\n            entityId: objectId,\n            meshIds: meshIds\n        });\n\n        ctx.stats.numObjects++;\n    }\n}\n\nfunction parseGeometrySurfacesWithOwnMaterials(ctx, geometry, surfaceMaterials, meshIds) {\n\n    const geomType = geometry.type;\n\n    switch (geomType) {\n\n        case \"MultiPoint\":\n            break;\n\n        case \"MultiLineString\":\n            break;\n\n        case \"MultiSurface\":\n\n        case \"CompositeSurface\":\n            const surfaces = geometry.boundaries;\n            parseSurfacesWithOwnMaterials(ctx, surfaceMaterials, surfaces, meshIds);\n            break;\n\n        case \"Solid\":\n            const shells = geometry.boundaries;\n            for (let j = 0; j < shells.length; j++) {\n                const surfaces = shells[j];\n                parseSurfacesWithOwnMaterials(ctx, surfaceMaterials, surfaces, meshIds);\n            }\n            break;\n\n        case \"MultiSolid\":\n\n        case \"CompositeSolid\":\n            const solids = geometry.boundaries;\n            for (let j = 0; j < solids.length; j++) {\n                for (let k = 0; k < solids[j].length; k++) {\n                    const surfaces = solids[j][k];\n                    parseSurfacesWithOwnMaterials(ctx, surfaceMaterials, surfaces, meshIds);\n                }\n            }\n            break;\n\n        case \"GeometryInstance\":\n            break;\n    }\n}\n\nfunction parseSurfacesWithOwnMaterials(ctx, surfaceMaterials, surfaces, meshIds) {\n\n    const vertices = ctx.vertices;\n    const xktModel = ctx.xktModel;\n\n    for (let i = 0; i < surfaces.length; i++) {\n\n        const surface = surfaces[i];\n        const surfaceMaterial = surfaceMaterials[i] || {diffuseColor: [0.8, 0.8, 0.8], transparency: 1.0};\n\n        const face = [];\n        const holes = [];\n\n        const sharedIndices = [];\n\n        const geometryCfg = {\n            positions: [],\n            indices: []\n        };\n\n        for (let j = 0; j < surface.length; j++) {\n\n            if (face.length > 0) {\n                holes.push(face.length);\n            }\n\n            const newFace = extractLocalIndices(ctx, surface[j], sharedIndices, geometryCfg);\n\n            face.push(...newFace);\n        }\n\n        if (face.length === 3) { // Triangle\n\n            geometryCfg.indices.push(face[0]);\n            geometryCfg.indices.push(face[1]);\n            geometryCfg.indices.push(face[2]);\n\n        } else if (face.length > 3) { // Polygon\n\n            // Prepare to triangulate\n\n            const pList = [];\n\n            for (let k = 0; k < face.length; k++) {\n                pList.push({\n                    x: vertices[sharedIndices[face[k]]][0],\n                    y: vertices[sharedIndices[face[k]]][1],\n                    z: vertices[sharedIndices[face[k]]][2]\n                });\n            }\n\n            const normal = getNormalOfPositions(pList, math.vec3());\n\n            // Convert to 2D\n\n            let pv = [];\n\n            for (let k = 0; k < pList.length; k++) {\n\n                to2D(pList[k], normal, tempVec2a);\n\n                pv.unshift(tempVec2a[0]);\n                pv.unshift(tempVec2a[1]);\n            }\n\n            // Triangulate\n\n            const tr = earcut(pv, holes, 2);\n\n            // Create triangles\n\n            for (let k = 0; k < tr.length; k += 3) {\n                geometryCfg.indices.unshift(face[tr[k]]);\n                geometryCfg.indices.unshift(face[tr[k + 1]]);\n                geometryCfg.indices.unshift(face[tr[k + 2]]);\n            }\n        }\n\n        const geometryId = \"\" + ctx.nextId++;\n        const meshId = \"\" + ctx.nextId++;\n\n        xktModel.createGeometry({\n            geometryId: geometryId,\n            primitiveType: \"triangles\",\n            positions: geometryCfg.positions,\n            indices: geometryCfg.indices\n        });\n\n        xktModel.createMesh({\n            meshId: meshId,\n            geometryId: geometryId,\n            color: (surfaceMaterial && surfaceMaterial.diffuseColor) ? surfaceMaterial.diffuseColor : [0.8, 0.8, 0.8],\n            opacity: 1.0\n            //opacity: (surfaceMaterial && surfaceMaterial.transparency !== undefined) ? (1.0 - surfaceMaterial.transparency) : 1.0\n        });\n\n        meshIds.push(meshId);\n\n        ctx.stats.numGeometries++;\n        ctx.stats.numVertices += geometryCfg.positions.length / 3;\n        ctx.stats.numTriangles += geometryCfg.indices.length / 3;\n    }\n}\n\nfunction parseGeometrySurfacesWithSharedMaterial(ctx, geometry, objectMaterial, meshIds) {\n\n    const xktModel = ctx.xktModel;\n    const sharedIndices = [];\n    const geometryCfg = {\n        positions: [],\n        indices: []\n    };\n\n    const geomType = geometry.type;\n\n    switch (geomType) {\n        case \"MultiPoint\":\n            break;\n\n        case \"MultiLineString\":\n            break;\n\n        case \"MultiSurface\":\n        case \"CompositeSurface\":\n            const surfaces = geometry.boundaries;\n            parseSurfacesWithSharedMaterial(ctx, surfaces, sharedIndices, geometryCfg);\n            break;\n\n        case \"Solid\":\n            const shells = geometry.boundaries;\n            for (let j = 0; j < shells.length; j++) {\n                const surfaces = shells[j];\n                parseSurfacesWithSharedMaterial(ctx, surfaces, sharedIndices, geometryCfg);\n            }\n            break;\n\n        case \"MultiSolid\":\n        case \"CompositeSolid\":\n            const solids = geometry.boundaries;\n            for (let j = 0; j < solids.length; j++) {\n                for (let k = 0; k < solids[j].length; k++) {\n                    const surfaces = solids[j][k];\n                    parseSurfacesWithSharedMaterial(ctx, surfaces, sharedIndices, geometryCfg);\n                }\n            }\n            break;\n\n        case \"GeometryInstance\":\n            break;\n    }\n\n    const geometryId = \"\" + ctx.nextId++;\n    const meshId = \"\" + ctx.nextId++;\n\n    xktModel.createGeometry({\n        geometryId: geometryId,\n        primitiveType: \"triangles\",\n        positions: geometryCfg.positions,\n        indices: geometryCfg.indices\n    });\n\n    xktModel.createMesh({\n        meshId: meshId,\n        geometryId: geometryId,\n        color: (objectMaterial && objectMaterial.diffuseColor) ? objectMaterial.diffuseColor : [0.8, 0.8, 0.8],\n        opacity: 1.0\n        //opacity: (objectMaterial && objectMaterial.transparency !== undefined) ? (1.0 - objectMaterial.transparency) : 1.0\n    });\n\n    meshIds.push(meshId);\n\n    ctx.stats.numGeometries++;\n    ctx.stats.numVertices += geometryCfg.positions.length / 3;\n    ctx.stats.numTriangles += geometryCfg.indices.length / 3;\n}\n\nfunction parseSurfacesWithSharedMaterial(ctx, surfaces, sharedIndices, primitiveCfg) {\n\n    const vertices = ctx.vertices;\n\n    for (let i = 0; i < surfaces.length; i++) {\n\n        let boundary = [];\n        let holes = [];\n\n        for (let j = 0; j < surfaces[i].length; j++) {\n            if (boundary.length > 0) {\n                holes.push(boundary.length);\n            }\n            const newBoundary = extractLocalIndices(ctx, surfaces[i][j], sharedIndices, primitiveCfg);\n            boundary.push(...newBoundary);\n        }\n\n        if (boundary.length === 3) { // Triangle\n\n            primitiveCfg.indices.push(boundary[0]);\n            primitiveCfg.indices.push(boundary[1]);\n            primitiveCfg.indices.push(boundary[2]);\n\n        } else if (boundary.length > 3) { // Polygon\n\n            let pList = [];\n\n            for (let k = 0; k < boundary.length; k++) {\n                pList.push({\n                    x: vertices[sharedIndices[boundary[k]]][0],\n                    y: vertices[sharedIndices[boundary[k]]][1],\n                    z: vertices[sharedIndices[boundary[k]]][2]\n                });\n            }\n\n            const normal = getNormalOfPositions(pList, math.vec3());\n            let pv = [];\n\n            for (let k = 0; k < pList.length; k++) {\n                to2D(pList[k], normal, tempVec2a);\n                pv.unshift(tempVec2a[0]);\n                pv.unshift(tempVec2a[1]);\n            }\n\n            const tr = earcut(pv, holes, 2);\n\n            for (let k = 0; k < tr.length; k += 3) {\n                primitiveCfg.indices.unshift(boundary[tr[k]]);\n                primitiveCfg.indices.unshift(boundary[tr[k + 1]]);\n                primitiveCfg.indices.unshift(boundary[tr[k + 2]]);\n            }\n        }\n    }\n}\n\nfunction extractLocalIndices(ctx, boundary, sharedIndices, geometryCfg) {\n\n    const vertices = ctx.vertices;\n    const newBoundary = []\n\n    for (let i = 0, len = boundary.length; i < len; i++) {\n\n        const index = boundary[i];\n\n        if (sharedIndices.includes(index)) {\n            const vertexIndex = sharedIndices.indexOf(index);\n            newBoundary.push(vertexIndex);\n\n        } else {\n            geometryCfg.positions.push(vertices[index][0]);\n            geometryCfg.positions.push(vertices[index][1]);\n            geometryCfg.positions.push(vertices[index][2]);\n\n            newBoundary.push(sharedIndices.length);\n\n            sharedIndices.push(index);\n        }\n    }\n\n    return newBoundary\n}\n\nfunction getNormalOfPositions(positions, normal) {\n\n    for (let i = 0; i < positions.length; i++) {\n\n        let nexti = i + 1;\n        if (nexti === positions.length) {\n            nexti = 0;\n        }\n\n        normal[0] += ((positions[i].y - positions[nexti].y) * (positions[i].z + positions[nexti].z));\n        normal[1] += ((positions[i].z - positions[nexti].z) * (positions[i].x + positions[nexti].x));\n        normal[2] += ((positions[i].x - positions[nexti].x) * (positions[i].y + positions[nexti].y));\n    }\n\n    return math.normalizeVec3(normal);\n}\n\nfunction to2D(_p, _n, re) {\n\n    const p = tempVec3a;\n    const n = tempVec3b;\n    const x3 = tempVec3c;\n\n    p[0] = _p.x;\n    p[1] = _p.y;\n    p[2] = _p.z;\n\n    n[0] = _n.x;\n    n[1] = _n.y;\n    n[2] = _n.z;\n\n    x3[0] = 1.1;\n    x3[1] = 1.1;\n    x3[2] = 1.1;\n\n    const dist = math.lenVec3(math.subVec3(x3, n));\n\n    if (dist < 0.01) {\n        x3[0] += 1.0;\n        x3[1] += 2.0;\n        x3[2] += 3.0;\n    }\n\n    const dot = math.dotVec3(x3, n);\n    const tmp2 = math.mulVec3Scalar(n, dot, math.vec3());\n\n    x3[0] -= tmp2[0];\n    x3[1] -= tmp2[1];\n    x3[2] -= tmp2[2];\n\n    math.normalizeVec3(x3);\n\n    const y3 = math.cross3Vec3(n, x3, math.vec3());\n    const x = math.dotVec3(p, x3);\n    const y = math.dotVec3(p, y3);\n\n    re[0] = x;\n    re[1] = y;\n}\n\nexport {parseCityJSONIntoXKTModel};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 401,
    "kind": "variable",
    "name": "tempVec2a",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~tempVec2a",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 402,
    "kind": "variable",
    "name": "tempVec3a",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~tempVec3a",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 5,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 403,
    "kind": "variable",
    "name": "tempVec3b",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~tempVec3b",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 404,
    "kind": "variable",
    "name": "tempVec3c",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~tempVec3c",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 7,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 405,
    "kind": "function",
    "name": "copyVertices",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~copyVertices",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 158,
    "undocument": true,
    "params": [
      {
        "name": "vertices",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 406,
    "kind": "function",
    "name": "transformVertices",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~transformVertices",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 169,
    "undocument": true,
    "params": [
      {
        "name": "vertices",
        "types": [
          "*"
        ]
      },
      {
        "name": "cityJSONTransform",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 407,
    "kind": "function",
    "name": "centerVertices",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~centerVertices",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 180,
    "undocument": true,
    "params": [
      {
        "name": "vertices",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 408,
    "kind": "function",
    "name": "customTransformVertices",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~customTransformVertices",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 202,
    "undocument": true,
    "params": [
      {
        "name": "vertices",
        "types": [
          "*"
        ]
      },
      {
        "name": "transform",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 409,
    "kind": "function",
    "name": "parseCityJSON",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~parseCityJSON",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 212,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 410,
    "kind": "function",
    "name": "parseCityObject",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~parseCityObject",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 225,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "cityObject",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectId",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 411,
    "kind": "function",
    "name": "parseGeometrySurfacesWithOwnMaterials",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~parseGeometrySurfacesWithOwnMaterials",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 303,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "geometry",
        "types": [
          "*"
        ]
      },
      {
        "name": "surfaceMaterials",
        "types": [
          "*"
        ]
      },
      {
        "name": "meshIds",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 412,
    "kind": "function",
    "name": "parseSurfacesWithOwnMaterials",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~parseSurfacesWithOwnMaterials",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 347,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "surfaceMaterials",
        "types": [
          "*"
        ]
      },
      {
        "name": "surfaces",
        "types": [
          "*"
        ]
      },
      {
        "name": "meshIds",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 413,
    "kind": "function",
    "name": "parseGeometrySurfacesWithSharedMaterial",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~parseGeometrySurfacesWithSharedMaterial",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 451,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "geometry",
        "types": [
          "*"
        ]
      },
      {
        "name": "objectMaterial",
        "types": [
          "*"
        ]
      },
      {
        "name": "meshIds",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 414,
    "kind": "function",
    "name": "parseSurfacesWithSharedMaterial",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~parseSurfacesWithSharedMaterial",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 523,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "surfaces",
        "types": [
          "*"
        ]
      },
      {
        "name": "sharedIndices",
        "types": [
          "*"
        ]
      },
      {
        "name": "primitiveCfg",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 415,
    "kind": "function",
    "name": "extractLocalIndices",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~extractLocalIndices",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 578,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "boundary",
        "types": [
          "*"
        ]
      },
      {
        "name": "sharedIndices",
        "types": [
          "*"
        ]
      },
      {
        "name": "geometryCfg",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 416,
    "kind": "function",
    "name": "getNormalOfPositions",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~getNormalOfPositions",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 605,
    "undocument": true,
    "params": [
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "normal",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 417,
    "kind": "function",
    "name": "to2D",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~to2D",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 622,
    "undocument": true,
    "params": [
      {
        "name": "_p",
        "types": [
          "*"
        ]
      },
      {
        "name": "_n",
        "types": [
          "*"
        ]
      },
      {
        "name": "re",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 418,
    "kind": "function",
    "name": "parseCityJSONIntoXKTModel",
    "memberof": "src/parsers/parseCityJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseCityJSONIntoXKTModel.js~parseCityJSONIntoXKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseCityJSONIntoXKTModel.js",
    "importStyle": "{parseCityJSONIntoXKTModel}",
    "description": "Parses a CityJSON model into an {@link XKTModel}.\n\n[CityJSON](https://www.cityjson.org) is a JSON-based encoding for a subset of the CityGML data model (version 2.0.0),\nwhich is an open standardised data model and exchange format to store digital 3D models of cities and\nlandscapes. CityGML is an official standard of the [Open Geospatial Consortium](https://www.ogc.org/).\n\nThis converter function supports most of the [CityJSON 1.0.2 Specification](https://www.cityjson.org/specs/1.0.2),\nwith the following limitations:\n\n* Does not (yet) support CityJSON semantics for geometry primitives.\n* Does not (yet) support textured geometries.\n* Does not (yet) support geometry templates.\n* When the CityJSON file provides multiple *themes* for a geometry, then we parse only the first of the provided themes for that geometry.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then load a CityJSON model into it.\n\n````javascript\nutils.loadJSON(\"./models/cityjson/DenHaag.json\", async (data) => {\n\n    const xktModel = new XKTModel();\n\n    parseCityJSONIntoXKTModel({\n         data,\n         xktModel,\n         log: (msg) => { console.log(msg); }\n    }).then(()=>{\n       xktModel.finalize();\n    },\n    (msg) => {\n        console.error(msg);\n    });\n});\n````",
    "lineNumber": 55,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} Resolves when CityJSON has been parsed."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Parsing params."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.data",
        "description": "CityJSON data."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "params.xktModel",
        "description": "XKTModel to parse into."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "params.center",
        "description": "Set true to center the CityJSON vertex positions to [0,0,0]. This is applied before the transformation matrix, if specified."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "params.transform",
        "description": "4x4 transformation matrix to transform CityJSON vertex positions. Use this to rotate, translate and scale them if neccessary."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "params.stats",
        "description": "Collects statistics."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.log",
        "description": "Logging callback."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Resolves when CityJSON has been parsed."
    }
  },
  {
    "__docId__": 419,
    "kind": "file",
    "name": "src/parsers/parseGLTFIntoXKTModel.js",
    "content": "import {utils} from \"../XKTModel/lib/utils.js\";\nimport {math} from \"../lib/math.js\";\n\nimport {parse} from '@loaders.gl/core';\nimport {GLTFLoader} from '@loaders.gl/gltf';\nimport {\n    ClampToEdgeWrapping,\n    LinearFilter,\n    LinearMipMapLinearFilter,\n    LinearMipMapNearestFilter,\n    MirroredRepeatWrapping,\n    NearestFilter,\n    NearestMipMapLinearFilter,\n    NearestMipMapNearestFilter,\n    RepeatWrapping\n} from \"../constants.js\";\n\n/**\n * @desc Parses glTF into an {@link XKTModel}, supporting ````.glb```` and textures.\n *\n * * Supports ````.glb```` and textures\n * * For a lightweight glTF JSON parser that ignores textures, see {@link parseGLTFJSONIntoXKTModel}.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then load a binary glTF model into it.\n *\n * ````javascript\n * utils.loadArraybuffer(\"../assets/models/gltf/HousePlan/glTF-Binary/HousePlan.glb\", async (data) => {\n *\n *     const xktModel = new XKTModel();\n *\n *     parseGLTFIntoXKTModel({\n *          data,\n *          xktModel,\n *          log: (msg) => { console.log(msg); }\n *     }).then(()=>{\n *        xktModel.finalize();\n *     },\n *     (msg) => {\n *         console.error(msg);\n *     });\n * });\n * ````\n *\n * @param {Object} params Parsing parameters.\n * @param {ArrayBuffer} params.data The glTF.\n * @param {String} [params.baseUri] The base URI used to load this glTF, if any. For resolving relative uris to linked resources.\n * @param {Object} [params.metaModelData] Metamodel JSON. If this is provided, then parsing is able to ensure that the XKTObjects it creates will fit the metadata properly.\n * @param {XKTModel} params.xktModel XKTModel to parse into.\n * @param {Boolean} [params.includeTextures=true] Whether to parse textures.\n * @param {Boolean} [params.includeNormals=true] Whether to parse normals. When false, the parser will ignore the glTF\n * geometry normals, and the glTF data will rely on the xeokit ````Viewer```` to automatically generate them. This has\n * the limitation that the normals will be face-aligned, and therefore the ````Viewer```` will only be able to render\n * a flat-shaded non-PBR representation of the glTF.\n * @param {Object} [params.stats] Collects statistics.\n * @param {function} [params.log] Logging callback.\n @returns {Promise} Resolves when glTF has been parsed.\n */\nfunction parseGLTFIntoXKTModel({\n                                   data,\n                                   baseUri,\n                                   xktModel,\n                                   metaModelData,\n                                   includeTextures = true,\n                                   includeNormals = true,\n                                   getAttachment,\n                                   stats = {},\n                                   log\n                               }) {\n\n    return new Promise(function (resolve, reject) {\n\n        if (!data) {\n            reject(\"Argument expected: data\");\n            return;\n        }\n\n        if (!xktModel) {\n            reject(\"Argument expected: xktModel\");\n            return;\n        }\n\n        stats.sourceFormat = \"glTF\";\n        stats.schemaVersion = \"2.0\";\n        stats.title = \"\";\n        stats.author = \"\";\n        stats.created = \"\";\n        stats.numTriangles = 0;\n        stats.numVertices = 0;\n        stats.numNormals = 0;\n        stats.numUVs = 0;\n        stats.numTextures = 0;\n        stats.numObjects = 0;\n        stats.numGeometries = 0;\n\n        parse(data, GLTFLoader, {\n            baseUri\n        }).then((gltfData) => {\n\n            const ctx = {\n                gltfData,\n                nodesHaveNames: false, // determined in testIfNodesHaveNames()\n                getAttachment: getAttachment || (() => {\n                    throw new Error('You must define getAttachment() method to convert glTF with external resources')\n                }),\n                log: (log || function (msg) {\n                }),\n                error: function (msg) {\n                    console.error(msg);\n                },\n                xktModel,\n                includeNormals: (includeNormals !== false),\n                includeTextures: (includeTextures !== false),\n                geometryCreated: {},\n                nextId: 0,\n                geometriesCreated : {},\n                stats\n            };\n\n            ctx.log(\"Using parser: parseGLTFIntoXKTModel\");\n            ctx.log(`Parsing normals: ${ctx.includeNormals ? \"enabled\" : \"disabled\"}`);\n            ctx.log(`Parsing textures: ${ctx.includeTextures ? \"enabled\" : \"disabled\"}`);\n\n            if (ctx.includeTextures) {\n                parseTextures(ctx);\n            }\n            parseMaterials(ctx);\n            parseDefaultScene(ctx);\n\n            resolve();\n\n        }, (errMsg) => {\n            reject(`[parseGLTFIntoXKTModel] ${errMsg}`);\n        });\n    });\n}\n\nfunction parseTextures(ctx) {\n    const gltfData = ctx.gltfData;\n    const textures = gltfData.textures;\n    if (textures) {\n        for (let i = 0, len = textures.length; i < len; i++) {\n            parseTexture(ctx, textures[i]);\n            ctx.stats.numTextures++;\n        }\n    }\n}\n\nfunction parseTexture(ctx, texture) {\n    if (!texture.source || !texture.source.image) {\n        return;\n    }\n    const textureId = `texture-${ctx.nextId++}`;\n\n    let minFilter = NearestMipMapLinearFilter;\n    switch (texture.sampler.minFilter) {\n        case 9728:\n            minFilter = NearestFilter;\n            break;\n        case 9729:\n            minFilter = LinearFilter;\n            break;\n        case 9984:\n            minFilter = NearestMipMapNearestFilter;\n            break;\n        case 9985:\n            minFilter = LinearMipMapNearestFilter;\n            break;\n        case 9986:\n            minFilter = NearestMipMapLinearFilter;\n            break;\n        case 9987:\n            minFilter = LinearMipMapLinearFilter;\n            break;\n    }\n\n    let magFilter = LinearFilter;\n    switch (texture.sampler.magFilter) {\n        case 9728:\n            magFilter = NearestFilter;\n            break;\n        case 9729:\n            magFilter = LinearFilter;\n            break;\n    }\n\n    let wrapS = RepeatWrapping;\n    switch (texture.sampler.wrapS) {\n        case 33071:\n            wrapS = ClampToEdgeWrapping;\n            break;\n        case 33648:\n            wrapS = MirroredRepeatWrapping;\n            break;\n        case 10497:\n            wrapS = RepeatWrapping;\n            break;\n    }\n\n    let wrapT = RepeatWrapping;\n    switch (texture.sampler.wrapT) {\n        case 33071:\n            wrapT = ClampToEdgeWrapping;\n            break;\n        case 33648:\n            wrapT = MirroredRepeatWrapping;\n            break;\n        case 10497:\n            wrapT = RepeatWrapping;\n            break;\n    }\n\n    let wrapR = RepeatWrapping;\n    switch (texture.sampler.wrapR) {\n        case 33071:\n            wrapR = ClampToEdgeWrapping;\n            break;\n        case 33648:\n            wrapR = MirroredRepeatWrapping;\n            break;\n        case 10497:\n            wrapR = RepeatWrapping;\n            break;\n    }\n\n    ctx.xktModel.createTexture({\n        textureId: textureId,\n        imageData: texture.source.image,\n        mediaType: texture.source.mediaType,\n        compressed: true,\n        width: texture.source.image.width,\n        height: texture.source.image.height,\n        minFilter,\n        magFilter,\n        wrapS,\n        wrapT,\n        wrapR,\n        flipY: !!texture.flipY,\n        //     encoding: \"sRGB\"\n    });\n    texture._textureId = textureId;\n}\n\nfunction parseMaterials(ctx) {\n    const gltfData = ctx.gltfData;\n    const materials = gltfData.materials;\n    if (materials) {\n        for (let i = 0, len = materials.length; i < len; i++) {\n            const material = materials[i];\n            material._textureSetId = ctx.includeTextures ? parseTextureSet(ctx, material) : null;\n            material._attributes = parseMaterialAttributes(ctx, material);\n        }\n    }\n}\n\nfunction parseTextureSet(ctx, material) {\n    const textureSetCfg = {};\n    if (material.normalTexture) {\n        textureSetCfg.normalTextureId = material.normalTexture.texture._textureId;\n    }\n    if (material.occlusionTexture) {\n        textureSetCfg.occlusionTextureId = material.occlusionTexture.texture._textureId;\n    }\n    if (material.emissiveTexture) {\n        textureSetCfg.emissiveTextureId = material.emissiveTexture.texture._textureId;\n    }\n    const metallicPBR = material.pbrMetallicRoughness;\n    if (material.pbrMetallicRoughness) {\n        const pbrMetallicRoughness = material.pbrMetallicRoughness;\n        const baseColorTexture = pbrMetallicRoughness.baseColorTexture || pbrMetallicRoughness.colorTexture;\n        if (baseColorTexture) {\n            if (baseColorTexture.texture) {\n                textureSetCfg.colorTextureId = baseColorTexture.texture._textureId;\n            } else {\n                textureSetCfg.colorTextureId = ctx.gltfData.textures[baseColorTexture.index]._textureId;\n            }\n        }\n        if (metallicPBR.metallicRoughnessTexture) {\n            textureSetCfg.metallicRoughnessTextureId = metallicPBR.metallicRoughnessTexture.texture._textureId;\n        }\n    }\n    const extensions = material.extensions;\n    if (extensions) {\n        const specularPBR = extensions[\"KHR_materials_pbrSpecularGlossiness\"];\n        if (specularPBR) {\n            const specularTexture = specularPBR.specularTexture;\n            if (specularTexture !== null && specularTexture !== undefined) {\n                //  textureSetCfg.colorTextureId = ctx.gltfData.textures[specularColorTexture.index]._textureId;\n            }\n            const specularColorTexture = specularPBR.specularColorTexture;\n            if (specularColorTexture !== null && specularColorTexture !== undefined) {\n                textureSetCfg.colorTextureId = ctx.gltfData.textures[specularColorTexture.index]._textureId;\n            }\n        }\n    }\n    if (textureSetCfg.normalTextureId !== undefined ||\n        textureSetCfg.occlusionTextureId !== undefined ||\n        textureSetCfg.emissiveTextureId !== undefined ||\n        textureSetCfg.colorTextureId !== undefined ||\n        textureSetCfg.metallicRoughnessTextureId !== undefined) {\n        textureSetCfg.textureSetId = `textureSet-${ctx.nextId++};`\n        ctx.xktModel.createTextureSet(textureSetCfg);\n        ctx.stats.numTextureSets++;\n        return textureSetCfg.textureSetId;\n    }\n    return null;\n}\n\nfunction parseMaterialAttributes(ctx, material) { // Substitute RGBA for material, to use fast flat shading instead\n    const extensions = material.extensions;\n    const materialAttributes = {\n        color: new Float32Array([1, 1, 1, 1]),\n        opacity: 1,\n        metallic: 0,\n        roughness: 1\n    };\n    if (extensions) {\n        const specularPBR = extensions[\"KHR_materials_pbrSpecularGlossiness\"];\n        if (specularPBR) {\n            const diffuseFactor = specularPBR.diffuseFactor;\n            if (diffuseFactor !== null && diffuseFactor !== undefined) {\n                materialAttributes.color.set(diffuseFactor);\n            }\n        }\n        const common = extensions[\"KHR_materials_common\"];\n        if (common) {\n            const technique = common.technique;\n            const values = common.values || {};\n            const blinn = technique === \"BLINN\";\n            const phong = technique === \"PHONG\";\n            const lambert = technique === \"LAMBERT\";\n            const diffuse = values.diffuse;\n            if (diffuse && (blinn || phong || lambert)) {\n                if (!utils.isString(diffuse)) {\n                    materialAttributes.color.set(diffuse);\n                }\n            }\n            const transparency = values.transparency;\n            if (transparency !== null && transparency !== undefined) {\n                materialAttributes.opacity = transparency;\n            }\n            const transparent = values.transparent;\n            if (transparent !== null && transparent !== undefined) {\n                materialAttributes.opacity = transparent;\n            }\n        }\n    }\n    const metallicPBR = material.pbrMetallicRoughness;\n    if (metallicPBR) {\n        const baseColorFactor = metallicPBR.baseColorFactor;\n        if (baseColorFactor) {\n            materialAttributes.color[0] = baseColorFactor[0];\n            materialAttributes.color[1] = baseColorFactor[1];\n            materialAttributes.color[2] = baseColorFactor[2];\n            materialAttributes.opacity = baseColorFactor[3];\n        }\n        const metallicFactor = metallicPBR.metallicFactor;\n        if (metallicFactor !== null && metallicFactor !== undefined) {\n            materialAttributes.metallic = metallicFactor;\n        }\n        const roughnessFactor = metallicPBR.roughnessFactor;\n        if (roughnessFactor !== null && roughnessFactor !== undefined) {\n            materialAttributes.roughness = roughnessFactor;\n        }\n    }\n    return materialAttributes;\n}\n\nfunction parseDefaultScene(ctx) {\n    const gltfData = ctx.gltfData;\n    const scene = gltfData.scene || gltfData.scenes[0];\n    if (!scene) {\n        ctx.error(\"glTF has no default scene\");\n        return;\n    }\n    parseScene(ctx, scene);\n}\n\nfunction parseScene(ctx, scene) {\n    const nodes = scene.nodes;\n    if (!nodes) {\n        return;\n    }\n    for (let i = 0, len = nodes.length; i < len; i++) {\n        const node = nodes[i];\n        countMeshUsage(ctx, node);\n    }\n    for (let i = 0, len = nodes.length; i < len && !ctx.nodesHaveNames; i++) {\n        const node = nodes[i];\n        if (testIfNodesHaveNames(node)) {\n            ctx.nodesHaveNames = true;\n        }\n    }\n    if (!ctx.nodesHaveNames) {\n        ctx.log(`Warning: No \"name\" attributes found on glTF scene nodes - objects in XKT may not be what you expect`);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            parseNodesWithoutNames(ctx, node, 0, null);\n        }\n    } else {\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            parseNodesWithNames(ctx, node, 0, null);\n        }\n    }\n}\n\nfunction countMeshUsage(ctx, node, level = 0) {\n    if (!node) {\n        return;\n    }\n    const mesh = node.mesh;\n    if (mesh) {\n        mesh.instances = mesh.instances ? mesh.instances + 1 : 1;\n    }\n    if (node.children) {\n        const children = node.children;\n        for (let i = 0, len = children.length; i < len; i++) {\n            const childNode = children[i];\n            if (!childNode) {\n                ctx.error(\"Node not found: \" + i);\n                continue;\n            }\n            countMeshUsage(ctx, childNode, level + 1);\n        }\n    }\n}\n\nfunction testIfNodesHaveNames(node, level = 0) {\n    if (!node) {\n        return;\n    }\n    if (node.name) {\n        return true;\n    }\n    if (node.children) {\n        const children = node.children;\n        for (let i = 0, len = children.length; i < len; i++) {\n            const childNode = children[i];\n            if (testIfNodesHaveNames(childNode, level + 1)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n\n/**\n * Parses a glTF node hierarchy that is known to NOT contain \"name\" attributes on the nodes.\n * Create a XKTMesh for each mesh primitive, and a single XKTEntity.\n */\nconst parseNodesWithoutNames = (function () {\n\n    const meshIds = [];\n\n    return function (ctx, node, depth, matrix) {\n        if (!node) {\n            return;\n        }\n        matrix = parseNodeMatrix(node, matrix);\n        if (node.mesh) {\n            parseNodeMesh(node, ctx, matrix, meshIds);\n        }\n        if (node.children) {\n            const children = node.children;\n            for (let i = 0, len = children.length; i < len; i++) {\n                const childNode = children[i];\n                parseNodesWithoutNames(ctx, childNode, depth + 1, matrix);\n            }\n        }\n        if (depth === 0) {\n            let entityId = \"entity-\" + ctx.nextId++;\n            if (meshIds && meshIds.length > 0) {\n                ctx.log(\"Creating XKTEntity with default ID: \" + entityId);\n                ctx.xktModel.createEntity({\n                    entityId,\n                    meshIds\n                });\n                meshIds.length = 0;\n            }\n            ctx.stats.numObjects++;\n        }\n    }\n})();\n\n\n/**\n * Parses a glTF node hierarchy that is known to contain \"name\" attributes on the nodes.\n *\n * Create a XKTMesh for each mesh primitive, and XKTEntity for each named node.\n *\n * Following a depth-first traversal, each XKTEntity is created on post-visit of each named node,\n * and gets all the XKTMeshes created since the last XKTEntity created.\n */\nconst parseNodesWithNames = (function () {\n\n    const objectIdStack = [];\n    const meshIdsStack = [];\n    let meshIds = null;\n\n    return function (ctx, node, depth, matrix) {\n        if (!node) {\n            return;\n        }\n        matrix = parseNodeMatrix(node, matrix);\n        if (node.name) {\n            meshIds = [];\n            let xktEntityId = node.name;\n            if (!!xktEntityId && ctx.xktModel.entities[xktEntityId]) {\n                ctx.log(`Warning: Two or more glTF nodes found with same 'name' attribute: '${xktEntityId} - will randomly-generating an object ID in XKT`);\n            }\n            while (!xktEntityId || ctx.xktModel.entities[xktEntityId]) {\n                xktEntityId = \"entity-\" + ctx.nextId++;\n            }\n            objectIdStack.push(xktEntityId);\n            meshIdsStack.push(meshIds);\n        }\n        if (meshIds && node.mesh) {\n            parseNodeMesh(node, ctx, matrix, meshIds);\n        }\n        if (node.children) {\n            const children = node.children;\n            for (let i = 0, len = children.length; i < len; i++) {\n                const childNode = children[i];\n                parseNodesWithNames(ctx, childNode, depth + 1, matrix);\n            }\n        }\n        const nodeName = node.name;\n        if ((nodeName !== undefined && nodeName !== null) || depth === 0) {\n            let xktEntityId = objectIdStack.pop();\n            if (!xktEntityId) { // For when there are no nodes with names\n                xktEntityId = \"entity-\" + ctx.nextId++;\n            }\n            let entityMeshIds = meshIdsStack.pop();\n            if (meshIds && meshIds.length > 0) {\n                ctx.xktModel.createEntity({\n                    entityId: xktEntityId,\n                    meshIds: entityMeshIds\n                });\n            }\n            ctx.stats.numObjects++;\n            meshIds = meshIdsStack.length > 0 ? meshIdsStack[meshIdsStack.length - 1] : null;\n        }\n    }\n})();\n\n/**\n * Parses transform at the given glTF node.\n *\n * @param node the glTF node\n * @param matrix Transfor matrix from parent nodes\n * @returns {*} Transform matrix for the node\n */\nfunction parseNodeMatrix(node, matrix) {\n    if (!node) {\n        return;\n    }\n    let localMatrix;\n    if (node.matrix) {\n        localMatrix = node.matrix;\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, math.mat4());\n        } else {\n            matrix = localMatrix;\n        }\n    }\n    if (node.translation) {\n        localMatrix = math.translationMat4v(node.translation);\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, math.mat4());\n        } else {\n            matrix = localMatrix;\n        }\n    }\n    if (node.rotation) {\n        localMatrix = math.quaternionToMat4(node.rotation);\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, math.mat4());\n        } else {\n            matrix = localMatrix;\n        }\n    }\n    if (node.scale) {\n        localMatrix = math.scalingMat4v(node.scale);\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, math.mat4());\n        } else {\n            matrix = localMatrix;\n        }\n    }\n    return matrix;\n}\n\nfunction createPrimitiveHash(primitive) {\n    const hash = [];\n    const attributes = primitive.attributes;\n    if (attributes) {\n        for (let key in attributes) {\n            hash.push(attributes[key].id);\n        }\n    }\n    if (primitive.indices) {\n        hash.push(primitive.indices.id);\n    }\n    return hash.join(\".\");\n}\n\n/**\n * Parses primitives referenced by the mesh belonging to the given node, creating XKTMeshes in the XKTModel.\n *\n * @param node glTF node\n * @param ctx Parsing context\n * @param matrix Matrix for the XKTMeshes\n * @param meshIds returns IDs of the new XKTMeshes\n */\nfunction parseNodeMesh(node, ctx, matrix, meshIds) {\n    if (!node) {\n        return;\n    }\n    const mesh = node.mesh;\n    if (!mesh) {\n        return;\n    }\n    const numPrimitives = mesh.primitives.length;\n    if (numPrimitives > 0) {\n        for (let i = 0; i < numPrimitives; i++) {\n            try {\n                const primitive = mesh.primitives[i];\n                const geometryId = createPrimitiveHash(primitive);\n                if (!ctx.geometriesCreated[geometryId]) {\n                    const geometryCfg = {\n                        geometryId\n                    };\n                    switch (primitive.mode) {\n                        case 0: // POINTS\n                            geometryCfg.primitiveType = \"points\";\n                            break;\n                        case 1: // LINES\n                            geometryCfg.primitiveType = \"lines\";\n                            break;\n                        case 2: // LINE_LOOP\n                            geometryCfg.primitiveType = \"line-loop\";\n                            break;\n                        case 3: // LINE_STRIP\n                            geometryCfg.primitiveType = \"line-strip\";\n                            break;\n                        case 4: // TRIANGLES\n                            geometryCfg.primitiveType = \"triangles\";\n                            break;\n                        case 5: // TRIANGLE_STRIP\n                            geometryCfg.primitiveType = \"triangle-strip\";\n                            break;\n                        case 6: // TRIANGLE_FAN\n                            geometryCfg.primitiveType = \"triangle-fan\";\n                            break;\n                        default:\n                            geometryCfg.primitiveType = \"triangles\";\n                    }\n                    const POSITION = primitive.attributes.POSITION;\n                    if (!POSITION) {\n                        continue;\n                    }\n                    geometryCfg.positions = primitive.attributes.POSITION.value;\n                    ctx.stats.numVertices += geometryCfg.positions.length / 3;\n                    if (ctx.includeNormals) {\n                        if (primitive.attributes.NORMAL) {\n                            geometryCfg.normals = primitive.attributes.NORMAL.value;\n                            ctx.stats.numNormals += geometryCfg.normals.length / 3;\n                        }\n                    }\n                    if (primitive.attributes.COLOR_0) {\n                        geometryCfg.colorsCompressed = primitive.attributes.COLOR_0.value;\n                    }\n                    if (ctx.includeTextures) {\n                        if (primitive.attributes.TEXCOORD_0) {\n                            geometryCfg.uvs = primitive.attributes.TEXCOORD_0.value;\n                            ctx.stats.numUVs += geometryCfg.uvs.length / 2;\n                        }\n                    }\n                    if (primitive.indices) {\n                        geometryCfg.indices = primitive.indices.value;\n                        if (primitive.mode === 4) {\n                            ctx.stats.numTriangles += geometryCfg.indices.length / 3;\n                        }\n                    }\n                    ctx.xktModel.createGeometry(geometryCfg);\n                    ctx.geometriesCreated[geometryId] = true;\n                    ctx.stats.numGeometries++;\n                }\n                const xktMeshId = ctx.nextId++;\n                const meshCfg = {\n                    meshId: xktMeshId,\n                    geometryId,\n                    matrix: matrix ? matrix.slice() : math.identityMat4()\n                };\n                const material = primitive.material;\n                if (material) {\n                    meshCfg.textureSetId = material._textureSetId;\n                    meshCfg.color = material._attributes.color;\n                    meshCfg.opacity = material._attributes.opacity;\n                    meshCfg.metallic = material._attributes.metallic;\n                    meshCfg.roughness = material._attributes.roughness;\n                } else {\n                    meshCfg.color = [1.0, 1.0, 1.0];\n                    meshCfg.opacity = 1.0;\n                }\n                ctx.xktModel.createMesh(meshCfg);\n                meshIds.push(xktMeshId);\n            } catch (e) {\n                console.log(e);\n            }\n        }\n    }\n}\n\nexport {parseGLTFIntoXKTModel};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 420,
    "kind": "function",
    "name": "parseTextures",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseTextures",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 139,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 421,
    "kind": "function",
    "name": "parseTexture",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseTexture",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 150,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "texture",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 422,
    "kind": "function",
    "name": "parseMaterials",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseMaterials",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 245,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 423,
    "kind": "function",
    "name": "parseTextureSet",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseTextureSet",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 257,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "material",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 424,
    "kind": "function",
    "name": "parseMaterialAttributes",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseMaterialAttributes",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 310,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "material",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 425,
    "kind": "function",
    "name": "parseDefaultScene",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseDefaultScene",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 370,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 426,
    "kind": "function",
    "name": "parseScene",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseScene",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 380,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "scene",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 427,
    "kind": "function",
    "name": "countMeshUsage",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~countMeshUsage",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 409,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "node",
        "types": [
          "*"
        ]
      },
      {
        "name": "level",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 428,
    "kind": "function",
    "name": "testIfNodesHaveNames",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~testIfNodesHaveNames",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 430,
    "undocument": true,
    "params": [
      {
        "name": "node",
        "types": [
          "*"
        ]
      },
      {
        "name": "level",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 429,
    "kind": "variable",
    "name": "parseNodesWithoutNames",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseNodesWithoutNames",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": "Parses a glTF node hierarchy that is known to NOT contain \"name\" attributes on the nodes.\nCreate a XKTMesh for each mesh primitive, and a single XKTEntity.",
    "lineNumber": 453,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 430,
    "kind": "variable",
    "name": "parseNodesWithNames",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseNodesWithNames",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": "Parses a glTF node hierarchy that is known to contain \"name\" attributes on the nodes.\n\nCreate a XKTMesh for each mesh primitive, and XKTEntity for each named node.\n\nFollowing a depth-first traversal, each XKTEntity is created on post-visit of each named node,\nand gets all the XKTMeshes created since the last XKTEntity created.",
    "lineNumber": 496,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 431,
    "kind": "function",
    "name": "parseNodeMatrix",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseNodeMatrix",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": "Parses transform at the given glTF node.",
    "lineNumber": 555,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{*} Transform matrix for the node"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": "the glTF node"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "matrix",
        "description": "Transfor matrix from parent nodes"
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "Transform matrix for the node"
    },
    "ignore": true
  },
  {
    "__docId__": 432,
    "kind": "function",
    "name": "createPrimitiveHash",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~createPrimitiveHash",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 595,
    "undocument": true,
    "params": [
      {
        "name": "primitive",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 433,
    "kind": "function",
    "name": "parseNodeMesh",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseNodeMesh",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": null,
    "description": "Parses primitives referenced by the mesh belonging to the given node, creating XKTMeshes in the XKTModel.",
    "lineNumber": 617,
    "params": [
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "node",
        "description": "glTF node"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "ctx",
        "description": "Parsing context"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "matrix",
        "description": "Matrix for the XKTMeshes"
      },
      {
        "nullable": null,
        "types": [
          "*"
        ],
        "spread": false,
        "optional": false,
        "name": "meshIds",
        "description": "returns IDs of the new XKTMeshes"
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 434,
    "kind": "function",
    "name": "parseGLTFIntoXKTModel",
    "memberof": "src/parsers/parseGLTFIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFIntoXKTModel.js~parseGLTFIntoXKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFIntoXKTModel.js",
    "importStyle": "{parseGLTFIntoXKTModel}",
    "description": "Parses glTF into an {@link XKTModel}, supporting ````.glb```` and textures.\n\n* Supports ````.glb```` and textures\n* For a lightweight glTF JSON parser that ignores textures, see {@link parseGLTFJSONIntoXKTModel}.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then load a binary glTF model into it.\n\n````javascript\nutils.loadArraybuffer(\"../assets/models/gltf/HousePlan/glTF-Binary/HousePlan.glb\", async (data) => {\n\n    const xktModel = new XKTModel();\n\n    parseGLTFIntoXKTModel({\n         data,\n         xktModel,\n         log: (msg) => { console.log(msg); }\n    }).then(()=>{\n       xktModel.finalize();\n    },\n    (msg) => {\n        console.error(msg);\n    });\n});\n````",
    "lineNumber": 60,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} Resolves when glTF has been parsed."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Parsing parameters."
      },
      {
        "nullable": null,
        "types": [
          "ArrayBuffer"
        ],
        "spread": false,
        "optional": false,
        "name": "params.data",
        "description": "The glTF."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "params.baseUri",
        "description": "The base URI used to load this glTF, if any. For resolving relative uris to linked resources."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "params.metaModelData",
        "description": "Metamodel JSON. If this is provided, then parsing is able to ensure that the XKTObjects it creates will fit the metadata properly."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "params.xktModel",
        "description": "XKTModel to parse into."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "params.includeTextures",
        "description": "Whether to parse textures."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "params.includeNormals",
        "description": "Whether to parse normals. When false, the parser will ignore the glTF\ngeometry normals, and the glTF data will rely on the xeokit ````Viewer```` to automatically generate them. This has\nthe limitation that the normals will be face-aligned, and therefore the ````Viewer```` will only be able to render\na flat-shaded non-PBR representation of the glTF."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "params.stats",
        "description": "Collects statistics."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.log",
        "description": "Logging callback."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Resolves when glTF has been parsed."
    }
  },
  {
    "__docId__": 435,
    "kind": "file",
    "name": "src/parsers/parseGLTFJSONIntoXKTModel.js",
    "content": "import {utils} from \"../XKTModel/lib/utils.js\";\nimport {math} from \"../lib/math.js\";\n\nconst atob2 = (typeof atob !== 'undefined') ? atob : a => Buffer.from(a, 'base64').toString('binary');\n\nconst WEBGL_COMPONENT_TYPES = {\n    5120: Int8Array,\n    5121: Uint8Array,\n    5122: Int16Array,\n    5123: Uint16Array,\n    5125: Uint32Array,\n    5126: Float32Array\n};\n\nconst WEBGL_TYPE_SIZES = {\n    'SCALAR': 1,\n    'VEC2': 2,\n    'VEC3': 3,\n    'VEC4': 4,\n    'MAT2': 4,\n    'MAT3': 9,\n    'MAT4': 16\n};\n\n/**\n * @desc Parses glTF JSON into an {@link XKTModel}, without ````.glb```` and textures.\n *\n * * Lightweight JSON-based glTF parser which ignores textures\n * * For texture and ````.glb```` support, see {@link parseGLTFIntoXKTModel}\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then load a glTF model into it.\n *\n * ````javascript\n * utils.loadJSON(\"./models/gltf/duplex/scene.gltf\", async (data) => {\n *\n *     const xktModel = new XKTModel();\n *\n *     parseGLTFJSONIntoXKTModel({\n *          data,\n *          xktModel,\n *          log: (msg) => { console.log(msg); }\n *     }).then(()=>{\n *        xktModel.finalize();\n *     },\n *     (msg) => {\n *         console.error(msg);\n *     });\n * });\n * ````\n *\n * @param {Object} params Parsing parameters.\n * @param {Object} params.data The glTF JSON.\n * @param {Object} [params.metaModelData] Metamodel JSON. If this is provided, then parsing is able to ensure that the XKTObjects it creates will fit the metadata properly.\n * @param {XKTModel} params.xktModel XKTModel to parse into.\n * @param {Boolean} [params.includeNormals=false] Whether to parse normals. When false, the parser will ignore the glTF\n * geometry normals, and the glTF data will rely on the xeokit ````Viewer```` to automatically generate them. This has\n * the limitation that the normals will be face-aligned, and therefore the ````Viewer```` will only be able to render\n * a flat-shaded representation of the glTF.\n * @param {Boolean} [params.reuseGeometries=true] When true, the parser will enable geometry reuse within the XKTModel. When false,\n * will automatically \"expand\" all reused geometries into duplicate copies. This has the drawback of increasing the XKT\n * file size (~10-30% for typical models), but can make the model more responsive in the xeokit Viewer, especially if the model\n * has excessive geometry reuse. An example of excessive geometry reuse would be if we have 4000 geometries that are\n * shared amongst 2000 objects, ie. a large number of geometries with a low amount of reuse, which can present a\n * pathological performance case for xeokit's underlying graphics APIs (WebGL, WebGPU etc).\n * @param {function} [params.getAttachment] Callback through which to fetch attachments, if the glTF has them.\n * @param {Object} [params.stats] Collects statistics.\n * @param {function} [params.log] Logging callback.\n * @returns {Promise}\n */\nfunction parseGLTFJSONIntoXKTModel({\n                                       data,\n                                       xktModel,\n                                       metaModelData,\n                                       includeNormals,\n                                       reuseGeometries,\n                                       getAttachment,\n                                       stats = {},\n                                       log\n                                   }) {\n\n    if (log) {\n        log(\"Using parser: parseGLTFJSONIntoXKTModel\");\n    }\n\n    return new Promise(function (resolve, reject) {\n\n        if (!data) {\n            reject(\"Argument expected: data\");\n            return;\n        }\n\n        if (!xktModel) {\n            reject(\"Argument expected: xktModel\");\n            return;\n        }\n\n        stats.sourceFormat = \"glTF\";\n        stats.schemaVersion = \"2.0\";\n        stats.title = \"\";\n        stats.author = \"\";\n        stats.created = \"\";\n        stats.numTriangles = 0;\n        stats.numVertices = 0;\n        stats.numNormals = 0;\n        stats.numObjects = 0;\n        stats.numGeometries = 0;\n\n        const ctx = {\n            gltf: data,\n            metaModelCorrections: metaModelData ? getMetaModelCorrections(metaModelData) : null,\n            getAttachment: getAttachment || (() => {\n                throw new Error('You must define getAttachment() method to convert glTF with external resources')\n            }),\n            log: (log || function (msg) {\n            }),\n            xktModel,\n            includeNormals,\n            createXKTGeometryIds: {},\n            nextMeshId: 0,\n            reuseGeometries: (reuseGeometries !== false),\n            stats\n        };\n\n        ctx.log(`Parsing normals: ${ctx.includeNormals ? \"enabled\" : \"disabled\"}`);\n\n        parseBuffers(ctx).then(() => {\n\n            parseBufferViews(ctx);\n            freeBuffers(ctx);\n            parseMaterials(ctx);\n            parseDefaultScene(ctx);\n\n            resolve();\n\n        }, (errMsg) => {\n            reject(errMsg);\n        });\n    });\n}\n\nfunction getMetaModelCorrections(metaModelData) {\n    const eachRootStats = {};\n    const eachChildRoot = {};\n    const metaObjects = metaModelData.metaObjects || [];\n    const metaObjectsMap = {};\n    for (let i = 0, len = metaObjects.length; i < len; i++) {\n        const metaObject = metaObjects[i];\n        metaObjectsMap[metaObject.id] = metaObject;\n    }\n    for (let i = 0, len = metaObjects.length; i < len; i++) {\n        const metaObject = metaObjects[i];\n        if (metaObject.parent !== undefined && metaObject.parent !== null) {\n            const metaObjectParent = metaObjectsMap[metaObject.parent];\n            if (metaObject.type === metaObjectParent.type) {\n                let rootMetaObject = metaObjectParent;\n                while (rootMetaObject.parent && metaObjectsMap[rootMetaObject.parent].type === rootMetaObject.type) {\n                    rootMetaObject = metaObjectsMap[rootMetaObject.parent];\n                }\n                const rootStats = eachRootStats[rootMetaObject.id] || (eachRootStats[rootMetaObject.id] = {\n                    numChildren: 0,\n                    countChildren: 0\n                });\n                rootStats.numChildren++;\n                eachChildRoot[metaObject.id] = rootMetaObject;\n            } else {\n\n            }\n        }\n    }\n    const metaModelCorrections = {\n        metaObjectsMap,\n        eachRootStats,\n        eachChildRoot\n    };\n    return metaModelCorrections;\n}\n\nfunction parseBuffers(ctx) {  // Parses geometry buffers into temporary  \"_buffer\" Unit8Array properties on the glTF \"buffer\" elements\n    const buffers = ctx.gltf.buffers;\n    if (buffers) {\n        return Promise.all(buffers.map(buffer => parseBuffer(ctx, buffer)));\n    } else {\n        return new Promise(function (resolve, reject) {\n            resolve();\n        });\n    }\n}\n\nfunction parseBuffer(ctx, bufferInfo) {\n    return new Promise(function (resolve, reject) {\n        // Allow a shortcut where the glTF buffer is \"enrichened\" with direct\n        // access to the data-arrayBuffer, w/out needing to either:\n        // - read the file indicated by the \".uri\" component of the buffer\n        // - base64-decode the encoded data in the \".uri\" component\n        if (bufferInfo._arrayBuffer) {\n            bufferInfo._buffer = bufferInfo._arrayBuffer;\n            resolve(bufferInfo);\n            return;\n        }\n        // Otherwise, proceed with \"standard-glTF\" .uri component.\n        const uri = bufferInfo.uri;\n        if (!uri) {\n            reject('gltf/handleBuffer missing uri in ' + JSON.stringify(bufferInfo));\n            return;\n        }\n        parseArrayBuffer(ctx, uri).then((arrayBuffer) => {\n            bufferInfo._buffer = arrayBuffer;\n            resolve(arrayBuffer);\n        }, (errMsg) => {\n            reject(errMsg);\n        })\n    });\n}\n\nfunction parseArrayBuffer(ctx, uri) {\n    return new Promise(function (resolve, reject) {\n        const dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/; // Check for data: URI\n        const dataUriRegexResult = uri.match(dataUriRegex);\n        if (dataUriRegexResult) { // Safari can't handle data URIs through XMLHttpRequest\n            const isBase64 = !!dataUriRegexResult[2];\n            let data = dataUriRegexResult[3];\n            data = decodeURIComponent(data);\n            if (isBase64) {\n                data = atob2(data);\n            }\n            const buffer = new ArrayBuffer(data.length);\n            const view = new Uint8Array(buffer);\n            for (let i = 0; i < data.length; i++) {\n                view[i] = data.charCodeAt(i);\n            }\n            resolve(buffer);\n        } else { // Uri is a path to a file\n            ctx.getAttachment(uri).then(\n                (arrayBuffer) => {\n                    resolve(arrayBuffer);\n                },\n                (errMsg) => {\n                    reject(errMsg);\n                });\n        }\n    });\n}\n\nfunction parseBufferViews(ctx) { // Parses our temporary \"_buffer\" properties into \"_buffer\" properties on glTF \"bufferView\" elements\n    const bufferViewsInfo = ctx.gltf.bufferViews;\n    if (bufferViewsInfo) {\n        for (let i = 0, len = bufferViewsInfo.length; i < len; i++) {\n            parseBufferView(ctx, bufferViewsInfo[i]);\n        }\n    }\n}\n\nfunction parseBufferView(ctx, bufferViewInfo) {\n    const buffer = ctx.gltf.buffers[bufferViewInfo.buffer];\n    bufferViewInfo._typedArray = null;\n    const byteLength = bufferViewInfo.byteLength || 0;\n    const byteOffset = bufferViewInfo.byteOffset || 0;\n    bufferViewInfo._buffer = buffer._buffer.slice(byteOffset, byteOffset + byteLength);\n}\n\nfunction freeBuffers(ctx) { // Deletes the \"_buffer\" properties from the glTF \"buffer\" elements, to save memory\n    const buffers = ctx.gltf.buffers;\n    if (buffers) {\n        for (let i = 0, len = buffers.length; i < len; i++) {\n            buffers[i]._buffer = null;\n        }\n    }\n}\n\nfunction parseMaterials(ctx) {\n    const materialsInfo = ctx.gltf.materials;\n    if (materialsInfo) {\n        for (let i = 0, len = materialsInfo.length; i < len; i++) {\n            const materialInfo = materialsInfo[i];\n            const material = parseMaterial(ctx, materialInfo);\n            materialInfo._materialData = material;\n        }\n    }\n}\n\nfunction parseMaterial(ctx, materialInfo) { // Attempts to extract an RGBA color for a glTF material\n    const material = {\n        color: new Float32Array([1, 1, 1]),\n        opacity: 1.0,\n        metallic: 0,\n        roughness: 1\n    };\n    const extensions = materialInfo.extensions;\n    if (extensions) {\n        const specularPBR = extensions[\"KHR_materials_pbrSpecularGlossiness\"];\n        if (specularPBR) {\n            const diffuseFactor = specularPBR.diffuseFactor;\n            if (diffuseFactor !== null && diffuseFactor !== undefined) {\n                material.color[0] = diffuseFactor[0];\n                material.color[1] = diffuseFactor[1];\n                material.color[2] = diffuseFactor[2];\n            }\n        }\n        const common = extensions[\"KHR_materials_common\"];\n        if (common) {\n            const technique = common.technique;\n            const values = common.values || {};\n            const blinn = technique === \"BLINN\";\n            const phong = technique === \"PHONG\";\n            const lambert = technique === \"LAMBERT\";\n            const diffuse = values.diffuse;\n            if (diffuse && (blinn || phong || lambert)) {\n                if (!utils.isString(diffuse)) {\n                    material.color[0] = diffuse[0];\n                    material.color[1] = diffuse[1];\n                    material.color[2] = diffuse[2];\n                }\n            }\n            const transparency = values.transparency;\n            if (transparency !== null && transparency !== undefined) {\n                material.opacity = transparency;\n            }\n            const transparent = values.transparent;\n            if (transparent !== null && transparent !== undefined) {\n                material.opacity = transparent;\n            }\n        }\n    }\n    const metallicPBR = materialInfo.pbrMetallicRoughness;\n    if (metallicPBR) {\n        const baseColorFactor = metallicPBR.baseColorFactor;\n        if (baseColorFactor) {\n            material.color[0] = baseColorFactor[0];\n            material.color[1] = baseColorFactor[1];\n            material.color[2] = baseColorFactor[2];\n            material.opacity = baseColorFactor[3];\n        }\n        const metallicFactor = metallicPBR.metallicFactor;\n        if (metallicFactor !== null && metallicFactor !== undefined) {\n            material.metallic = metallicFactor;\n        }\n        const roughnessFactor = metallicPBR.roughnessFactor;\n        if (roughnessFactor !== null && roughnessFactor !== undefined) {\n            material.roughness = roughnessFactor;\n        }\n    }\n    return material;\n}\n\nfunction parseDefaultScene(ctx) {\n    const scene = ctx.gltf.scene || 0;\n    const defaultSceneInfo = ctx.gltf.scenes[scene];\n    if (!defaultSceneInfo) {\n        throw new Error(\"glTF has no default scene\");\n    }\n    parseScene(ctx, defaultSceneInfo);\n}\n\n\nfunction parseScene(ctx, sceneInfo) {\n    const nodes = sceneInfo.nodes;\n    if (!nodes) {\n        return;\n    }\n    for (let i = 0, len = nodes.length; i < len; i++) {\n        const glTFNode = ctx.gltf.nodes[nodes[i]];\n        if (glTFNode) {\n            parseNode(ctx, glTFNode, 0, null);\n        }\n    }\n}\n\nlet deferredMeshIds = [];\n\nfunction parseNode(ctx, glTFNode, depth, matrix) {\n\n    const gltf = ctx.gltf;\n    const xktModel = ctx.xktModel;\n\n    let localMatrix;\n\n    if (glTFNode.matrix) {\n        localMatrix = glTFNode.matrix;\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, math.mat4());\n        } else {\n            matrix = localMatrix;\n        }\n    }\n\n    if (glTFNode.translation) {\n        localMatrix = math.translationMat4v(glTFNode.translation);\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, localMatrix);\n        } else {\n            matrix = localMatrix;\n        }\n    }\n\n    if (glTFNode.rotation) {\n        localMatrix = math.quaternionToMat4(glTFNode.rotation);\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, localMatrix);\n        } else {\n            matrix = localMatrix;\n        }\n    }\n\n    if (glTFNode.scale) {\n        localMatrix = math.scalingMat4v(glTFNode.scale);\n        if (matrix) {\n            matrix = math.mulMat4(matrix, localMatrix, localMatrix);\n        } else {\n            matrix = localMatrix;\n        }\n    }\n\n    const gltfMeshId = glTFNode.mesh;\n\n    if (gltfMeshId !== undefined) {\n\n        const meshInfo = gltf.meshes[gltfMeshId];\n\n        if (meshInfo) {\n\n            const numPrimitivesInMesh = meshInfo.primitives.length;\n\n            if (numPrimitivesInMesh > 0) {\n\n                for (let i = 0; i < numPrimitivesInMesh; i++) {\n\n                    const primitiveInfo = meshInfo.primitives[i];\n\n                    const geometryHash = createPrimitiveGeometryHash(primitiveInfo);\n\n                    let xktGeometryId = ctx.createXKTGeometryIds[geometryHash];\n\n                    if ((!ctx.reuseGeometries) || !xktGeometryId) {\n\n                        xktGeometryId = \"geometry-\" + ctx.nextMeshId++\n\n                        const geometryArrays = {};\n\n                        parsePrimitiveGeometry(ctx, primitiveInfo, geometryArrays);\n\n                        const colors = geometryArrays.colors;\n\n                        let colorsCompressed;\n\n                        if (geometryArrays.colors) {\n                            colorsCompressed = [];\n                            for (let j = 0, lenj = colors.length; j < lenj; j += 4) {\n                                colorsCompressed.push(colors[j + 0]);\n                                colorsCompressed.push(colors[j + 1]);\n                                colorsCompressed.push(colors[j + 2]);\n                                colorsCompressed.push(255);\n                            }\n                        }\n\n                        xktModel.createGeometry({\n                            geometryId: xktGeometryId,\n                            primitiveType: geometryArrays.primitive,\n                            positions: geometryArrays.positions,\n                            normals: ctx.includeNormals ? geometryArrays.normals : null,\n                            colorsCompressed: colorsCompressed,\n                            indices: geometryArrays.indices\n                        });\n\n                        ctx.stats.numGeometries++;\n                        ctx.stats.numVertices += geometryArrays.positions ? geometryArrays.positions.length / 3 : 0;\n                        ctx.stats.numNormals += (ctx.includeNormals && geometryArrays.normals) ? geometryArrays.normals.length / 3 : 0;\n                        ctx.stats.numTriangles += geometryArrays.indices ? geometryArrays.indices.length / 3 : 0;\n\n                        ctx.createXKTGeometryIds[geometryHash] = xktGeometryId;\n                    } else {\n// Geometry reused\n                    }\n\n                    const materialIndex = primitiveInfo.material;\n                    const materialInfo = (materialIndex !== null && materialIndex !== undefined) ? gltf.materials[materialIndex] : null;\n                    const color = materialInfo ? materialInfo._materialData.color : new Float32Array([1.0, 1.0, 1.0, 1.0]);\n                    const opacity = materialInfo ? materialInfo._materialData.opacity : 1.0;\n                    const metallic = materialInfo ? materialInfo._materialData.metallic : 0.0;\n                    const roughness = materialInfo ? materialInfo._materialData.roughness : 1.0;\n\n                    const xktMeshId = \"mesh-\" + ctx.nextMeshId++;\n\n                    xktModel.createMesh({\n                        meshId: xktMeshId,\n                        geometryId: xktGeometryId,\n                        matrix: matrix ? matrix.slice() : math.identityMat4(),\n                        color: color,\n                        opacity: opacity,\n                        metallic: metallic,\n                        roughness: roughness\n                    });\n\n                    deferredMeshIds.push(xktMeshId);\n                }\n            }\n        }\n    }\n\n\n    if (glTFNode.children) {\n        const children = glTFNode.children;\n        for (let i = 0, len = children.length; i < len; i++) {\n            const childNodeIdx = children[i];\n            const childGLTFNode = gltf.nodes[childNodeIdx];\n            if (!childGLTFNode) {\n                console.warn('Node not found: ' + i);\n                continue;\n            }\n            parseNode(ctx, childGLTFNode, depth + 1, matrix);\n        }\n    }\n\n    // Post-order visit scene node\n\n    const nodeName = glTFNode.name;\n    if (((nodeName !== undefined && nodeName !== null) || depth === 0) && deferredMeshIds.length > 0) {\n        if (nodeName === undefined || nodeName === null) {\n            ctx.log(`[parseGLTFJSONIntoXKTModel] Warning: 'name' properties not found on glTF scene nodes - will randomly-generate object IDs in XKT`);\n        }\n        let xktEntityId = nodeName; // Fall back on generated ID when `name` not found on glTF scene node(s)\n        if (xktEntityId === undefined || xktEntityId === null) {\n            if (xktModel.entities[xktEntityId]) {\n                ctx.error(\"Two or more glTF nodes found with same 'name' attribute: '\" + nodeName + \"'\");\n            }\n            while (!xktEntityId || xktModel.entities[xktEntityId]) {\n                xktEntityId = \"entity-\" + ctx.nextId++;\n            }\n        }\n        if (ctx.metaModelCorrections) {  // Merging meshes into XKTObjects that map to metaobjects\n            const rootMetaObject = ctx.metaModelCorrections.eachChildRoot[xktEntityId];\n            if (rootMetaObject) {\n                const rootMetaObjectStats = ctx.metaModelCorrections.eachRootStats[rootMetaObject.id];\n                rootMetaObjectStats.countChildren++;\n                if (rootMetaObjectStats.countChildren >= rootMetaObjectStats.numChildren) {\n                    xktModel.createEntity({\n                        entityId: rootMetaObject.id,\n                        meshIds: deferredMeshIds\n                    });\n                    ctx.stats.numObjects++;\n                    deferredMeshIds = [];\n                }\n            } else {\n                const metaObject = ctx.metaModelCorrections.metaObjectsMap[xktEntityId];\n                if (metaObject) {\n                    xktModel.createEntity({\n                        entityId: xktEntityId,\n                        meshIds: deferredMeshIds\n                    });\n                    ctx.stats.numObjects++;\n                    deferredMeshIds = [];\n                }\n            }\n        } else { // Create an XKTObject from the meshes at each named glTF node, don't care about metaobjects\n            xktModel.createEntity({\n                entityId: xktEntityId,\n                meshIds: deferredMeshIds\n            });\n            ctx.stats.numObjects++;\n            deferredMeshIds = [];\n        }\n    }\n}\n\nfunction createPrimitiveGeometryHash(primitiveInfo) {\n    const attributes = primitiveInfo.attributes;\n    if (!attributes) {\n        return \"empty\";\n    }\n    const mode = primitiveInfo.mode;\n    const material = primitiveInfo.material;\n    const indices = primitiveInfo.indices;\n    const positions = primitiveInfo.attributes.POSITION;\n    const normals = primitiveInfo.attributes.NORMAL;\n    const colors = primitiveInfo.attributes.COLOR_0;\n    const uv = primitiveInfo.attributes.TEXCOORD_0;\n    return [\n        mode,\n        //  material,\n        (indices !== null && indices !== undefined) ? indices : \"-\",\n        (positions !== null && positions !== undefined) ? positions : \"-\",\n        (normals !== null && normals !== undefined) ? normals : \"-\",\n        (colors !== null && colors !== undefined) ? colors : \"-\",\n        (uv !== null && uv !== undefined) ? uv : \"-\"\n    ].join(\";\");\n}\n\nfunction parsePrimitiveGeometry(ctx, primitiveInfo, geometryArrays) {\n    const attributes = primitiveInfo.attributes;\n    if (!attributes) {\n        return;\n    }\n    switch (primitiveInfo.mode) {\n        case 0: // POINTS\n            geometryArrays.primitive = \"points\";\n            break;\n        case 1: // LINES\n            geometryArrays.primitive = \"lines\";\n            break;\n        case 2: // LINE_LOOP\n            // TODO: convert\n            geometryArrays.primitive = \"lines\";\n            break;\n        case 3: // LINE_STRIP\n            // TODO: convert\n            geometryArrays.primitive = \"lines\";\n            break;\n        case 4: // TRIANGLES\n            geometryArrays.primitive = \"triangles\";\n            break;\n        case 5: // TRIANGLE_STRIP\n            // TODO: convert\n            console.log(\"TRIANGLE_STRIP\");\n            geometryArrays.primitive = \"triangles\";\n            break;\n        case 6: // TRIANGLE_FAN\n            // TODO: convert\n            console.log(\"TRIANGLE_FAN\");\n            geometryArrays.primitive = \"triangles\";\n            break;\n        default:\n            geometryArrays.primitive = \"triangles\";\n    }\n    const accessors = ctx.gltf.accessors;\n    const indicesIndex = primitiveInfo.indices;\n    if (indicesIndex !== null && indicesIndex !== undefined) {\n        const accessorInfo = accessors[indicesIndex];\n        geometryArrays.indices = parseAccessorTypedArray(ctx, accessorInfo);\n    }\n    const positionsIndex = attributes.POSITION;\n    if (positionsIndex !== null && positionsIndex !== undefined) {\n        const accessorInfo = accessors[positionsIndex];\n        geometryArrays.positions = parseAccessorTypedArray(ctx, accessorInfo);\n    }\n    const normalsIndex = attributes.NORMAL;\n    if (normalsIndex !== null && normalsIndex !== undefined) {\n        const accessorInfo = accessors[normalsIndex];\n        geometryArrays.normals = parseAccessorTypedArray(ctx, accessorInfo);\n    }\n    const colorsIndex = attributes.COLOR_0;\n    if (colorsIndex !== null && colorsIndex !== undefined) {\n        const accessorInfo = accessors[colorsIndex];\n        geometryArrays.colors = parseAccessorTypedArray(ctx, accessorInfo);\n    }\n}\n\nfunction parseAccessorTypedArray(ctx, accessorInfo) {\n    const bufferView = ctx.gltf.bufferViews[accessorInfo.bufferView];\n    const itemSize = WEBGL_TYPE_SIZES[accessorInfo.type];\n    const TypedArray = WEBGL_COMPONENT_TYPES[accessorInfo.componentType];\n    const elementBytes = TypedArray.BYTES_PER_ELEMENT; // For VEC3: itemSize is 3, elementBytes is 4, itemBytes is 12.\n    const itemBytes = elementBytes * itemSize;\n    if (accessorInfo.byteStride && accessorInfo.byteStride !== itemBytes) { // The buffer is not interleaved if the stride is the item size in bytes.\n        throw new Error(\"interleaved buffer!\"); // TODO\n    } else {\n        return new TypedArray(bufferView._buffer, accessorInfo.byteOffset || 0, accessorInfo.count * itemSize);\n    }\n}\n\nexport {parseGLTFJSONIntoXKTModel};\n",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/parsers/parseGLTFJSONIntoXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 436,
    "kind": "variable",
    "name": "atob2",
    "memberof": "src/parsers/parseGLTFJSONIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseGLTFJSONIntoXKTModel.js~atob2",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 4,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 437,
    "kind": "variable",
    "name": "WEBGL_COMPONENT_TYPES",
    "memberof": "src/parsers/parseGLTFJSONIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseGLTFJSONIntoXKTModel.js~WEBGL_COMPONENT_TYPES",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "{\"5120\": *, \"5121\": *, \"5122\": *, \"5123\": *, \"5125\": *, \"5126\": *}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 438,
    "kind": "variable",
    "name": "WEBGL_TYPE_SIZES",
    "memberof": "src/parsers/parseGLTFJSONIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseGLTFJSONIntoXKTModel.js~WEBGL_TYPE_SIZES",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "{\"SCALAR\": number, \"VEC2\": number, \"VEC3\": number, \"VEC4\": number, \"MAT2\": number, \"MAT3\": number, \"MAT4\": number}"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 439,
    "kind": "function",
    "name": "getMetaModelCorrections",
    "memberof": "src/parsers/parseGLTFJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFJSONIntoXKTModel.js~getMetaModelCorrections",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 143,
    "undocument": true,
    "params": [
      {
        "name": "metaModelData",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 440,
    "kind": "function",
    "name": "parseBuffers",
    "memberof": "src/parsers/parseGLTFJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFJSONIntoXKTModel.js~parseBuffers",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 180,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 441,
    "kind": "function",
    "name": "parseBuffer",
    "memberof": "src/parsers/parseGLTFJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFJSONIntoXKTModel.js~parseBuffer",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 191,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "bufferInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 442,
    "kind": "function",
    "name": "parseArrayBuffer",
    "memberof": "src/parsers/parseGLTFJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFJSONIntoXKTModel.js~parseArrayBuffer",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 217,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "uri",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 443,
    "kind": "function",
    "name": "parseBufferViews",
    "memberof": "src/parsers/parseGLTFJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFJSONIntoXKTModel.js~parseBufferViews",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 246,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 444,
    "kind": "function",
    "name": "parseBufferView",
    "memberof": "src/parsers/parseGLTFJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFJSONIntoXKTModel.js~parseBufferView",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 255,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "bufferViewInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 445,
    "kind": "function",
    "name": "freeBuffers",
    "memberof": "src/parsers/parseGLTFJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFJSONIntoXKTModel.js~freeBuffers",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 263,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 446,
    "kind": "function",
    "name": "parseMaterials",
    "memberof": "src/parsers/parseGLTFJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFJSONIntoXKTModel.js~parseMaterials",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 272,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 447,
    "kind": "function",
    "name": "parseMaterial",
    "memberof": "src/parsers/parseGLTFJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFJSONIntoXKTModel.js~parseMaterial",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 283,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "materialInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 448,
    "kind": "function",
    "name": "parseDefaultScene",
    "memberof": "src/parsers/parseGLTFJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFJSONIntoXKTModel.js~parseDefaultScene",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 347,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 449,
    "kind": "function",
    "name": "parseScene",
    "memberof": "src/parsers/parseGLTFJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFJSONIntoXKTModel.js~parseScene",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 357,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "sceneInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 450,
    "kind": "variable",
    "name": "deferredMeshIds",
    "memberof": "src/parsers/parseGLTFJSONIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseGLTFJSONIntoXKTModel.js~deferredMeshIds",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 370,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 451,
    "kind": "function",
    "name": "parseNode",
    "memberof": "src/parsers/parseGLTFJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFJSONIntoXKTModel.js~parseNode",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 372,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "glTFNode",
        "types": [
          "*"
        ]
      },
      {
        "name": "depth",
        "types": [
          "*"
        ]
      },
      {
        "name": "matrix",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 452,
    "kind": "function",
    "name": "createPrimitiveGeometryHash",
    "memberof": "src/parsers/parseGLTFJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFJSONIntoXKTModel.js~createPrimitiveGeometryHash",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 566,
    "undocument": true,
    "params": [
      {
        "name": "primitiveInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 453,
    "kind": "function",
    "name": "parsePrimitiveGeometry",
    "memberof": "src/parsers/parseGLTFJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFJSONIntoXKTModel.js~parsePrimitiveGeometry",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 589,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "primitiveInfo",
        "types": [
          "*"
        ]
      },
      {
        "name": "geometryArrays",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 454,
    "kind": "function",
    "name": "parseAccessorTypedArray",
    "memberof": "src/parsers/parseGLTFJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFJSONIntoXKTModel.js~parseAccessorTypedArray",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFJSONIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 648,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "accessorInfo",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 455,
    "kind": "function",
    "name": "parseGLTFJSONIntoXKTModel",
    "memberof": "src/parsers/parseGLTFJSONIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseGLTFJSONIntoXKTModel.js~parseGLTFJSONIntoXKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseGLTFJSONIntoXKTModel.js",
    "importStyle": "{parseGLTFJSONIntoXKTModel}",
    "description": "Parses glTF JSON into an {@link XKTModel}, without ````.glb```` and textures.\n\n* Lightweight JSON-based glTF parser which ignores textures\n* For texture and ````.glb```` support, see {@link parseGLTFIntoXKTModel}\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then load a glTF model into it.\n\n````javascript\nutils.loadJSON(\"./models/gltf/duplex/scene.gltf\", async (data) => {\n\n    const xktModel = new XKTModel();\n\n    parseGLTFJSONIntoXKTModel({\n         data,\n         xktModel,\n         log: (msg) => { console.log(msg); }\n    }).then(()=>{\n       xktModel.finalize();\n    },\n    (msg) => {\n        console.error(msg);\n    });\n});\n````",
    "lineNumber": 72,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise}"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Parsing parameters."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.data",
        "description": "The glTF JSON."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "params.metaModelData",
        "description": "Metamodel JSON. If this is provided, then parsing is able to ensure that the XKTObjects it creates will fit the metadata properly."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "params.xktModel",
        "description": "XKTModel to parse into."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "params.includeNormals",
        "description": "Whether to parse normals. When false, the parser will ignore the glTF\ngeometry normals, and the glTF data will rely on the xeokit ````Viewer```` to automatically generate them. This has\nthe limitation that the normals will be face-aligned, and therefore the ````Viewer```` will only be able to render\na flat-shaded representation of the glTF."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "params.reuseGeometries",
        "description": "When true, the parser will enable geometry reuse within the XKTModel. When false,\nwill automatically \"expand\" all reused geometries into duplicate copies. This has the drawback of increasing the XKT\nfile size (~10-30% for typical models), but can make the model more responsive in the xeokit Viewer, especially if the model\nhas excessive geometry reuse. An example of excessive geometry reuse would be if we have 4000 geometries that are\nshared amongst 2000 objects, ie. a large number of geometries with a low amount of reuse, which can present a\npathological performance case for xeokit's underlying graphics APIs (WebGL, WebGPU etc)."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.getAttachment",
        "description": "Callback through which to fetch attachments, if the glTF has them."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "params.stats",
        "description": "Collects statistics."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.log",
        "description": "Logging callback."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": ""
    }
  },
  {
    "__docId__": 456,
    "kind": "file",
    "name": "src/parsers/parseIFCIntoXKTModel.js",
    "content": "/**\n * @desc Parses IFC STEP file data into an {@link XKTModel}.\n *\n * This function uses [web-ifc](https://github.com/tomvandig/web-ifc) to parse the IFC, which relies on a\n * WASM file to do the parsing.\n *\n * Depending on how we use this function, we may need to provide it with a path to the directory where that WASM file is stored.\n *\n * This function is tested with web-ifc version 0.0.34.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then load an IFC model into it.\n *\n * ````javascript\n * import {XKTModel, parseIFCIntoXKTModel, writeXKTModelToArrayBuffer} from \"xeokit-convert.es.js\";\n *\n * import * as WebIFC from \"web-ifc-api.js\";\n *\n * utils.loadArraybuffer(\"rac_advanced_sample_project.ifc\", async (data) => {\n *\n *     const xktModel = new XKTModel();\n *\n *     parseIFCIntoXKTModel({\n *          WebIFC,\n *          data,\n *          xktModel,\n *          wasmPath: \"../dist/\",\n *          autoNormals: true,\n *          log: (msg) => { console.log(msg); }\n *     }).then(()=>{\n *        xktModel.finalize();\n *     },\n *     (msg) => {\n *         console.error(msg);\n *     });\n * });\n * ````\n *\n * @param {Object} params Parsing params.\n * @param {Object} params.WebIFC The WebIFC library. We pass this in as an external dependency, in order to give the\n * caller the choice of whether to use the Browser or NodeJS version.\n * @param {ArrayBuffer} [params.data] IFC file data.\n * @param {XKTModel} [params.xktModel] XKTModel to parse into.\n * @param {Boolean} [params.autoNormals=true] When true, the parser will ignore the IFC geometry normals, and the IFC\n * data will rely on the xeokit ````Viewer```` to automatically generate them. This has the limitation that the\n * normals will be face-aligned, and therefore the ````Viewer```` will only be able to render a flat-shaded representation\n * of the IFC model. This is ````true```` by default, because IFC models tend to look acceptable with flat-shading,\n * and we always want to minimize IFC model size wherever possible.\n * @param {String[]} [params.includeTypes] Option to only convert objects of these types.\n * @param {String[]} [params.excludeTypes] Option to never convert objects of these types.\n * @param {String} params.wasmPath Path to ````web-ifc.wasm````, required by this function.\n * @param {Object} [params.stats={}] Collects statistics.\n * @param {function} [params.log] Logging callback.\n * @returns {Promise} Resolves when IFC has been parsed.\n */\nfunction parseIFCIntoXKTModel({\n                                  WebIFC,\n                                  data,\n                                  xktModel,\n                                  autoNormals = true,\n                                  includeTypes,\n                                  excludeTypes,\n                                  wasmPath,\n                                  stats = {},\n                                  log\n                              }) {\n\n    if (log) {\n        log(\"Using parser: parseIFCIntoXKTModel\");\n    }\n\n    return new Promise(function (resolve, reject) {\n\n        if (!data) {\n            reject(\"Argument expected: data\");\n            return;\n        }\n\n        if (!xktModel) {\n            reject(\"Argument expected: xktModel\");\n            return;\n        }\n\n        if (!wasmPath) {\n            reject(\"Argument expected: wasmPath\");\n            return;\n        }\n\n        const ifcAPI = new WebIFC.IfcAPI();\n\n        if (wasmPath) {\n            ifcAPI.SetWasmPath(wasmPath);\n        }\n\n        ifcAPI.Init().then(() => {\n\n            const dataArray = new Uint8Array(data);\n\n            const modelID = ifcAPI.OpenModel(dataArray);\n\n            stats.sourceFormat = \"IFC\";\n            stats.schemaVersion = \"\";\n            stats.title = \"\";\n            stats.author = \"\";\n            stats.created = \"\";\n            stats.numMetaObjects = 0;\n            stats.numPropertySets = 0;\n            stats.numObjects = 0;\n            stats.numGeometries = 0;\n            stats.numTriangles = 0;\n            stats.numVertices = 0;\n\n            const ctx = {\n                WebIFC,\n                modelID,\n                ifcAPI,\n                xktModel,\n                autoNormals,\n                log: (log || function (msg) {\n                }),\n                nextId: 0,\n                stats\n            };\n\n            if (includeTypes) {\n                ctx.includeTypes = {};\n                for (let i = 0, len = includeTypes.length; i < len; i++) {\n                    ctx.includeTypes[includeTypes[i]] = true;\n                }\n            }\n\n            if (excludeTypes) {\n                ctx.excludeTypes = {};\n                for (let i = 0, len = excludeTypes.length; i < len; i++) {\n                    ctx.excludeTypes[excludeTypes[i]] = true;\n                }\n            }\n\n            const lines = ctx.ifcAPI.GetLineIDsWithType(modelID, WebIFC.IFCPROJECT);\n            const ifcProjectId = lines.get(0);\n            const ifcProject = ctx.ifcAPI.GetLine(modelID, ifcProjectId);\n\n            ctx.xktModel.schema = \"\";\n            ctx.xktModel.modelId = \"\" + modelID;\n            ctx.xktModel.projectId = \"\" + ifcProjectId;\n\n            parseMetadata(ctx);\n            parseGeometry(ctx);\n            parsePropertySets(ctx);\n\n            resolve();\n\n        }).catch((e) => {\n\n            reject(e);\n        })\n    });\n}\n\nfunction parsePropertySets(ctx) {\n\n    const lines = ctx.ifcAPI.GetLineIDsWithType(ctx.modelID, ctx.WebIFC.IFCRELDEFINESBYPROPERTIES);\n\n    for (let i = 0; i < lines.size(); i++) {\n\n        let relID = lines.get(i);\n\n        let rel = ctx.ifcAPI.GetLine(ctx.modelID, relID, true);\n\n        if (rel) {\n\n            const relatingPropertyDefinition = rel.RelatingPropertyDefinition;\n            if (!relatingPropertyDefinition) {\n                continue;\n            }\n\n            const propertySetId = relatingPropertyDefinition.GlobalId.value;\n\n            const relatedObjects = rel.RelatedObjects;\n            if (relatedObjects) {\n                for (let i = 0, len = relatedObjects.length; i < len; i++) {\n                    const relatedObject = relatedObjects[i];\n                    const metaObjectId = relatedObject.GlobalId.value;\n                    const metaObject = ctx.xktModel.metaObjects[metaObjectId];\n                    if (metaObject) {\n                        if (!metaObject.propertySetIds) {\n                            metaObject.propertySetIds = [];\n                        }\n                        metaObject.propertySetIds.push(propertySetId);\n                    }\n                }\n            }\n\n            const props = relatingPropertyDefinition.HasProperties;\n            if (props && props.length > 0) {\n                const propertySetType = \"Default\";\n                const propertySetName = relatingPropertyDefinition.Name.value;\n                const properties = [];\n                for (let i = 0, len = props.length; i < len; i++) {\n                    const prop = props[i];\n                    const name = prop.Name;\n                    const nominalValue = prop.NominalValue;\n                    if (name && nominalValue) {\n                        const property = {\n                            name: name.value,\n                            type: nominalValue.type,\n                            value: nominalValue.value,\n                            valueType: nominalValue.valueType\n                        };\n                        if (prop.Description) {\n                            property.description = prop.Description.value;\n                        } else if (nominalValue.description) {\n                            property.description = nominalValue.description;\n                        }\n                        properties.push(property);\n                    }\n                }\n                ctx.xktModel.createPropertySet({propertySetId, propertySetType, propertySetName, properties});\n                ctx.stats.numPropertySets++;\n            }\n        }\n    }\n}\n\nfunction parseMetadata(ctx) {\n\n    const lines = ctx.ifcAPI.GetLineIDsWithType(ctx.modelID, ctx.WebIFC.IFCPROJECT);\n    const ifcProjectId = lines.get(0);\n    const ifcProject = ctx.ifcAPI.GetLine(ctx.modelID, ifcProjectId);\n\n    parseSpatialChildren(ctx, ifcProject);\n}\n\nfunction parseSpatialChildren(ctx, ifcElement, parentMetaObjectId) {\n\n    const metaObjectType = ifcElement.__proto__.constructor.name;\n\n    if (ctx.includeTypes && (!ctx.includeTypes[metaObjectType])) {\n        return;\n    }\n\n    if (ctx.excludeTypes && ctx.excludeTypes[metaObjectType]) {\n        return;\n    }\n\n    createMetaObject(ctx, ifcElement, parentMetaObjectId);\n\n    const metaObjectId = ifcElement.GlobalId.value;\n\n    parseRelatedItemsOfType(\n        ctx,\n        ifcElement.expressID,\n        'RelatingObject',\n        'RelatedObjects',\n        ctx.WebIFC.IFCRELAGGREGATES,\n        metaObjectId);\n\n    parseRelatedItemsOfType(\n        ctx,\n        ifcElement.expressID,\n        'RelatingStructure',\n        'RelatedElements',\n        ctx.WebIFC.IFCRELCONTAINEDINSPATIALSTRUCTURE,\n        metaObjectId);\n}\n\nfunction createMetaObject(ctx, ifcElement, parentMetaObjectId) {\n\n    const metaObjectId = ifcElement.GlobalId.value;\n    const propertySetIds = null;\n    const metaObjectType = ifcElement.__proto__.constructor.name;\n    const metaObjectName = (ifcElement.Name && ifcElement.Name.value !== \"\") ? ifcElement.Name.value : metaObjectType;\n\n    ctx.xktModel.createMetaObject({metaObjectId, propertySetIds, metaObjectType, metaObjectName, parentMetaObjectId});\n    ctx.stats.numMetaObjects++;\n}\n\nfunction parseRelatedItemsOfType(ctx, id, relation, related, type, parentMetaObjectId) {\n\n    const lines = ctx.ifcAPI.GetLineIDsWithType(ctx.modelID, type);\n\n    for (let i = 0; i < lines.size(); i++) {\n\n        const relID = lines.get(i);\n        const rel = ctx.ifcAPI.GetLine(ctx.modelID, relID);\n        const relatedItems = rel[relation];\n\n        let foundElement = false;\n\n        if (Array.isArray(relatedItems)) {\n            const values = relatedItems.map((item) => item.value);\n            foundElement = values.includes(id);\n\n        } else {\n            foundElement = (relatedItems.value === id);\n        }\n\n        if (foundElement) {\n\n            const element = rel[related];\n\n            if (!Array.isArray(element)) {\n\n                const ifcElement = ctx.ifcAPI.GetLine(ctx.modelID, element.value);\n\n                parseSpatialChildren(ctx, ifcElement, parentMetaObjectId);\n\n            } else {\n\n                element.forEach((element2) => {\n\n                    const ifcElement = ctx.ifcAPI.GetLine(ctx.modelID, element2.value);\n\n                    parseSpatialChildren(ctx, ifcElement, parentMetaObjectId);\n                });\n            }\n        }\n    }\n}\n\nfunction parseGeometry(ctx) {\n\n    // Parses the geometry and materials in the IFC, creates\n    // XKTEntity, XKTMesh and XKTGeometry components within the XKTModel.\n\n    const flatMeshes = ctx.ifcAPI.LoadAllGeometry(ctx.modelID);\n\n    for (let i = 0, len = flatMeshes.size(); i < len; i++) {\n        const flatMesh = flatMeshes.get(i);\n        createObject(ctx, flatMesh);\n    }\n\n    // LoadAllGeometry does not return IFCSpace meshes\n    // here is a workaround\n\n    const lines = ctx.ifcAPI.GetLineIDsWithType(ctx.modelID, ctx.WebIFC.IFCSPACE);\n    for (let j = 0, len = lines.size(); j < len; j++) {\n        const ifcSpaceId = lines.get(j);\n        const flatMesh = ctx.ifcAPI.GetFlatMesh(ctx.modelID, ifcSpaceId);\n        createObject(ctx, flatMesh);\n    }\n}\n\nfunction createObject(ctx, flatMesh) {\n\n    const flatMeshExpressID = flatMesh.expressID;\n    const placedGeometries = flatMesh.geometries;\n\n    const meshIds = [];\n\n    const properties = ctx.ifcAPI.GetLine(ctx.modelID, flatMeshExpressID);\n    const entityId = properties.GlobalId.value;\n\n    const metaObjectId = entityId;\n    const metaObject = ctx.xktModel.metaObjects[metaObjectId];\n\n    if (ctx.includeTypes && (!metaObject || (!ctx.includeTypes[metaObject.metaObjectType]))) {\n        return;\n    }\n\n    if (ctx.excludeTypes && (!metaObject || ctx.excludeTypes[metaObject.metaObjectType])) {\n        console.log(\"excluding: \" + metaObjectId)\n        return;\n    }\n\n    for (let j = 0, lenj = placedGeometries.size(); j < lenj; j++) {\n\n        const placedGeometry = placedGeometries.get(j);\n        const geometryId = \"\" + placedGeometry.geometryExpressID;\n\n        if (!ctx.xktModel.geometries[geometryId]) {\n\n            const geometry = ctx.ifcAPI.GetGeometry(ctx.modelID, placedGeometry.geometryExpressID);\n            const vertexData = ctx.ifcAPI.GetVertexArray(geometry.GetVertexData(), geometry.GetVertexDataSize());\n            const indices = ctx.ifcAPI.GetIndexArray(geometry.GetIndexData(), geometry.GetIndexDataSize());\n\n            // De-interleave vertex arrays\n\n            const positions = [];\n            const normals = [];\n\n            for (let k = 0, lenk = vertexData.length / 6; k < lenk; k++) {\n                positions.push(vertexData[k * 6 + 0]);\n                positions.push(vertexData[k * 6 + 1]);\n                positions.push(vertexData[k * 6 + 2]);\n            }\n\n            if (!ctx.autoNormals) {\n                for (let k = 0, lenk = vertexData.length / 6; k < lenk; k++) {\n                    normals.push(vertexData[k * 6 + 3]);\n                    normals.push(vertexData[k * 6 + 4]);\n                    normals.push(vertexData[k * 6 + 5]);\n                }\n            }\n\n            ctx.xktModel.createGeometry({\n                geometryId: geometryId,\n                primitiveType: \"triangles\",\n                positions: positions,\n                normals: ctx.autoNormals ? null : normals,\n                indices: indices\n            });\n\n            ctx.stats.numGeometries++;\n            ctx.stats.numVertices += (positions.length / 3);\n            ctx.stats.numTriangles += (indices.length / 3);\n        }\n\n        const meshId = (\"mesh\" + ctx.nextId++);\n\n        ctx.xktModel.createMesh({\n            meshId: meshId,\n            geometryId: geometryId,\n            matrix: placedGeometry.flatTransformation,\n            color: [placedGeometry.color.x, placedGeometry.color.y, placedGeometry.color.z],\n            opacity: placedGeometry.color.w\n        });\n\n        meshIds.push(meshId);\n    }\n\n    if (meshIds.length > 0) {\n        ctx.xktModel.createEntity({\n            entityId: entityId,\n            meshIds: meshIds\n        });\n        ctx.stats.numObjects++;\n    }\n}\n\nexport {parseIFCIntoXKTModel};\n",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/parsers/parseIFCIntoXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 457,
    "kind": "function",
    "name": "parsePropertySets",
    "memberof": "src/parsers/parseIFCIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseIFCIntoXKTModel.js~parsePropertySets",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseIFCIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 161,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 458,
    "kind": "function",
    "name": "parseMetadata",
    "memberof": "src/parsers/parseIFCIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseIFCIntoXKTModel.js~parseMetadata",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseIFCIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 226,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 459,
    "kind": "function",
    "name": "parseSpatialChildren",
    "memberof": "src/parsers/parseIFCIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseIFCIntoXKTModel.js~parseSpatialChildren",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseIFCIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 235,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "ifcElement",
        "types": [
          "*"
        ]
      },
      {
        "name": "parentMetaObjectId",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 460,
    "kind": "function",
    "name": "createMetaObject",
    "memberof": "src/parsers/parseIFCIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseIFCIntoXKTModel.js~createMetaObject",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseIFCIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 268,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "ifcElement",
        "types": [
          "*"
        ]
      },
      {
        "name": "parentMetaObjectId",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 461,
    "kind": "function",
    "name": "parseRelatedItemsOfType",
    "memberof": "src/parsers/parseIFCIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseIFCIntoXKTModel.js~parseRelatedItemsOfType",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseIFCIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 279,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "id",
        "types": [
          "*"
        ]
      },
      {
        "name": "relation",
        "types": [
          "*"
        ]
      },
      {
        "name": "related",
        "types": [
          "*"
        ]
      },
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "parentMetaObjectId",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 462,
    "kind": "function",
    "name": "parseGeometry",
    "memberof": "src/parsers/parseIFCIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseIFCIntoXKTModel.js~parseGeometry",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseIFCIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 322,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 463,
    "kind": "function",
    "name": "createObject",
    "memberof": "src/parsers/parseIFCIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseIFCIntoXKTModel.js~createObject",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseIFCIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 345,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "flatMesh",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 464,
    "kind": "function",
    "name": "parseIFCIntoXKTModel",
    "memberof": "src/parsers/parseIFCIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseIFCIntoXKTModel.js~parseIFCIntoXKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseIFCIntoXKTModel.js",
    "importStyle": "{parseIFCIntoXKTModel}",
    "description": "Parses IFC STEP file data into an {@link XKTModel}.\n\nThis function uses [web-ifc](https://github.com/tomvandig/web-ifc) to parse the IFC, which relies on a\nWASM file to do the parsing.\n\nDepending on how we use this function, we may need to provide it with a path to the directory where that WASM file is stored.\n\nThis function is tested with web-ifc version 0.0.34.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then load an IFC model into it.\n\n````javascript\nimport {XKTModel, parseIFCIntoXKTModel, writeXKTModelToArrayBuffer} from \"xeokit-convert.es.js\";\n\nimport * as WebIFC from \"web-ifc-api.js\";\n\nutils.loadArraybuffer(\"rac_advanced_sample_project.ifc\", async (data) => {\n\n    const xktModel = new XKTModel();\n\n    parseIFCIntoXKTModel({\n         WebIFC,\n         data,\n         xktModel,\n         wasmPath: \"../dist/\",\n         autoNormals: true,\n         log: (msg) => { console.log(msg); }\n    }).then(()=>{\n       xktModel.finalize();\n    },\n    (msg) => {\n        console.error(msg);\n    });\n});\n````",
    "lineNumber": 57,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} Resolves when IFC has been parsed."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Parsing params."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params.WebIFC",
        "description": "The WebIFC library. We pass this in as an external dependency, in order to give the\ncaller the choice of whether to use the Browser or NodeJS version."
      },
      {
        "nullable": null,
        "types": [
          "ArrayBuffer"
        ],
        "spread": false,
        "optional": true,
        "name": "params.data",
        "description": "IFC file data."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": true,
        "name": "params.xktModel",
        "description": "XKTModel to parse into."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "params.autoNormals",
        "description": "When true, the parser will ignore the IFC geometry normals, and the IFC\ndata will rely on the xeokit ````Viewer```` to automatically generate them. This has the limitation that the\nnormals will be face-aligned, and therefore the ````Viewer```` will only be able to render a flat-shaded representation\nof the IFC model. This is ````true```` by default, because IFC models tend to look acceptable with flat-shading,\nand we always want to minimize IFC model size wherever possible."
      },
      {
        "nullable": null,
        "types": [
          "String[]"
        ],
        "spread": false,
        "optional": true,
        "name": "params.includeTypes",
        "description": "Option to only convert objects of these types."
      },
      {
        "nullable": null,
        "types": [
          "String[]"
        ],
        "spread": false,
        "optional": true,
        "name": "params.excludeTypes",
        "description": "Option to never convert objects of these types."
      },
      {
        "nullable": null,
        "types": [
          "String"
        ],
        "spread": false,
        "optional": false,
        "name": "params.wasmPath",
        "description": "Path to ````web-ifc.wasm````, required by this function."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "{}",
        "defaultRaw": {},
        "name": "params.stats",
        "description": "Collects statistics."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.log",
        "description": "Logging callback."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Resolves when IFC has been parsed."
    }
  },
  {
    "__docId__": 465,
    "kind": "file",
    "name": "src/parsers/parseLASIntoXKTModel.js",
    "content": "import {parse} from '@loaders.gl/core';\nimport {LASLoader} from '@loaders.gl/las';\n\nimport {math} from \"../lib/math.js\";\n\nconst MAX_VERTICES = 500000; // TODO: Rough estimate\n\n/**\n * @desc Parses LAS and LAZ point cloud data into an {@link XKTModel}.\n *\n * This parser handles both the LASER file format (LAS) and its compressed version (LAZ),\n * a public format for the interchange of 3-dimensional point cloud data data, developed\n * for LIDAR mapping purposes.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then load an LAZ point cloud model into it.\n *\n * ````javascript\n * utils.loadArraybuffer(\"./models/laz/autzen.laz\", async (data) => {\n *\n *     const xktModel = new XKTModel();\n *\n *     await parseLASIntoXKTModel({\n *          data,\n *          xktModel,\n *          rotateX: true,\n *          log: (msg) => { console.log(msg); }\n *     }).then(()=>{\n *        xktModel.finalize();\n *     },\n *     (msg) => {\n *         console.error(msg);\n *     });\n * });\n * ````\n *\n * @param {Object} params Parsing params.\n * @param {ArrayBuffer} params.data LAS/LAZ file data.\n * @param {XKTModel} params.xktModel XKTModel to parse into.\n * @param {boolean} [params.center=false] Set true to center the LAS point positions to [0,0,0]. This is applied before the transformation matrix, if specified.\n * @param {Boolean} [params.transform] 4x4 transformation matrix to transform point positions. Use this to rotate, translate and scale them if neccessary.\n * @param {Number|String} [params.colorDepth=8] Whether colors encoded using 8 or 16 bits. Can be set to 'auto'. LAS specification recommends 16 bits.\n * @param {Boolean} [params.fp64=false] Configures if LASLoaderPlugin assumes that LAS positions are stored in 64-bit floats instead of 32-bit.\n * @param {Number} [params.skip=1] Read one from every n points.\n * @param {Object} [params.stats] Collects statistics.\n * @param {function} [params.log] Logging callback.\n * @returns {Promise} Resolves when LAS has been parsed.\n */\nfunction parseLASIntoXKTModel({\n                                  data,\n                                  xktModel,\n                                  center = false,\n                                  transform = null,\n                                  colorDepth = \"auto\",\n                                  fp64 = false,\n                                  skip = 1,\n                                  stats,\n                                  log = () => {\n                                  }\n                              }) {\n\n    if (log) {\n        log(\"Using parser: parseLASIntoXKTModel\");\n    }\n\n    return new Promise(function (resolve, reject) {\n\n        if (!data) {\n            reject(\"Argument expected: data\");\n            return;\n        }\n\n        if (!xktModel) {\n            reject(\"Argument expected: xktModel\");\n            return;\n        }\n\n        log(\"Converting LAZ/LAS\");\n\n        log(`center: ${center}`);\n        if (transform) {\n            log(`transform: [${transform}]`);\n        }\n        log(`colorDepth: ${colorDepth}`);\n        log(`fp64: ${fp64}`);\n        log(`skip: ${skip}`);\n\n        parse(data, LASLoader, {\n            las: {\n                colorDepth,\n                fp64\n            }\n        }).then((parsedData) => {\n\n            const attributes = parsedData.attributes;\n\n            const loaderData = parsedData.loaderData;\n            const pointsFormatId = loaderData.pointsFormatId !== undefined ? loaderData.pointsFormatId : -1;\n\n            if (!attributes.POSITION) {\n                log(\"No positions found in file (expected for all LAS point formats)\");\n                return;\n            }\n\n            let readAttributes = {};\n\n            switch (pointsFormatId) {\n                case 0:\n                    if (!attributes.intensity) {\n                        log(\"No intensities found in file (expected for LAS point format 0)\");\n                        return;\n                    }\n\n                    readAttributes = readIntensities(attributes.POSITION, attributes.intensity);\n                    break;\n                case 1:\n                    if (!attributes.intensity) {\n                        log(\"No intensities found in file (expected for LAS point format 1)\");\n                        return;\n                    }\n                    readAttributes = readIntensities(attributes.POSITION, attributes.intensity);\n                    break;\n                case 2:\n                    if (!attributes.intensity) {\n                        log(\"No intensities found in file (expected for LAS point format 2)\");\n                        return;\n                    }\n\n                    readAttributes = readColorsAndIntensities(attributes.POSITION, attributes.COLOR_0, attributes.intensity);\n                    break;\n                case 3:\n                    if (!attributes.intensity) {\n                        log(\"No intensities found in file (expected for LAS point format 3)\");\n                        return;\n                    }\n                    readAttributes = readColorsAndIntensities(attributes.POSITION, attributes.COLOR_0, attributes.intensity);\n                    break;\n            }\n\n            const pointsChunks = chunkArray(readPositions(readAttributes.positions), MAX_VERTICES * 3);\n            const colorsChunks = chunkArray(readAttributes.colors, MAX_VERTICES * 4);\n\n            const meshIds = [];\n\n            for (let j = 0, lenj = pointsChunks.length; j < lenj; j++) {\n\n                const geometryId = `geometry-${j}`;\n                const meshId = `mesh-${j}`;\n\n                meshIds.push(meshId);\n\n                xktModel.createGeometry({\n                    geometryId: geometryId,\n                    primitiveType: \"points\",\n                    positions: pointsChunks[j],\n                    colorsCompressed: colorsChunks[j]\n                });\n\n                xktModel.createMesh({\n                    meshId,\n                    geometryId\n                });\n            }\n\n            const entityId = math.createUUID();\n\n            xktModel.createEntity({\n                entityId,\n                meshIds\n            });\n\n            const rootMetaObjectId = math.createUUID();\n\n            xktModel.createMetaObject({\n                metaObjectId: rootMetaObjectId,\n                metaObjectType: \"Model\",\n                metaObjectName: \"Model\"\n            });\n\n            xktModel.createMetaObject({\n                metaObjectId: entityId,\n                metaObjectType: \"PointCloud\",\n                metaObjectName: \"PointCloud (LAZ)\",\n                parentMetaObjectId: rootMetaObjectId\n            });\n\n            if (stats) {\n                stats.sourceFormat = \"LAS\";\n                stats.schemaVersion = \"\";\n                stats.title = \"\";\n                stats.author = \"\";\n                stats.created = \"\";\n                stats.numMetaObjects = 2;\n                stats.numPropertySets = 0;\n                stats.numObjects = 1;\n                stats.numGeometries = 1;\n                stats.numVertices = readAttributes.positions.length / 3;\n            }\n\n            resolve();\n\n        }, (errMsg) => {\n            reject(errMsg);\n        });\n    });\n\n    function readPositions(positionsValue) {\n        if (positionsValue) {\n            if (center) {\n                const centerPos = math.vec3();\n                const numPoints = positionsValue.length;\n                for (let i = 0, len = positionsValue.length; i < len; i += 3) {\n                    centerPos[0] += positionsValue[i + 0];\n                    centerPos[1] += positionsValue[i + 1];\n                    centerPos[2] += positionsValue[i + 2];\n                }\n                centerPos[0] /= numPoints;\n                centerPos[1] /= numPoints;\n                centerPos[2] /= numPoints;\n                for (let i = 0, len = positionsValue.length; i < len; i += 3) {\n                    positionsValue[i + 0] -= centerPos[0];\n                    positionsValue[i + 1] -= centerPos[1];\n                    positionsValue[i + 2] -= centerPos[2];\n                }\n            }\n            if (transform) {\n                const mat = math.mat4(transform);\n                const pos = math.vec3();\n                for (let i = 0, len = positionsValue.length; i < len; i += 3) {\n                    pos[0] = positionsValue[i + 0];\n                    pos[1] = positionsValue[i + 1];\n                    pos[2] = positionsValue[i + 2];\n                    math.transformPoint3(mat, pos, pos);\n                    positionsValue[i + 0] = pos[0];\n                    positionsValue[i + 1] = pos[1];\n                    positionsValue[i + 2] = pos[2];\n                }\n            }\n        }\n        return positionsValue;\n    }\n\n    function readColorsAndIntensities(attributesPosition, attributesColor, attributesIntensity) {\n        const positionsValue = attributesPosition.value;\n        const colors = attributesColor.value;\n        const colorSize = attributesColor.size;\n        const intensities = attributesIntensity.value;\n        const colorsCompressedSize = intensities.length * 4;\n        const positions = [];\n        const colorsCompressed = new Uint8Array(colorsCompressedSize / skip);\n        let count = skip;\n        for (let i = 0, j = 0, k = 0, l = 0, m = 0, n=0,len = intensities.length; i < len; i++, k += colorSize, j += 4, l += 3) {\n            if (count <= 0) {\n                colorsCompressed[m++] = colors[k + 0];\n                colorsCompressed[m++] = colors[k + 1];\n                colorsCompressed[m++] = colors[k + 2];\n                colorsCompressed[m++] = Math.round((intensities[i] / 65536) * 255);\n                positions[n++] = positionsValue[l + 0];\n                positions[n++] = positionsValue[l + 1];\n                positions[n++] = positionsValue[l + 2];\n                count = skip;\n            } else {\n                count--;\n            }\n        }\n        return {\n            positions,\n            colors: colorsCompressed\n        };\n    }\n\n    function readIntensities(attributesPosition, attributesIntensity) {\n        const positionsValue = attributesPosition.value;\n        const intensities = attributesIntensity.value;\n        const colorsCompressedSize = intensities.length * 4;\n        const positions = [];\n        const colorsCompressed = new Uint8Array(colorsCompressedSize / skip);\n        let count = skip;\n        for (let i = 0, j = 0, k = 0, l = 0, m = 0, n = 0, len = intensities.length; i < len; i++, k += 3, j += 4, l += 3) {\n            if (count <= 0) {\n                colorsCompressed[m++] = 0;\n                colorsCompressed[m++] = 0;\n                colorsCompressed[m++] = 0;\n                colorsCompressed[m++] = Math.round((intensities[i] / 65536) * 255);\n                positions[n++] = positionsValue[l + 0];\n                positions[n++] = positionsValue[l + 1];\n                positions[n++] = positionsValue[l + 2];\n                count = skip;\n            } else {\n                count--;\n            }\n        }\n        return {\n            positions,\n            colors: colorsCompressed\n        };\n    }\n\n    function chunkArray(array, chunkSize) {\n        if (chunkSize >= array.length) {\n            return [array]; // One chunk\n        }\n        let result = [];\n        for (let i = 0; i < array.length; i += chunkSize) {\n            result.push(array.slice(i, i + chunkSize));\n        }\n        return result;\n    }\n\n}\n\nexport {parseLASIntoXKTModel};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/parsers/parseLASIntoXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 466,
    "kind": "variable",
    "name": "MAX_VERTICES",
    "memberof": "src/parsers/parseLASIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseLASIntoXKTModel.js~MAX_VERTICES",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseLASIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 6,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 467,
    "kind": "function",
    "name": "parseLASIntoXKTModel",
    "memberof": "src/parsers/parseLASIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseLASIntoXKTModel.js~parseLASIntoXKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseLASIntoXKTModel.js",
    "importStyle": "{parseLASIntoXKTModel}",
    "description": "Parses LAS and LAZ point cloud data into an {@link XKTModel}.\n\nThis parser handles both the LASER file format (LAS) and its compressed version (LAZ),\na public format for the interchange of 3-dimensional point cloud data data, developed\nfor LIDAR mapping purposes.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then load an LAZ point cloud model into it.\n\n````javascript\nutils.loadArraybuffer(\"./models/laz/autzen.laz\", async (data) => {\n\n    const xktModel = new XKTModel();\n\n    await parseLASIntoXKTModel({\n         data,\n         xktModel,\n         rotateX: true,\n         log: (msg) => { console.log(msg); }\n    }).then(()=>{\n       xktModel.finalize();\n    },\n    (msg) => {\n        console.error(msg);\n    });\n});\n````",
    "lineNumber": 50,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} Resolves when LAS has been parsed."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Parsing params."
      },
      {
        "nullable": null,
        "types": [
          "ArrayBuffer"
        ],
        "spread": false,
        "optional": false,
        "name": "params.data",
        "description": "LAS/LAZ file data."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "params.xktModel",
        "description": "XKTModel to parse into."
      },
      {
        "nullable": null,
        "types": [
          "boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "params.center",
        "description": "Set true to center the LAS point positions to [0,0,0]. This is applied before the transformation matrix, if specified."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "name": "params.transform",
        "description": "4x4 transformation matrix to transform point positions. Use this to rotate, translate and scale them if neccessary."
      },
      {
        "nullable": null,
        "types": [
          "Number",
          "String"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "8",
        "defaultRaw": 8,
        "name": "params.colorDepth",
        "description": "Whether colors encoded using 8 or 16 bits. Can be set to 'auto'. LAS specification recommends 16 bits."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "params.fp64",
        "description": "Configures if LASLoaderPlugin assumes that LAS positions are stored in 64-bit floats instead of 32-bit."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "1",
        "defaultRaw": 1,
        "name": "params.skip",
        "description": "Read one from every n points."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "params.stats",
        "description": "Collects statistics."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.log",
        "description": "Logging callback."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Resolves when LAS has been parsed."
    }
  },
  {
    "__docId__": 468,
    "kind": "file",
    "name": "src/parsers/parseMetaModelIntoXKTModel.js",
    "content": "/**\n * @desc Parses JSON metamodel into an {@link XKTModel}.\n *\n * @param {Object} params Parsing parameters.\n * @param {JSON} params.metaModelData Metamodel data.\n * @param {String[]} [params.excludeTypes] Types to exclude from parsing.\n * @param {String[]} [params.includeTypes] Types to include in parsing.\n * @param {XKTModel} params.xktModel XKTModel to parse into.\n * @param {function} [params.log] Logging callback.\n @returns {Promise} Resolves when JSON has been parsed.\n */\nfunction parseMetaModelIntoXKTModel({metaModelData, xktModel, includeTypes, excludeTypes, log}) {\n\n    if (log) {\n        log(\"Using parser: parseMetaModelIntoXKTModel\");\n    }\n\n    return new Promise(function (resolve, reject) {\n\n        const metaObjects = metaModelData.metaObjects || [];\n        const propertySets = metaModelData.propertySets || [];\n\n        xktModel.modelId = metaModelData.revisionId || \"\"; // HACK\n        xktModel.projectId = metaModelData.projectId || \"\";\n        xktModel.revisionId = metaModelData.revisionId || \"\";\n        xktModel.author = metaModelData.author || \"\";\n        xktModel.createdAt = metaModelData.createdAt || \"\";\n        xktModel.creatingApplication = metaModelData.creatingApplication || \"\";\n        xktModel.schema = metaModelData.schema || \"\";\n\n        for (let i = 0, len = propertySets.length; i < len; i++) {\n\n            const propertySet = propertySets[i];\n\n            xktModel.createPropertySet({\n                propertySetId: propertySet.id,\n                propertySetName: propertySet.name,\n                propertySetType: propertySet.type,\n                properties: propertySet.properties\n            });\n        }\n\n        let includeTypesMap;\n        if (includeTypes) {\n            includeTypesMap = {};\n            for (let i = 0, len = includeTypes.length; i < len; i++) {\n                includeTypesMap[includeTypes[i]] = true;\n            }\n        }\n\n        let excludeTypesMap;\n        if (excludeTypes) {\n            excludeTypesMap = {};\n            for (let i = 0, len = excludeTypes.length; i < len; i++) {\n                excludeTypesMap[excludeTypes[i]] = true;\n            }\n        }\n\n        const metaObjectsMap = {};\n\n        for (let i = 0, len = metaObjects.length; i < len; i++) {\n            const newObject = metaObjects[i];\n            metaObjectsMap[newObject.id] = newObject;\n        }\n\n        let countMetaObjects = 0;\n\n        for (let i = 0, len = metaObjects.length; i < len; i++) {\n\n            const metaObject = metaObjects[i];\n            const type = metaObject.type;\n\n            if (excludeTypesMap && excludeTypesMap[type]) {\n                continue;\n            }\n\n            if (includeTypesMap && !includeTypesMap[type]) {\n                continue;\n            }\n\n            if (metaObject.parent !== undefined && metaObject.parent !== null) {\n                const metaObjectParent = metaObjectsMap[metaObject.parent];\n                if (metaObject.type === metaObjectParent.type) { // Don't create redundant sub-objects\n                    continue\n                }\n            }\n\n            const propertySetIds = [];\n            if (metaObject.propertySetIds) {\n                for (let j = 0, lenj = metaObject.propertySetIds.length; j < lenj; j++) {\n                    const propertySetId = metaObject.propertySetIds[j];\n                    if (propertySetId !== undefined && propertySetId !== null && propertySetId !== \"\") {\n                        propertySetIds.push(propertySetId);\n                    }\n                }\n            }\n            if (metaObject.propertySetId !== undefined && metaObject.propertySetId !== null && metaObject.propertySetId !== \"\") {\n                propertySetIds.push(metaObject.propertySetId);\n            }\n\n            xktModel.createMetaObject({\n                metaObjectId: metaObject.id,\n                metaObjectType: metaObject.type,\n                metaObjectName: metaObject.name,\n                parentMetaObjectId: metaObject.parent,\n                propertySetIds: propertySetIds.length > 0 ? propertySetIds : null\n            });\n\n            countMetaObjects++;\n        }\n\n        if (log) {\n            log(\"Converted meta objects: \" + countMetaObjects);\n        }\n\n        resolve();\n    });\n}\n\nexport {parseMetaModelIntoXKTModel};\n",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/parsers/parseMetaModelIntoXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 469,
    "kind": "function",
    "name": "parseMetaModelIntoXKTModel",
    "memberof": "src/parsers/parseMetaModelIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseMetaModelIntoXKTModel.js~parseMetaModelIntoXKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseMetaModelIntoXKTModel.js",
    "importStyle": "{parseMetaModelIntoXKTModel}",
    "description": "Parses JSON metamodel into an {@link XKTModel}.",
    "lineNumber": 12,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} Resolves when JSON has been parsed."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Parsing parameters."
      },
      {
        "nullable": null,
        "types": [
          "JSON"
        ],
        "spread": false,
        "optional": false,
        "name": "params.metaModelData",
        "description": "Metamodel data."
      },
      {
        "nullable": null,
        "types": [
          "String[]"
        ],
        "spread": false,
        "optional": true,
        "name": "params.excludeTypes",
        "description": "Types to exclude from parsing."
      },
      {
        "nullable": null,
        "types": [
          "String[]"
        ],
        "spread": false,
        "optional": true,
        "name": "params.includeTypes",
        "description": "Types to include in parsing."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "params.xktModel",
        "description": "XKTModel to parse into."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.log",
        "description": "Logging callback."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Resolves when JSON has been parsed."
    }
  },
  {
    "__docId__": 470,
    "kind": "file",
    "name": "src/parsers/parsePCDIntoXKTModel.js",
    "content": "/**\n * @desc Parses PCD point cloud data into an {@link XKTModel}.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then load an LAZ point cloud model into it.\n *\n * ````javascript\n * utils.loadArraybuffer(\"\"./models/pcd/ism_test_cat.pcd\"\", async (data) => {\n *\n *     const xktModel = new XKTModel();\n *\n *     await parsePCDIntoXKTModel({\n *          data,\n *          xktModel,\n *          log: (msg) => { console.log(msg); }\n *     }).then(()=>{\n *        xktModel.finalize();\n *     },\n *     (msg) => {\n *         console.error(msg);\n *     });\n * });\n * ````\n *\n * @param {Object} params Parsing params.\n * @param {ArrayBuffer} params.data PCD file data.\n * @param {Boolean} [params.littleEndian=true] Whether PCD binary data is Little-Endian or Big-Endian.\n * @param {XKTModel} params.xktModel XKTModel to parse into.\n * @param {Object} [params.stats] Collects statistics.\n * @param {function} [params.log] Logging callback.\n @returns {Promise} Resolves when PCD has been parsed.\n */\nfunction parsePCDIntoXKTModel({data, xktModel, littleEndian = true, stats, log}) {\n\n    if (log) {\n        log(\"Using parser: parsePCDIntoXKTModel\");\n    }\n\n    return new Promise(function(resolve, reject) {\n\n        const textData = decodeText(new Uint8Array(data));\n\n        const header = parseHeader(textData);\n\n        const positions = [];\n        const normals = [];\n        const colors = [];\n\n        if (header.data === 'ascii') {\n\n            const offset = header.offset;\n            const data = textData.substr(header.headerLen);\n            const lines = data.split('\\n');\n\n            for (let i = 0, l = lines.length; i < l; i++) {\n\n                if (lines[i] === '') {\n                    continue;\n                }\n\n                const line = lines[i].split(' ');\n\n                if (offset.x !== undefined) {\n                    positions.push(parseFloat(line[offset.x]));\n                    positions.push(parseFloat(line[offset.y]));\n                    positions.push(parseFloat(line[offset.z]));\n                }\n\n                if (offset.rgb !== undefined) {\n                    const rgb = parseFloat(line[offset.rgb]);\n                    const r = (rgb >> 16) & 0x0000ff;\n                    const g = (rgb >> 8) & 0x0000ff;\n                    const b = (rgb >> 0) & 0x0000ff;\n                    colors.push(r, g, b, 255);\n                } else {\n                    colors.push(255);\n                    colors.push(255);\n                    colors.push(255);\n                }\n            }\n        }\n\n        if (header.data === 'binary_compressed') {\n\n            const sizes = new Uint32Array(data.slice(header.headerLen, header.headerLen + 8));\n            const compressedSize = sizes[0];\n            const decompressedSize = sizes[1];\n            const decompressed = decompressLZF(new Uint8Array(data, header.headerLen + 8, compressedSize), decompressedSize);\n            const dataview = new DataView(decompressed.buffer);\n            const offset = header.offset;\n\n            for (let i = 0; i < header.points; i++) {\n\n                if (offset.x !== undefined) {\n                    positions.push(dataview.getFloat32((header.points * offset.x) + header.size[0] * i, littleEndian));\n                    positions.push(dataview.getFloat32((header.points * offset.y) + header.size[1] * i, littleEndian));\n                    positions.push(dataview.getFloat32((header.points * offset.z) + header.size[2] * i, littleEndian));\n                }\n\n                if (offset.rgb !== undefined) {\n                    colors.push(dataview.getUint8((header.points * offset.rgb) + header.size[3] * i + 0));\n                    colors.push(dataview.getUint8((header.points * offset.rgb) + header.size[3] * i + 1));\n                    colors.push(dataview.getUint8((header.points * offset.rgb) + header.size[3] * i + 2));\n                    //    colors.push(255);\n                } else {\n                    colors.push(1);\n                    colors.push(1);\n                    colors.push(1);\n                }\n            }\n        }\n\n        if (header.data === 'binary') {\n\n            const dataview = new DataView(data, header.headerLen);\n            const offset = header.offset;\n\n            for (let i = 0, row = 0; i < header.points; i++, row += header.rowSize) {\n                if (offset.x !== undefined) {\n                    positions.push(dataview.getFloat32(row + offset.x, littleEndian));\n                    positions.push(dataview.getFloat32(row + offset.y, littleEndian));\n                    positions.push(dataview.getFloat32(row + offset.z, littleEndian));\n                }\n\n                if (offset.rgb !== undefined) {\n                    colors.push(dataview.getUint8(row + offset.rgb + 2));\n                    colors.push(dataview.getUint8(row + offset.rgb + 1));\n                    colors.push(dataview.getUint8(row + offset.rgb + 0));\n                } else {\n                    colors.push(255);\n                    colors.push(255);\n                    colors.push(255);\n                }\n            }\n        }\n\n        xktModel.createGeometry({\n            geometryId: \"pointsGeometry\",\n            primitiveType: \"points\",\n            positions: positions,\n            colors: colors && colors.length > 0 ? colors : null\n        });\n\n        xktModel.createMesh({\n            meshId: \"pointsMesh\",\n            geometryId: \"pointsGeometry\"\n        });\n\n        xktModel.createEntity({\n            entityId: \"geometries\",\n            meshIds: [\"pointsMesh\"]\n        });\n\n        if (log) {\n            log(\"Converted drawable objects: 1\");\n            log(\"Converted geometries: 1\");\n            log(\"Converted vertices: \" + positions.length / 3);\n        }\n\n        if (stats) {\n            stats.sourceFormat = \"PCD\";\n            stats.schemaVersion = \"\";\n            stats.title = \"\";\n            stats.author = \"\";\n            stats.created = \"\";\n            stats.numObjects = 1;\n            stats.numGeometries = 1;\n            stats.numVertices = positions.length / 3;\n        }\n\n        resolve();\n    });\n}\n\nfunction parseHeader(data) {\n    const header = {};\n    const result1 = data.search(/[\\r\\n]DATA\\s(\\S*)\\s/i);\n    const result2 = /[\\r\\n]DATA\\s(\\S*)\\s/i.exec(data.substr(result1 - 1));\n    header.data = result2[1];\n    header.headerLen = result2[0].length + result1;\n    header.str = data.substr(0, header.headerLen);\n    header.str = header.str.replace(/\\#.*/gi, '');     // Strip comments\n    header.version = /VERSION (.*)/i.exec(header.str); // Parse\n    header.fields = /FIELDS (.*)/i.exec(header.str);\n    header.size = /SIZE (.*)/i.exec(header.str);\n    header.type = /TYPE (.*)/i.exec(header.str);\n    header.count = /COUNT (.*)/i.exec(header.str);\n    header.width = /WIDTH (.*)/i.exec(header.str);\n    header.height = /HEIGHT (.*)/i.exec(header.str);\n    header.viewpoint = /VIEWPOINT (.*)/i.exec(header.str);\n    header.points = /POINTS (.*)/i.exec(header.str);\n    if (header.version !== null) {\n        header.version = parseFloat(header.version[1]);\n    }\n    if (header.fields !== null) {\n        header.fields = header.fields[1].split(' ');\n    }\n    if (header.type !== null) {\n        header.type = header.type[1].split(' ');\n    }\n    if (header.width !== null) {\n        header.width = parseInt(header.width[1]);\n    }\n    if (header.height !== null) {\n        header.height = parseInt(header.height[1]);\n    }\n    if (header.viewpoint !== null) {\n        header.viewpoint = header.viewpoint[1];\n    }\n    if (header.points !== null) {\n        header.points = parseInt(header.points[1], 10);\n    }\n    if (header.points === null) {\n        header.points = header.width * header.height;\n    }\n    if (header.size !== null) {\n        header.size = header.size[1].split(' ').map(function (x) {\n            return parseInt(x, 10);\n        });\n    }\n    if (header.count !== null) {\n        header.count = header.count[1].split(' ').map(function (x) {\n            return parseInt(x, 10);\n        });\n    } else {\n        header.count = [];\n        for (let i = 0, l = header.fields.length; i < l; i++) {\n            header.count.push(1);\n        }\n    }\n    header.offset = {};\n    let sizeSum = 0;\n    for (let i = 0, l = header.fields.length; i < l; i++) {\n        if (header.data === 'ascii') {\n            header.offset[header.fields[i]] = i;\n        } else {\n            header.offset[header.fields[i]] = sizeSum;\n            sizeSum += header.size[i] * header.count[i];\n        }\n    }\n    header.rowSize = sizeSum; // For binary only\n    return header;\n}\n\nfunction decodeText(array) {\n    if (typeof TextDecoder !== 'undefined') {\n        return new TextDecoder().decode(array);\n    }\n    let s = '';\n    for (let i = 0, il = array.length; i < il; i++) {\n        s += String.fromCharCode(array[i]);\n    }\n    try {\n        return decodeURIComponent(escape(s));\n    } catch (e) {\n        return s;\n    }\n}\n\nfunction decompressLZF(inData, outLength) { // https://gitlab.com/taketwo/three-pcd-loader/blob/master/decompress-lzf.js\n    const inLength = inData.length;\n    const outData = new Uint8Array(outLength);\n    let inPtr = 0;\n    let outPtr = 0;\n    let ctrl;\n    let len;\n    let ref;\n    do {\n        ctrl = inData[inPtr++];\n        if (ctrl < (1 << 5)) {\n            ctrl++;\n            if (outPtr + ctrl > outLength) throw new Error('Output buffer is not large enough');\n            if (inPtr + ctrl > inLength) throw new Error('Invalid compressed data');\n            do {\n                outData[outPtr++] = inData[inPtr++];\n            } while (--ctrl);\n        } else {\n            len = ctrl >> 5;\n            ref = outPtr - ((ctrl & 0x1f) << 8) - 1;\n            if (inPtr >= inLength) throw new Error('Invalid compressed data');\n            if (len === 7) {\n                len += inData[inPtr++];\n                if (inPtr >= inLength) throw new Error('Invalid compressed data');\n            }\n            ref -= inData[inPtr++];\n            if (outPtr + len + 2 > outLength) throw new Error('Output buffer is not large enough');\n            if (ref < 0) throw new Error('Invalid compressed data');\n            if (ref >= outPtr) throw new Error('Invalid compressed data');\n            do {\n                outData[outPtr++] = outData[ref++];\n            } while (--len + 2);\n        }\n    } while (inPtr < inLength);\n    return outData;\n}\n\nexport {parsePCDIntoXKTModel};",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/parsers/parsePCDIntoXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 471,
    "kind": "function",
    "name": "parseHeader",
    "memberof": "src/parsers/parsePCDIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parsePCDIntoXKTModel.js~parseHeader",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parsePCDIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 176,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 472,
    "kind": "function",
    "name": "decodeText",
    "memberof": "src/parsers/parsePCDIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parsePCDIntoXKTModel.js~decodeText",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parsePCDIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 246,
    "undocument": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 473,
    "kind": "function",
    "name": "decompressLZF",
    "memberof": "src/parsers/parsePCDIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parsePCDIntoXKTModel.js~decompressLZF",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parsePCDIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 261,
    "undocument": true,
    "params": [
      {
        "name": "inData",
        "types": [
          "*"
        ]
      },
      {
        "name": "outLength",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 474,
    "kind": "function",
    "name": "parsePCDIntoXKTModel",
    "memberof": "src/parsers/parsePCDIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parsePCDIntoXKTModel.js~parsePCDIntoXKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parsePCDIntoXKTModel.js",
    "importStyle": "{parsePCDIntoXKTModel}",
    "description": "Parses PCD point cloud data into an {@link XKTModel}.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then load an LAZ point cloud model into it.\n\n````javascript\nutils.loadArraybuffer(\"\"./models/pcd/ism_test_cat.pcd\"\", async (data) => {\n\n    const xktModel = new XKTModel();\n\n    await parsePCDIntoXKTModel({\n         data,\n         xktModel,\n         log: (msg) => { console.log(msg); }\n    }).then(()=>{\n       xktModel.finalize();\n    },\n    (msg) => {\n        console.error(msg);\n    });\n});\n````",
    "lineNumber": 34,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} Resolves when PCD has been parsed."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Parsing params."
      },
      {
        "nullable": null,
        "types": [
          "ArrayBuffer"
        ],
        "spread": false,
        "optional": false,
        "name": "params.data",
        "description": "PCD file data."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "params.littleEndian",
        "description": "Whether PCD binary data is Little-Endian or Big-Endian."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "params.xktModel",
        "description": "XKTModel to parse into."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "params.stats",
        "description": "Collects statistics."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.log",
        "description": "Logging callback."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Resolves when PCD has been parsed."
    }
  },
  {
    "__docId__": 475,
    "kind": "file",
    "name": "src/parsers/parsePLYIntoXKTModel.js",
    "content": "import {parse} from '@loaders.gl/core';\nimport {PLYLoader} from '@loaders.gl/ply';\n\n/**\n * @desc Parses PLY file data into an {@link XKTModel}.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then load a PLY model into it.\n *\n * ````javascript\n * utils.loadArraybuffer(\"./models/ply/test.ply\", async (data) => {\n *\n *     const xktModel = new XKTModel();\n *\n *     parsePLYIntoXKTModel({data, xktModel}).then(()=>{\n *        xktModel.finalize();\n *     },\n *     (msg) => {\n *         console.error(msg);\n *     });\n * });\n * ````\n *\n * @param {Object} params Parsing params.\n * @param {ArrayBuffer} params.data PLY file data.\n * @param {XKTModel} params.xktModel XKTModel to parse into.\n * @param {Object} [params.stats] Collects statistics.\n * @param {function} [params.log] Logging callback.\n @returns {Promise} Resolves when PLY has been parsed.\n */\nasync function parsePLYIntoXKTModel({data, xktModel, stats, log}) {\n\n    if (log) {\n        log(\"Using parser: parsePLYIntoXKTModel\");\n    }\n\n    if (!data) {\n        throw \"Argument expected: data\";\n    }\n\n    if (!xktModel) {\n        throw \"Argument expected: xktModel\";\n    }\n\n    let parsedData;\n    try {\n        parsedData = await parse(data, PLYLoader);\n    } catch (e) {\n        if (log) {\n            log(\"Error: \" + e);\n        }\n        return;\n    }\n\n    const attributes = parsedData.attributes;\n    const hasColors = !!attributes.COLOR_0;\n\n    if (hasColors) {\n        const colorsValue = hasColors ? attributes.COLOR_0.value : null;\n        const colorsCompressed = [];\n        for (let i = 0, len = colorsValue.length; i < len; i += 4) {\n            colorsCompressed.push(colorsValue[i]);\n            colorsCompressed.push(colorsValue[i + 1]);\n            colorsCompressed.push(colorsValue[i + 2]);\n        }\n        xktModel.createGeometry({\n            geometryId: \"plyGeometry\",\n            primitiveType: \"triangles\",\n            positions: attributes.POSITION.value,\n            indices: parsedData.indices ? parsedData.indices.value : [],\n            colorsCompressed: colorsCompressed\n        });\n    } else {\n        xktModel.createGeometry({\n            geometryId: \"plyGeometry\",\n            primitiveType: \"triangles\",\n            positions: attributes.POSITION.value,\n            indices: parsedData.indices ? parsedData.indices.value : []\n        });\n    }\n\n    xktModel.createMesh({\n        meshId: \"plyMesh\",\n        geometryId: \"plyGeometry\",\n        color: (!hasColors) ? [1, 1, 1] : null\n    });\n\n    xktModel.createEntity({\n        entityId: \"ply\",\n        meshIds: [\"plyMesh\"]\n    });\n\n    if (stats) {\n        stats.sourceFormat = \"PLY\";\n        stats.schemaVersion = \"\";\n        stats.title = \"\";\n        stats.author = \"\";\n        stats.created = \"\";\n        stats.numMetaObjects = 2;\n        stats.numPropertySets = 0;\n        stats.numObjects = 1;\n        stats.numGeometries = 1;\n        stats.numVertices = attributes.POSITION.value.length / 3;\n    }\n}\n\nexport {parsePLYIntoXKTModel};\n",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/parsers/parsePLYIntoXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 476,
    "kind": "function",
    "name": "parsePLYIntoXKTModel",
    "memberof": "src/parsers/parsePLYIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/parsers/parsePLYIntoXKTModel.js~parsePLYIntoXKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parsePLYIntoXKTModel.js",
    "importStyle": "{parsePLYIntoXKTModel}",
    "description": "Parses PLY file data into an {@link XKTModel}.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then load a PLY model into it.\n\n````javascript\nutils.loadArraybuffer(\"./models/ply/test.ply\", async (data) => {\n\n    const xktModel = new XKTModel();\n\n    parsePLYIntoXKTModel({data, xktModel}).then(()=>{\n       xktModel.finalize();\n    },\n    (msg) => {\n        console.error(msg);\n    });\n});\n````",
    "lineNumber": 32,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} Resolves when PLY has been parsed."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Parsing params."
      },
      {
        "nullable": null,
        "types": [
          "ArrayBuffer"
        ],
        "spread": false,
        "optional": false,
        "name": "params.data",
        "description": "PLY file data."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": false,
        "name": "params.xktModel",
        "description": "XKTModel to parse into."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "params.stats",
        "description": "Collects statistics."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.log",
        "description": "Logging callback."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Resolves when PLY has been parsed."
    }
  },
  {
    "__docId__": 477,
    "kind": "file",
    "name": "src/parsers/parseSTLIntoXKTModel.js",
    "content": "import {faceToVertexNormals} from \"../lib/faceToVertexNormals.js\";\nimport {math} from \"../lib/math.js\";\n\n/**\n * @desc Parses STL file data into an {@link XKTModel}.\n *\n * * Supports binary and ASCII STL formats.\n * * Option to create a separate {@link XKTEntity} for each group of faces that share the same vertex colors.\n * * Option to smooth face-aligned normals loaded from STL.\n * * Option to reduce XKT file size by ignoring STL normals and relying on xeokit to auto-generate them.\n *\n * ## Usage\n *\n * In the example below we'll create an {@link XKTModel}, then load an STL model into it.\n *\n * ````javascript\n * utils.loadArraybuffer(\"./models/stl/binary/spurGear.stl\", async (data) => {\n *\n *     const xktModel = new XKTModel();\n *\n *     parseSTLIntoXKTModel({data, xktModel});\n *\n *     xktModel.finalize();\n * });\n * ````\n *\n * @param {Object} params Parsing params.\n * @param {ArrayBuffer|String} [params.data] STL file data. Can be binary or string.\n * @param {Boolean} [params.autoNormals=false] When true, the parser will ignore the STL geometry normals, and the STL\n * data will rely on the xeokit ````Viewer```` to automatically generate them. This has the limitation that the\n * normals will be face-aligned, and therefore the ````Viewer```` will only be able to render a flat-shaded representation\n * of the STL.\n * Overrides ````smoothNormals```` when ````true````. This ignores the normals in the STL, and loads no\n * normals from the STL into the {@link XKTModel}, resulting in the XKT file storing no normals for the STL model. The\n * xeokit-sdk will then automatically generate the normals within its shaders. The disadvantages are that auto-normals\n * may slow rendering down a little bit, and that the normals can only be face-aligned (and thus rendered using flat\n * shading). The advantages, however, are a smaller XKT file size, and the ability to apply certain geometry optimizations\n * during parsing, such as removing duplicated STL vertex positions, that are not possible when normals are loaded\n * for the STL vertices.\n * @param {Boolean} [params.smoothNormals=true] When true, automatically converts face-oriented STL normals to vertex normals, for a smooth appearance. Ignored if ````autoNormals```` is ````true````.\n * @param {Number} [params.smoothNormalsAngleThreshold=20] This is the threshold angle between normals of adjacent triangles, below which their shared wireframe edge is not drawn.\n * @param {Boolean} [params.splitMeshes=true] When true, creates a separate {@link XKTEntity} for each group of faces that share the same vertex colors. Only works with binary STL (ie. when ````data```` is an ArrayBuffer).\n * @param {XKTModel} [params.xktModel] XKTModel to parse into.\n * @param {Object} [params.stats] Collects statistics.\n * @param {function} [params.log] Logging callback.\n @returns {Promise} Resolves when STL has been parsed.\n */\nasync function parseSTLIntoXKTModel({\n                                        data,\n                                        splitMeshes,\n                                        autoNormals,\n                                        smoothNormals,\n                                        smoothNormalsAngleThreshold,\n                                        xktModel,\n                                        stats,\n                                        log\n                                    }) {\n\n    if (log) {\n        log(\"Using parser: parseSTLIntoXKTModel\");\n    }\n\n    return new Promise(function (resolve, reject) {\n\n        if (!data) {\n            reject(\"Argument expected: data\");\n            return;\n        }\n\n        if (!xktModel) {\n            reject(\"Argument expected: xktModel\");\n            return;\n        }\n\n        const rootMetaObjectId = math.createUUID();\n\n        const rootMetaObject = xktModel.createMetaObject({\n            metaObjectId: rootMetaObjectId,\n            metaObjectType: \"Model\",\n            metaObjectName: \"Model\"\n        });\n\n        const ctx = {\n            data,\n            splitMeshes,\n            autoNormals,\n            smoothNormals,\n            smoothNormalsAngleThreshold,\n            xktModel,\n            rootMetaObject,\n            nextId: 0,\n            log: (log || function (msg) {\n            }),\n            stats: {\n                numObjects: 0,\n                numGeometries: 0,\n                numTriangles: 0,\n                numVertices: 0\n            }\n        };\n\n        const binData = ensureBinary(data);\n\n        if (isBinary(binData)) {\n            parseBinary(ctx, binData);\n        } else {\n            parseASCII(ctx, ensureString(data));\n        }\n\n        if (stats) {\n            stats.sourceFormat = \"STL\";\n            stats.schemaVersion = \"\";\n            stats.title = \"\";\n            stats.author = \"\";\n            stats.created = \"\";\n            stats.numMetaObjects = 2;\n            stats.numPropertySets = 0;\n            stats.numObjects = 1;\n            stats.numGeometries = 1;\n            stats.numTriangles = ctx.stats.numTriangles;\n            stats.numVertices = ctx.stats.numVertices;\n        }\n\n        resolve();\n    });\n}\n\nfunction isBinary(data) {\n    const reader = new DataView(data);\n    const numFaces = reader.getUint32(80, true);\n    const faceSize = (32 / 8 * 3) + ((32 / 8 * 3) * 3) + (16 / 8);\n    const numExpectedBytes = 80 + (32 / 8) + (numFaces * faceSize);\n    if (numExpectedBytes === reader.byteLength) {\n        return true;\n    }\n    const solid = [115, 111, 108, 105, 100];\n    for (let i = 0; i < 5; i++) {\n        if (solid[i] !== reader.getUint8(i, false)) {\n            return true;\n        }\n    }\n    return false;\n}\n\nfunction parseBinary(ctx, data) {\n    const reader = new DataView(data);\n    const faces = reader.getUint32(80, true);\n    let r;\n    let g;\n    let b;\n    let hasColors = false;\n    let colors;\n    let defaultR;\n    let defaultG;\n    let defaultB;\n    let lastR = null;\n    let lastG = null;\n    let lastB = null;\n    let newMesh = false;\n    let alpha;\n    for (let index = 0; index < 80 - 10; index++) {\n        if ((reader.getUint32(index, false) === 0x434F4C4F /*COLO*/) &&\n            (reader.getUint8(index + 4) === 0x52 /*'R'*/) &&\n            (reader.getUint8(index + 5) === 0x3D /*'='*/)) {\n            hasColors = true;\n            colors = [];\n            defaultR = reader.getUint8(index + 6) / 255;\n            defaultG = reader.getUint8(index + 7) / 255;\n            defaultB = reader.getUint8(index + 8) / 255;\n            alpha = reader.getUint8(index + 9) / 255;\n        }\n    }\n    let dataOffset = 84;\n    let faceLength = 12 * 4 + 2;\n    let positions = [];\n    let normals = [];\n    let splitMeshes = ctx.splitMeshes;\n    for (let face = 0; face < faces; face++) {\n        let start = dataOffset + face * faceLength;\n        let normalX = reader.getFloat32(start, true);\n        let normalY = reader.getFloat32(start + 4, true);\n        let normalZ = reader.getFloat32(start + 8, true);\n        if (hasColors) {\n            let packedColor = reader.getUint16(start + 48, true);\n            if ((packedColor & 0x8000) === 0) {\n                r = (packedColor & 0x1F) / 31;\n                g = ((packedColor >> 5) & 0x1F) / 31;\n                b = ((packedColor >> 10) & 0x1F) / 31;\n            } else {\n                r = defaultR;\n                g = defaultG;\n                b = defaultB;\n            }\n            if (splitMeshes && r !== lastR || g !== lastG || b !== lastB) {\n                if (lastR !== null) {\n                    newMesh = true;\n                }\n                lastR = r;\n                lastG = g;\n                lastB = b;\n            }\n        }\n        for (let i = 1; i <= 3; i++) {\n            let vertexstart = start + i * 12;\n            positions.push(reader.getFloat32(vertexstart, true));\n            positions.push(reader.getFloat32(vertexstart + 4, true));\n            positions.push(reader.getFloat32(vertexstart + 8, true));\n            if (!ctx.autoNormals) {\n                normals.push(normalX, normalY, normalZ);\n            }\n            if (hasColors) {\n                colors.push(r, g, b, 1); // TODO: handle alpha\n            }\n        }\n        if (splitMeshes && newMesh) {\n            addMesh(ctx, positions, normals, colors);\n            positions = [];\n            normals = [];\n            colors = colors ? [] : null;\n            newMesh = false;\n        }\n    }\n    if (positions.length > 0) {\n        addMesh(ctx, positions, normals, colors);\n    }\n}\n\nfunction parseASCII(ctx, data) {\n    const faceRegex = /facet([\\s\\S]*?)endfacet/g;\n    let faceCounter = 0;\n    const floatRegex = /[\\s]+([+-]?(?:\\d+.\\d+|\\d+.|\\d+|.\\d+)(?:[eE][+-]?\\d+)?)/.source;\n    const vertexRegex = new RegExp('vertex' + floatRegex + floatRegex + floatRegex, 'g');\n    const normalRegex = new RegExp('normal' + floatRegex + floatRegex + floatRegex, 'g');\n    const positions = [];\n    const normals = [];\n    const colors = null;\n    let normalx;\n    let normaly;\n    let normalz;\n    let result;\n    let verticesPerFace;\n    let normalsPerFace;\n    let text;\n    while ((result = faceRegex.exec(data)) !== null) {\n        verticesPerFace = 0;\n        normalsPerFace = 0;\n        text = result[0];\n        while ((result = normalRegex.exec(text)) !== null) {\n            normalx = parseFloat(result[1]);\n            normaly = parseFloat(result[2]);\n            normalz = parseFloat(result[3]);\n            normalsPerFace++;\n        }\n        while ((result = vertexRegex.exec(text)) !== null) {\n            positions.push(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3]));\n            normals.push(normalx, normaly, normalz);\n            verticesPerFace++;\n        }\n        if (normalsPerFace !== 1) {\n            ctx.log(\"Error in normal of face \" + faceCounter);\n            return -1;\n        }\n        if (verticesPerFace !== 3) {\n            ctx.log(\"Error in positions of face \" + faceCounter);\n            return -1;\n        }\n        faceCounter++;\n    }\n    addMesh(ctx, positions, normals, colors);\n}\n\nlet nextGeometryId = 0;\n\nfunction addMesh(ctx, positions, normals, colors) {\n\n    const indices = new Int32Array(positions.length / 3);\n    for (let ni = 0, len = indices.length; ni < len; ni++) {\n        indices[ni] = ni;\n    }\n\n    normals = normals && normals.length > 0 ? normals : null;\n    colors = colors && colors.length > 0 ? colors : null;\n\n    if (!ctx.autoNormals && ctx.smoothNormals) {\n        faceToVertexNormals(positions, normals, {smoothNormalsAngleThreshold: ctx.smoothNormalsAngleThreshold});\n    }\n\n    const geometryId = \"\" + nextGeometryId++;\n    const meshId = \"\" + nextGeometryId++;\n    const entityId = \"\" + nextGeometryId++;\n\n    ctx.xktModel.createGeometry({\n        geometryId: geometryId,\n        primitiveType: \"triangles\",\n        positions: positions,\n        normals: (!ctx.autoNormals) ? normals : null,\n        colors: colors,\n        indices: indices\n    });\n\n    ctx.xktModel.createMesh({\n        meshId: meshId,\n        geometryId: geometryId,\n        color: colors ? null : [1, 1, 1],\n        metallic: 0.9,\n        roughness: 0.1\n    });\n\n    ctx.xktModel.createEntity({\n        entityId: entityId,\n        meshIds: [meshId]\n    });\n\n    ctx.xktModel.createMetaObject({\n        metaObjectId: entityId,\n        metaObjectType: \"Default\",\n        metaObjectName: \"STL Mesh\",\n        parentMetaObjectId: ctx.rootMetaObject.metaObjectId\n    });\n\n    ctx.stats.numGeometries++;\n    ctx.stats.numObjects++;\n    ctx.stats.numVertices += positions.length / 3;\n    ctx.stats.numTriangles += indices.length / 3;\n}\n\nfunction ensureString(buffer) {\n    if (typeof buffer !== 'string') {\n        return decodeText(new Uint8Array(buffer));\n    }\n    return buffer;\n}\n\nfunction ensureBinary(buffer) {\n    if (typeof buffer === 'string') {\n        const arrayBuffer = new Uint8Array(buffer.length);\n        for (let i = 0; i < buffer.length; i++) {\n            arrayBuffer[i] = buffer.charCodeAt(i) & 0xff; // implicitly assumes little-endian\n        }\n        return arrayBuffer.buffer;\n    } else {\n        return buffer.buffer;\n    }\n}\n\nfunction decodeText(array) {\n    if (typeof TextDecoder !== 'undefined') {\n        return new TextDecoder().decode(array);\n    }\n    let s = '';\n    for (let i = 0, il = array.length; i < il; i++) {\n        s += String.fromCharCode(array[i]); // Implicitly assumes little-endian.\n    }\n    return decodeURIComponent(escape(s));\n}\n\nexport {parseSTLIntoXKTModel};\n",
    "static": true,
    "longname": "/root/Repos/xeokit-convert/src/parsers/parseSTLIntoXKTModel.js",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 478,
    "kind": "function",
    "name": "isBinary",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~isBinary",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 128,
    "undocument": true,
    "params": [
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 479,
    "kind": "function",
    "name": "parseBinary",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~parseBinary",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 145,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 480,
    "kind": "function",
    "name": "parseASCII",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~parseASCII",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 228,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "data",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 481,
    "kind": "variable",
    "name": "nextGeometryId",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~nextGeometryId",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 272,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 482,
    "kind": "function",
    "name": "addMesh",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~addMesh",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 274,
    "undocument": true,
    "params": [
      {
        "name": "ctx",
        "types": [
          "*"
        ]
      },
      {
        "name": "positions",
        "types": [
          "*"
        ]
      },
      {
        "name": "normals",
        "types": [
          "*"
        ]
      },
      {
        "name": "colors",
        "types": [
          "*"
        ]
      }
    ],
    "return": null,
    "ignore": true
  },
  {
    "__docId__": 483,
    "kind": "function",
    "name": "ensureString",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~ensureString",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 327,
    "undocument": true,
    "params": [
      {
        "name": "buffer",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 484,
    "kind": "function",
    "name": "ensureBinary",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~ensureBinary",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 334,
    "undocument": true,
    "params": [
      {
        "name": "buffer",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 485,
    "kind": "function",
    "name": "decodeText",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~decodeText",
    "access": "public",
    "export": false,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": null,
    "description": null,
    "lineNumber": 346,
    "undocument": true,
    "params": [
      {
        "name": "array",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 486,
    "kind": "function",
    "name": "parseSTLIntoXKTModel",
    "memberof": "src/parsers/parseSTLIntoXKTModel.js",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/parsers/parseSTLIntoXKTModel.js~parseSTLIntoXKTModel",
    "access": "public",
    "export": true,
    "importPath": "@xeokit/xeokit-convert/src/parsers/parseSTLIntoXKTModel.js",
    "importStyle": "{parseSTLIntoXKTModel}",
    "description": "Parses STL file data into an {@link XKTModel}.\n\n* Supports binary and ASCII STL formats.\n* Option to create a separate {@link XKTEntity} for each group of faces that share the same vertex colors.\n* Option to smooth face-aligned normals loaded from STL.\n* Option to reduce XKT file size by ignoring STL normals and relying on xeokit to auto-generate them.\n\n## Usage\n\nIn the example below we'll create an {@link XKTModel}, then load an STL model into it.\n\n````javascript\nutils.loadArraybuffer(\"./models/stl/binary/spurGear.stl\", async (data) => {\n\n    const xktModel = new XKTModel();\n\n    parseSTLIntoXKTModel({data, xktModel});\n\n    xktModel.finalize();\n});\n````",
    "lineNumber": 48,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{Promise} Resolves when STL has been parsed."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "Parsing params."
      },
      {
        "nullable": null,
        "types": [
          "ArrayBuffer",
          "String"
        ],
        "spread": false,
        "optional": true,
        "name": "params.data",
        "description": "STL file data. Can be binary or string."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "false",
        "defaultRaw": false,
        "name": "params.autoNormals",
        "description": "When true, the parser will ignore the STL geometry normals, and the STL\ndata will rely on the xeokit ````Viewer```` to automatically generate them. This has the limitation that the\nnormals will be face-aligned, and therefore the ````Viewer```` will only be able to render a flat-shaded representation\nof the STL.\nOverrides ````smoothNormals```` when ````true````. This ignores the normals in the STL, and loads no\nnormals from the STL into the {@link XKTModel}, resulting in the XKT file storing no normals for the STL model. The\nxeokit-sdk will then automatically generate the normals within its shaders. The disadvantages are that auto-normals\nmay slow rendering down a little bit, and that the normals can only be face-aligned (and thus rendered using flat\nshading). The advantages, however, are a smaller XKT file size, and the ability to apply certain geometry optimizations\nduring parsing, such as removing duplicated STL vertex positions, that are not possible when normals are loaded\nfor the STL vertices."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "params.smoothNormals",
        "description": "When true, automatically converts face-oriented STL normals to vertex normals, for a smooth appearance. Ignored if ````autoNormals```` is ````true````."
      },
      {
        "nullable": null,
        "types": [
          "Number"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "20",
        "defaultRaw": 20,
        "name": "params.smoothNormalsAngleThreshold",
        "description": "This is the threshold angle between normals of adjacent triangles, below which their shared wireframe edge is not drawn."
      },
      {
        "nullable": null,
        "types": [
          "Boolean"
        ],
        "spread": false,
        "optional": true,
        "defaultValue": "true",
        "defaultRaw": true,
        "name": "params.splitMeshes",
        "description": "When true, creates a separate {@link XKTEntity} for each group of faces that share the same vertex colors. Only works with binary STL (ie. when ````data```` is an ArrayBuffer)."
      },
      {
        "nullable": null,
        "types": [
          "XKTModel"
        ],
        "spread": false,
        "optional": true,
        "name": "params.xktModel",
        "description": "XKTModel to parse into."
      },
      {
        "nullable": null,
        "types": [
          "Object"
        ],
        "spread": false,
        "optional": true,
        "name": "params.stats",
        "description": "Collects statistics."
      },
      {
        "nullable": null,
        "types": [
          "function"
        ],
        "spread": false,
        "optional": true,
        "name": "params.log",
        "description": "Logging callback."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "Promise"
      ],
      "spread": false,
      "description": "Resolves when STL has been parsed."
    }
  },
  {
    "kind": "index",
    "content": "# xeokit-convert\n\n[![Twitter Follow](https://img.shields.io/twitter/follow/xeolabs?style=social)](https://twitter.com/xeolabs)\n[![npm version](https://badge.fury.io/js/%40xeokit%2Fxeokit-convert.svg)](https://badge.fury.io/js/%40xeokit%2Fxeokit-convert)\n\nUse **xeokit-convert** to:\n\n* Convert BIM and AEC models directly into XKT files for super fast loading into [xeokit](https://xeokit.io)\n* Generate XKT files with JavaScript\n\n> xeokit-convert replaces [xeokit-gltf-to-xkt](https://github.com/xeokit/xeokit-gltf-to-xkt) and [xeokit-xkt-utils](https://github.com/xeokit/xeokit-xkt-utils), which are deprecated.\n\n> CAUTION: Direct IFC conversion is an alpha status feature, since it depends on  [web-ifc](https://github.com/tomvandig/web-ifc), a 3rd-party library, which is also alpha at this time. As such, some IFC models may not convert properly. If this is the case for your models, consider using our [standard conversion setup](https://www.notion.so/xeokit/Converting-IFC-Models-using-3rd-Party-Open-Source-Tools-c373e48bc4094ff5b6e5c5700ff580ee)\nuntil issues have been resolved. Also, direct IFC conversion does not currently support all property sets.\n\n---\n\n# Contents\n\n- [Introduction](#introduction)\n- [Acknowledgements](#acknowledgements)\n- [Resources](#resources)\n- [Features](#features)\n- [Installing](#installing)\n- [Components](#components)\n- [Using ````convert2xkt````](#using-----convert2xkt----)\n    + [Converting an IFC file into an XKT file on the command line](#converting-an-ifc-file-into-an-xkt-file-on-the-command-line)\n    + [Viewing the XKT file with xeokit](#viewing-the-xkt-file-with-xeokit)\n    + [Querying the XKT version in Node.js](#querying-the-xkt-version-in-nodejs)\n    + [Converting an IFC file into an XKT file in Node.js](#converting-an-ifc-file-into-an-xkt-file-in-nodejs)\n    + [Converting IFC file data into XKT data in Node.js](#converting-ifc-file-data-into-xkt-data-in-nodejs)\n- [Converting Split Files Output from ````ifc2gltf````](#converting-split-files-from-ifc2gltf)\n- [Using ````XKTModel````](#using-----xktmodel----)\n    + [Programmatically Building an XKT File](#programmatically-building-an-xkt-file)\n    + [Serializing the XKTModel to an ArrayBuffer](#serializing-the-xktmodel-to-an-arraybuffer)\n    + [Loading the ArrayBuffer into a Viewer](#loading-the-arraybuffer-into-a-viewer)\n    + [Loading IFC into an XKTModel](#loading-ifc-into-an-xktmodel)\n    + [Loading LAS into an XKTModel](#loading-las-into-an-xktmodel)\n    + [Loading GLB into an XKTModel](#loading-glb-into-an-xktmodel)\n    + [Loading STL into an XKTModel](#loading-stl-into-an-xktmodel)\n- [Building](#building)\n    + [Building Binaries](#building-binaries)\n\n---\n\n# Introduction\n\n[````xeokit-convert````](https://github.com/xeokit/xeokit-convert) provides the means to convert 3D BIM and AEC models\ninto XKT files for super fast loading into [xeokit](https://xeokit.io), along with programming tools to generate XKT\nfiles with JavaScript on Node.js.\n\nThe [XKT format](https://github.com/xeokit/xeokit-convert/tree/master/specs) compresses large double-precision models to\na compact payload that loads quickly over the Web into a xeokit viewer running in the browser. We can use xeokit-convert\nto convert several source formats into XKT, such as IFC, GLB and CityJSON.\n\n# Acknowledgements\n\nOur thanks to the authors of these open source libraries, which we use internally within ````xeokit-convert````:\n\n* [loaders.gl](https://loaders.gl) - Copyright (C) 2015 Uber Technologies,\n  Inc. ([MIT License](http://www.opensource.org/licenses/mit-license.php))\n* [Basis Universal](https://github.com/BinomialLLC/basis_universal) - Binomal\n  LLC, ([Apache 2 License](http://www.apache.org/licenses/LICENSE-2.0))\n* [Pako](https://github.com/nodeca/pako) - Copyright (C) 2014-2017 by Vitaly Puzrin and Andrei\n  Tuputcyn ([MIT License](http://www.opensource.org/licenses/mit-license.php))\n* [earcut](https://github.com/mapbox/earcut) - Copyright (C) 2016,\n  Mapbox ([ISC License](https://opensource.org/licenses/ISC))\n* [web-ifc](https://github.com/tomvandig/web-ifc) - Copyright (C) 2020-2021 web-ifc\n  contributors ([Mozilla Public License Version 2.0](https://www.mozilla.org/en-US/MPL/2.0/))\n\n# Resources\n\n* [npm](https://www.npmjs.com/package/@xeokit/xeokit-convert)\n* [API Docs](https://xeokit.github.io/xeokit-convert/docs)\n* [Source Code](https://github.com/xeokit/xeokit-convert)\n* [Releases / Changelog](https://github.com/xeokit/xeokit-convert/releases)\n* [XKT Specifications](https://xeokit.github.io/xeokit-convert/specs/)\n\n# Features\n\n* A Node-based CLI tool to convert various 3D model formats to XKT files.\n* A JavaScript toolkit of components for loading, generating and saving XKT files.\n\n# Installing\n\nListed below these are the steps for installing and running `convert2xkt` on Linux. Make sure you have first installed \n`git` and that your version of `NodeJS` is at least `v16.10.0.`\n\n````bash\ngit clone https://github.com/xeokit/xeokit-convert.git\ncd xeokit-convert/\nnpm install\nnode convert2xkt.js -h\n\nUsage: convert2xkt [options]\n\nOptions:\n-v, --version                output the version number\n-c, --configs [file]         optional path to JSON configs file; overrides convert2xkt.conf.js\n-s, --source [file]          path to source file\n-a, --sourcemanifest [file]  path to source manifest file (for converting split file output from ifcgltf -s)\n-f, --format [string]        source file format (optional); supported formats are glb, ifc, laz, las, pcd, ply, stl and cityjson\n-m, --metamodel [file]       path to source metamodel JSON file (optional)\n-i, --include [types]        only convert these types (optional)\n-x, --exclude [types]        never convert these types (optional)\n-r, --rotatex                rotate model 90 degrees about X axis (for las and cityjson)\n-g, --disablegeoreuse        disable geometry reuse (optional)\n-z, --minTileSize [number]   minimum diagonal tile size (optional, default 500)\n-t, --disabletextures        ignore textures (optional)\n-n, --disablenormals         ignore normals (optional)\n-o, --output [file]          path to target .xkt file when -s option given, or JSON manifest for multiple .xkt files when source manifest\nfile given with -a; creates directories on path automatically if not existing\n-l, --log                    enable logging (optional)\n-h, --help                   display help for command\n````\n\nIf you get ````RuntimeError: memory access out of bounds```` while converting IFC, then you'll need to compile the\n3rd-party web-ifc WASM module for your system - see [Building Binaries](#building-binaries).\n\n# Components\n\nThe table below lists the components provided by ````xeokit-convert````.\n\nAt the center of the toolkit, we've got the converter tool, provided as both a Node.js function and CLI executable.\n\nBundled with the converter, we've got the XKT document model, a bunch of loaders for different formats, and a function\nto serialize the document model to a BLOB. We use these components within the converter tool, and also provide them as\npart of the public API for extensibility.\n\n| Component | Description                                                                                                                                                                                                                               |\n| --- |-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n| [convert2xkt](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-convert2xkt) (function)<br> [convert2xkt](https://github.com/xeokit/xeokit-convert/blob/master/convert2xkt.js) (Node script)| A Node-based JavaScript function and CLI tool that converts various AEC model formats into xeokit's native, super-fast-loading XKT format.                                                                                                |\n| [XKTModel](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) | A JavaScript document model that represents the contents of an XKT file in memory. Using this, we can programmatically build a document model in JavaScript, adding geometries, materials, objects etc, then serialize it to an XKT file. |\n| [parseIFCIntoXKTModel](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-parseIFCIntoXKTModel) | Parses IFC data into an ````XKTModel````. This is an alpha-status feature.                                                                                                                                                                |\n| [parseGLTFIntoXKTModel](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-parseGLTFIntoXKTModel) | Parses GLB into an ````XKTModel````. Supports textures.                                                                                                                                                                                   |\n| [parseCityJSONIntoXKTModel](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-parseJSONIntoXKTModel) | Parses CityJSON into an ````XKTModel````                                                                                                                                                                                                  |\n| [parseLASIntoXKTModel](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-parseLASIntoXKTModel) | Parses LAS and LAZ into an ````XKTModel````                                                                                                                                                                                               |\n| [parseSTLIntoXKTModel](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-parseSTLIntoXKTModel) | Parses STL into an ````XKTModel````                                                                                                                                                                                                       |\n| [writeXKTModelToArrayBuffer](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-writeXKTModelToArrayBuffer) | Serializes an ````XKTModel```` to an XKT file                                                                                                                                                                                             |\n\n# Using ````convert2xkt````\n\nThe ````convert2xkt```` tool converts various model formats into xeokit's native XKT format, which is designed to load\nsuper fast over the Web into a xeokit viewer. We provide this tool as both a [CLI script]() and as\na [function](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-convert2xkt) to use within\nour own Node scripts.\n\n````bash\nnode convert2xkt.js -h\n\nUsage: convert2xkt [options]\n\nOptions:\n  -v, --version                output the version number\n  -s, --source [file]          path to source file\n  -a, --sourcemanifest [file]  path to source manifest file (for converting split file output from ifcgltf -s)\n  -f, --format [string]        source file format (optional); supported formats are glb, ifc, laz, las, pcd, ply, stl and cityjson\n  -m, --metamodel [file]       path to source metamodel JSON file (optional)\n  -i, --include [types]        only convert these types (optional)\n  -x, --exclude [types]        never convert these types (optional)\n  -r, --rotatex                rotate model 90 degrees about X axis (for las and cityjson)\n  -g, --disablegeoreuse        disable geometry reuse (optional)\n  -z, --mintilesize [number]   minimum diagonal tile size (optional, default 500)\n  -t, --disabletextures        ignore textures (optional)\n  -n, --disablenormals         ignore normals (optional)\n  -o, --output [file]          path to target .xkt file when -s option given, or JSON manifest for multiple .xkt files when source manifest file given with -a; creates directories on path automatically if not existing\n  -l, --log                    enable logging (optional)\n  -h, --help                   display help for command\n\nXKT version: 10\n````\n\n### Converting an IFC file into an XKT file on the command line\n\nLet's use the [convert2xkt](https://github.com/xeokit/xeokit-convert/blob/master/convert2xkt.js) Node script to convert\nan IFC file to XKT on the command line.\n\n````bash\nnode convert2xkt.js -s rme_advanced_sample_project.ifc -o rme_advanced_sample_project.ifc.xkt -l\n\n[convert2xkt] Reading input file: rme_advanced_sample_project.ifc\n[convert2xkt] Input file size: 35309.94 kB\n[convert2xkt] Geometry reuse is enabled\n[convert2xkt] Converting...\n[convert2xkt] Converted to: XKT v9\n[convert2xkt] XKT size: 1632.98 kB\n[convert2xkt] Compression ratio: 21.62\n[convert2xkt] Conversion time: 54.41 s\n[convert2xkt] Converted metaobjects: 0\n[convert2xkt] Converted property sets: 0\n[convert2xkt] Converted drawable objects: 1986\n[convert2xkt] Converted geometries: 3897\n[convert2xkt] Converted triangles: 286076\n[convert2xkt] Converted vertices: 547740\n[convert2xkt] reuseGeometries: false\n[convert2xkt] minTileSize: 10000\n[convert2xkt] Writing XKT file: rme_advanced_sample_project.ifc.xkt\n````\n\n### Viewing the XKT file with xeokit\n\nNow that we've got an XKT file, we can now view it in the browser using a\nxeokit [Viewer](https://xeokit.github.io/xeokit-sdk/docs/class/src/viewer/Viewer.js~Viewer.html) configured with\nan [XKTLoaderPlugin](https://xeokit.github.io/xeokit-sdk/docs/class/src/plugins/XKTLoaderPlugin/XKTLoaderPlugin.js~XKTLoaderPlugin.html)\n.\n\n````javascript\nimport {Viewer, XKTLoaderPlugin} from\n        \"https://cdn.jsdelivr.net/npm/@xeokit/xeokit-sdk@1/dist/xeokit-sdk.es.min.js\";\n\nconst viewer = new Viewer({\n    canvasId: \"myCanvas\"\n});\n\nconst xktLoader = new XKTLoaderPlugin(viewer);\n\nconst modelNode = xktLoader.load({\n    id: \"myModel\",\n    src: \"./rme_sample_project.ifc.xkt\"\n});\n````\n\n### Querying the XKT version in Node.js\n\nFrom with a Node script, we can query which XKT version ````xeokit-convert```` currently generates:\n\n````javascript\nconst {XKT_INFO} = require(\"./dist/xeokit-convert.cjs.js\");\n\nconst xktVersion = XKT_INFO.xktVersion; // Unsigned integer\nconsole.log(`XKT version: ${xktVersion}`);\n````\n\n### Converting an IFC file into an XKT file in Node.js\n\nWe can use\nthe [convert2xkt](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-convert2xkt)\nfunction from within our Nodejs scripts to programmatically convert files to XKT.\n\n````javascript\nconst convert2xkt = require(\"@xeokit/xeokit-convert/dist/convert2xkt.cjs.js\");\n\nconvert2xkt({\n    source: \"rme_advanced_sample_project.ifc\",\n    output: \"rme_advanced_sample_project.ifc.xkt\",\n    log: (msg) => {\n        console.log(msg)\n    }\n}).then(() => {\n    console.log(\"Converted.\");\n}, (errMsg) => {\n    console.error(\"Conversion failed: \" + errMsg)\n});\n````\n\n### Converting IFC file data into XKT data in Node.js\n\nWhen using\nthe [convert2xkt](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-convert2xkt)\nfunction in our Node scripts, we can manage all file data in memory.\n\nThis is great for when we want more control over where we read and write the files.\n\n````javascript\nconst convert2xkt = require(\"@xeokit/xeokit-convert/dist/convert2xkt.cjs.js\");\nconst fs = require('fs');\n\nconvert2xkt({\n    sourceData: fs.readFileSync(\"rme_advanced_sample_project.ifc\"),\n    outputXKT: (xtkArrayBuffer) => {\n        fs.writeFileSync(\"rme_advanced_sample_project.ifc.xkt\", xtkArrayBuffer);\n    }\n}).then(() => {\n    console.log(\"Converted.\");\n}, (errMsg) => {\n    console.error(\"Conversion failed: \" + errMsg)\n});\n````\n\nWhen using\nthe [convert2xkt](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-convert2xkt)\nfunction in our Node scripts, we can manage all file data in memory.\n\nThis is great for when we want more control over where we read and write the files.\n\n````javascript\nconst convert2xkt = require(\"@xeokit/xeokit-convert/dist/convert2xkt.cjs.js\");\nconst fs = require('fs');\n\nconvert2xkt({\n    sourceData: fs.readFileSync(\"rme_advanced_sample_project.ifc\"),\n    outputXKT: (xtkArrayBuffer) => {\n        fs.writeFileSync(\"rme_advanced_sample_project.ifc.xkt\", xtkArrayBuffer);\n    }\n}).then(() => {\n    console.log(\"Converted.\");\n}, (errMsg) => {\n    console.error(\"Conversion failed: \" + errMsg)\n});\n````\n\n# Converting Split Files Output from ````ifc2gltf````\n\nThe ````ifc2gltf```` tool has the option to convert IFC files into multiple GLB and JSON metadata files. We can then use ````convert2xkt```` to convert each of these \nfiles individually. This allows us to convert a huge IFC files into several, smaller XKT files, then load \nthose XKT files individually into a xeokit Viewer.\n\n## Usage\n\nRun ````ifc2gltf```` with the ````-s```` option, to convert an IFC file into a set of multiple ````glb```` geometry and ````json```` metadata files:\n\n````\nifc2gltfcxconverter -i model.ifc -o myGLBFiles/model.glb -m myGLBFiles/model.json -s 100\n````\n\nThe ````ifc2gltf````  ````-s 100```` option causes ````ifc2gltf```` to split the output into these multiple files, each no bigger than 100MBytes.\n\nThe contents of the ````myGLBFiles```` directory then looks like this:\n\n````\nmyGLBFiles\n├── model.glb\n├── model.json\n├── model_1.glb\n├── model_1.json\n├── model_2.glb\n├── model_2.json\n├── model_3.glb\n├── model_3.json\n└── model.glb.manifest.json\n````\n\nNow run ````convert2xkt```` with the ````-a```` option, pointing to the ````myGLBFiles/model.glb.manifest.json```` file:\n\n````bash\nnode convert2xkt.js -a myGLBFiles/model.glb.manifest.json -o myXKTFiles -l\n````\n\nThe contents of ````myXKTFiles```` now look like this:\n\n````\nmyXKTFiles\n├── model.xkt\n├── model_1.xkt\n├── model_2.xkt\n├── model_3.xkt\n└── model.xkt.manifest.json\n````\n\nThe ````model.xkt.manifest```` file looks like this:\n\n````json\n{\n  \"inputFile\": \"/absolute/path/myGLBFiles/model.glb.manifest.json\",\n  \"converterApplication\": \"convert2xkt\",\n  \"converterApplicationVersion\": \"v1.1.8\",\n  \"conversionDate\": \"09-08-2023- 23-53-30\",\n  \"outputDir\": \"/absolute/path/myXKTFiles\",\n  \"xktFiles\": [\n    \"model.xkt\",\n    \"model_1.xkt\",\n    \"model_2.xkt\",\n    \"model_3.xkt\"\n  ]\n}\n````\n\nWe can then load those XKT files into a xeokit Viewer, and the Viewer will automaticlly combine their geometry and metadata into the same scene. \n# Using ````XKTModel````\n\n````XKTModel```` is a JavaScript class that represents the contents of an XKT file in memory.\n\nIt's a sort of *XKT document model*, with methods to build 3D objects within it, functions to import various model\nformats, and a function to serialize it to an XKT file.\n\nWe can use these tools to:\n\n* programmatically XKT files,\n* combine multiple models into an XKT file, from different formats,\n* develop custom XKT converters, and\n* extend ````convert2xkt```` to support more formats.\n\n### Programmatically Building an XKT File\n\nTo demonstrate the API, let's\nuse [````XKTModel````](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) 's\nbuilder methods to programmatically build a model that resembles the screenshot below. Then we'll serialize\nthe ````XKTModel```` to an\n````ArrayBuffer````, which we'll finally load that into a\nxeokit [````Viewer````](https://xeokit.github.io/xeokit-sdk/docs/class/src/viewer/Viewer.js~Viewer.html)\nusing [````XKTLoaderPlugin````](https://xeokit.github.io/xeokit-sdk/docs/class/src/plugins/XKTLoaderPlugin/XKTLoaderPlugin.js~XKTLoaderPlugin.html)\n.\n\nWe'll code this example to run in the browser, using the ES module\nin [xeokit-convert.es.js](./dist/xeokit-convert.es.js). We could also code it to run on node, using the CommonJS module\nin [xeokit-convert.cjs.js](./dist/xeokit-convert.cjs.js).\n\n![XKTModel Example](http://xeokit.io/img/docs/PerformanceModel/PerformanceModel.png)\n\n````javascript\nconst {\n    XKTModel,\n    writeXKTModelToArrayBuffer\n} = require(\"@xeokit/xeokit-convert/dist/xeokit-convert.cjs.js\");\nconst fs = require('fs');\n\nconst xktModel = new XKTModel();\n\n// Create metamodel - this part is optional\n\n// Create property sets to hold info about the model\n\nxktModel.createPropertySet({\n    propertySetId: \"tableTopPropSet\",\n    propertySetType: \"Default\",\n    propertySetName: \"Table Top\",\n    properties: [\n        {\n            id: \"tableTopMaterial\",\n            type: \"Default\",\n            name: \"Table top material\",\n            value: \"Marble\"\n        },\n        {\n            id: \"tableTopDimensions\",\n            type: \"Default\",\n            name: \"Table top dimensions\",\n            value: \"90x90x3 cm\"\n        }\n    ]\n});\n\nxktModel.createPropertySet({\n    propertySetId: \"tableLegPropSet\",\n    propertySetType: \"Default\",\n    propertySetName: \"Table Leg\",\n    properties: [\n        {\n            id: \"tableLegMaterial\",\n            type: \"Default\",\n            name: \"Table leg material\",\n            value: \"Pine\"\n        },\n        {\n            id: \"tableLegDimensions\",\n            type: \"Default\",\n            name: \"Table leg dimensions\",\n            value: \"5x5x50 cm\"\n        }\n    ]\n});\n\n// Create a hierarchy of metaobjects to describe the structure of the model\n\nxktModel.createMetaObject({ // Root XKTMetaObject, has no XKTEntity\n    metaObjectId: \"table\",\n    metaObjectName: \"The Table\",\n    metaObjectType: \"furniture\"\n});\n\nxktModel.createMetaObject({\n    metaObjectId: \"redLeg\",\n    metaObjectName: \"Red Table Leg\",\n    metaObjectType: \"furniturePart\",\n    parentMetaObjectId: \"table\",\n    propertySetIds: [\"tableLegPropSet\"]\n});\n\nxktModel.createMetaObject({\n    metaObjectId: \"greenLeg\",\n    metaObjectName: \"Green Table Leg\",\n    metaObjectType: \"furniturePart\",\n    parentMetaObjectId: \"table\",\n    propertySetIds: [\"tableLegPropSet\"]\n});\n\nxktModel.createMetaObject({\n    metaObjectId: \"blueLeg\",\n    metaObjectName: \"Blue Table Leg\",\n    metaObjectType: \"furniturePart\",\n    parentMetaObjectId: \"table\",\n    propertySetIds: [\"tableLegPropSet\"]\n});\n\nxktModel.createMetaObject({\n    metaObjectId: \"yellowLeg\",\n    metaObjectName: \"Yellow Table Leg\",\n    metaObjectType: \"furniturePart\",\n    parentMetaObjectId: \"table\",\n    propertySetIds: [\"tableLegPropSet\"]\n});\n\nxktModel.createMetaObject({\n    metaObjectId: \"pinkTop\",\n    metaObjectName: \"The Pink Table Top\",\n    metaObjectType: \"furniturePart\",\n    parentMetaObjectId: \"table\",\n    propertySetIds: [\"tableTopPropSet\"]\n});\n\n// Create an XKTGeometry that defines a box shape, as a triangle mesh \n\nxktModel.createGeometry({\n    geometryId: \"boxGeometry\",\n    primitiveType: \"triangles\", // Also \"lines\" and \"points\"\n    positions: [\n        1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 1, -1, -1, 1,\n        -1, -1, 1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, 1, -1,\n        -1, -1, -1, -1, -1, 1, -1, 1, 1, -1\n    ],\n    normals: [ // Only for \"triangles\"\n        0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0,\n        -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, -1, 0, 0, -1, 0, 0,\n        -1, 0, 0, -1\n    ],\n    indices: [\n        0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19,\n        20, 21, 22, 20, 22, 23\n    ]\n});\n\n// Create five XKTMeshes, which represent the table top and legs.\n// Each XKTMesh has its own color, position, orientation and size, \n// and uses the XKTGeometry to define its shape.  \n// An XKTGeometry can be used by multiple XKTMeshes.\n\nxktModel.createMesh({\n    meshId: \"redLegMesh\",\n    geometryId: \"boxGeometry\",\n    position: [-4, -6, -4],\n    scale: [1, 3, 1],\n    rotation: [0, 0, 0],\n    color: [1, 0, 0],\n    opacity: 1\n});\n\nxktModel.createMesh({\n    meshId: \"greenLegMesh\",\n    geometryId: \"boxGeometry\",\n    position: [4, -6, -4],\n    scale: [1, 3, 1],\n    rotation: [0, 0, 0],\n    color: [0, 1, 0],\n    opacity: 1\n});\n\nxktModel.createMesh({\n    meshId: \"blueLegMesh\",\n    geometryId: \"boxGeometry\",\n    position: [4, -6, 4],\n    scale: [1, 3, 1],\n    rotation: [0, 0, 0],\n    color: [0, 0, 1],\n    opacity: 1\n});\n\nxktModel.createMesh({\n    meshId: \"yellowLegMesh\",\n    geometryId: \"boxGeometry\",\n    position: [-4, -6, 4],\n    scale: [1, 3, 1],\n    rotation: [0, 0, 0],\n    color: [1, 1, 0],\n    opacity: 1\n});\n\nxktModel.createMesh({\n    meshId: \"pinkTopMesh\",\n    geometryId: \"boxGeometry\",\n    position: [0, -3, 0],\n    scale: [6, 0.5, 6],\n    rotation: [0, 0, 0],\n    color: [1, 0, 1],\n    opacity: 1\n});\n\n// Create five XKTEntities, which represent abstract, named objects in the model. \n// Each XKTEntity has an XKTMesh.\n// An XKTEntity can have multiple XKTMeshes. \n// An XKTMesh can only belong to one XKTEntity.\n\nxktModel.createEntity({\n    entityId: \"redLeg\",\n    meshIds: [\"redLegMesh\"]\n});\n\nxktModel.createEntity({\n    entityId: \"greenLeg\",\n    meshIds: [\"greenLegMesh\"]\n});\n\nxktModel.createEntity({\n    entityId: \"blueLeg\",\n    meshIds: [\"blueLegMesh\"]\n});\n\nxktModel.createEntity({\n    entityId: \"yellowLeg\",\n    meshIds: [\"yellowLegMesh\"]\n});\n\nxktModel.createEntity({\n    entityId: \"pinkTop\",\n    meshIds: [\"pinkTopMesh\"]\n});\n````\n\nOnce we've built\nour [````XKTModel````](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html), we\nneed to finalize it. Then it's ready to use. Note that finalizing is an asynhronous operation, so we await its\ncompletion before continuing.\n\n````javascript\nawait xktModel.finalize();\n````\n\n### Serializing the XKTModel to an ArrayBuffer\n\nNext, we'll\nuse  [````writeXKTModelToArrayBuffer````](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-writeXKTModelToArrayBuffer)\nto serialize\nour [````XKTModel````](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) to\nan ````ArrayBuffer````.\n\n````javascript\nconst xktArrayBuffer = writeXKTModelToArrayBuffer(xktModel);\n\nfs.writeFileSync(\"./myModel.xkt\", xktArrayBuffer);\n````\n\n### Loading the ArrayBuffer into a Viewer\n\nLet's now create a [````Viewer````](https://xeokit.github.io/xeokit-sdk/docs/class/src/viewer/Viewer.js~Viewer.html),\nthen load the ````ArrayBuffer```` into it using\nan [````XKTLoaderPlugin````](https://xeokit.github.io/xeokit-sdk/docs/class/src/plugins/XKTLoaderPlugin/XKTLoaderPlugin.js~XKTLoaderPlugin.html)\n.\n\n````javascript\nconst viewer = new Viewer({\n    canvasId: \"myCanvas\"\n});\n\nconst xktLoader = new XKTLoaderPlugin(viewer);\n\nconst model = xktLoader.load({\n    id: \"myModel\",\n    src: \"./myModel.xkt\"\n});\n````\n\nFinally, when the model has loaded, let's fit it in view.\n\n````javascript\nmodel.on(\"loaded\", () => {\n    viewer.cameraFlight.flyTo(model);\n});\n````\n\n### Loading IFC into an XKTModel\n\nLet's\nuse [````parseIFCIntoXKTModel````](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-parseIFCIntoXKTModel)\nto import IFC into\nan [````XKTModel````](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html).\n\nAs before, we'll also use the classes and functions introduced in the previous examples to serialize\nthe [````XKTModel````](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) to\nan ````ArrayBuffer````, then load it into\na [````Viewer````](https://xeokit.github.io/xeokit-sdk/docs/class/src/viewer/Viewer.js~Viewer.html).\n\n````javascript\nconst viewer = new Viewer({\n    canvasId: \"myCanvas\"\n});\n\nconst xktLoader = new XKTLoaderPlugin(viewer);\n\nutils.loadArraybuffer(\"./assets/models/ifc/rac_advanced_sample_project.ifc\", async (data) => {\n\n        const xktModel = new XKTModel();\n\n        parseIFCIntoXKTModel({data, xktModel, wasmPath: \"../dist/\"}).then(() => {\n\n            xktModel.finalize().then(() => {\n\n                const xktArrayBuffer = writeXKTModelToArrayBuffer(xktModel);\n\n                xktLoader.load({\n                    id: \"myModel\",\n                    xkt: xktArrayBuffer,\n                    edges: true\n                });\n\n                viewer.cameraFlight.flyTo(viewer.scene);\n            });\n        });\n    },\n    (errMsg) => {\n    });\n````\n\n### Loading LAS into an XKTModel\n\nLet's\nuse [````parseLASIntoXKTModel````](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-parseLASIntoXKTModel)\nto import LAS into\nan [````XKTModel````](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html).\n\nAs before, we'll also use the classes and functions introduced in the previous examples to serialize\nthe [````XKTModel````](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) to\nan ````ArrayBuffer````, then load it into\na [````Viewer````](https://xeokit.github.io/xeokit-sdk/docs/class/src/viewer/Viewer.js~Viewer.html).\n\n````javascript\nconst viewer = new Viewer({\n    canvasId: \"myCanvas\"\n});\n\nconst xktLoader = new XKTLoaderPlugin(viewer);\n\nutils.loadArraybuffer(\"./assets/models/laz/indoor.0.1.laz\", async (data) => {\n\n        const xktModel = new XKTModel();\n\n        parseLASIntoXKTModel({data, xktModel, rotateX: true}).then(() => {\n\n            xktModel.finalize().then(() => {\n\n                const xktArrayBuffer = writeXKTModelToArrayBuffer(xktModel);\n\n                xktLoader.load({\n                    id: \"myModel\",\n                    xkt: xktArrayBuffer,\n                    edges: true\n                });\n\n                viewer.cameraFlight.flyTo(viewer.scene);\n            });\n        });\n    },\n    (errMsg) => {\n    });\n````\n\n### Loading GLB into an XKTModel\n\nLet's\nuse [````parseGLTFIntoXKTModel````](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-parseGLTFIntoXKTModel)\nto import binary glTF into\nan [````XKTModel````](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html).\n\nWe'll also use the classes and functions introduced in the previous examples to serialize\nthe [````XKTModel````](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) to\nan ````ArrayBuffer````, then validate the ````ArrayBuffer```` and load it into\na [````Viewer````](https://xeokit.github.io/xeokit-sdk/docs/class/src/viewer/Viewer.js~Viewer.html).\n\n````javascript\nconst viewer = new Viewer({\n    canvasId: \"myCanvas\"\n});\n\nconst xktLoader = new XKTLoaderPlugin(viewer);\n\nutils.loadArraybuffer(\"./assets/models/glb/MAP/MAP.glb\", (glb) => {\n\n        const xktModel = new XKTModel();\n\n        parseGLTFIntoXKTModel({data: glb, xktModel: xktModel}).then(() => {\n\n            xktModel.finalize().then(() => {\n\n                const xktArrayBuffer = writeXKTModelToArrayBuffer(xktModel);\n\n                xktLoader.load({\n                    id: \"myModel\",\n                    xkt: xktArrayBuffer\n                });\n\n                viewer.cameraFlight.flyTo(viewer.scene);\n            });\n        });\n    },\n    (errMsg) => {\n    });\n````\n\n### Loading STL into an XKTModel\n\nLet's\nuse [````parseSTLIntoXKTModel````](https://xeokit.github.io/xeokit-convert/docs/function/index.html#static-function-parseSTLIntoXKTModel)\nto import STL into\nan [````XKTModel````](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html).\n\nAs before, we'll also use the classes and functions introduced in the previous examples to serialize\nthe [````XKTModel````](https://xeokit.github.io/xeokit-convert/docs/class/src/XKTModel/XKTModel.js~XKTModel.html) to\nan ````ArrayBuffer````, then load it into\na [````Viewer````](https://xeokit.github.io/xeokit-sdk/docs/class/src/viewer/Viewer.js~Viewer.html).\n\n````javascript\nconst viewer = new Viewer({\n    canvasId: \"myCanvas\"\n});\n\nconst xktLoader = new XKTLoaderPlugin(viewer);\n\nutils.loadArraybuffer(\"./assets/models/stl/binary/spurGear.stl\", (json) => {\n\n        const xktModel = new XKTModel();\n\n        parseSTLIntoXKTModel({stlData: json, xktModel: xktModel}).then(() => {\n\n            xktModel.finalize().then(() => {\n\n                const xktArrayBuffer = writeXKTModelToArrayBuffer(xktModel);\n\n                xktLoader.load({\n                    id: \"myModel\",\n                    xkt: xktArrayBuffer\n                });\n\n                viewer.cameraFlight.flyTo(viewer.scene);\n            });\n        });\n    },\n    (errMsg) => {\n    });\n````\n\n# Building\n\n### Building Binaries\n\nBuilding the binaries in [````./dist````](https://github.com/xeokit/xeokit-convert/tree/main/dist):\n\n````bash\nnpm update\nnpm run build\n````\n\nThis will build:\n\n* [./dist/convert2xkt.cjs.js](./dist/convert2xkt.cjs.js) - Nodejs CLI converter tool\n* [./dist/xeokit-convert.cjs.js](./dist/xeokit-convert.cjs.js) - CommonJS module library of XKT classes and functions\n* [./dist/xeokit-convert.es.js](./dist/xeokit-convert.es.js) - ES module library of XKT classes and functions\n* [./dist/web-ifc.wasm](./dist/web-ifc.wasm) - 3rd-party web-ifc WASM module\n\nBuilding the JavaScript API documentation in [````./docs````](https://xeokit.github.io/xeokit-convert/docs):\n\n````bash\nnpm run docs\n````\n\n### RuntimeError: memory access out of bounds\n\nWith luck, the WASM module already be compiled appropriately for your target x86 system.\n\nHowever, if you get this error:\n\n````bash\nRuntimeError: memory access out of bounds\n````\n\nthen you will need to compile that WASM module for your target system. Please follow the instructions for that on the\n[web-ifc](https://github.com/tomvandig/web-ifc) project page, then replace [./dist/web-ifc.wasm](./dist/web-ifc.wasm)\nwith your compiled binary.\n\n### TypeError: fetch failed\n\nThis error is possible in in nodejs version 17+. As fix you will have to add the --no-experimental-fetch flag to the command.\n````bash\nnode --no-experimental-fetch convert2xkt.js ...\n````\n",
    "longname": "/root/Repos/xeokit-convert/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  },
  {
    "kind": "packageJSON",
    "content": "{\n  \"name\": \"@xeokit/xeokit-convert\",\n  \"version\": \"1.1.23\",\n  \"description\": \"JavaScript utilities to create .XKT files\",\n  \"main\": \"index.js\",\n  \"bin\": \"/convert2xkt.js\",\n  \"directories\": {},\n  \"scripts\": {\n    \"build\": \"npm run build-node && npm run build-browser && rollup --config rollup.config.convert2xkt.js && npm run docs\",\n    \"build-node\": \"webpack --mode=development --node-env=development --progress\",\n    \"build-browser\": \"rollup --config rollup.config.dist.js\",\n    \"docs\": \"rimraf ./docs/* && npx esdoc\",\n    \"publish\": \"npm publish --access public\",\n    \"changelog\": \"auto-changelog --commit-limit false --package --template changelog-template.hbs\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/xeokit/xeokit-convert.git\"\n  },\n  \"keywords\": [\n    \"xeolabs\",\n    \"xeokit\",\n    \"bim\",\n    \"opensource\",\n    \"ifc\",\n    \"webgl\",\n    \"xkt\",\n    \"gltf\",\n    \"glb\",\n    \"cityjson\",\n    \"laz\",\n    \"gis\"\n  ],\n  \"author\": \"Lindsay Kay\",\n  \"license\": \"LICENSE\",\n  \"bugs\": {\n    \"url\": \"https://github.com/xeokit/xeokit-convert/issues\"\n  },\n  \"homepage\": \"https://github.com/xeokit/xeokit-convert#readme\",\n  \"dependencies\": {\n    \"@loaders.gl/core\": \"^3.2.6\",\n    \"@loaders.gl/gltf\": \"^3.2.6\",\n    \"@loaders.gl/images\": \"^3.2.6\",\n    \"@loaders.gl/json\": \"^3.2.6\",\n    \"@loaders.gl/las\": \"^3.2.6\",\n    \"@loaders.gl/obj\": \"^3.2.6\",\n    \"@loaders.gl/ply\": \"^3.2.6\",\n    \"@loaders.gl/polyfills\": \"^3.2.6\",\n    \"@loaders.gl/textures\": \"^3.2.6\",\n    \"@typeonly/validator\": \"^0.5.2\",\n    \"commander\": \"^11.0.0\",\n    \"core-js\": \"^3.22.5\",\n    \"fs\": \"0.0.1-security\",\n    \"pako\": \"^2.0.4\",\n    \"path\": \"^0.12.7\",\n    \"web-ifc\": \"0.0.40\"\n  },\n  \"devDependencies\": {\n    \"@babel/core\": \"^7.17.10\",\n    \"@babel/plugin-external-helpers\": \"^7.17.12\",\n    \"@babel/preset-env\": \"^7.17.12\",\n    \"@rollup/plugin-alias\": \"^3.1.9\",\n    \"@rollup/plugin-commonjs\": \"^21.1.0\",\n    \"@rollup/plugin-node-resolve\": \"^13.2.1\",\n    \"@xeokit/xeokit-sdk\": \"^2.3.0\",\n    \"auto-changelog\": \"^2.4.0\",\n    \"babel-loader\": \"^8.2.5\",\n    \"copy-webpack-plugin\": \"^11.0.0\",\n    \"esdoc\": \"^1.1.0\",\n    \"esdoc-node\": \"^1.0.5\",\n    \"esdoc-standard-plugin\": \"^1.0.0\",\n    \"http-server\": \"^14.1.0\",\n    \"npm-upgrade\": \"^3.1.0\",\n    \"rimraf\": \"^3.0.2\",\n    \"rollup\": \"^2.70.2\",\n    \"rollup-plugin-copy\": \"^3.4.0\",\n    \"rollup-plugin-minify-es\": \"^1.1.1\",\n    \"typeonly\": \"^0.4.6\",\n    \"webpack\": \"^5.72.1\",\n    \"webpack-cli\": \"^4.9.2\",\n    \"webpack-node-externals\": \"^3.0.0\"\n  },\n  \"files\": [\n    \"/dist\",\n    \"/convert2xkt.js\",\n    \"/convert2xkt.conf.js\"\n  ]\n}",
    "longname": "/root/Repos/xeokit-convert/package.json",
    "name": "package.json",
    "static": true,
    "access": "public"
  }
]