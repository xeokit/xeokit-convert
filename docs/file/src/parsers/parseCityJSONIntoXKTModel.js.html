<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">src/parsers/parseCityJSONIntoXKTModel.js | xeokit-convert</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="JavaScript utilities to create .XKT files"><meta property="og:type" content="website"><meta property="og:url" content="http://xeokit.io"><meta property="og:site_name" content="xeokit-convert"><meta property="og:title" content="xeokit-convert"><meta property="og:image" content="./images/logo.jpg"><meta property="og:description" content="JavaScript utilities to create .XKT files"><meta property="og:author" content="http://xeolabs.com"><meta property="twitter:card" content="summary"><meta property="twitter:title" content="xeokit-convert"><meta property="twitter:description" content="JavaScript utilities to create .XKT files"><meta property="twitter:image" content="./images/logo.jpg"></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./" style="display: flex; align-items: center;"><img src="./image/brand_logo.jpg" style="width:34px;"></a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/xeokit/xeokit-convert"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-convert2xkt">convert2xkt</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-XKT_INFO">XKT_INFO</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-ClampToEdgeWrapping">ClampToEdgeWrapping</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-GIFMediaType">GIFMediaType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-JPEGMediaType">JPEGMediaType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LinearFilter">LinearFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LinearMipMapLinearFilter">LinearMipMapLinearFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LinearMipMapNearestFilter">LinearMipMapNearestFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LinearMipmapLinearFilter">LinearMipmapLinearFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-LinearMipmapNearestFilter">LinearMipmapNearestFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-MirroredRepeatWrapping">MirroredRepeatWrapping</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-NearestFilter">NearestFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-NearestMipMapLinearFilter">NearestMipMapLinearFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-NearestMipMapNearestFilter">NearestMipMapNearestFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-NearestMipmapLinearFilter">NearestMipmapLinearFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-NearestMipmapNearestFilter">NearestMipmapNearestFilter</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-PNGMediaType">PNGMediaType</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-RepeatWrapping">RepeatWrapping</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#xktmodel">XKTModel</a><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/XKTModel/XKTEntity.js~XKTEntity.html">XKTEntity</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/XKTModel/XKTGeometry.js~XKTGeometry.html">XKTGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/XKTModel/XKTMesh.js~XKTMesh.html">XKTMesh</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/XKTModel/XKTMetaObject.js~XKTMetaObject.html">XKTMetaObject</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/XKTModel/XKTModel.js~XKTModel.html">XKTModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/XKTModel/XKTPropertySet.js~XKTPropertySet.html">XKTPropertySet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/XKTModel/XKTTexture.js~XKTTexture.html">XKTTexture</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/XKTModel/XKTTextureSet.js~XKTTextureSet.html">XKTTextureSet</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/XKTModel/XKTTile.js~XKTTile.html">XKTTile</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-writeXKTModelToArrayBuffer">writeXKTModelToArrayBuffer</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#geometrybuilders">geometryBuilders</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildBoxGeometry">buildBoxGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildBoxLinesGeometry">buildBoxLinesGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildCylinderGeometry">buildCylinderGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildGridGeometry">buildGridGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildPlaneGeometry">buildPlaneGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildSphereGeometry">buildSphereGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildTorusGeometry">buildTorusGeometry</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-buildVectorTextGeometry">buildVectorTextGeometry</a></span></span></li>
<li data-ice="doc"><a data-ice="dirPath" class="nav-dir-path" href="identifiers.html#parsers">parsers</a><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseCityJSONIntoXKTModel">parseCityJSONIntoXKTModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseGLTFIntoXKTModel">parseGLTFIntoXKTModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseGLTFJSONIntoXKTModel">parseGLTFJSONIntoXKTModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseIFCIntoXKTModel">parseIFCIntoXKTModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseLASIntoXKTModel">parseLASIntoXKTModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseMetaModelIntoXKTModel">parseMetaModelIntoXKTModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parsePCDIntoXKTModel">parsePCDIntoXKTModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parsePLYIntoXKTModel">parsePLYIntoXKTModel</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-parseSTLIntoXKTModel">parseSTLIntoXKTModel</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/parsers/parseCityJSONIntoXKTModel.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import {earcut} from &apos;./../lib/earcut&apos;;
import {math} from &quot;./../lib/math.js&quot;;

const tempVec2a = math.vec2();
const tempVec3a = math.vec3();
const tempVec3b = math.vec3();
const tempVec3c = math.vec3();

/**
 * @desc Parses a CityJSON model into an {@link XKTModel}.
 *
 * [CityJSON](https://www.cityjson.org) is a JSON-based encoding for a subset of the CityGML data model (version 2.0.0),
 * which is an open standardised data model and exchange format to store digital 3D models of cities and
 * landscapes. CityGML is an official standard of the [Open Geospatial Consortium](https://www.ogc.org/).
 *
 * This converter function supports most of the [CityJSON 1.0.2 Specification](https://www.cityjson.org/specs/1.0.2),
 * with the following limitations:
 *
 * * Does not (yet) support CityJSON semantics for geometry primitives.
 * * Does not (yet) support textured geometries.
 * * Does not (yet) support geometry templates.
 * * When the CityJSON file provides multiple *themes* for a geometry, then we parse only the first of the provided themes for that geometry.
 *
 * ## Usage
 *
 * In the example below we&apos;ll create an {@link XKTModel}, then load a CityJSON model into it.
 *
 * ````javascript
 * utils.loadJSON(&quot;./models/cityjson/DenHaag.json&quot;, async (data) =&gt; {
 *
 *     const xktModel = new XKTModel();
 *
 *     parseCityJSONIntoXKTModel({
 *          data,
 *          xktModel,
 *          log: (msg) =&gt; { console.log(msg); }
 *     }).then(()=&gt;{
 *        xktModel.finalize();
 *     },
 *     (msg) =&gt; {
 *         console.error(msg);
 *     });
 * });
 * ````
 *
 * @param {Object} params Parsing params.
 * @param {Object} params.data CityJSON data.
 * @param {XKTModel} params.xktModel XKTModel to parse into.
 * @param {boolean} [params.center=false] Set true to center the CityJSON vertex positions to [0,0,0]. This is applied before the transformation matrix, if specified.
 * @param {Boolean} [params.transform] 4x4 transformation matrix to transform CityJSON vertex positions. Use this to rotate, translate and scale them if neccessary.
 * @param {Object} [params.stats] Collects statistics.
 * @param {function} [params.log] Logging callback.
 @returns {Promise} Resolves when CityJSON has been parsed.
 */
function parseCityJSONIntoXKTModel({
                                       data,
                                       xktModel,
                                       center = false,
                                       transform = null,
                                       stats = {}, log
                                   }) {

    return new Promise(function (resolve, reject) {

        if (!data) {
            reject(&quot;Argument expected: data&quot;);
            return;
        }

        if (data.type !== &quot;CityJSON&quot;) {
            reject(&quot;Invalid argument: data is not a CityJSON file&quot;);
            return;
        }

        if (!xktModel) {
            reject(&quot;Argument expected: xktModel&quot;);
            return;
        }

        let vertices;

        log(&quot;Using parser: parseCityJSONIntoXKTModel&quot;);

        log(`center: ${center}`);
        if (transform) {
            log(`transform: [${transform}]`);
        }

        if (data.transform || center || transform) {
            vertices = copyVertices(data.vertices);
            if (data.transform) {
                transformVertices(vertices, data.transform)
            }
            if (center) {
                centerVertices(vertices);
            }
            if (transform) {
                customTransformVertices(vertices, transform);
            }
        } else {
            vertices = data.vertices;
        }

        stats.sourceFormat = data.type || &quot;&quot;;
        stats.schemaVersion = data.version || &quot;&quot;;
        stats.title = &quot;&quot;;
        stats.author = &quot;&quot;;
        stats.created = &quot;&quot;;
        stats.numMetaObjects = 0;
        stats.numPropertySets = 0;
        stats.numTriangles = 0;
        stats.numVertices = 0;
        stats.numObjects = 0;
        stats.numGeometries = 0;

        const rootMetaObjectId = math.createUUID();

        xktModel.createMetaObject({
            metaObjectId: rootMetaObjectId,
            metaObjectType: &quot;Model&quot;,
            metaObjectName: &quot;Model&quot;
        });

        stats.numMetaObjects++;

        const modelMetaObjectId = math.createUUID();

        xktModel.createMetaObject({
            metaObjectId: modelMetaObjectId,
            metaObjectType: &quot;CityJSON&quot;,
            metaObjectName: &quot;CityJSON&quot;,
            parentMetaObjectId: rootMetaObjectId
        });

        stats.numMetaObjects++;

        const ctx = {
            data,
            vertices,
            xktModel,
            rootMetaObjectId: modelMetaObjectId,
            log: (log || function (msg) {
            }),
            nextId: 0,
            stats
        };

        ctx.xktModel.schema = data.type + &quot; &quot; + data.version;

        ctx.log(&quot;Converting &quot; + ctx.xktModel.schema);

        parseCityJSON(ctx);

        resolve();
    });
}

function copyVertices(vertices) {
    const vertices2 = [];
    for (let i = 0, j = 0; i &lt; vertices.length; i++, j += 3) {
        const x = vertices[i][0];
        const y = vertices[i][1];
        const z = vertices[i][2];
        vertices2.push([x, y, z]);
    }
    return vertices2;
}

function transformVertices(vertices, cityJSONTransform) {
    const scale = cityJSONTransform.scale || math.vec3([1, 1, 1]);
    const translate = cityJSONTransform.translate || math.vec3([0, 0, 0]);
    for (let i = 0; i &lt; vertices.length; i++) {
        const vertex = vertices[i];
        vertex[0] = (vertex[0] * scale[0]) + translate[0];
        vertex[1] = (vertex[1] * scale[1]) + translate[1];
        vertex[2] = (vertex[2] * scale[2]) + translate[2];
    }
}

function centerVertices(vertices) {
    if (center) {
        const centerPos = math.vec3();
        const numPoints = vertices.length;
        for (let i = 0, len = vertices.length; i &lt; len; i++) {
            const vertex = vertices[i];
            centerPos[0] += vertex[0];
            centerPos[1] += vertex[1];
            centerPos[2] += vertex[2];
        }
        centerPos[0] /= numPoints;
        centerPos[1] /= numPoints;
        centerPos[2] /= numPoints;
        for (let i = 0, len = vertices.length; i &lt; len; i++) {
            const vertex = vertices[i];
            vertex[0] -= centerPos[0];
            vertex[1] -= centerPos[1];
            vertex[2] -= centerPos[2];
        }
    }
}

function customTransformVertices(vertices, transform) {
    if (transform) {
        const mat = math.mat4(transform);
        for (let i = 0, len = vertices.length; i &lt; len; i++) {
            const vertex = vertices[i];
            math.transformPoint3(mat, vertex, vertex);
        }
    }
}

function parseCityJSON(ctx) {

    const data = ctx.data;
    const cityObjects = data.CityObjects;

    for (const objectId in cityObjects) {
        if (cityObjects.hasOwnProperty(objectId)) {
            const cityObject = cityObjects[objectId];
            parseCityObject(ctx, cityObject, objectId);
        }
    }
}

function parseCityObject(ctx, cityObject, objectId) {

    const xktModel = ctx.xktModel;
    const data = ctx.data;
    const metaObjectId = objectId;
    const metaObjectType = cityObject.type;
    const metaObjectName = metaObjectType + &quot; : &quot; + objectId;

    const parentMetaObjectId = cityObject.parents ? cityObject.parents[0] : ctx.rootMetaObjectId;

    xktModel.createMetaObject({
        metaObjectId,
        metaObjectName,
        metaObjectType,
        parentMetaObjectId
    });

    ctx.stats.numMetaObjects++;

    if (!(cityObject.geometry &amp;&amp; cityObject.geometry.length &gt; 0)) {
        return;
    }

    const meshIds = [];

    for (let i = 0, len = cityObject.geometry.length; i &lt; len; i++) {

        const geometry = cityObject.geometry[i];

        let objectMaterial;
        let surfaceMaterials;

        const appearance = data.appearance;
        if (appearance) {
            const materials = appearance.materials;
            if (materials) {
                const geometryMaterial = geometry.material;
                if (geometryMaterial) {
                    const themeIds = Object.keys(geometryMaterial);
                    if (themeIds.length &gt; 0) {
                        const themeId = themeIds[0];
                        const theme = geometryMaterial[themeId];
                        if (theme.value !== undefined) {
                            objectMaterial = materials[theme.value];
                        } else {
                            const values = theme.values;
                            if (values) {
                                surfaceMaterials = [];
                                for (let j = 0, lenj = values.length; j &lt; lenj; j++) {
                                    const value = values[i];
                                    const surfaceMaterial = materials[value];
                                    surfaceMaterials.push(surfaceMaterial);
                                }
                            }
                        }
                    }
                }
            }
        }

        if (surfaceMaterials) {
            parseGeometrySurfacesWithOwnMaterials(ctx, geometry, surfaceMaterials, meshIds);

        } else {
            parseGeometrySurfacesWithSharedMaterial(ctx, geometry, objectMaterial, meshIds);
        }
    }

    if (meshIds.length &gt; 0) {
        xktModel.createEntity({
            entityId: objectId,
            meshIds: meshIds
        });

        ctx.stats.numObjects++;
    }
}

function parseGeometrySurfacesWithOwnMaterials(ctx, geometry, surfaceMaterials, meshIds) {

    const geomType = geometry.type;

    switch (geomType) {

        case &quot;MultiPoint&quot;:
            break;

        case &quot;MultiLineString&quot;:
            break;

        case &quot;MultiSurface&quot;:

        case &quot;CompositeSurface&quot;:
            const surfaces = geometry.boundaries;
            parseSurfacesWithOwnMaterials(ctx, surfaceMaterials, surfaces, meshIds);
            break;

        case &quot;Solid&quot;:
            const shells = geometry.boundaries;
            for (let j = 0; j &lt; shells.length; j++) {
                const surfaces = shells[j];
                parseSurfacesWithOwnMaterials(ctx, surfaceMaterials, surfaces, meshIds);
            }
            break;

        case &quot;MultiSolid&quot;:

        case &quot;CompositeSolid&quot;:
            const solids = geometry.boundaries;
            for (let j = 0; j &lt; solids.length; j++) {
                for (let k = 0; k &lt; solids[j].length; k++) {
                    const surfaces = solids[j][k];
                    parseSurfacesWithOwnMaterials(ctx, surfaceMaterials, surfaces, meshIds);
                }
            }
            break;

        case &quot;GeometryInstance&quot;:
            break;
    }
}

function parseSurfacesWithOwnMaterials(ctx, surfaceMaterials, surfaces, meshIds) {

    const vertices = ctx.vertices;
    const xktModel = ctx.xktModel;

    for (let i = 0; i &lt; surfaces.length; i++) {

        const surface = surfaces[i];
        const surfaceMaterial = surfaceMaterials[i] || {diffuseColor: [0.8, 0.8, 0.8], transparency: 1.0};

        const face = [];
        const holes = [];

        const sharedIndices = [];

        const geometryCfg = {
            positions: [],
            indices: []
        };

        for (let j = 0; j &lt; surface.length; j++) {

            if (face.length &gt; 0) {
                holes.push(face.length);
            }

            const newFace = extractLocalIndices(ctx, surface[j], sharedIndices, geometryCfg);

            face.push(...newFace);
        }

        if (face.length === 3) { // Triangle

            geometryCfg.indices.push(face[0]);
            geometryCfg.indices.push(face[1]);
            geometryCfg.indices.push(face[2]);

        } else if (face.length &gt; 3) { // Polygon

            // Prepare to triangulate

            const pList = [];

            for (let k = 0; k &lt; face.length; k++) {
                pList.push({
                    x: vertices[sharedIndices[face[k]]][0],
                    y: vertices[sharedIndices[face[k]]][1],
                    z: vertices[sharedIndices[face[k]]][2]
                });
            }

            const normal = getNormalOfPositions(pList, math.vec3());

            // Convert to 2D

            let pv = [];

            for (let k = 0; k &lt; pList.length; k++) {

                to2D(pList[k], normal, tempVec2a);

                pv.unshift(tempVec2a[0]);
                pv.unshift(tempVec2a[1]);
            }

            // Triangulate

            const tr = earcut(pv, holes, 2);

            // Create triangles

            for (let k = 0; k &lt; tr.length; k += 3) {
                geometryCfg.indices.unshift(face[tr[k]]);
                geometryCfg.indices.unshift(face[tr[k + 1]]);
                geometryCfg.indices.unshift(face[tr[k + 2]]);
            }
        }

        const geometryId = &quot;&quot; + ctx.nextId++;
        const meshId = &quot;&quot; + ctx.nextId++;

        xktModel.createGeometry({
            geometryId: geometryId,
            primitiveType: &quot;triangles&quot;,
            positions: geometryCfg.positions,
            indices: geometryCfg.indices
        });

        xktModel.createMesh({
            meshId: meshId,
            geometryId: geometryId,
            color: (surfaceMaterial &amp;&amp; surfaceMaterial.diffuseColor) ? surfaceMaterial.diffuseColor : [0.8, 0.8, 0.8],
            opacity: 1.0
            //opacity: (surfaceMaterial &amp;&amp; surfaceMaterial.transparency !== undefined) ? (1.0 - surfaceMaterial.transparency) : 1.0
        });

        meshIds.push(meshId);

        ctx.stats.numGeometries++;
        ctx.stats.numVertices += geometryCfg.positions.length / 3;
        ctx.stats.numTriangles += geometryCfg.indices.length / 3;
    }
}

function parseGeometrySurfacesWithSharedMaterial(ctx, geometry, objectMaterial, meshIds) {

    const xktModel = ctx.xktModel;
    const sharedIndices = [];
    const geometryCfg = {
        positions: [],
        indices: []
    };

    const geomType = geometry.type;

    switch (geomType) {
        case &quot;MultiPoint&quot;:
            break;

        case &quot;MultiLineString&quot;:
            break;

        case &quot;MultiSurface&quot;:
        case &quot;CompositeSurface&quot;:
            const surfaces = geometry.boundaries;
            parseSurfacesWithSharedMaterial(ctx, surfaces, sharedIndices, geometryCfg);
            break;

        case &quot;Solid&quot;:
            const shells = geometry.boundaries;
            for (let j = 0; j &lt; shells.length; j++) {
                const surfaces = shells[j];
                parseSurfacesWithSharedMaterial(ctx, surfaces, sharedIndices, geometryCfg);
            }
            break;

        case &quot;MultiSolid&quot;:
        case &quot;CompositeSolid&quot;:
            const solids = geometry.boundaries;
            for (let j = 0; j &lt; solids.length; j++) {
                for (let k = 0; k &lt; solids[j].length; k++) {
                    const surfaces = solids[j][k];
                    parseSurfacesWithSharedMaterial(ctx, surfaces, sharedIndices, geometryCfg);
                }
            }
            break;

        case &quot;GeometryInstance&quot;:
            break;
    }

    const geometryId = &quot;&quot; + ctx.nextId++;
    const meshId = &quot;&quot; + ctx.nextId++;

    xktModel.createGeometry({
        geometryId: geometryId,
        primitiveType: &quot;triangles&quot;,
        positions: geometryCfg.positions,
        indices: geometryCfg.indices
    });

    xktModel.createMesh({
        meshId: meshId,
        geometryId: geometryId,
        color: (objectMaterial &amp;&amp; objectMaterial.diffuseColor) ? objectMaterial.diffuseColor : [0.8, 0.8, 0.8],
        opacity: 1.0
        //opacity: (objectMaterial &amp;&amp; objectMaterial.transparency !== undefined) ? (1.0 - objectMaterial.transparency) : 1.0
    });

    meshIds.push(meshId);

    ctx.stats.numGeometries++;
    ctx.stats.numVertices += geometryCfg.positions.length / 3;
    ctx.stats.numTriangles += geometryCfg.indices.length / 3;
}

function parseSurfacesWithSharedMaterial(ctx, surfaces, sharedIndices, primitiveCfg) {

    const vertices = ctx.vertices;

    for (let i = 0; i &lt; surfaces.length; i++) {

        let boundary = [];
        let holes = [];

        for (let j = 0; j &lt; surfaces[i].length; j++) {
            if (boundary.length &gt; 0) {
                holes.push(boundary.length);
            }
            const newBoundary = extractLocalIndices(ctx, surfaces[i][j], sharedIndices, primitiveCfg);
            boundary.push(...newBoundary);
        }

        if (boundary.length === 3) { // Triangle

            primitiveCfg.indices.push(boundary[0]);
            primitiveCfg.indices.push(boundary[1]);
            primitiveCfg.indices.push(boundary[2]);

        } else if (boundary.length &gt; 3) { // Polygon

            let pList = [];

            for (let k = 0; k &lt; boundary.length; k++) {
                pList.push({
                    x: vertices[sharedIndices[boundary[k]]][0],
                    y: vertices[sharedIndices[boundary[k]]][1],
                    z: vertices[sharedIndices[boundary[k]]][2]
                });
            }

            const normal = getNormalOfPositions(pList, math.vec3());
            let pv = [];

            for (let k = 0; k &lt; pList.length; k++) {
                to2D(pList[k], normal, tempVec2a);
                pv.unshift(tempVec2a[0]);
                pv.unshift(tempVec2a[1]);
            }

            const tr = earcut(pv, holes, 2);

            for (let k = 0; k &lt; tr.length; k += 3) {
                primitiveCfg.indices.unshift(boundary[tr[k]]);
                primitiveCfg.indices.unshift(boundary[tr[k + 1]]);
                primitiveCfg.indices.unshift(boundary[tr[k + 2]]);
            }
        }
    }
}

function extractLocalIndices(ctx, boundary, sharedIndices, geometryCfg) {

    const vertices = ctx.vertices;
    const newBoundary = []

    for (let i = 0, len = boundary.length; i &lt; len; i++) {

        const index = boundary[i];

        if (sharedIndices.includes(index)) {
            const vertexIndex = sharedIndices.indexOf(index);
            newBoundary.push(vertexIndex);

        } else {
            geometryCfg.positions.push(vertices[index][0]);
            geometryCfg.positions.push(vertices[index][1]);
            geometryCfg.positions.push(vertices[index][2]);

            newBoundary.push(sharedIndices.length);

            sharedIndices.push(index);
        }
    }

    return newBoundary
}

function getNormalOfPositions(positions, normal) {

    for (let i = 0; i &lt; positions.length; i++) {

        let nexti = i + 1;
        if (nexti === positions.length) {
            nexti = 0;
        }

        normal[0] += ((positions[i].y - positions[nexti].y) * (positions[i].z + positions[nexti].z));
        normal[1] += ((positions[i].z - positions[nexti].z) * (positions[i].x + positions[nexti].x));
        normal[2] += ((positions[i].x - positions[nexti].x) * (positions[i].y + positions[nexti].y));
    }

    return math.normalizeVec3(normal);
}

function to2D(_p, _n, re) {

    const p = tempVec3a;
    const n = tempVec3b;
    const x3 = tempVec3c;

    p[0] = _p.x;
    p[1] = _p.y;
    p[2] = _p.z;

    n[0] = _n.x;
    n[1] = _n.y;
    n[2] = _n.z;

    x3[0] = 1.1;
    x3[1] = 1.1;
    x3[2] = 1.1;

    const dist = math.lenVec3(math.subVec3(x3, n));

    if (dist &lt; 0.01) {
        x3[0] += 1.0;
        x3[1] += 2.0;
        x3[2] += 3.0;
    }

    const dot = math.dotVec3(x3, n);
    const tmp2 = math.mulVec3Scalar(n, dot, math.vec3());

    x3[0] -= tmp2[0];
    x3[1] -= tmp2[1];
    x3[2] -= tmp2[2];

    math.normalizeVec3(x3);

    const y3 = math.cross3Vec3(n, x3, math.vec3());
    const x = math.dotVec3(p, x3);
    const y = math.dotVec3(p, y3);

    re[0] = x;
    re[1] = y;
}

export {parseCityJSONIntoXKTModel};</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
